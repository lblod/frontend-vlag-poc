import { macroCondition, getOwnConfig, importSync } from '@embroider/macros';
function _classPrivateFieldBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }
  return receiver;
}
var id = 0;
function _classPrivateFieldKey(name) {
  return "__private_" + id++ + "_" + name;
}
const IS_FUTURE = Symbol('IS_FUTURE');
function isFuture(maybe) {
  return maybe[IS_FUTURE] === true;
}
function createDeferred() {
  let resolve;
  let reject;
  let promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    resolve,
    reject,
    promise
  };
}
function upgradePromise(promise, future) {
  promise[IS_FUTURE] = true;
  // eslint-disable-next-line @typescript-eslint/unbound-method
  promise.getStream = future.getStream;
  // eslint-disable-next-line @typescript-eslint/unbound-method
  promise.abort = future.abort;
  // eslint-disable-next-line @typescript-eslint/unbound-method
  promise.onFinalize = future.onFinalize;
  return promise;
}
function createFuture(owner) {
  const deferred = createDeferred();
  let {
    promise
  } = deferred;
  let cbs;
  promise = promise.finally(() => {
    owner.resolveStream();
    if (cbs) {
      cbs.forEach(cb => cb());
    }
  });
  promise.onFinalize = fn => {
    cbs = cbs || [];
    cbs.push(fn);
  };
  promise[IS_FUTURE] = true;
  promise.getStream = () => {
    return owner.getStream();
  };
  promise.abort = reason => {
    owner.abort(enhanceReason(reason));
  };
  deferred.promise = promise;
  return deferred;
}
function enhanceReason(reason) {
  return new DOMException(reason || 'The user aborted a request.', 'AbortError');
}
class ContextOwner {
  constructor(request, god) {
    this.hasSetStream = false;
    this.hasSetResponse = false;
    this.hasSubscribers = false;
    this.stream = createDeferred();
    this.response = null;
    this.nextCalled = 0;
    this.requestId = god.id;
    this.controller = request.controller || god.controller;
    if (request.controller) {
      if (request.controller !== god.controller) {
        god.controller.signal.addEventListener('abort', () => {
          this.controller.abort(god.controller.signal.reason);
        });
      }
      delete request.controller;
    }
    let enhancedRequest = Object.assign({
      signal: this.controller.signal
    }, request);
    if (macroCondition(getOwnConfig().env.DEBUG)) {
      if (!request?.cacheOptions?.[Symbol.for('ember-data:skip-cache')]) {
        request = deepFreeze(request);
        enhancedRequest = deepFreeze(enhancedRequest);
      }
    } else {
      if (request.headers) {
        request.headers.clone = () => {
          return new Headers([...request.headers.entries()]);
        };
        request.headers.toJSON = () => {
          return [...request.headers.entries()];
        };
      }
    }
    this.enhancedRequest = enhancedRequest;
    this.request = request;
    this.god = god;
    this.stream.promise = this.stream.promise.then(stream => {
      if (this.god.stream === stream && this.hasSubscribers) {
        this.god.stream = null;
      }
      return stream;
    });
  }
  getResponse() {
    if (this.hasSetResponse) {
      return this.response;
    }
    if (this.nextCalled === 1) {
      return this.god.response;
    }
    return null;
  }
  getStream() {
    this.hasSubscribers = true;
    return this.stream.promise;
  }
  abort(reason) {
    this.controller.abort(reason);
  }
  setStream(stream) {
    if (!this.hasSetStream) {
      this.hasSetStream = true;
      if (!(stream instanceof Promise)) {
        this.god.stream = stream;
      }
      // @ts-expect-error
      this.stream.resolve(stream);
    }
  }
  resolveStream() {
    this.setStream(this.nextCalled === 1 ? this.god.stream : null);
  }
  setResponse(response) {
    if (this.hasSetResponse) {
      if (macroCondition(getOwnConfig().env.DEBUG)) {
        throw new Error(`Cannot setResponse when a response has already been set`);
      }
      return;
    }
    this.hasSetResponse = true;
    if (response instanceof Response) {
      const {
        headers,
        ok,
        redirected,
        status,
        statusText,
        type,
        url
      } = response;
      headers.clone = () => {
        return new Headers([...headers.entries()]);
      };
      headers.toJSON = () => {
        return [...headers.entries()];
      };
      let responseData = {
        headers: headers,
        ok,
        redirected,
        status,
        statusText,
        type,
        url
      };
      if (macroCondition(getOwnConfig().env.DEBUG)) {
        responseData = deepFreeze(responseData);
      }
      this.response = responseData;
      this.god.response = responseData;
    } else {
      this.response = response;
      this.god.response = response;
    }
  }
}
var _owner = /*#__PURE__*/_classPrivateFieldKey("owner");
class Context {
  constructor(owner) {
    Object.defineProperty(this, _owner, {
      writable: true,
      value: void 0
    });
    this.id = owner.requestId;
    _classPrivateFieldBase(this, _owner)[_owner] = owner;
    this.request = owner.enhancedRequest;
  }
  setStream(stream) {
    _classPrivateFieldBase(this, _owner)[_owner].setStream(stream);
  }
  setResponse(response) {
    _classPrivateFieldBase(this, _owner)[_owner].setResponse(response);
  }
}
const BODY_TYPES = {
  type: 'string',
  klass: ['Blob', 'ArrayBuffer', 'TypedArray', 'DataView', 'FormData', 'URLSearchParams', 'ReadableStream']
};
const ValidKeys = new Map([['records', 'array'], ['data', 'json'], ['body', BODY_TYPES], ['disableTestWaiter', 'boolean'], ['options', 'object'], ['cacheOptions', 'object'], ['op', 'string'], ['store', 'object'], ['url', 'string'], ['cache', ['default', 'force-cache', 'no-cache', 'no-store', 'only-if-cached', 'reload']], ['credentials', ['include', 'omit', 'same-origin']], ['destination', ['', 'object', 'audio', 'audioworklet', 'document', 'embed', 'font', 'frame', 'iframe', 'image', 'manifest', 'paintworklet', 'report', 'script', 'sharedworker', 'style', 'track', 'video', 'worker', 'xslt']], ['headers', 'headers'], ['integrity', 'string'], ['keepalive', 'boolean'], ['method', ['GET', 'PUT', 'PATCH', 'DELETE', 'POST', 'OPTIONS']], ['mode', ['same-origin', 'cors', 'navigate', 'no-cors']], ['redirect', ['error', 'follow', 'manual']], ['referrer', 'string'], ['signal', 'AbortSignal'], ['controller', 'AbortController'], ['referrerPolicy', ['', 'same-origin', 'no-referrer', 'no-referrer-when-downgrade', 'origin', 'origin-when-cross-origin', 'strict-origin', 'strict-origin-when-cross-origin', 'unsafe-url']]]);
const IS_FROZEN = Symbol('FROZEN');
function freezeHeaders(headers) {
  headers.delete = headers.set = headers.append = () => {
    throw new Error(`Cannot Mutate Immutatable Headers, use headers.clone to get a copy`);
  };
  headers.clone = () => {
    return new Headers([...headers.entries()]);
  };
  return headers;
}
function deepFreeze(value) {
  if (value && value[IS_FROZEN]) {
    return value;
  }
  const _type = typeof value;
  switch (_type) {
    case 'boolean':
    case 'string':
    case 'number':
    case 'symbol':
    case 'undefined':
    case 'bigint':
      return value;
    case 'function':
      throw new Error(`Cannot deep-freeze a function`);
    case 'object':
      {
        const _niceType = niceTypeOf(value);
        switch (_niceType) {
          case 'array':
            {
              if (value[Symbol.for('Collection')]) {
                return value;
              }
              const arr = value.map(deepFreeze);
              arr[IS_FROZEN] = true;
              return Object.freeze(arr);
            }
          case 'null':
            return value;
          case 'object':
            Object.keys(value).forEach(key => {
              try {
                value[key] = deepFreeze(value[key]);
              } catch {
                // continue
              }
            });
            value[IS_FROZEN] = true;
            return Object.freeze(value);
          case 'headers':
            return freezeHeaders(value);
          case 'Collection':
          case 'Store':
          case 'AbortSignal':
            return value;
          case 'date':
          case 'map':
          case 'set':
          case 'error':
          case 'stream':
          default:
            // eslint-disable-next-line no-console
            // console.log(`Cannot deep-freeze ${_niceType}`);
            return value;
        }
      }
  }
}
function isMaybeContext(request) {
  if (request && typeof request === 'object') {
    const keys = Object.keys(request);
    if (keys.length === 1 && keys[0] === 'request') {
      return true;
    }
  }
  return false;
}
function niceTypeOf(v) {
  if (v === null) {
    return 'null';
  }
  if (typeof v === 'string') {
    return v ? 'non-empty-string' : 'empty-string';
  }
  if (!v) {
    return typeof v;
  }
  if (Array.isArray(v)) {
    return 'array';
  }
  if (v instanceof Date) {
    return 'date';
  }
  if (v instanceof Map) {
    return 'map';
  }
  if (v instanceof Set) {
    return 'set';
  }
  if (v instanceof Error) {
    return 'error';
  }
  if (v instanceof ReadableStream || v instanceof WritableStream || v instanceof TransformStream) {
    return 'stream';
  }
  if (v instanceof Headers) {
    return 'headers';
  }
  if (typeof v === 'object' && v.constructor && v.constructor.name !== 'Object') {
    return v.constructor.name;
  }
  return typeof v;
}
function validateKey(key, value, errors) {
  const schema = ValidKeys.get(key);
  if (!schema && !IgnoredKeys.has(key)) {
    errors.push(`InvalidKey: '${key}'`);
    return;
  }
  if (schema) {
    if (schema === BODY_TYPES) {
      if (typeof value === 'string' || value instanceof ReadableStream) {
        return;
      }
      let type = niceTypeOf(value);
      if (schema.klass.includes(type)) {
        return;
      }
      errors.push(`InvalidValue: key 'body' should be a string or one of '${schema.klass.join("', '")}', received ${'<a value of type ' + niceTypeOf(value) + '>'}`);
      return;
    }
    if (Array.isArray(schema)) {
      if (!schema.includes(value)) {
        errors.push(`InvalidValue: key ${key} should be a one of '${schema.join("', '")}', received ${typeof value === 'string' ? value : '<a value of type ' + niceTypeOf(value) + '>'}`);
      }
      return;
    } else if (schema === 'json') {
      try {
        JSON.stringify(value);
      } catch (e) {
        errors.push(`InvalidValue: key ${key} should be a JSON serializable value, but failed to serialize with Error - ${e.message}`);
      }
      return;
    } else if (schema === 'headers') {
      if (!(value instanceof Headers)) {
        errors.push(`InvalidValue: key ${key} should be an instance of Headers, received ${niceTypeOf(value)}`);
      }
      return;
    } else if (schema === 'record') {
      const _type = typeof value;
      // record must extend plain object or Object.create(null)
      if (!value || _type !== 'object' || value.constructor && value.constructor !== Object) {
        errors.push(`InvalidValue: key ${key} should be a dictionary of string keys to string values, received ${niceTypeOf(value)}`);
        return;
      }
      const keys = Object.keys(value);
      keys.forEach(k => {
        let v = value[k];
        if (typeof k !== 'string') {
          errors.push(`\tThe key ${String(k)} on ${key} should be a string key`);
        } else if (typeof v !== 'string') {
          errors.push(`\tThe value of ${key}.${k} should be a string not ${niceTypeOf(v)}`);
        }
      });
      return;
    } else if (schema === 'string') {
      if (typeof value !== 'string' || value.length === 0) {
        errors.push(`InvalidValue: key ${key} should be a non-empty string, received ${typeof value === 'string' ? "''" : typeof value}`);
      }
      return;
    } else if (schema === 'object') {
      if (!value || Array.isArray(value) || typeof value !== 'object') {
        errors.push(`InvalidValue: key ${key} should be an object`);
      }
      return;
    } else if (schema === 'boolean') {
      if (typeof value !== 'boolean') {
        errors.push(`InvalidValue: key ${key} should be a boolean, received ${typeof value}`);
      }
      return;
    } else if (schema === 'array') {
      if (!Array.isArray(value)) {
        errors.push(`InvalidValue: key ${key} should be an array, received ${typeof value}`);
      }
      return;
    }
  }
}
const IgnoredKeys = new Set([]);
function assertValidRequest(request, isTopLevel) {
  if (macroCondition(getOwnConfig().env.DEBUG)) {
    // handle basic shape
    if (!request) {
      throw new Error(`Expected ${isTopLevel ? 'RequestManager.request' : 'next'}(<request>) to be called with a request, but none was provided.`);
    }
    if (Array.isArray(request) || typeof request !== 'object') {
      throw new Error(`The \`request\` passed to \`${isTopLevel ? 'RequestManager.request' : 'next'}(<request>)\` should be an object, received \`${niceTypeOf(request)}\``);
    }
    if (Object.keys(request).length === 0) {
      throw new Error(`The \`request\` passed to \`${isTopLevel ? 'RequestManager.request' : 'next'}(<request>)\` was empty (\`{}\`). Requests need at least one valid key.`);
    }

    // handle accidentally passing context entirely
    if (request instanceof Context) {
      throw new Error(`Expected a request passed to \`${isTopLevel ? 'RequestManager.request' : 'next'}(<request>)\` but received the previous handler's context instead`);
    }
    // handle Object.assign({}, context);
    if (isMaybeContext(request)) {
      throw new Error(`Expected a request passed to \`${isTopLevel ? 'RequestManager.request' : 'next'}(<request>)\` but received an object with a request key instead.`);
    }

    // handle schema
    const keys = Object.keys(request);
    const validationErrors = [];
    const isLegacyRequest = Boolean('op' in request && !request.url);
    keys.forEach(key => {
      if (isLegacyRequest && key === 'data') {
        return;
      }
      validateKey(key, request[key], validationErrors);
    });
    if (validationErrors.length) {
      const error = new Error(`Invalid Request passed to \`${isTopLevel ? 'RequestManager.request' : 'next'}(<request>)\`.\n\nThe following issues were found:\n\n\t${validationErrors.join('\n\t')}`);
      error.errors = validationErrors;
      throw error;
    }
  }
}
const STRUCTURED = Symbol('DOC');
function curryFuture(owner, inbound, outbound) {
  owner.setStream(inbound.getStream());
  inbound.then(doc => {
    const document = {
      [STRUCTURED]: true,
      request: owner.request,
      response: doc.response,
      content: doc.content
    };
    outbound.resolve(document);
  }, error => {
    if (isDoc(error)) {
      owner.setStream(owner.god.stream);
    }
    if (!error || !(error instanceof Error)) {
      try {
        throw new Error(error ? error : `Request Rejected with an Unknown Error`);
      } catch (e) {
        if (error && typeof error === 'object') {
          Object.assign(e, error);
          e.message = error.message || `Request Rejected with an Unknown Error`;
        }
        error = e;
      }
    }
    error[STRUCTURED] = true;
    error.request = owner.request;
    error.response = owner.getResponse();
    error.error = error.error || error.message;
    outbound.reject(error);
  });
  return outbound.promise;
}
function isDoc(doc) {
  return doc && doc[STRUCTURED] === true;
}
function handleOutcome(owner, inbound, outbound) {
  inbound.then(content => {
    if (owner.controller.signal.aborted) {
      // the next function did not respect the signal, we handle it here
      outbound.reject(new DOMException(owner.controller.signal.reason || 'The user aborted a request.', 'AbortError'));
      return;
    }
    if (isDoc(content)) {
      owner.setStream(owner.god.stream);
      content = content.content;
    }
    const document = {
      [STRUCTURED]: true,
      request: owner.request,
      response: owner.getResponse(),
      content
    };
    outbound.resolve(document);
  }, error => {
    if (isDoc(error)) {
      owner.setStream(owner.god.stream);
    }
    if (!error) {
      try {
        throw new Error(`Request Rejected with an Unknown Error`);
      } catch (e) {
        error = e;
      }
    }
    error[STRUCTURED] = true;
    error.request = owner.request;
    error.response = owner.getResponse();
    error.error = error.error || error.message;
    outbound.reject(error);
  });
  return outbound.promise;
}
function executeNextHandler(wares, request, i, god) {
  if (macroCondition(getOwnConfig().env.DEBUG)) {
    if (i === wares.length) {
      throw new Error(`No handler was able to handle this request.`);
    }
    assertValidRequest(request, false);
  }
  const owner = new ContextOwner(request, god);
  function next(r) {
    owner.nextCalled++;
    return executeNextHandler(wares, r, i + 1, god);
  }
  const context = new Context(owner);
  let outcome;
  try {
    outcome = wares[i].request(context, next);
    if (macroCondition(getOwnConfig().env.DEBUG)) {
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      if (!outcome || !(outcome instanceof Promise) && !(typeof outcome === 'object' && 'then' in outcome)) {
        // eslint-disable-next-line no-console
        console.log({
          request,
          handler: wares[i],
          outcome
        });
        if (outcome === undefined) {
          throw new Error(`Expected handler.request to return a promise, instead received undefined.`);
        }
        throw new Error(`Expected handler.request to return a promise, instead received a synchronous value.`);
      }
    }
  } catch (e) {
    outcome = Promise.reject(e);
  }
  const future = createFuture(owner);
  if (isFuture(outcome)) {
    return curryFuture(owner, outcome, future);
  }
  return handleOutcome(owner, outcome, future);
}
let REQ_ID = 0;
/**
 * ```js
 * import RequestManager from '@ember-data/request';
 * ```
 *
 * A RequestManager provides a request/response flow in which configured
 * handlers are successively given the opportunity to handle, modify, or
 * pass-along a request.
 *
 * ```ts
 * interface RequestManager {
 *   request<T>(req: RequestInfo): Future<T>;
 * }
 * ```
 *
 * For example:
 *
 * ```ts
 * import RequestManager from '@ember-data/request';
 * import Fetch from '@ember-data/request/fetch';
 * import Auth from 'ember-simple-auth/ember-data-handler';
 * import Config from './config';
 *
 * const { apiUrl } = Config;
 *
 * // ... create manager
 * const manager = new RequestManager();
 * manager.use([Auth, Fetch]);
 *
 * // ... execute a request
 * const response = await manager.request({
 *   url: `${apiUrl}/users`
 * });
 * ```
 *
 * ### Futures
 *
 * The return value of `manager.request` is a `Future`, which allows
 * access to limited information about the request while it is still
 * pending and fulfills with the final state when the request completes.
 *
 * A `Future` is cancellable via `abort`.
 *
 * Handlers may optionally expose a `ReadableStream` to the `Future` for
 * streaming data; however, when doing so the future should not resolve
 * until the response stream is fully read.
 *
 * ```ts
 * interface Future<T> extends Promise<StructuredDocument<T>> {
 *   abort(): void;
 *
 *   async getStream(): ReadableStream | null;
 * }
 * ```
 *
 * ### StructuredDocuments
 *
 * A Future resolves with a `StructuredDataDocument` or rejects with a `StructuredErrorDocument`.
 *
 * ```ts
 * interface StructuredDataDocument<T> {
 *   request: ImmutableRequestInfo;
 *   response: ImmutableResponseInfo;
 *   content: T;
 * }
 * interface StructuredErrorDocument extends Error {
 *   request: ImmutableRequestInfo;
 *   response: ImmutableResponseInfo;
 *   error: string | object;
 * }
 * type StructuredDocument<T> = StructuredDataDocument<T> | StructuredErrorDocument;
 * ```
 *
 * @class RequestManager
 * @public
 */
var _handlers = /*#__PURE__*/_classPrivateFieldKey("handlers");
class RequestManager {
  constructor(options) {
    Object.defineProperty(this, _handlers, {
      writable: true,
      value: []
    });
    Object.assign(this, options);
    this._pending = new Map();
  }

  /**
   * Register a handler to use for primary cache intercept.
   *
   * Only one such handler may exist. If using the same
   * RequestManager as the Store instance the Store
   * registers itself as a Cache handler.
   *
   * @method useCache
   * @public
   * @param {Handler[]} cacheHandler
   * @returns {void}
   */
  useCache(cacheHandler) {
    if (macroCondition(getOwnConfig().env.DEBUG)) {
      if (this._hasCacheHandler) {
        throw new Error(`\`RequestManager.useCache(<handler>)\` May only be invoked once.`);
      }
      if (Object.isFrozen(_classPrivateFieldBase(this, _handlers)[_handlers])) {
        throw new Error(`\`RequestManager.useCache(<handler>)\` May only be invoked prior to any request having been made.`);
      }
      this._hasCacheHandler = true;
    }
    _classPrivateFieldBase(this, _handlers)[_handlers].unshift(cacheHandler);
  }

  /**
   * Register handler(s) to use when a request is issued.
   *
   * Handlers will be invoked in the order they are registered.
   * Each Handler is given the opportunity to handle the request,
   * curry the request, or pass along a modified request.
   *
   * @method use
   * @public
   * @param {Handler[]} newHandlers
   * @returns {void}
   */
  use(newHandlers) {
    const handlers = _classPrivateFieldBase(this, _handlers)[_handlers];
    if (macroCondition(getOwnConfig().env.DEBUG)) {
      if (Object.isFrozen(handlers)) {
        throw new Error(`Cannot add a Handler to a RequestManager after a request has been made`);
      }
      if (!Array.isArray(newHandlers)) {
        throw new Error(`\`RequestManager.use(<Handler[]>)\` expects an array of handlers, but was called with \`${typeof newHandlers}\``);
      }
      newHandlers.forEach((handler, index) => {
        if (!handler || typeof handler !== 'object' || typeof handler.request !== 'function') {
          throw new Error(`\`RequestManager.use(<Handler[]>)\` expected to receive an array of handler objects with request methods, by the handler at index ${index} does not conform.`);
        }
      });
    }
    handlers.push(...newHandlers);
  }

  /**
   * Issue a Request.
   *
   * Returns a Future that fulfills with a StructuredDocument
   *
   * @method request
   * @public
   * @param {RequestInfo} request
   * @returns {Future}
   */
  request(request) {
    const handlers = _classPrivateFieldBase(this, _handlers)[_handlers];
    if (macroCondition(getOwnConfig().env.DEBUG)) {
      if (!Object.isFrozen(handlers)) {
        Object.freeze(handlers);
      }
      assertValidRequest(request, true);
    }
    const controller = request.controller || new AbortController();
    if (request.controller) {
      delete request.controller;
    }
    let promise = executeNextHandler(handlers, request, 0, {
      controller,
      response: null,
      stream: null,
      id: REQ_ID++
    });
    if (macroCondition(getOwnConfig().env.TESTING)) {
      if (!request.disableTestWaiter) {
        const {
          waitForPromise
        } = importSync('@ember/test-waiters');
        const newPromise = waitForPromise(promise);
        return upgradePromise(newPromise, promise);
      }
    }
    return promise;
  }
  static create(options) {
    return new this(options);
  }
}
export { createDeferred, RequestManager as default };