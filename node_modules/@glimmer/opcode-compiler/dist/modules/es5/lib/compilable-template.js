import { meta } from './opcode-builder/helpers/shared';
import { EMPTY_ARRAY } from '@glimmer/util';
import { templateCompilationContext } from './opcode-builder/context';
import { debugCompiler } from './compiler';
import { STATEMENTS } from './syntax/statements';
import { encodeOp } from './opcode-builder/encoder';
export var PLACEHOLDER_HANDLE = -1;

var CompilableTemplateImpl = /*#__PURE__*/function () {
  function CompilableTemplateImpl(statements, meta, // Part of CompilableTemplate
  symbolTable, // Used for debugging
  moduleName) {
    if (moduleName === void 0) {
      moduleName = 'plain block';
    }

    this.statements = statements;
    this.meta = meta;
    this.symbolTable = symbolTable;
    this.moduleName = moduleName;
    this.compiled = null;
  } // Part of CompilableTemplate


  var _proto = CompilableTemplateImpl.prototype;

  _proto.compile = function compile(context) {
    return maybeCompile(this, context);
  };

  return CompilableTemplateImpl;
}();

export function compilable(layout, moduleName) {
  var _layout$block = layout.block,
      statements = _layout$block[0],
      symbols = _layout$block[1],
      hasEval = _layout$block[2];
  return new CompilableTemplateImpl(statements, meta(layout), {
    symbols: symbols,
    hasEval: hasEval
  }, moduleName);
}

function maybeCompile(compilable, context) {
  if (compilable.compiled !== null) return compilable.compiled;
  compilable.compiled = PLACEHOLDER_HANDLE;
  var statements = compilable.statements,
      meta = compilable.meta;
  var result = compileStatements(statements, meta, context);
  compilable.compiled = result;
  return result;
}

export function compileStatements(statements, meta, syntaxContext) {
  var sCompiler = STATEMENTS;
  var context = templateCompilationContext(syntaxContext, meta);
  var encoder = context.encoder,
      _context$program = context.program,
      constants = _context$program.constants,
      resolver = _context$program.resolver;

  function pushOp() {
    for (var _len = arguments.length, op = new Array(_len), _key = 0; _key < _len; _key++) {
      op[_key] = arguments[_key];
    }

    encodeOp(encoder, constants, resolver, meta, op);
  }

  for (var i = 0; i < statements.length; i++) {
    sCompiler.compile(pushOp, statements[i]);
  }

  var handle = context.encoder.commit(meta.size);

  if (false
  /* LOCAL_SHOULD_LOG */
  ) {
      debugCompiler(context, handle);
    }

  return handle;
}
export function compilableBlock(block, containing) {
  return new CompilableTemplateImpl(block[0], containing, {
    parameters: block[1] || EMPTY_ARRAY
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvY29tcGlsYWJsZS10ZW1wbGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFrQkEsU0FBQSxJQUFBLFFBQUEsaUNBQUE7QUFDQSxTQUFBLFdBQUEsUUFBQSxlQUFBO0FBQ0EsU0FBQSwwQkFBQSxRQUFBLDBCQUFBO0FBRUEsU0FBQSxhQUFBLFFBQUEsWUFBQTtBQUNBLFNBQUEsVUFBQSxRQUFBLHFCQUFBO0FBRUEsU0FBQSxRQUFBLFFBQUEsMEJBQUE7QUFFQSxPQUFPLElBQU0sa0JBQWtCLEdBQUcsQ0FBM0IsQ0FBQTs7SUFFUCxzQjtBQUdFLGtDQUFBLFVBQUEsRUFBQSxJQUFBLEVBR0U7QUFIRixFQUFBLFdBQUEsRUFLRTtBQUNTLEVBQUEsVUFOWCxFQU1xQztBQUFBLFFBQTFCLFVBQTBCO0FBQTFCLE1BQUEsVUFBMEIsR0FOckMsYUFNcUM7QUFBQTs7QUFMMUIsU0FBQSxVQUFBLEdBQUEsVUFBQTtBQUNBLFNBQUEsSUFBQSxHQUFBLElBQUE7QUFFQSxTQUFBLFdBQUEsR0FBQSxXQUFBO0FBRUEsU0FBQSxVQUFBLEdBQUEsVUFBQTtBQVJYLFNBQUEsUUFBQSxHQUFBLElBQUE7QUFEMEIsRyxDQVkxQjs7Ozs7U0FDQSxPLEdBQUEsaUJBQU8sT0FBUCxFQUE4QztBQUM1QyxXQUFPLFlBQVksQ0FBQSxJQUFBLEVBQW5CLE9BQW1CLENBQW5CO0FBQ0QsRzs7Ozs7QUFHSCxPQUFNLFNBQUEsVUFBQSxDQUFBLE1BQUEsRUFBQSxVQUFBLEVBQWtFO0FBQUEsc0JBQ2pDLE1BQU0sQ0FBM0MsS0FEc0U7QUFBQSxNQUNsRSxVQURrRTtBQUFBLE1BQ2xFLE9BRGtFO0FBQUEsTUFDbEUsT0FEa0U7QUFFdEUsU0FBTyxJQUFBLHNCQUFBLENBQUEsVUFBQSxFQUVMLElBQUksQ0FGQyxNQUVELENBRkMsRUFHTDtBQUNFLElBQUEsT0FERixFQUNFLE9BREY7QUFFRSxJQUFBLE9BQUEsRUFBQTtBQUZGLEdBSEssRUFBUCxVQUFPLENBQVA7QUFTRDs7QUFFRCxTQUFBLFlBQUEsQ0FBQSxVQUFBLEVBQUEsT0FBQSxFQUV3QztBQUV0QyxNQUFJLFVBQVUsQ0FBVixRQUFBLEtBQUosSUFBQSxFQUFrQyxPQUFPLFVBQVUsQ0FBakIsUUFBQTtBQUVsQyxFQUFBLFVBQVUsQ0FBVixRQUFBLEdBQUEsa0JBQUE7QUFKc0MsTUFNbEMsVUFOa0MsR0FNdEMsVUFOc0MsQ0FNbEMsVUFOa0M7QUFBQSxNQU1wQixJQU5vQixHQU10QyxVQU5zQyxDQU1wQixJQU5vQjtBQVF0QyxNQUFJLE1BQU0sR0FBRyxpQkFBaUIsQ0FBQSxVQUFBLEVBQUEsSUFBQSxFQUE5QixPQUE4QixDQUE5QjtBQUNBLEVBQUEsVUFBVSxDQUFWLFFBQUEsR0FBQSxNQUFBO0FBRUEsU0FBQSxNQUFBO0FBQ0Q7O0FBRUQsT0FBTSxTQUFBLGlCQUFBLENBQUEsVUFBQSxFQUFBLElBQUEsRUFBQSxhQUFBLEVBR3dDO0FBRTVDLE1BQUksU0FBUyxHQUFiLFVBQUE7QUFDQSxNQUFJLE9BQU8sR0FBRywwQkFBMEIsQ0FBQSxhQUFBLEVBQXhDLElBQXdDLENBQXhDO0FBSDRDLE1BS3hDLE9BTHdDLEdBSzVDLE9BTDRDLENBS3hDLE9BTHdDO0FBQUEseUJBSzVDLE9BTDRDLENBTzFDLE9BUDBDO0FBQUEsTUFPakMsU0FQaUMsb0JBT2pDLFNBUGlDO0FBQUEsTUFPcEIsUUFQb0Isb0JBT3BCLFFBUG9COztBQVU1QyxXQUFBLE1BQUEsR0FBcUU7QUFBQSxzQ0FBckUsRUFBcUU7QUFBckUsTUFBQSxFQUFxRTtBQUFBOztBQUNuRSxJQUFBLFFBQVEsQ0FBQSxPQUFBLEVBQUEsU0FBQSxFQUFBLFFBQUEsRUFBQSxJQUFBLEVBQVIsRUFBUSxDQUFSO0FBQ0Q7O0FBRUQsT0FBSyxJQUFJLENBQUMsR0FBVixDQUFBLEVBQWdCLENBQUMsR0FBRyxVQUFVLENBQTlCLE1BQUEsRUFBdUMsQ0FBdkMsRUFBQSxFQUE0QztBQUMxQyxJQUFBLFNBQVMsQ0FBVCxPQUFBLENBQUEsTUFBQSxFQUEwQixVQUFVLENBQXBDLENBQW9DLENBQXBDO0FBQ0Q7O0FBRUQsTUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFQLE9BQUEsQ0FBQSxNQUFBLENBQXVCLElBQUksQ0FBeEMsSUFBYSxDQUFiOztBQUVBLE1BQUE7QUFBQTtBQUFBLElBQXNCO0FBQ3BCLE1BQUEsYUFBYSxDQUFBLE9BQUEsRUFBYixNQUFhLENBQWI7QUFDRDs7QUFFRCxTQUFBLE1BQUE7QUFDRDtBQUVELE9BQU0sU0FBQSxlQUFBLENBQUEsS0FBQSxFQUFBLFVBQUEsRUFFMEI7QUFFOUIsU0FBTyxJQUFBLHNCQUFBLENBQTZDLEtBQUssQ0FBbEQsQ0FBa0QsQ0FBbEQsRUFBQSxVQUFBLEVBQW1FO0FBQ3hFLElBQUEsVUFBVSxFQUFFLEtBQUssQ0FBTCxDQUFLLENBQUwsSUFBYTtBQUQrQyxHQUFuRSxDQUFQO0FBR0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBPcHRpb24sXG4gIExheW91dFdpdGhDb250ZXh0LFxuICBDb250YWluaW5nTWV0YWRhdGEsXG4gIFNlcmlhbGl6ZWRJbmxpbmVCbG9jayxcbiAgV2lyZUZvcm1hdCxcbiAgU3ltYm9sVGFibGUsXG4gIENvbXBpbGFibGVUZW1wbGF0ZSxcbiAgU3RhdGVtZW50LFxuICBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCxcbiAgQ29tcGlsYWJsZUJsb2NrLFxuICBDb21waWxhYmxlUHJvZ3JhbSxcbiAgSGFuZGxlUmVzdWx0LFxuICBCbG9ja1N5bWJvbFRhYmxlLFxuICBTZXJpYWxpemVkQmxvY2ssXG4gIEJ1aWxkZXJPcCxcbiAgSGlnaExldmVsT3AsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgbWV0YSB9IGZyb20gJy4vb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9zaGFyZWQnO1xuaW1wb3J0IHsgRU1QVFlfQVJSQVkgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IHRlbXBsYXRlQ29tcGlsYXRpb25Db250ZXh0IH0gZnJvbSAnLi9vcGNvZGUtYnVpbGRlci9jb250ZXh0JztcbmltcG9ydCB7IExPQ0FMX1NIT1VMRF9MT0cgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBkZWJ1Z0NvbXBpbGVyIH0gZnJvbSAnLi9jb21waWxlcic7XG5pbXBvcnQgeyBTVEFURU1FTlRTIH0gZnJvbSAnLi9zeW50YXgvc3RhdGVtZW50cyc7XG5pbXBvcnQgeyBIaWdoTGV2ZWxTdGF0ZW1lbnRPcCB9IGZyb20gJy4vc3ludGF4L2NvbXBpbGVycyc7XG5pbXBvcnQgeyBlbmNvZGVPcCB9IGZyb20gJy4vb3Bjb2RlLWJ1aWxkZXIvZW5jb2Rlcic7XG5cbmV4cG9ydCBjb25zdCBQTEFDRUhPTERFUl9IQU5ETEUgPSAtMTtcblxuY2xhc3MgQ29tcGlsYWJsZVRlbXBsYXRlSW1wbDxTIGV4dGVuZHMgU3ltYm9sVGFibGU+IGltcGxlbWVudHMgQ29tcGlsYWJsZVRlbXBsYXRlPFM+IHtcbiAgY29tcGlsZWQ6IE9wdGlvbjxIYW5kbGVSZXN1bHQ+ID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBzdGF0ZW1lbnRzOiBXaXJlRm9ybWF0LlN0YXRlbWVudFtdLFxuICAgIHJlYWRvbmx5IG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgICAvLyBQYXJ0IG9mIENvbXBpbGFibGVUZW1wbGF0ZVxuICAgIHJlYWRvbmx5IHN5bWJvbFRhYmxlOiBTLFxuICAgIC8vIFVzZWQgZm9yIGRlYnVnZ2luZ1xuICAgIHJlYWRvbmx5IG1vZHVsZU5hbWUgPSAncGxhaW4gYmxvY2snXG4gICkge31cblxuICAvLyBQYXJ0IG9mIENvbXBpbGFibGVUZW1wbGF0ZVxuICBjb21waWxlKGNvbnRleHQ6IENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0KTogSGFuZGxlUmVzdWx0IHtcbiAgICByZXR1cm4gbWF5YmVDb21waWxlKHRoaXMsIGNvbnRleHQpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxhYmxlKGxheW91dDogTGF5b3V0V2l0aENvbnRleHQsIG1vZHVsZU5hbWU6IHN0cmluZyk6IENvbXBpbGFibGVQcm9ncmFtIHtcbiAgbGV0IFtzdGF0ZW1lbnRzLCBzeW1ib2xzLCBoYXNFdmFsXSA9IGxheW91dC5ibG9jaztcbiAgcmV0dXJuIG5ldyBDb21waWxhYmxlVGVtcGxhdGVJbXBsKFxuICAgIHN0YXRlbWVudHMsXG4gICAgbWV0YShsYXlvdXQpLFxuICAgIHtcbiAgICAgIHN5bWJvbHMsXG4gICAgICBoYXNFdmFsLFxuICAgIH0sXG4gICAgbW9kdWxlTmFtZVxuICApO1xufVxuXG5mdW5jdGlvbiBtYXliZUNvbXBpbGUoXG4gIGNvbXBpbGFibGU6IENvbXBpbGFibGVUZW1wbGF0ZUltcGw8U3ltYm9sVGFibGU+LFxuICBjb250ZXh0OiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dFxuKTogSGFuZGxlUmVzdWx0IHtcbiAgaWYgKGNvbXBpbGFibGUuY29tcGlsZWQgIT09IG51bGwpIHJldHVybiBjb21waWxhYmxlLmNvbXBpbGVkITtcblxuICBjb21waWxhYmxlLmNvbXBpbGVkID0gUExBQ0VIT0xERVJfSEFORExFO1xuXG4gIGxldCB7IHN0YXRlbWVudHMsIG1ldGEgfSA9IGNvbXBpbGFibGU7XG5cbiAgbGV0IHJlc3VsdCA9IGNvbXBpbGVTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIG1ldGEsIGNvbnRleHQpO1xuICBjb21waWxhYmxlLmNvbXBpbGVkID0gcmVzdWx0O1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlU3RhdGVtZW50cyhcbiAgc3RhdGVtZW50czogU3RhdGVtZW50W10sXG4gIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgc3ludGF4Q29udGV4dDogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHRcbik6IEhhbmRsZVJlc3VsdCB7XG4gIGxldCBzQ29tcGlsZXIgPSBTVEFURU1FTlRTO1xuICBsZXQgY29udGV4dCA9IHRlbXBsYXRlQ29tcGlsYXRpb25Db250ZXh0KHN5bnRheENvbnRleHQsIG1ldGEpO1xuXG4gIGxldCB7XG4gICAgZW5jb2RlcixcbiAgICBwcm9ncmFtOiB7IGNvbnN0YW50cywgcmVzb2x2ZXIgfSxcbiAgfSA9IGNvbnRleHQ7XG5cbiAgZnVuY3Rpb24gcHVzaE9wKC4uLm9wOiBCdWlsZGVyT3AgfCBIaWdoTGV2ZWxPcCB8IEhpZ2hMZXZlbFN0YXRlbWVudE9wKSB7XG4gICAgZW5jb2RlT3AoZW5jb2RlciwgY29uc3RhbnRzLCByZXNvbHZlciwgbWV0YSwgb3AgYXMgQnVpbGRlck9wIHwgSGlnaExldmVsT3ApO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgc0NvbXBpbGVyLmNvbXBpbGUocHVzaE9wLCBzdGF0ZW1lbnRzW2ldKTtcbiAgfVxuXG4gIGxldCBoYW5kbGUgPSBjb250ZXh0LmVuY29kZXIuY29tbWl0KG1ldGEuc2l6ZSk7XG5cbiAgaWYgKExPQ0FMX1NIT1VMRF9MT0cpIHtcbiAgICBkZWJ1Z0NvbXBpbGVyKGNvbnRleHQsIGhhbmRsZSk7XG4gIH1cblxuICByZXR1cm4gaGFuZGxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsYWJsZUJsb2NrKFxuICBibG9jazogU2VyaWFsaXplZElubGluZUJsb2NrIHwgU2VyaWFsaXplZEJsb2NrLFxuICBjb250YWluaW5nOiBDb250YWluaW5nTWV0YWRhdGFcbik6IENvbXBpbGFibGVCbG9jayB7XG4gIHJldHVybiBuZXcgQ29tcGlsYWJsZVRlbXBsYXRlSW1wbDxCbG9ja1N5bWJvbFRhYmxlPihibG9ja1swXSwgY29udGFpbmluZywge1xuICAgIHBhcmFtZXRlcnM6IGJsb2NrWzFdIHx8IChFTVBUWV9BUlJBWSBhcyBudW1iZXJbXSksXG4gIH0pO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==