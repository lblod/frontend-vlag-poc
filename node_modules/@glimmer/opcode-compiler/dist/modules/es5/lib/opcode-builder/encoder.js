function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import { InstructionEncoderImpl } from '@glimmer/encoder';
import { isMachineOp } from '@glimmer/vm';
import { Stack, dict, EMPTY_STRING_ARRAY, encodeHandle, assert } from '@glimmer/util';
import { resolveComponent, resolveComponentOrHelper, resolveHelper, resolveModifier, resolveOptionalComponentOrHelper, resolveOptionalHelper } from './helpers/resolution';
import { compilableBlock } from '../compilable-template';
import { DEBUG } from '@glimmer/env';
export var Labels = /*#__PURE__*/function () {
  function Labels() {
    this.labels = dict();
    this.targets = [];
  }

  var _proto = Labels.prototype;

  _proto.label = function label(name, index) {
    this.labels[name] = index;
  };

  _proto.target = function target(at, _target) {
    this.targets.push({
      at: at,
      target: _target
    });
  };

  _proto.patch = function patch(heap) {
    var targets = this.targets,
        labels = this.labels;

    for (var i = 0; i < targets.length; i++) {
      var _targets$i = targets[i],
          at = _targets$i.at,
          target = _targets$i.target;
      var address = labels[target] - at;
      false && assert(heap.getbyaddr(at) === -1, 'Expected heap to contain a placeholder, but it did not');
      heap.setbyaddr(at, address);
    }
  };

  return Labels;
}();
export function encodeOp(encoder, constants, resolver, meta, op) {
  if (isBuilderOpcode(op[0])) {
    var type = op[0],
        operands = op.slice(1);
    encoder.push.apply(encoder, [constants, type].concat(operands));
  } else {
    switch (op[0]) {
      case 1000
      /* Label */
      :
        return encoder.label(op[1]);

      case 1001
      /* StartLabels */
      :
        return encoder.startLabels();

      case 1002
      /* StopLabels */
      :
        return encoder.stopLabels();

      case 1004
      /* ResolveComponent */
      :
        return resolveComponent(resolver, constants, meta, op);

      case 1003
      /* ResolveModifier */
      :
        return resolveModifier(resolver, constants, meta, op);

      case 1005
      /* ResolveHelper */
      :
        return resolveHelper(resolver, constants, meta, op);

      case 1007
      /* ResolveComponentOrHelper */
      :
        return resolveComponentOrHelper(resolver, constants, meta, op);

      case 1006
      /* ResolveOptionalHelper */
      :
        return resolveOptionalHelper(resolver, constants, meta, op);

      case 1008
      /* ResolveOptionalComponentOrHelper */
      :
        return resolveOptionalComponentOrHelper(resolver, constants, meta, op);

      case 1010
      /* ResolveLocal */
      :
        var freeVar = op[1];
        var name = meta.upvars[freeVar];
        var andThen = op[2];
        andThen(name, meta.moduleName);
        break;

      case 1011
      /* ResolveTemplateLocal */
      :
        var valueIndex = op[1],
            then = op[2];
        var value = meta.scopeValues[valueIndex];
        then(constants.value(value));
        break;

      case 1009
      /* ResolveFree */
      :
        if (DEBUG) {
          var upvarIndex = op[1];
          var freeName = meta.upvars[upvarIndex];
          throw new Error("Attempted to resolve a value in a strict mode template, but that value was not in scope: " + freeName);
        }

        break;

      default:
        throw new Error("Unexpected high level opcode " + op[0]);
    }
  }
}
export var EncoderImpl = /*#__PURE__*/function () {
  function EncoderImpl(heap, meta, stdlib) {
    this.heap = heap;
    this.meta = meta;
    this.stdlib = stdlib;
    this.labelsStack = new Stack();
    this.encoder = new InstructionEncoderImpl([]);
    this.errors = [];
    this.handle = heap.malloc();
  }

  var _proto2 = EncoderImpl.prototype;

  _proto2.error = function error(_error) {
    this.encoder.encode(30
    /* Primitive */
    , 0);
    this.errors.push(_error);
  };

  _proto2.commit = function commit(size) {
    var handle = this.handle;
    this.heap.push(5
    /* Return */
    | 1024
    /* MACHINE_MASK */
    );
    this.heap.finishMalloc(handle, size);

    if (this.errors.length) {
      return {
        errors: this.errors,
        handle: handle
      };
    } else {
      return handle;
    }
  };

  _proto2.push = function push(constants, type) {
    var heap = this.heap;

    if (DEBUG && type > 255
    /* TYPE_SIZE */
    ) {
        throw new Error("Opcode type over 8-bits. Got " + type + ".");
      }

    var machine = isMachineOp(type) ? 1024
    /* MACHINE_MASK */
    : 0;
    var first = type | machine | (arguments.length <= 2 ? 0 : arguments.length - 2) << 8
    /* ARG_SHIFT */
    ;
    heap.push(first);

    for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
      var op = i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2];
      heap.push(this.operand(constants, op));
    }
  };

  _proto2.operand = function operand(constants, _operand) {
    if (typeof _operand === 'number') {
      return _operand;
    }

    if (typeof _operand === 'object' && _operand !== null) {
      if (Array.isArray(_operand)) {
        return encodeHandle(constants.array(_operand));
      } else {
        switch (_operand.type) {
          case 1
          /* Label */
          :
            this.currentLabels.target(this.heap.offset, _operand.value);
            return -1;

          case 2
          /* IsStrictMode */
          :
            return encodeHandle(constants.value(this.meta.isStrictMode));

          case 3
          /* EvalSymbols */
          :
            return encodeHandle(constants.array(this.meta.evalSymbols || EMPTY_STRING_ARRAY));

          case 4
          /* Block */
          :
            return encodeHandle(constants.value(compilableBlock(_operand.value, this.meta)));

          case 5
          /* StdLib */
          :
            return this.stdlib[_operand.value];

          case 6
          /* NonSmallInt */
          :
          case 7
          /* SymbolTable */
          :
          case 8
          /* Layout */
          :
            return constants.value(_operand.value);
        }
      }
    }

    return encodeHandle(constants.value(_operand));
  };

  _proto2.label = function label(name) {
    this.currentLabels.label(name, this.heap.offset + 1);
  };

  _proto2.startLabels = function startLabels() {
    this.labelsStack.push(new Labels());
  };

  _proto2.stopLabels = function stopLabels() {
    var label = this.labelsStack.pop();
    label.patch(this.heap);
  };

  _createClass(EncoderImpl, [{
    key: "currentLabels",
    get: function get() {
      return this.labelsStack.current;
    }
  }]);

  return EncoderImpl;
}();

function isBuilderOpcode(op) {
  return op < 1000
  /* Start */
  ;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvb3Bjb2RlLWJ1aWxkZXIvZW5jb2Rlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsU0FBQSxzQkFBQSxRQUFBLGtCQUFBO0FBeUJBLFNBQUEsV0FBQSxRQUFBLGFBQUE7QUFDQSxTQUFBLEtBQUEsRUFBQSxJQUFBLEVBQUEsa0JBQUEsRUFBQSxZQUFBLEVBQUEsTUFBQSxRQUFBLGVBQUE7QUFDQSxTQUFBLGdCQUFBLEVBQUEsd0JBQUEsRUFBQSxhQUFBLEVBQUEsZUFBQSxFQUFBLGdDQUFBLEVBQUEscUJBQUEsUUFBQSxzQkFBQTtBQVFBLFNBQUEsZUFBQSxRQUFBLHdCQUFBO0FBQ0EsU0FBQSxLQUFBLFFBQUEsY0FBQTtBQUVBLFdBQU0sTUFBTjtBQUFBLG9CQUFBO0FBQ0UsU0FBQSxNQUFBLEdBQXVCLElBQXZCLEVBQUE7QUFDQSxTQUFBLE9BQUEsR0FBQSxFQUFBO0FBcUJEOztBQXZCRDs7QUFBQSxTQUlFLEtBSkYsR0FJRSxlQUFLLElBQUwsRUFBSyxLQUFMLEVBQWlDO0FBQy9CLFNBQUEsTUFBQSxDQUFBLElBQUEsSUFBQSxLQUFBO0FBQ0QsR0FOSDs7QUFBQSxTQVFFLE1BUkYsR0FRRSxnQkFBTSxFQUFOLEVBQU0sT0FBTixFQUFpQztBQUMvQixTQUFBLE9BQUEsQ0FBQSxJQUFBLENBQWtCO0FBQUUsTUFBQSxFQUFGLEVBQUUsRUFBRjtBQUFNLE1BQUEsTUFBQSxFQUFBO0FBQU4sS0FBbEI7QUFDRCxHQVZIOztBQUFBLFNBWUUsS0FaRixHQVlFLGVBQUssSUFBTCxFQUEyQjtBQUFBLFFBQ3JCLE9BRHFCLEdBQ3pCLElBRHlCLENBQ3JCLE9BRHFCO0FBQUEsUUFDVixNQURVLEdBQ3pCLElBRHlCLENBQ1YsTUFEVTs7QUFFekIsU0FBSyxJQUFJLENBQUMsR0FBVixDQUFBLEVBQWdCLENBQUMsR0FBRyxPQUFPLENBQTNCLE1BQUEsRUFB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QXhHSDs7QUFBQSxVQTBHRSxVQTFHRixHQTBHRSxzQkFBVTtBQUNSLFFBQUksS0FBSyxHQUFVLEtBQUEsV0FBQSxDQUFuQixHQUFtQixFQUFuQjtBQUNBLElBQUEsS0FBSyxDQUFMLEtBQUEsQ0FBWSxLQUFaLElBQUE7QUFDRCxHQTdHSDs7QUFBQTtBQUFBO0FBQUEsd0JBOEYyQjtBQUN2QixhQUFjLEtBQUEsV0FBQSxDQUFkLE9BQUE7QUFDRDtBQWhHSDs7QUFBQTtBQUFBOztBQWdIQSxTQUFBLGVBQUEsQ0FBQSxFQUFBLEVBQW1DO0FBQ2pDLFNBQU8sRUFBRSxHQUFBO0FBQUE7QUFBVDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5zdHJ1Y3Rpb25FbmNvZGVySW1wbCB9IGZyb20gJ0BnbGltbWVyL2VuY29kZXInO1xuaW1wb3J0IHtcbiAgQ29tcGlsZVRpbWVDb25zdGFudHMsXG4gIE9wZXJhbmQsXG4gIENvbXBpbGVUaW1lSGVhcCxcbiAgT3AsXG4gIEJ1aWxkZXJPcGNvZGUsXG4gIEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUsXG4gIE1hY2hpbmVPcCxcbiAgU2luZ2xlQnVpbGRlck9wZXJhbmQsXG4gIEVuY29kZXIsXG4gIEhpZ2hMZXZlbFJlc29sdXRpb25PcGNvZGUsXG4gIEhpZ2hMZXZlbE9wLFxuICBPcGNvZGVTaXplLFxuICBJbnN0cnVjdGlvbkVuY29kZXIsXG4gIERpY3QsXG4gIEVuY29kZXJFcnJvcixcbiAgSGFuZGxlUmVzdWx0LFxuICBCdWlsZGVyT3AsXG4gIENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgSGlnaExldmVsT3BlcmFuZCxcbiAgU1RETGliLFxuICBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBpc01hY2hpbmVPcCB9IGZyb20gJ0BnbGltbWVyL3ZtJztcbmltcG9ydCB7IFN0YWNrLCBkaWN0LCBleHBlY3QsIEVNUFRZX1NUUklOR19BUlJBWSwgZW5jb2RlSGFuZGxlLCBhc3NlcnQgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7XG4gIHJlc29sdmVDb21wb25lbnQsXG4gIHJlc29sdmVDb21wb25lbnRPckhlbHBlcixcbiAgcmVzb2x2ZUhlbHBlcixcbiAgcmVzb2x2ZU1vZGlmaWVyLFxuICByZXNvbHZlT3B0aW9uYWxDb21wb25lbnRPckhlbHBlcixcbiAgcmVzb2x2ZU9wdGlvbmFsSGVscGVyLFxufSBmcm9tICcuL2hlbHBlcnMvcmVzb2x1dGlvbic7XG5pbXBvcnQgeyBjb21waWxhYmxlQmxvY2sgfSBmcm9tICcuLi9jb21waWxhYmxlLXRlbXBsYXRlJztcbmltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcblxuZXhwb3J0IGNsYXNzIExhYmVscyB7XG4gIGxhYmVsczogRGljdDxudW1iZXI+ID0gZGljdCgpO1xuICB0YXJnZXRzOiBBcnJheTx7IGF0OiBudW1iZXI7IHRhcmdldDogc3RyaW5nIH0+ID0gW107XG5cbiAgbGFiZWwobmFtZTogc3RyaW5nLCBpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5sYWJlbHNbbmFtZV0gPSBpbmRleDtcbiAgfVxuXG4gIHRhcmdldChhdDogbnVtYmVyLCB0YXJnZXQ6IHN0cmluZykge1xuICAgIHRoaXMudGFyZ2V0cy5wdXNoKHsgYXQsIHRhcmdldCB9KTtcbiAgfVxuXG4gIHBhdGNoKGhlYXA6IENvbXBpbGVUaW1lSGVhcCk6IHZvaWQge1xuICAgIGxldCB7IHRhcmdldHMsIGxhYmVscyB9ID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB7IGF0LCB0YXJnZXQgfSA9IHRhcmdldHNbaV07XG4gICAgICBsZXQgYWRkcmVzcyA9IGxhYmVsc1t0YXJnZXRdIC0gYXQ7XG5cbiAgICAgIGFzc2VydChoZWFwLmdldGJ5YWRkcihhdCkgPT09IC0xLCAnRXhwZWN0ZWQgaGVhcCB0byBjb250YWluIGEgcGxhY2Vob2xkZXIsIGJ1dCBpdCBkaWQgbm90Jyk7XG5cbiAgICAgIGhlYXAuc2V0YnlhZGRyKGF0LCBhZGRyZXNzKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZU9wKFxuICBlbmNvZGVyOiBFbmNvZGVyLFxuICBjb25zdGFudHM6IENvbXBpbGVUaW1lQ29uc3RhbnRzICYgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG4gIHJlc29sdmVyOiBDb21waWxlVGltZVJlc29sdmVyLFxuICBtZXRhOiBDb250YWluaW5nTWV0YWRhdGEsXG4gIG9wOiBCdWlsZGVyT3AgfCBIaWdoTGV2ZWxPcFxuKTogdm9pZCB7XG4gIGlmIChpc0J1aWxkZXJPcGNvZGUob3BbMF0pKSB7XG4gICAgbGV0IFt0eXBlLCAuLi5vcGVyYW5kc10gPSBvcDtcbiAgICBlbmNvZGVyLnB1c2goY29uc3RhbnRzLCB0eXBlLCAuLi4ob3BlcmFuZHMgYXMgU2luZ2xlQnVpbGRlck9wZXJhbmRbXSkpO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgIGNhc2UgSGlnaExldmVsQnVpbGRlck9wY29kZS5MYWJlbDpcbiAgICAgICAgcmV0dXJuIGVuY29kZXIubGFiZWwob3BbMV0pO1xuICAgICAgY2FzZSBIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLlN0YXJ0TGFiZWxzOlxuICAgICAgICByZXR1cm4gZW5jb2Rlci5zdGFydExhYmVscygpO1xuICAgICAgY2FzZSBIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLlN0b3BMYWJlbHM6XG4gICAgICAgIHJldHVybiBlbmNvZGVyLnN0b3BMYWJlbHMoKTtcblxuICAgICAgY2FzZSBIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiByZXNvbHZlQ29tcG9uZW50KHJlc29sdmVyLCBjb25zdGFudHMsIG1ldGEsIG9wKTtcbiAgICAgIGNhc2UgSGlnaExldmVsUmVzb2x1dGlvbk9wY29kZS5SZXNvbHZlTW9kaWZpZXI6XG4gICAgICAgIHJldHVybiByZXNvbHZlTW9kaWZpZXIocmVzb2x2ZXIsIGNvbnN0YW50cywgbWV0YSwgb3ApO1xuICAgICAgY2FzZSBIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVIZWxwZXI6XG4gICAgICAgIHJldHVybiByZXNvbHZlSGVscGVyKHJlc29sdmVyLCBjb25zdGFudHMsIG1ldGEsIG9wKTtcbiAgICAgIGNhc2UgSGlnaExldmVsUmVzb2x1dGlvbk9wY29kZS5SZXNvbHZlQ29tcG9uZW50T3JIZWxwZXI6XG4gICAgICAgIHJldHVybiByZXNvbHZlQ29tcG9uZW50T3JIZWxwZXIocmVzb2x2ZXIsIGNvbnN0YW50cywgbWV0YSwgb3ApO1xuICAgICAgY2FzZSBIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVPcHRpb25hbEhlbHBlcjpcbiAgICAgICAgcmV0dXJuIHJlc29sdmVPcHRpb25hbEhlbHBlcihyZXNvbHZlciwgY29uc3RhbnRzLCBtZXRhLCBvcCk7XG4gICAgICBjYXNlIEhpZ2hMZXZlbFJlc29sdXRpb25PcGNvZGUuUmVzb2x2ZU9wdGlvbmFsQ29tcG9uZW50T3JIZWxwZXI6XG4gICAgICAgIHJldHVybiByZXNvbHZlT3B0aW9uYWxDb21wb25lbnRPckhlbHBlcihyZXNvbHZlciwgY29uc3RhbnRzLCBtZXRhLCBvcCk7XG5cbiAgICAgIGNhc2UgSGlnaExldmVsUmVzb2x1dGlvbk9wY29kZS5SZXNvbHZlTG9jYWw6XG4gICAgICAgIGxldCBmcmVlVmFyID0gb3BbMV07XG4gICAgICAgIGxldCBuYW1lID0gZXhwZWN0KG1ldGEudXB2YXJzLCAnQlVHOiBhdHRlbXB0ZWQgdG8gcmVzb2x2ZSB2YWx1ZSBidXQgbm8gdXB2YXJzIGZvdW5kJylbXG4gICAgICAgICAgZnJlZVZhclxuICAgICAgICBdO1xuXG4gICAgICAgIGxldCBhbmRUaGVuID0gb3BbMl07XG5cbiAgICAgICAgYW5kVGhlbihuYW1lLCBtZXRhLm1vZHVsZU5hbWUpO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEhpZ2hMZXZlbFJlc29sdXRpb25PcGNvZGUuUmVzb2x2ZVRlbXBsYXRlTG9jYWw6XG4gICAgICAgIGxldCBbLCB2YWx1ZUluZGV4LCB0aGVuXSA9IG9wO1xuICAgICAgICBsZXQgdmFsdWUgPSBleHBlY3QoXG4gICAgICAgICAgbWV0YS5zY29wZVZhbHVlcyxcbiAgICAgICAgICAnQlVHOiBBdHRlbXB0ZWQgdG8gZ2VjdCBhIHRlbXBsYXRlIGxvY2FsLCBidXQgdGVtcGxhdGUgZG9lcyBub3QgaGF2ZSBhbnknXG4gICAgICAgIClbdmFsdWVJbmRleF07XG5cbiAgICAgICAgdGhlbihjb25zdGFudHMudmFsdWUodmFsdWUpKTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVGcmVlOlxuICAgICAgICBpZiAoREVCVUcpIHtcbiAgICAgICAgICBsZXQgWywgdXB2YXJJbmRleF0gPSBvcDtcbiAgICAgICAgICBsZXQgZnJlZU5hbWUgPSBleHBlY3QobWV0YS51cHZhcnMsICdCVUc6IGF0dGVtcHRlZCB0byByZXNvbHZlIHZhbHVlIGJ1dCBubyB1cHZhcnMgZm91bmQnKVtcbiAgICAgICAgICAgIHVwdmFySW5kZXhcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEF0dGVtcHRlZCB0byByZXNvbHZlIGEgdmFsdWUgaW4gYSBzdHJpY3QgbW9kZSB0ZW1wbGF0ZSwgYnV0IHRoYXQgdmFsdWUgd2FzIG5vdCBpbiBzY29wZTogJHtmcmVlTmFtZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGhpZ2ggbGV2ZWwgb3Bjb2RlICR7b3BbMF19YCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFbmNvZGVySW1wbCBpbXBsZW1lbnRzIEVuY29kZXIge1xuICBwcml2YXRlIGxhYmVsc1N0YWNrID0gbmV3IFN0YWNrPExhYmVscz4oKTtcbiAgcHJpdmF0ZSBlbmNvZGVyOiBJbnN0cnVjdGlvbkVuY29kZXIgPSBuZXcgSW5zdHJ1Y3Rpb25FbmNvZGVySW1wbChbXSk7XG4gIHByaXZhdGUgZXJyb3JzOiBFbmNvZGVyRXJyb3JbXSA9IFtdO1xuICBwcml2YXRlIGhhbmRsZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaGVhcDogQ29tcGlsZVRpbWVIZWFwLFxuICAgIHByaXZhdGUgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICAgIHByaXZhdGUgc3RkbGliPzogU1RETGliXG4gICkge1xuICAgIHRoaXMuaGFuZGxlID0gaGVhcC5tYWxsb2MoKTtcbiAgfVxuXG4gIGVycm9yKGVycm9yOiBFbmNvZGVyRXJyb3IpOiB2b2lkIHtcbiAgICB0aGlzLmVuY29kZXIuZW5jb2RlKE9wLlByaW1pdGl2ZSwgMCk7XG4gICAgdGhpcy5lcnJvcnMucHVzaChlcnJvcik7XG4gIH1cblxuICBjb21taXQoc2l6ZTogbnVtYmVyKTogSGFuZGxlUmVzdWx0IHtcbiAgICBsZXQgaGFuZGxlID0gdGhpcy5oYW5kbGU7XG5cbiAgICB0aGlzLmhlYXAucHVzaChNYWNoaW5lT3AuUmV0dXJuIHwgT3Bjb2RlU2l6ZS5NQUNISU5FX01BU0spO1xuICAgIHRoaXMuaGVhcC5maW5pc2hNYWxsb2MoaGFuZGxlLCBzaXplKTtcblxuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7IGVycm9yczogdGhpcy5lcnJvcnMsIGhhbmRsZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaGFuZGxlO1xuICAgIH1cbiAgfVxuXG4gIHB1c2goXG4gICAgY29uc3RhbnRzOiBDb21waWxlVGltZUNvbnN0YW50cyxcbiAgICB0eXBlOiBCdWlsZGVyT3Bjb2RlLFxuICAgIC4uLmFyZ3M6IFNpbmdsZUJ1aWxkZXJPcGVyYW5kW11cbiAgKTogdm9pZCB7XG4gICAgbGV0IHsgaGVhcCB9ID0gdGhpcztcblxuICAgIGlmIChERUJVRyAmJiAodHlwZSBhcyBudW1iZXIpID4gT3Bjb2RlU2l6ZS5UWVBFX1NJWkUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT3Bjb2RlIHR5cGUgb3ZlciA4LWJpdHMuIEdvdCAke3R5cGV9LmApO1xuICAgIH1cblxuICAgIGxldCBtYWNoaW5lID0gaXNNYWNoaW5lT3AodHlwZSkgPyBPcGNvZGVTaXplLk1BQ0hJTkVfTUFTSyA6IDA7XG4gICAgbGV0IGZpcnN0ID0gdHlwZSB8IG1hY2hpbmUgfCAoYXJncy5sZW5ndGggPDwgT3Bjb2RlU2l6ZS5BUkdfU0hJRlQpO1xuXG4gICAgaGVhcC5wdXNoKGZpcnN0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG9wID0gYXJnc1tpXTtcbiAgICAgIGhlYXAucHVzaCh0aGlzLm9wZXJhbmQoY29uc3RhbnRzLCBvcCkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb3BlcmFuZChjb25zdGFudHM6IENvbXBpbGVUaW1lQ29uc3RhbnRzLCBvcGVyYW5kOiBTaW5nbGVCdWlsZGVyT3BlcmFuZCk6IE9wZXJhbmQge1xuICAgIGlmICh0eXBlb2Ygb3BlcmFuZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBvcGVyYW5kO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3BlcmFuZCA9PT0gJ29iamVjdCcgJiYgb3BlcmFuZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3BlcmFuZCkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUhhbmRsZShjb25zdGFudHMuYXJyYXkob3BlcmFuZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChvcGVyYW5kLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIEhpZ2hMZXZlbE9wZXJhbmQuTGFiZWw6XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRMYWJlbHMudGFyZ2V0KHRoaXMuaGVhcC5vZmZzZXQsIG9wZXJhbmQudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuXG4gICAgICAgICAgY2FzZSBIaWdoTGV2ZWxPcGVyYW5kLklzU3RyaWN0TW9kZTpcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVIYW5kbGUoY29uc3RhbnRzLnZhbHVlKHRoaXMubWV0YS5pc1N0cmljdE1vZGUpKTtcblxuICAgICAgICAgIGNhc2UgSGlnaExldmVsT3BlcmFuZC5FdmFsU3ltYm9sczpcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVIYW5kbGUoY29uc3RhbnRzLmFycmF5KHRoaXMubWV0YS5ldmFsU3ltYm9scyB8fCBFTVBUWV9TVFJJTkdfQVJSQVkpKTtcblxuICAgICAgICAgIGNhc2UgSGlnaExldmVsT3BlcmFuZC5CbG9jazpcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVIYW5kbGUoY29uc3RhbnRzLnZhbHVlKGNvbXBpbGFibGVCbG9jayhvcGVyYW5kLnZhbHVlLCB0aGlzLm1ldGEpKSk7XG5cbiAgICAgICAgICBjYXNlIEhpZ2hMZXZlbE9wZXJhbmQuU3RkTGliOlxuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdChcbiAgICAgICAgICAgICAgdGhpcy5zdGRsaWIsXG4gICAgICAgICAgICAgICdhdHRlbXB0ZWQgdG8gZW5jb2RlIGEgc3RkbGliIG9wZXJhbmQsIGJ1dCB0aGUgZW5jb2RlciBkaWQgbm90IGhhdmUgYSBzdGRsaWIuIEFyZSB5b3UgY3VycmVudGx5IGJ1aWxkaW5nIHRoZSBzdGRsaWI/J1xuICAgICAgICAgICAgKVtvcGVyYW5kLnZhbHVlXTtcblxuICAgICAgICAgIGNhc2UgSGlnaExldmVsT3BlcmFuZC5Ob25TbWFsbEludDpcbiAgICAgICAgICBjYXNlIEhpZ2hMZXZlbE9wZXJhbmQuU3ltYm9sVGFibGU6XG4gICAgICAgICAgY2FzZSBIaWdoTGV2ZWxPcGVyYW5kLkxheW91dDpcbiAgICAgICAgICAgIHJldHVybiBjb25zdGFudHMudmFsdWUob3BlcmFuZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RlSGFuZGxlKGNvbnN0YW50cy52YWx1ZShvcGVyYW5kKSk7XG4gIH1cblxuICBwcml2YXRlIGdldCBjdXJyZW50TGFiZWxzKCk6IExhYmVscyB7XG4gICAgcmV0dXJuIGV4cGVjdCh0aGlzLmxhYmVsc1N0YWNrLmN1cnJlbnQsICdidWc6IG5vdCBpbiBhIGxhYmVsIHN0YWNrJyk7XG4gIH1cblxuICBsYWJlbChuYW1lOiBzdHJpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnRMYWJlbHMubGFiZWwobmFtZSwgdGhpcy5oZWFwLm9mZnNldCArIDEpO1xuICB9XG5cbiAgc3RhcnRMYWJlbHMoKSB7XG4gICAgdGhpcy5sYWJlbHNTdGFjay5wdXNoKG5ldyBMYWJlbHMoKSk7XG4gIH1cblxuICBzdG9wTGFiZWxzKCkge1xuICAgIGxldCBsYWJlbCA9IGV4cGVjdCh0aGlzLmxhYmVsc1N0YWNrLnBvcCgpLCAndW5iYWxhbmNlZCBwdXNoIGFuZCBwb3AgbGFiZWxzJyk7XG4gICAgbGFiZWwucGF0Y2godGhpcy5oZWFwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0J1aWxkZXJPcGNvZGUob3A6IG51bWJlcik6IG9wIGlzIEJ1aWxkZXJPcGNvZGUge1xuICByZXR1cm4gb3AgPCBIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLlN0YXJ0O1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==