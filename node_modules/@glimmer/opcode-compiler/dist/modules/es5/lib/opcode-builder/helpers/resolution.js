import { DEBUG } from '@glimmer/env';
import { assert, debugToString } from '@glimmer/util';

function isGetLikeTuple(opcode) {
  return Array.isArray(opcode) && opcode.length === 2;
}

function makeResolutionTypeVerifier(typeToVerify) {
  return function (opcode) {
    if (!isGetLikeTuple(opcode)) return false;
    var type = opcode[0];
    return type === 31
    /* GetStrictFree */
    || type === 32
    /* GetTemplateSymbol */
    || type === typeToVerify;
  };
}

export var isGetFreeComponent = makeResolutionTypeVerifier(39
/* GetFreeAsComponentHead */
);
export var isGetFreeModifier = makeResolutionTypeVerifier(38
/* GetFreeAsModifierHead */
);
export var isGetFreeHelper = makeResolutionTypeVerifier(37
/* GetFreeAsHelperHead */
);
export var isGetFreeComponentOrHelper = makeResolutionTypeVerifier(35
/* GetFreeAsComponentOrHelperHead */
);
export var isGetFreeOptionalHelper = makeResolutionTypeVerifier(36
/* GetFreeAsHelperHeadOrThisFallback */
);
export function isGetFreeDeprecatedHelper(opcode) {
  return Array.isArray(opcode) && opcode[0] === 99
  /* GetFreeAsDeprecatedHelperHeadOrThisFallback */
  ;
}
export var isGetFreeOptionalComponentOrHelper = makeResolutionTypeVerifier(34
/* GetFreeAsComponentOrHelperHeadOrThisFallback */
);

function assertResolverInvariants(meta) {
  if (DEBUG) {
    if (!meta.upvars) {
      throw new Error('Attempted to resolve a component, helper, or modifier, but no free vars were found');
    }

    if (!meta.owner) {
      throw new Error('Attempted to resolve a component, helper, or modifier, but no owner was associated with the template it was being resolved from');
    }
  }

  return meta;
}
/**
 * <Foo/>
 * <Foo></Foo>
 * <Foo @arg={{true}} />
 */


export function resolveComponent(resolver, constants, meta, _ref) {
  var expr = _ref[1],
      then = _ref[2];
  false && assert(isGetFreeComponent(expr), 'Attempted to resolve a component with incorrect opcode');
  var type = expr[0];

  if (DEBUG && expr[0] === 31
  /* GetStrictFree */
  ) {
      throw new Error("Attempted to resolve a component in a strict mode template, but that value was not in scope: " + meta.upvars[expr[1]]);
    }

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      var scopeValues = meta.scopeValues,
          owner = meta.owner;
      var definition = scopeValues[expr[1]];
      then(constants.component(definition, owner));
    } else {
    var _assertResolverInvari = assertResolverInvariants(meta),
        upvars = _assertResolverInvari.upvars,
        _owner = _assertResolverInvari.owner;

    var name = upvars[expr[1]];

    var _definition = resolver.lookupComponent(name, _owner);

    if (DEBUG && (typeof _definition !== 'object' || _definition === null)) {
      throw new Error("Attempted to resolve `" + name + "`, which was expected to be a component, but nothing was found.");
    }

    then(constants.resolvedComponent(_definition, name));
  }
}
/**
 * (helper)
 * (helper arg)
 */

export function resolveHelper(resolver, constants, meta, _ref2) {
  var expr = _ref2[1],
      then = _ref2[2];
  false && assert(isGetFreeHelper(expr), 'Attempted to resolve a helper with incorrect opcode');
  var type = expr[0];

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      var scopeValues = meta.scopeValues;
      var definition = scopeValues[expr[1]];
      then(constants.helper(definition));
    } else if (type === 31
  /* GetStrictFree */
  ) {
      then(lookupBuiltInHelper(expr, resolver, meta, constants, 'helper'));
    } else {
    var _assertResolverInvari2 = assertResolverInvariants(meta),
        upvars = _assertResolverInvari2.upvars,
        owner = _assertResolverInvari2.owner;

    var name = upvars[expr[1]];
    var helper = resolver.lookupHelper(name, owner);

    if (DEBUG && helper === null) {
      throw new Error("Attempted to resolve `" + name + "`, which was expected to be a helper, but nothing was found.");
    }

    then(constants.helper(helper, name));
  }
}
/**
 * <div {{modifier}}/>
 * <div {{modifier arg}}/>
 * <Foo {{modifier}}/>
 */

export function resolveModifier(resolver, constants, meta, _ref3) {
  var expr = _ref3[1],
      then = _ref3[2];
  false && assert(isGetFreeModifier(expr), 'Attempted to resolve a modifier with incorrect opcode');
  var type = expr[0];

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      var scopeValues = meta.scopeValues;
      var definition = scopeValues[expr[1]];
      then(constants.modifier(definition));
    } else if (type === 31
  /* GetStrictFree */
  ) {
      var _assertResolverInvari3 = assertResolverInvariants(meta),
          upvars = _assertResolverInvari3.upvars;

      var name = upvars[expr[1]];
      var modifier = resolver.lookupBuiltInModifier(name);

      if (DEBUG && modifier === null) {
        throw new Error("Attempted to resolve a modifier in a strict mode template, but it was not in scope: " + name);
      }

      then(constants.modifier(modifier, name));
    } else {
    var _assertResolverInvari4 = assertResolverInvariants(meta),
        _upvars = _assertResolverInvari4.upvars,
        owner = _assertResolverInvari4.owner;

    var _name = _upvars[expr[1]];

    var _modifier = resolver.lookupModifier(_name, owner);

    if (DEBUG && _modifier === null) {
      throw new Error("Attempted to resolve `" + _name + "`, which was expected to be a modifier, but nothing was found.");
    }

    then(constants.modifier(_modifier, _name));
  }
}
/**
 * {{component-or-helper arg}}
 */

export function resolveComponentOrHelper(resolver, constants, meta, _ref4) {
  var expr = _ref4[1],
      _ref4$ = _ref4[2],
      ifComponent = _ref4$.ifComponent,
      ifHelper = _ref4$.ifHelper;
  false && assert(isGetFreeComponentOrHelper(expr), 'Attempted to resolve a component or helper with incorrect opcode');
  var type = expr[0];

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      var scopeValues = meta.scopeValues,
          owner = meta.owner;
      var definition = scopeValues[expr[1]];
      var component = constants.component(definition, owner, true);

      if (component !== null) {
        ifComponent(component);
        return;
      }

      var helper = constants.helper(definition, null, true);

      if (DEBUG && helper === null) {
        throw new Error("Attempted to use a value as either a component or helper, but it did not have a component manager or helper manager associated with it. The value was: " + debugToString(definition));
      }

      ifHelper(helper);
    } else if (type === 31
  /* GetStrictFree */
  ) {
      ifHelper(lookupBuiltInHelper(expr, resolver, meta, constants, 'component or helper'));
    } else {
    var _assertResolverInvari5 = assertResolverInvariants(meta),
        upvars = _assertResolverInvari5.upvars,
        _owner2 = _assertResolverInvari5.owner;

    var name = upvars[expr[1]];

    var _definition2 = resolver.lookupComponent(name, _owner2);

    if (_definition2 !== null) {
      ifComponent(constants.resolvedComponent(_definition2, name));
    } else {
      var _helper = resolver.lookupHelper(name, _owner2);

      if (DEBUG && _helper === null) {
        throw new Error("Attempted to resolve `" + name + "`, which was expected to be a component or helper, but nothing was found.");
      }

      ifHelper(constants.helper(_helper, name));
    }
  }
}
/**
 * <Foo @arg={{helper}}>
 */

export function resolveOptionalHelper(resolver, constants, meta, _ref5) {
  var expr = _ref5[1],
      ifHelper = _ref5[2].ifHelper;
  false && assert(isGetFreeOptionalHelper(expr) || isGetFreeDeprecatedHelper(expr), 'Attempted to resolve a helper with incorrect opcode');

  var _assertResolverInvari6 = assertResolverInvariants(meta),
      upvars = _assertResolverInvari6.upvars,
      owner = _assertResolverInvari6.owner;

  var name = upvars[expr[1]];
  var helper = resolver.lookupHelper(name, owner);

  if (helper) {
    ifHelper(constants.helper(helper, name), name, meta.moduleName);
  }
}
/**
 * {{maybeHelperOrComponent}}
 */

export function resolveOptionalComponentOrHelper(resolver, constants, meta, _ref6) {
  var expr = _ref6[1],
      _ref6$ = _ref6[2],
      ifComponent = _ref6$.ifComponent,
      ifHelper = _ref6$.ifHelper,
      ifValue = _ref6$.ifValue;
  false && assert(isGetFreeOptionalComponentOrHelper(expr), 'Attempted to resolve an optional component or helper with incorrect opcode');
  var type = expr[0];

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      var scopeValues = meta.scopeValues,
          owner = meta.owner;
      var definition = scopeValues[expr[1]];

      if (typeof definition !== 'function' && (typeof definition !== 'object' || definition === null)) {
        // The value is not an object, so it can't be a component or helper.
        ifValue(constants.value(definition));
        return;
      }

      var component = constants.component(definition, owner, true);

      if (component !== null) {
        ifComponent(component);
        return;
      }

      var helper = constants.helper(definition, null, true);

      if (helper !== null) {
        ifHelper(helper);
        return;
      }

      ifValue(constants.value(definition));
    } else if (type === 31
  /* GetStrictFree */
  ) {
      ifHelper(lookupBuiltInHelper(expr, resolver, meta, constants, 'value'));
    } else {
    var _assertResolverInvari7 = assertResolverInvariants(meta),
        upvars = _assertResolverInvari7.upvars,
        _owner3 = _assertResolverInvari7.owner;

    var name = upvars[expr[1]];

    var _definition3 = resolver.lookupComponent(name, _owner3);

    if (_definition3 !== null) {
      ifComponent(constants.resolvedComponent(_definition3, name));
      return;
    }

    var _helper2 = resolver.lookupHelper(name, _owner3);

    if (_helper2 !== null) {
      ifHelper(constants.helper(_helper2, name));
    }
  }
}

function lookupBuiltInHelper(expr, resolver, meta, constants, type) {
  var _assertResolverInvari8 = assertResolverInvariants(meta),
      upvars = _assertResolverInvari8.upvars;

  var name = upvars[expr[1]];
  var helper = resolver.lookupBuiltInHelper(name);

  if (DEBUG && helper === null) {
    // Keyword helper did not exist, which means that we're attempting to use a
    // value of some kind that is not in scope
    throw new Error("Attempted to resolve a " + type + " in a strict mode template, but that value was not in scope: " + meta.upvars[expr[1]]);
  }

  return constants.helper(helper, name);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9yZXNvbHV0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFNBQUEsS0FBQSxRQUFBLGNBQUE7QUFnQkEsU0FBQSxNQUFBLEVBQUEsYUFBQSxRQUFBLGVBQUE7O0FBRUEsU0FBQSxjQUFBLENBQUEsTUFBQSxFQUFzRDtBQUNwRCxTQUFPLEtBQUssQ0FBTCxPQUFBLENBQUEsTUFBQSxLQUF5QixNQUFNLENBQU4sTUFBQSxLQUFoQyxDQUFBO0FBQ0Q7O0FBRUQsU0FBQSwwQkFBQSxDQUFBLFlBQUEsRUFBNkQ7QUFDM0QsU0FDRSxVQUFBLE1BREssRUFFNEQ7QUFDakUsUUFBSSxDQUFDLGNBQWMsQ0FBbkIsTUFBbUIsQ0FBbkIsRUFBNkIsT0FBQSxLQUFBO0FBRTdCLFFBQUksSUFBSSxHQUFHLE1BQU0sQ0FBakIsQ0FBaUIsQ0FBakI7QUFFQSxXQUNFLElBQUksS0FBQTtBQUFBO0FBQUosT0FDQSxJQUFJLEtBQUE7QUFBQTtBQURKLE9BRUEsSUFBSSxLQUhOLFlBQUE7QUFQRixHQUFBO0FBYUQ7O0FBRUQsT0FBTyxJQUFNLGtCQUFrQixHQUFHLDBCQUEwQixDQUFBO0FBQUE7QUFBQSxDQUFyRDtBQUVQLE9BQU8sSUFBTSxpQkFBaUIsR0FBRywwQkFBMEIsQ0FBQTtBQUFBO0FBQUEsQ0FBcEQ7QUFFUCxPQUFPLElBQU0sZUFBZSxHQUFHLDBCQUEwQixDQUFBO0FBQUE7QUFBQSxDQUFsRDtBQUVQLE9BQU8sSUFBTSwwQkFBMEIsR0FBRywwQkFBMEIsQ0FBQTtBQUFBO0FBQUEsQ0FBN0Q7QUFJUCxPQUFPLElBQU0sdUJBQXVCLEdBQUcsMEJBQTBCLENBQUE7QUFBQTtBQUFBLENBQTFEO0FBSVAsT0FBTSxTQUFBLHlCQUFBLENBQUEsTUFBQSxFQUMwQjtBQUU5QixTQUNFLEtBQUssQ0FBTCxPQUFBLENBQUEs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TSwwQkFFTixNQUZNOztBQUlaLE1BQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQXRCLENBQXNCLENBQUwsQ0FBakI7QUFDQSxNQUFJLE1BQU0sR0FBRyxRQUFRLENBQVIsbUJBQUEsQ0FBYixJQUFhLENBQWI7O0FBRUEsTUFBSSxLQUFLLElBQUksTUFBTSxLQUFuQixJQUFBLEVBQThCO0FBQzVCO0FBQ0E7QUFDQSxVQUFNLElBQUEsS0FBQSw2QkFDc0IsSUFEdEIscUVBRUYsSUFBSSxDQUFKLE1BQUEsQ0FBYSxJQUFJLENBRnJCLENBRXFCLENBQWpCLENBRkUsQ0FBTjtBQUtEOztBQUVELFNBQU8sU0FBUyxDQUFULE1BQUEsQ0FBQSxNQUFBLEVBQVAsSUFBTyxDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQge1xuICBDb21waWxlVGltZUNvbnN0YW50cyxcbiAgQ29tcGlsZVRpbWVSZXNvbHZlcixcbiAgQ29udGFpbmluZ01ldGFkYXRhLFxuICBFeHByZXNzaW9ucyxcbiAgT3duZXIsXG4gIFJlc29sdmVDb21wb25lbnRPcCxcbiAgUmVzb2x2ZUNvbXBvbmVudE9ySGVscGVyT3AsXG4gIFJlc29sdmVIZWxwZXJPcCxcbiAgUmVzb2x2ZU1vZGlmaWVyT3AsXG4gIFJlc29sdmVPcHRpb25hbENvbXBvbmVudE9ySGVscGVyT3AsXG4gIFJlc29sdmVPcHRpb25hbEhlbHBlck9wLFxuICBTZXhwT3Bjb2RlcyxcbiAgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0LCBkZWJ1Z1RvU3RyaW5nLCBleHBlY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcblxuZnVuY3Rpb24gaXNHZXRMaWtlVHVwbGUob3Bjb2RlOiBFeHByZXNzaW9ucy5FeHByZXNzaW9uKTogb3Bjb2RlIGlzIEV4cHJlc3Npb25zLlR1cGxlRXhwcmVzc2lvbiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9wY29kZSkgJiYgb3Bjb2RlLmxlbmd0aCA9PT0gMjtcbn1cblxuZnVuY3Rpb24gbWFrZVJlc29sdXRpb25UeXBlVmVyaWZpZXIodHlwZVRvVmVyaWZ5OiBTZXhwT3Bjb2Rlcykge1xuICByZXR1cm4gKFxuICAgIG9wY29kZTogRXhwcmVzc2lvbnMuRXhwcmVzc2lvblxuICApOiBvcGNvZGUgaXMgRXhwcmVzc2lvbnMuR2V0RnJlZSB8IEV4cHJlc3Npb25zLkdldFRlbXBsYXRlU3ltYm9sID0+IHtcbiAgICBpZiAoIWlzR2V0TGlrZVR1cGxlKG9wY29kZSkpIHJldHVybiBmYWxzZTtcblxuICAgIGxldCB0eXBlID0gb3Bjb2RlWzBdO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFN0cmljdEZyZWUgfHxcbiAgICAgIHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFRlbXBsYXRlU3ltYm9sIHx8XG4gICAgICB0eXBlID09PSB0eXBlVG9WZXJpZnlcbiAgICApO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgaXNHZXRGcmVlQ29tcG9uZW50ID0gbWFrZVJlc29sdXRpb25UeXBlVmVyaWZpZXIoU2V4cE9wY29kZXMuR2V0RnJlZUFzQ29tcG9uZW50SGVhZCk7XG5cbmV4cG9ydCBjb25zdCBpc0dldEZyZWVNb2RpZmllciA9IG1ha2VSZXNvbHV0aW9uVHlwZVZlcmlmaWVyKFNleHBPcGNvZGVzLkdldEZyZWVBc01vZGlmaWVySGVhZCk7XG5cbmV4cG9ydCBjb25zdCBpc0dldEZyZWVIZWxwZXIgPSBtYWtlUmVzb2x1dGlvblR5cGVWZXJpZmllcihTZXhwT3Bjb2Rlcy5HZXRGcmVlQXNIZWxwZXJIZWFkKTtcblxuZXhwb3J0IGNvbnN0IGlzR2V0RnJlZUNvbXBvbmVudE9ySGVscGVyID0gbWFrZVJlc29sdXRpb25UeXBlVmVyaWZpZXIoXG4gIFNleHBPcGNvZGVzLkdldEZyZWVBc0NvbXBvbmVudE9ySGVscGVySGVhZFxuKTtcblxuZXhwb3J0IGNvbnN0IGlzR2V0RnJlZU9wdGlvbmFsSGVscGVyID0gbWFrZVJlc29sdXRpb25UeXBlVmVyaWZpZXIoXG4gIFNleHBPcGNvZGVzLkdldEZyZWVBc0hlbHBlckhlYWRPclRoaXNGYWxsYmFja1xuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzR2V0RnJlZURlcHJlY2F0ZWRIZWxwZXIoXG4gIG9wY29kZTogRXhwcmVzc2lvbnMuRXhwcmVzc2lvblxuKTogb3Bjb2RlIGlzIEV4cHJlc3Npb25zLkdldFBhdGhGcmVlQXNEZXByZWNhdGVkSGVscGVySGVhZE9yVGhpc0ZhbGxiYWNrIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KG9wY29kZSkgJiYgb3Bjb2RlWzBdID09PSBTZXhwT3Bjb2Rlcy5HZXRGcmVlQXNEZXByZWNhdGVkSGVscGVySGVhZE9yVGhpc0ZhbGxiYWNrXG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCBpc0dldEZyZWVPcHRpb25hbENvbXBvbmVudE9ySGVscGVyID0gbWFrZVJlc29sdXRpb25UeXBlVmVyaWZpZXIoXG4gIFNleHBPcGNvZGVzLkdldEZyZWVBc0NvbXBvbmVudE9ySGVscGVySGVhZE9yVGhpc0ZhbGxiYWNrXG4pO1xuXG5pbnRlcmZhY2UgUmVzb2x2ZWRDb250YWluaW5nTWV0YWRhdGEgZXh0ZW5kcyBDb250YWluaW5nTWV0YWRhdGEge1xuICBvd25lcjogT3duZXI7XG4gIHVwdmFyczogc3RyaW5nW107XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlc29sdmVySW52YXJpYW50cyhtZXRhOiBDb250YWluaW5nTWV0YWRhdGEpOiBSZXNvbHZlZENvbnRhaW5pbmdNZXRhZGF0YSB7XG4gIGlmIChERUJVRykge1xuICAgIGlmICghbWV0YS51cHZhcnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0F0dGVtcHRlZCB0byByZXNvbHZlIGEgY29tcG9uZW50LCBoZWxwZXIsIG9yIG1vZGlmaWVyLCBidXQgbm8gZnJlZSB2YXJzIHdlcmUgZm91bmQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghbWV0YS5vd25lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBjb21wb25lbnQsIGhlbHBlciwgb3IgbW9kaWZpZXIsIGJ1dCBubyBvd25lciB3YXMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0ZW1wbGF0ZSBpdCB3YXMgYmVpbmcgcmVzb2x2ZWQgZnJvbSdcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChtZXRhIGFzIHVua25vd24pIGFzIFJlc29sdmVkQ29udGFpbmluZ01ldGFkYXRhO1xufVxuXG4vKipcbiAqIDxGb28vPlxuICogPEZvbz48L0Zvbz5cbiAqIDxGb28gQGFyZz17e3RydWV9fSAvPlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudChcbiAgcmVzb2x2ZXI6IENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIGNvbnN0YW50czogQ29tcGlsZVRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICBbLCBleHByLCB0aGVuXTogUmVzb2x2ZUNvbXBvbmVudE9wXG4pOiB2b2lkIHtcbiAgYXNzZXJ0KGlzR2V0RnJlZUNvbXBvbmVudChleHByKSwgJ0F0dGVtcHRlZCB0byByZXNvbHZlIGEgY29tcG9uZW50IHdpdGggaW5jb3JyZWN0IG9wY29kZScpO1xuXG4gIGxldCB0eXBlID0gZXhwclswXTtcblxuICBpZiAoREVCVUcgJiYgZXhwclswXSA9PT0gU2V4cE9wY29kZXMuR2V0U3RyaWN0RnJlZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRlbXBsYXRlLCBidXQgdGhhdCB2YWx1ZSB3YXMgbm90IGluIHNjb3BlOiAke1xuICAgICAgICBtZXRhLnVwdmFycyFbZXhwclsxXV1cbiAgICAgIH1gXG4gICAgKTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRUZW1wbGF0ZVN5bWJvbCkge1xuICAgIGxldCB7IHNjb3BlVmFsdWVzLCBvd25lciB9ID0gbWV0YTtcbiAgICBsZXQgZGVmaW5pdGlvbiA9IGV4cGVjdChzY29wZVZhbHVlcywgJ0JVRzogc2NvcGVWYWx1ZXMgbXVzdCBleGlzdCBpZiB0ZW1wbGF0ZSBzeW1ib2wgaXMgdXNlZCcpW1xuICAgICAgZXhwclsxXVxuICAgIF07XG5cbiAgICB0aGVuKFxuICAgICAgY29uc3RhbnRzLmNvbXBvbmVudChcbiAgICAgICAgZGVmaW5pdGlvbiBhcyBvYmplY3QsXG4gICAgICAgIGV4cGVjdChvd25lciwgJ0JVRzogZXhwZWN0ZWQgb3duZXIgd2hlbiByZXNvbHZpbmcgY29tcG9uZW50IGRlZmluaXRpb24nKVxuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHsgdXB2YXJzLCBvd25lciB9ID0gYXNzZXJ0UmVzb2x2ZXJJbnZhcmlhbnRzKG1ldGEpO1xuXG4gICAgbGV0IG5hbWUgPSB1cHZhcnNbZXhwclsxXV07XG4gICAgbGV0IGRlZmluaXRpb24gPSByZXNvbHZlci5sb29rdXBDb21wb25lbnQobmFtZSwgb3duZXIpITtcblxuICAgIGlmIChERUJVRyAmJiAodHlwZW9mIGRlZmluaXRpb24gIT09ICdvYmplY3QnIHx8IGRlZmluaXRpb24gPT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBcXGAke25hbWV9XFxgLCB3aGljaCB3YXMgZXhwZWN0ZWQgdG8gYmUgYSBjb21wb25lbnQsIGJ1dCBub3RoaW5nIHdhcyBmb3VuZC5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoZW4oY29uc3RhbnRzLnJlc29sdmVkQ29tcG9uZW50KGRlZmluaXRpb24sIG5hbWUpKTtcbiAgfVxufVxuXG4vKipcbiAqIChoZWxwZXIpXG4gKiAoaGVscGVyIGFyZylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVIZWxwZXIoXG4gIHJlc29sdmVyOiBDb21waWxlVGltZVJlc29sdmVyLFxuICBjb25zdGFudHM6IENvbXBpbGVUaW1lQ29uc3RhbnRzICYgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG4gIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgWywgZXhwciwgdGhlbl06IFJlc29sdmVIZWxwZXJPcFxuKTogdm9pZCB7XG4gIGFzc2VydChpc0dldEZyZWVIZWxwZXIoZXhwciksICdBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhIGhlbHBlciB3aXRoIGluY29ycmVjdCBvcGNvZGUnKTtcblxuICBsZXQgdHlwZSA9IGV4cHJbMF07XG5cbiAgaWYgKHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFRlbXBsYXRlU3ltYm9sKSB7XG4gICAgbGV0IHsgc2NvcGVWYWx1ZXMgfSA9IG1ldGE7XG4gICAgbGV0IGRlZmluaXRpb24gPSBleHBlY3Qoc2NvcGVWYWx1ZXMsICdCVUc6IHNjb3BlVmFsdWVzIG11c3QgZXhpc3QgaWYgdGVtcGxhdGUgc3ltYm9sIGlzIHVzZWQnKVtcbiAgICAgIGV4cHJbMV1cbiAgICBdO1xuXG4gICAgdGhlbihjb25zdGFudHMuaGVscGVyKGRlZmluaXRpb24gYXMgb2JqZWN0KSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gU2V4cE9wY29kZXMuR2V0U3RyaWN0RnJlZSkge1xuICAgIHRoZW4oXG4gICAgICBsb29rdXBCdWlsdEluSGVscGVyKGV4cHIgYXMgRXhwcmVzc2lvbnMuR2V0U3RyaWN0RnJlZSwgcmVzb2x2ZXIsIG1ldGEsIGNvbnN0YW50cywgJ2hlbHBlcicpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgeyB1cHZhcnMsIG93bmVyIH0gPSBhc3NlcnRSZXNvbHZlckludmFyaWFudHMobWV0YSk7XG5cbiAgICBsZXQgbmFtZSA9IHVwdmFyc1tleHByWzFdXTtcbiAgICBsZXQgaGVscGVyID0gcmVzb2x2ZXIubG9va3VwSGVscGVyKG5hbWUsIG93bmVyISkhO1xuXG4gICAgaWYgKERFQlVHICYmIGhlbHBlciA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQXR0ZW1wdGVkIHRvIHJlc29sdmUgXFxgJHtuYW1lfVxcYCwgd2hpY2ggd2FzIGV4cGVjdGVkIHRvIGJlIGEgaGVscGVyLCBidXQgbm90aGluZyB3YXMgZm91bmQuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGVuKGNvbnN0YW50cy5oZWxwZXIoaGVscGVyLCBuYW1lKSk7XG4gIH1cbn1cblxuLyoqXG4gKiA8ZGl2IHt7bW9kaWZpZXJ9fS8+XG4gKiA8ZGl2IHt7bW9kaWZpZXIgYXJnfX0vPlxuICogPEZvbyB7e21vZGlmaWVyfX0vPlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVyKFxuICByZXNvbHZlcjogQ29tcGlsZVRpbWVSZXNvbHZlcixcbiAgY29uc3RhbnRzOiBDb21waWxlVGltZUNvbnN0YW50cyAmIFJlc29sdXRpb25UaW1lQ29uc3RhbnRzLFxuICBtZXRhOiBDb250YWluaW5nTWV0YWRhdGEsXG4gIFssIGV4cHIsIHRoZW5dOiBSZXNvbHZlTW9kaWZpZXJPcFxuKTogdm9pZCB7XG4gIGFzc2VydChpc0dldEZyZWVNb2RpZmllcihleHByKSwgJ0F0dGVtcHRlZCB0byByZXNvbHZlIGEgbW9kaWZpZXIgd2l0aCBpbmNvcnJlY3Qgb3Bjb2RlJyk7XG5cbiAgbGV0IHR5cGUgPSBleHByWzBdO1xuXG4gIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRUZW1wbGF0ZVN5bWJvbCkge1xuICAgIGxldCB7IHNjb3BlVmFsdWVzIH0gPSBtZXRhO1xuICAgIGxldCBkZWZpbml0aW9uID0gZXhwZWN0KHNjb3BlVmFsdWVzLCAnQlVHOiBzY29wZVZhbHVlcyBtdXN0IGV4aXN0IGlmIHRlbXBsYXRlIHN5bWJvbCBpcyB1c2VkJylbXG4gICAgICBleHByWzFdXG4gICAgXTtcblxuICAgIHRoZW4oY29uc3RhbnRzLm1vZGlmaWVyKGRlZmluaXRpb24gYXMgb2JqZWN0KSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gU2V4cE9wY29kZXMuR2V0U3RyaWN0RnJlZSkge1xuICAgIGxldCB7IHVwdmFycyB9ID0gYXNzZXJ0UmVzb2x2ZXJJbnZhcmlhbnRzKG1ldGEpO1xuICAgIGxldCBuYW1lID0gdXB2YXJzW2V4cHJbMV1dO1xuICAgIGxldCBtb2RpZmllciA9IHJlc29sdmVyLmxvb2t1cEJ1aWx0SW5Nb2RpZmllcihuYW1lKTtcblxuICAgIGlmIChERUJVRyAmJiBtb2RpZmllciA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBtb2RpZmllciBpbiBhIHN0cmljdCBtb2RlIHRlbXBsYXRlLCBidXQgaXQgd2FzIG5vdCBpbiBzY29wZTogJHtuYW1lfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhlbihjb25zdGFudHMubW9kaWZpZXIobW9kaWZpZXIhLCBuYW1lKSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHsgdXB2YXJzLCBvd25lciB9ID0gYXNzZXJ0UmVzb2x2ZXJJbnZhcmlhbnRzKG1ldGEpO1xuICAgIGxldCBuYW1lID0gdXB2YXJzW2V4cHJbMV1dO1xuICAgIGxldCBtb2RpZmllciA9IHJlc29sdmVyLmxvb2t1cE1vZGlmaWVyKG5hbWUsIG93bmVyKSE7XG5cbiAgICBpZiAoREVCVUcgJiYgbW9kaWZpZXIgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEF0dGVtcHRlZCB0byByZXNvbHZlIFxcYCR7bmFtZX1cXGAsIHdoaWNoIHdhcyBleHBlY3RlZCB0byBiZSBhIG1vZGlmaWVyLCBidXQgbm90aGluZyB3YXMgZm91bmQuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGVuKGNvbnN0YW50cy5tb2RpZmllcihtb2RpZmllciwgbmFtZSkpO1xuICB9XG59XG5cbi8qKlxuICoge3tjb21wb25lbnQtb3ItaGVscGVyIGFyZ319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50T3JIZWxwZXIoXG4gIHJlc29sdmVyOiBDb21waWxlVGltZVJlc29sdmVyLFxuICBjb25zdGFudHM6IENvbXBpbGVUaW1lQ29uc3RhbnRzICYgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG4gIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgWywgZXhwciwgeyBpZkNvbXBvbmVudCwgaWZIZWxwZXIgfV06IFJlc29sdmVDb21wb25lbnRPckhlbHBlck9wXG4pOiB2b2lkIHtcbiAgYXNzZXJ0KFxuICAgIGlzR2V0RnJlZUNvbXBvbmVudE9ySGVscGVyKGV4cHIpLFxuICAgICdBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhIGNvbXBvbmVudCBvciBoZWxwZXIgd2l0aCBpbmNvcnJlY3Qgb3Bjb2RlJ1xuICApO1xuXG4gIGxldCB0eXBlID0gZXhwclswXTtcblxuICBpZiAodHlwZSA9PT0gU2V4cE9wY29kZXMuR2V0VGVtcGxhdGVTeW1ib2wpIHtcbiAgICBsZXQgeyBzY29wZVZhbHVlcywgb3duZXIgfSA9IG1ldGE7XG4gICAgbGV0IGRlZmluaXRpb24gPSBleHBlY3Qoc2NvcGVWYWx1ZXMsICdCVUc6IHNjb3BlVmFsdWVzIG11c3QgZXhpc3QgaWYgdGVtcGxhdGUgc3ltYm9sIGlzIHVzZWQnKVtcbiAgICAgIGV4cHJbMV1cbiAgICBdO1xuXG4gICAgbGV0IGNvbXBvbmVudCA9IGNvbnN0YW50cy5jb21wb25lbnQoXG4gICAgICBkZWZpbml0aW9uIGFzIG9iamVjdCxcbiAgICAgIGV4cGVjdChvd25lciwgJ0JVRzogZXhwZWN0ZWQgb3duZXIgd2hlbiByZXNvbHZpbmcgY29tcG9uZW50IGRlZmluaXRpb24nKSxcbiAgICAgIHRydWVcbiAgICApO1xuXG4gICAgaWYgKGNvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWZDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgaGVscGVyID0gY29uc3RhbnRzLmhlbHBlcihkZWZpbml0aW9uIGFzIG9iamVjdCwgbnVsbCwgdHJ1ZSk7XG5cbiAgICBpZiAoREVCVUcgJiYgaGVscGVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBdHRlbXB0ZWQgdG8gdXNlIGEgdmFsdWUgYXMgZWl0aGVyIGEgY29tcG9uZW50IG9yIGhlbHBlciwgYnV0IGl0IGRpZCBub3QgaGF2ZSBhIGNvbXBvbmVudCBtYW5hZ2VyIG9yIGhlbHBlciBtYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCBpdC4gVGhlIHZhbHVlIHdhczogJHtkZWJ1Z1RvU3RyaW5nIShcbiAgICAgICAgICBkZWZpbml0aW9uXG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZkhlbHBlcihleHBlY3QoaGVscGVyLCAnQlVHOiBoZWxwZXIgbXVzdCBleGlzdCcpKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRTdHJpY3RGcmVlKSB7XG4gICAgaWZIZWxwZXIoXG4gICAgICBsb29rdXBCdWlsdEluSGVscGVyKFxuICAgICAgICBleHByIGFzIEV4cHJlc3Npb25zLkdldFN0cmljdEZyZWUsXG4gICAgICAgIHJlc29sdmVyLFxuICAgICAgICBtZXRhLFxuICAgICAgICBjb25zdGFudHMsXG4gICAgICAgICdjb21wb25lbnQgb3IgaGVscGVyJ1xuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHsgdXB2YXJzLCBvd25lciB9ID0gYXNzZXJ0UmVzb2x2ZXJJbnZhcmlhbnRzKG1ldGEpO1xuXG4gICAgbGV0IG5hbWUgPSB1cHZhcnNbZXhwclsxXV07XG4gICAgbGV0IGRlZmluaXRpb24gPSByZXNvbHZlci5sb29rdXBDb21wb25lbnQobmFtZSwgb3duZXIpO1xuXG4gICAgaWYgKGRlZmluaXRpb24gIT09IG51bGwpIHtcbiAgICAgIGlmQ29tcG9uZW50KGNvbnN0YW50cy5yZXNvbHZlZENvbXBvbmVudChkZWZpbml0aW9uLCBuYW1lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBoZWxwZXIgPSByZXNvbHZlci5sb29rdXBIZWxwZXIobmFtZSwgb3duZXIpO1xuXG4gICAgICBpZiAoREVCVUcgJiYgaGVscGVyID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHJlc29sdmUgXFxgJHtuYW1lfVxcYCwgd2hpY2ggd2FzIGV4cGVjdGVkIHRvIGJlIGEgY29tcG9uZW50IG9yIGhlbHBlciwgYnV0IG5vdGhpbmcgd2FzIGZvdW5kLmBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWZIZWxwZXIoY29uc3RhbnRzLmhlbHBlcihoZWxwZXIhLCBuYW1lKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogPEZvbyBAYXJnPXt7aGVscGVyfX0+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlT3B0aW9uYWxIZWxwZXIoXG4gIHJlc29sdmVyOiBDb21waWxlVGltZVJlc29sdmVyLFxuICBjb25zdGFudHM6IENvbXBpbGVUaW1lQ29uc3RhbnRzICYgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG4gIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgWywgZXhwciwgeyBpZkhlbHBlciB9XTogUmVzb2x2ZU9wdGlvbmFsSGVscGVyT3Bcbik6IHZvaWQge1xuICBhc3NlcnQoXG4gICAgaXNHZXRGcmVlT3B0aW9uYWxIZWxwZXIoZXhwcikgfHwgaXNHZXRGcmVlRGVwcmVjYXRlZEhlbHBlcihleHByKSxcbiAgICAnQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBoZWxwZXIgd2l0aCBpbmNvcnJlY3Qgb3Bjb2RlJ1xuICApO1xuICBsZXQgeyB1cHZhcnMsIG93bmVyIH0gPSBhc3NlcnRSZXNvbHZlckludmFyaWFudHMobWV0YSk7XG5cbiAgbGV0IG5hbWUgPSB1cHZhcnNbZXhwclsxXV07XG4gIGxldCBoZWxwZXIgPSByZXNvbHZlci5sb29rdXBIZWxwZXIobmFtZSwgb3duZXIpO1xuXG4gIGlmIChoZWxwZXIpIHtcbiAgICBpZkhlbHBlcihjb25zdGFudHMuaGVscGVyKGhlbHBlciwgbmFtZSksIG5hbWUsIG1ldGEubW9kdWxlTmFtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiB7e21heWJlSGVscGVyT3JDb21wb25lbnR9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU9wdGlvbmFsQ29tcG9uZW50T3JIZWxwZXIoXG4gIHJlc29sdmVyOiBDb21waWxlVGltZVJlc29sdmVyLFxuICBjb25zdGFudHM6IENvbXBpbGVUaW1lQ29uc3RhbnRzICYgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG4gIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgWywgZXhwciwgeyBpZkNvbXBvbmVudCwgaWZIZWxwZXIsIGlmVmFsdWUgfV06IFJlc29sdmVPcHRpb25hbENvbXBvbmVudE9ySGVscGVyT3Bcbik6IHZvaWQge1xuICBhc3NlcnQoXG4gICAgaXNHZXRGcmVlT3B0aW9uYWxDb21wb25lbnRPckhlbHBlcihleHByKSxcbiAgICAnQXR0ZW1wdGVkIHRvIHJlc29sdmUgYW4gb3B0aW9uYWwgY29tcG9uZW50IG9yIGhlbHBlciB3aXRoIGluY29ycmVjdCBvcGNvZGUnXG4gICk7XG5cbiAgbGV0IHR5cGUgPSBleHByWzBdO1xuXG4gIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRUZW1wbGF0ZVN5bWJvbCkge1xuICAgIGxldCB7IHNjb3BlVmFsdWVzLCBvd25lciB9ID0gbWV0YTtcbiAgICBsZXQgZGVmaW5pdGlvbiA9IGV4cGVjdChzY29wZVZhbHVlcywgJ0JVRzogc2NvcGVWYWx1ZXMgbXVzdCBleGlzdCBpZiB0ZW1wbGF0ZSBzeW1ib2wgaXMgdXNlZCcpW1xuICAgICAgZXhwclsxXVxuICAgIF07XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgZGVmaW5pdGlvbiAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKHR5cGVvZiBkZWZpbml0aW9uICE9PSAnb2JqZWN0JyB8fCBkZWZpbml0aW9uID09PSBudWxsKVxuICAgICkge1xuICAgICAgLy8gVGhlIHZhbHVlIGlzIG5vdCBhbiBvYmplY3QsIHNvIGl0IGNhbid0IGJlIGEgY29tcG9uZW50IG9yIGhlbHBlci5cbiAgICAgIGlmVmFsdWUoY29uc3RhbnRzLnZhbHVlKGRlZmluaXRpb24pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY29tcG9uZW50ID0gY29uc3RhbnRzLmNvbXBvbmVudChcbiAgICAgIGRlZmluaXRpb24sXG4gICAgICBleHBlY3Qob3duZXIsICdCVUc6IGV4cGVjdGVkIG93bmVyIHdoZW4gcmVzb2x2aW5nIGNvbXBvbmVudCBkZWZpbml0aW9uJyksXG4gICAgICB0cnVlXG4gICAgKTtcblxuICAgIGlmIChjb21wb25lbnQgIT09IG51bGwpIHtcbiAgICAgIGlmQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGhlbHBlciA9IGNvbnN0YW50cy5oZWxwZXIoZGVmaW5pdGlvbiwgbnVsbCwgdHJ1ZSk7XG5cbiAgICBpZiAoaGVscGVyICE9PSBudWxsKSB7XG4gICAgICBpZkhlbHBlcihoZWxwZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmVmFsdWUoY29uc3RhbnRzLnZhbHVlKGRlZmluaXRpb24pKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRTdHJpY3RGcmVlKSB7XG4gICAgaWZIZWxwZXIoXG4gICAgICBsb29rdXBCdWlsdEluSGVscGVyKGV4cHIgYXMgRXhwcmVzc2lvbnMuR2V0U3RyaWN0RnJlZSwgcmVzb2x2ZXIsIG1ldGEsIGNvbnN0YW50cywgJ3ZhbHVlJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxldCB7IHVwdmFycywgb3duZXIgfSA9IGFzc2VydFJlc29sdmVySW52YXJpYW50cyhtZXRhKTtcblxuICAgIGxldCBuYW1lID0gdXB2YXJzW2V4cHJbMV1dO1xuICAgIGxldCBkZWZpbml0aW9uID0gcmVzb2x2ZXIubG9va3VwQ29tcG9uZW50KG5hbWUsIG93bmVyKTtcblxuICAgIGlmIChkZWZpbml0aW9uICE9PSBudWxsKSB7XG4gICAgICBpZkNvbXBvbmVudChjb25zdGFudHMucmVzb2x2ZWRDb21wb25lbnQoZGVmaW5pdGlvbiwgbmFtZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBoZWxwZXIgPSByZXNvbHZlci5sb29rdXBIZWxwZXIobmFtZSwgb3duZXIpO1xuXG4gICAgaWYgKGhlbHBlciAhPT0gbnVsbCkge1xuICAgICAgaWZIZWxwZXIoY29uc3RhbnRzLmhlbHBlcihoZWxwZXIsIG5hbWUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9va3VwQnVpbHRJbkhlbHBlcihcbiAgZXhwcjogRXhwcmVzc2lvbnMuR2V0U3RyaWN0RnJlZSxcbiAgcmVzb2x2ZXI6IENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgY29uc3RhbnRzOiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgdHlwZTogc3RyaW5nXG4pOiBudW1iZXIge1xuICBsZXQgeyB1cHZhcnMgfSA9IGFzc2VydFJlc29sdmVySW52YXJpYW50cyhtZXRhKTtcblxuICBsZXQgbmFtZSA9IHVwdmFyc1tleHByWzFdXTtcbiAgbGV0IGhlbHBlciA9IHJlc29sdmVyLmxvb2t1cEJ1aWx0SW5IZWxwZXIobmFtZSk7XG5cbiAgaWYgKERFQlVHICYmIGhlbHBlciA9PT0gbnVsbCkge1xuICAgIC8vIEtleXdvcmQgaGVscGVyIGRpZCBub3QgZXhpc3QsIHdoaWNoIG1lYW5zIHRoYXQgd2UncmUgYXR0ZW1wdGluZyB0byB1c2UgYVxuICAgIC8vIHZhbHVlIG9mIHNvbWUga2luZCB0aGF0IGlzIG5vdCBpbiBzY29wZVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhICR7dHlwZX0gaW4gYSBzdHJpY3QgbW9kZSB0ZW1wbGF0ZSwgYnV0IHRoYXQgdmFsdWUgd2FzIG5vdCBpbiBzY29wZTogJHtcbiAgICAgICAgbWV0YS51cHZhcnMhW2V4cHJbMV1dXG4gICAgICB9YFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gY29uc3RhbnRzLmhlbHBlcihoZWxwZXIhLCBuYW1lKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=