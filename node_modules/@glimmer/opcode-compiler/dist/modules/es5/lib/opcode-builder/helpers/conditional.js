function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import { labelOperand } from '../operands';
export function SwitchCases(op, bootstrap, callback) {
  // Setup the switch DSL
  var clauses = [];
  var count = 0;

  function when(match, callback) {
    clauses.push({
      match: match,
      callback: callback,
      label: "CLAUSE" + count++
    });
  } // Call the callback


  callback(when); // Emit the opcodes for the switch

  op(69
  /* Enter */
  , 1);
  bootstrap();
  op(1001
  /* StartLabels */
  ); // First, emit the jump opcodes. We don't need a jump for the last
  // opcode, since it bleeds directly into its clause.

  for (var _iterator = _createForOfIteratorHelperLoose(clauses.slice(0, -1)), _step; !(_step = _iterator()).done;) {
    var _clause = _step.value;
    op(67
    /* JumpEq */
    , labelOperand(_clause.label), _clause.match);
  } // Enumerate the clauses in reverse order. Earlier matches will
  // require fewer checks.


  for (var i = clauses.length - 1; i >= 0; i--) {
    var clause = clauses[i];
    op(1000
    /* Label */
    , clause.label);
    op(34
    /* Pop */
    , 1);
    clause.callback(); // The first match is special: it is placed directly before the END
    // label, so no additional jump is needed at the end of it.

    if (i !== 0) {
      op(4
      /* Jump */
      , labelOperand('END'));
    }
  }

  op(1000
  /* Label */
  , 'END');
  op(1002
  /* StopLabels */
  );
  op(70
  /* Exit */
  );
}
/**
 * A convenience for pushing some arguments on the stack and
 * running some code if the code needs to be re-executed during
 * updating execution if some of the arguments have changed.
 *
 * # Initial Execution
 *
 * The `args` function should push zero or more arguments onto
 * the stack and return the number of arguments pushed.
 *
 * The `body` function provides the instructions to execute both
 * during initial execution and during updating execution.
 *
 * Internally, this function starts by pushing a new frame, so
 * that the body can return and sets the return point ($ra) to
 * the ENDINITIAL label.
 *
 * It then executes the `args` function, which adds instructions
 * responsible for pushing the arguments for the block to the
 * stack. These arguments will be restored to the stack before
 * updating execution.
 *
 * Next, it adds the Enter opcode, which marks the current position
 * in the DOM, and remembers the current $pc (the next instruction)
 * as the first instruction to execute during updating execution.
 *
 * Next, it runs `body`, which adds the opcodes that should
 * execute both during initial execution and during updating execution.
 * If the `body` wishes to finish early, it should Jump to the
 * `FINALLY` label.
 *
 * Next, it adds the FINALLY label, followed by:
 *
 * - the Exit opcode, which finalizes the marked DOM started by the
 *   Enter opcode.
 * - the Return opcode, which returns to the current return point
 *   ($ra).
 *
 * Finally, it adds the ENDINITIAL label followed by the PopFrame
 * instruction, which restores $fp, $sp and $ra.
 *
 * # Updating Execution
 *
 * Updating execution for this `replayable` occurs if the `body` added an
 * assertion, via one of the `JumpIf`, `JumpUnless` or `AssertSame` opcodes.
 *
 * If, during updating executon, the assertion fails, the initial VM is
 * restored, and the stored arguments are pushed onto the stack. The DOM
 * between the starting and ending markers is cleared, and the VM's cursor
 * is set to the area just cleared.
 *
 * The return point ($ra) is set to -1, the exit instruction.
 *
 * Finally, the $pc is set to to the instruction saved off by the
 * Enter opcode during initial execution, and execution proceeds as
 * usual.
 *
 * The only difference is that when a `Return` instruction is
 * encountered, the program jumps to -1 rather than the END label,
 * and the PopFrame opcode is not needed.
 */

export function Replayable(op, args, body) {
  // Start a new label frame, to give END and RETURN
  // a unique meaning.
  op(1001
  /* StartLabels */
  );
  op(0
  /* PushFrame */
  ); // If the body invokes a block, its return will return to
  // END. Otherwise, the return in RETURN will return to END.

  op(6
  /* ReturnTo */
  , labelOperand('ENDINITIAL')); // Push the arguments onto the stack. The args() function
  // tells us how many stack elements to retain for re-execution
  // when updating.

  var count = args(); // Start a new updating closure, remembering `count` elements
  // from the stack. Everything after this point, and before END,
  // will execute both initially and to update the block.
  //
  // The enter and exit opcodes also track the area of the DOM
  // associated with this block. If an assertion inside the block
  // fails (for example, the test value changes from true to false
  // in an #if), the DOM is cleared and the program is re-executed,
  // restoring `count` elements to the stack and executing the
  // instructions between the enter and exit.

  op(69
  /* Enter */
  , count); // Evaluate the body of the block. The body of the block may
  // return, which will jump execution to END during initial
  // execution, and exit the updating routine.

  body(); // All execution paths in the body should run the FINALLY once
  // they are done. It is executed both during initial execution
  // and during updating execution.

  op(1000
  /* Label */
  , 'FINALLY'); // Finalize the DOM.

  op(70
  /* Exit */
  ); // In initial execution, this is a noop: it returns to the
  // immediately following opcode. In updating execution, this
  // exits the updating routine.

  op(5
  /* Return */
  ); // Cleanup code for the block. Runs on initial execution
  // but not on updating.

  op(1000
  /* Label */
  , 'ENDINITIAL');
  op(1
  /* PopFrame */
  );
  op(1002
  /* StopLabels */
  );
}
/**
 * A specialized version of the `replayable` convenience that allows the
 * caller to provide different code based upon whether the item at
 * the top of the stack is true or false.
 *
 * As in `replayable`, the `ifTrue` and `ifFalse` code can invoke `return`.
 *
 * During the initial execution, a `return` will continue execution
 * in the cleanup code, which finalizes the current DOM block and pops
 * the current frame.
 *
 * During the updating execution, a `return` will exit the updating
 * routine, as it can reuse the DOM block and is always only a single
 * frame deep.
 */

export function ReplayableIf(op, args, ifTrue, ifFalse) {
  return Replayable(op, args, function () {
    // If the conditional is false, jump to the ELSE label.
    op(66
    /* JumpUnless */
    , labelOperand('ELSE')); // Otherwise, execute the code associated with the true branch.

    ifTrue(); // We're done, so return. In the initial execution, this runs
    // the cleanup code. In the updating VM, it exits the updating
    // routine.

    op(4
    /* Jump */
    , labelOperand('FINALLY'));
    op(1000
    /* Label */
    , 'ELSE'); // If the conditional is false, and code associatied ith the
    // false branch was provided, execute it. If there was no code
    // associated with the false branch, jumping to the else statement
    // has no other behavior.

    if (ifFalse !== undefined) {
      ifFalse();
    }
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9jb25kaXRpb25hbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxTQUFBLFlBQUEsUUFBQSxhQUFBO0FBTUEsT0FBTSxTQUFBLFdBQUEsQ0FBQSxFQUFBLEVBQUEsU0FBQSxFQUFBLFFBQUEsRUFHMEI7QUFFOUI7QUFDQSxNQUFJLE9BQU8sR0FBWCxFQUFBO0FBRUEsTUFBSSxLQUFLLEdBQVQsQ0FBQTs7QUFFQSxXQUFBLElBQUEsQ0FBQSxLQUFBLEVBQUEsUUFBQSxFQUFpRDtBQUMvQyxJQUFBLE9BQU8sQ0FBUCxJQUFBLENBQWE7QUFBRSxNQUFBLEtBQUYsRUFBRSxLQUFGO0FBQVMsTUFBQSxRQUFULEVBQVMsUUFBVDtBQUFtQixNQUFBLEtBQUssYUFBVyxLQUFLO0FBQXhDLEtBQWI7QUFSNEIsR0FBQSxDQVc5Qjs7O0FBQ0EsRUFBQSxRQUFRLENBWnNCLElBWXRCLENBQVIsQ0FaOEIsQ0FjOUI7O0FBQ0EsRUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLElBQUYsQ0FBRSxDQUFGO0FBQ0EsRUFBQSxTQUFTO0FBQ1QsRUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLEdBQUYsQ0FqQjhCLENBbUI5QjtBQUNBOztBQUNBLHVEQUFtQixPQUFPLENBQVAsS0FBQSxDQUFBLENBQUEsRUFBaUIsQ0FBcEMsQ0FBbUIsQ0FBbkIsd0NBQXlDO0FBQUEsUUFBekMsT0FBeUM7QUFDdkMsSUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLE1BQVksWUFBWSxDQUFDLE9BQU0sQ0FBL0IsS0FBd0IsQ0FBeEIsRUFBd0MsT0FBTSxDQUFoRCxLQUFFLENBQUY7QUF0QjRCLEdBQUEsQ0F5QjlCO0FBQ0E7OztBQUNBLE9BQUssSUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFQLE1BQUEsR0FBYixDQUFBLEVBQWlDLENBQUMsSUFBbEMsQ0FBQSxFQUF5QyxDQUF6QyxFQUFBLEVBQThDO0FBQzVDLFFBQUksTUFBTSxHQUFHLE9BQU8sQ0FBcEIsQ0FBb0IsQ0FBcEI7QUFFQSxJQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsTUFBK0IsTUFBTSxDQUF2QyxLQUFFLENBQUY7QUFDQSxJQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsTUFBRixDQUFFLENBQUY7QUFDQSxJQUFBLE1BQU0sQ0FMc0MsUUFLNUMsR0FMNEMsQ0FPNUM7QUFDQTs7QUFDQSxRQUFJLENBQUMsS0FBTCxDQUFBLEVBQWE7QUFDWCxNQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsUUFBaUIsWUFBWSxDQUEvQixLQUErQixDQUE3QixDQUFGO0FBQ0Q7QUFDRjs7QUFFRCxFQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsSUFBRixLQUFFLENBQUY7QUFDQSxFQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsR0FBRjtBQUNBLEVBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxHQUFGO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2REEsT0FBTSxTQUFBLFVBQUEsQ0FBQSxFQUFBLEVBQUEsSUFBQSxFQUFBLElBQUEsRUFBOEU7QUFDbEY7QUFDQTtBQUVBLEVBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxHQUFGO0FBQ0EsRUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLEdBQUYsQ0FMa0YsQ0FPbEY7QUFDQTs7QUFDQSxFQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsSUFBcUIsWUFBWSxDQVQrQyxZQVMvQyxDQUFqQyxDQUFGLENBVGtGLENBV2xGO0FBQ0E7QUFDQTs7QUFDQSxNQUFJLEtBQUssR0FBRyxJQWRzRSxFQWNsRixDQWRrRixDQWdCbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsRUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLElBMUJnRixLQTBCaEYsQ0FBRixDQTFCa0YsQ0E0QmxGO0FBQ0E7QUFDQTs7QUFDQSxFQUFBLElBL0JrRixHQUFBLENBaUNsRjtBQUNBO0FBQ0E7O0FBQ0EsRUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLElBcENnRixTQW9DaEYsQ0FBRixDQXBDa0YsQ0FzQ2xGOztBQUNBLEVBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxHQUFGLENBdkNrRixDQXlDbEY7QUFDQTtBQUNBOztBQUNBLEVBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxHQUFGLENBNUNrRixDQThDbEY7QUFDQTs7QUFDQSxFQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsSUFBRixZQUFFLENBQUY7QUFDQSxFQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsR0FBRjtBQUNBLEVBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxHQUFGO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OztBQWVBLE9BQU0sU0FBQSxZQUFBLENBQUEsRUFBQSxFQUFBLElBQUEsRUFBQSxNQUFBLEVBQUEsT0FBQSxFQUlnQjtBQUVwQixTQUFPLFVBQVUsQ0FBQSxFQUFBLEVBQUEsSUFBQSxFQUFXLFlBQUs7QUFDL0I7QUFDQSxJQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsTUFBZ0IsWUFBWSxDQUZDLE1BRUQsQ0FBNUIsQ0FBRixDQUYrQixDQUcvQjs7QUFDQSxJQUFBLE1BSitCLEdBQUEsQ0FLL0I7QUFDQTtBQUNBOztBQUNBLElBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxNQUFpQixZQUFZLENBQS9CLFNBQStCLENBQTdCLENBQUY7QUFDQSxJQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsTUFUNkIsTUFTN0IsQ0FBRixDQVQrQixDQVcvQjtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxRQUFJLE9BQU8sS0FBWCxTQUFBLEVBQTJCO0FBQ3pCLE1BQUEsT0FBTztBQUNSO0FBakJILEdBQWlCLENBQWpCO0FBbUJEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGFiZWxPcGVyYW5kIH0gZnJvbSAnLi4vb3BlcmFuZHMnO1xuaW1wb3J0IHsgT3AsIE1hY2hpbmVPcCwgSGlnaExldmVsQnVpbGRlck9wY29kZSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgUHVzaFN0YXRlbWVudE9wIH0gZnJvbSAnLi4vLi4vc3ludGF4L2NvbXBpbGVycyc7XG5cbmV4cG9ydCB0eXBlIFdoZW4gPSAobWF0Y2g6IG51bWJlciwgY2FsbGJhY2s6ICgpID0+IHZvaWQpID0+IHZvaWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBTd2l0Y2hDYXNlcyhcbiAgb3A6IFB1c2hTdGF0ZW1lbnRPcCxcbiAgYm9vdHN0cmFwOiAoKSA9PiB2b2lkLFxuICBjYWxsYmFjazogKHdoZW46IFdoZW4pID0+IHZvaWRcbik6IHZvaWQge1xuICAvLyBTZXR1cCB0aGUgc3dpdGNoIERTTFxuICBsZXQgY2xhdXNlczogQXJyYXk8eyBtYXRjaDogbnVtYmVyOyBsYWJlbDogc3RyaW5nOyBjYWxsYmFjazogKCkgPT4gdm9pZCB9PiA9IFtdO1xuXG4gIGxldCBjb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gd2hlbihtYXRjaDogbnVtYmVyLCBjYWxsYmFjazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGNsYXVzZXMucHVzaCh7IG1hdGNoLCBjYWxsYmFjaywgbGFiZWw6IGBDTEFVU0Uke2NvdW50Kyt9YCB9KTtcbiAgfVxuXG4gIC8vIENhbGwgdGhlIGNhbGxiYWNrXG4gIGNhbGxiYWNrKHdoZW4pO1xuXG4gIC8vIEVtaXQgdGhlIG9wY29kZXMgZm9yIHRoZSBzd2l0Y2hcbiAgb3AoT3AuRW50ZXIsIDEpO1xuICBib290c3RyYXAoKTtcbiAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5TdGFydExhYmVscyk7XG5cbiAgLy8gRmlyc3QsIGVtaXQgdGhlIGp1bXAgb3Bjb2Rlcy4gV2UgZG9uJ3QgbmVlZCBhIGp1bXAgZm9yIHRoZSBsYXN0XG4gIC8vIG9wY29kZSwgc2luY2UgaXQgYmxlZWRzIGRpcmVjdGx5IGludG8gaXRzIGNsYXVzZS5cbiAgZm9yIChsZXQgY2xhdXNlIG9mIGNsYXVzZXMuc2xpY2UoMCwgLTEpKSB7XG4gICAgb3AoT3AuSnVtcEVxLCBsYWJlbE9wZXJhbmQoY2xhdXNlLmxhYmVsKSwgY2xhdXNlLm1hdGNoKTtcbiAgfVxuXG4gIC8vIEVudW1lcmF0ZSB0aGUgY2xhdXNlcyBpbiByZXZlcnNlIG9yZGVyLiBFYXJsaWVyIG1hdGNoZXMgd2lsbFxuICAvLyByZXF1aXJlIGZld2VyIGNoZWNrcy5cbiAgZm9yIChsZXQgaSA9IGNsYXVzZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgY2xhdXNlID0gY2xhdXNlc1tpXTtcblxuICAgIG9wKEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUuTGFiZWwsIGNsYXVzZS5sYWJlbCk7XG4gICAgb3AoT3AuUG9wLCAxKTtcbiAgICBjbGF1c2UuY2FsbGJhY2soKTtcblxuICAgIC8vIFRoZSBmaXJzdCBtYXRjaCBpcyBzcGVjaWFsOiBpdCBpcyBwbGFjZWQgZGlyZWN0bHkgYmVmb3JlIHRoZSBFTkRcbiAgICAvLyBsYWJlbCwgc28gbm8gYWRkaXRpb25hbCBqdW1wIGlzIG5lZWRlZCBhdCB0aGUgZW5kIG9mIGl0LlxuICAgIGlmIChpICE9PSAwKSB7XG4gICAgICBvcChNYWNoaW5lT3AuSnVtcCwgbGFiZWxPcGVyYW5kKCdFTkQnKSk7XG4gICAgfVxuICB9XG5cbiAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5MYWJlbCwgJ0VORCcpO1xuICBvcChIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLlN0b3BMYWJlbHMpO1xuICBvcChPcC5FeGl0KTtcbn1cblxuLyoqXG4gKiBBIGNvbnZlbmllbmNlIGZvciBwdXNoaW5nIHNvbWUgYXJndW1lbnRzIG9uIHRoZSBzdGFjayBhbmRcbiAqIHJ1bm5pbmcgc29tZSBjb2RlIGlmIHRoZSBjb2RlIG5lZWRzIHRvIGJlIHJlLWV4ZWN1dGVkIGR1cmluZ1xuICogdXBkYXRpbmcgZXhlY3V0aW9uIGlmIHNvbWUgb2YgdGhlIGFyZ3VtZW50cyBoYXZlIGNoYW5nZWQuXG4gKlxuICogIyBJbml0aWFsIEV4ZWN1dGlvblxuICpcbiAqIFRoZSBgYXJnc2AgZnVuY3Rpb24gc2hvdWxkIHB1c2ggemVybyBvciBtb3JlIGFyZ3VtZW50cyBvbnRvXG4gKiB0aGUgc3RhY2sgYW5kIHJldHVybiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBwdXNoZWQuXG4gKlxuICogVGhlIGBib2R5YCBmdW5jdGlvbiBwcm92aWRlcyB0aGUgaW5zdHJ1Y3Rpb25zIHRvIGV4ZWN1dGUgYm90aFxuICogZHVyaW5nIGluaXRpYWwgZXhlY3V0aW9uIGFuZCBkdXJpbmcgdXBkYXRpbmcgZXhlY3V0aW9uLlxuICpcbiAqIEludGVybmFsbHksIHRoaXMgZnVuY3Rpb24gc3RhcnRzIGJ5IHB1c2hpbmcgYSBuZXcgZnJhbWUsIHNvXG4gKiB0aGF0IHRoZSBib2R5IGNhbiByZXR1cm4gYW5kIHNldHMgdGhlIHJldHVybiBwb2ludCAoJHJhKSB0b1xuICogdGhlIEVORElOSVRJQUwgbGFiZWwuXG4gKlxuICogSXQgdGhlbiBleGVjdXRlcyB0aGUgYGFyZ3NgIGZ1bmN0aW9uLCB3aGljaCBhZGRzIGluc3RydWN0aW9uc1xuICogcmVzcG9uc2libGUgZm9yIHB1c2hpbmcgdGhlIGFyZ3VtZW50cyBmb3IgdGhlIGJsb2NrIHRvIHRoZVxuICogc3RhY2suIFRoZXNlIGFyZ3VtZW50cyB3aWxsIGJlIHJlc3RvcmVkIHRvIHRoZSBzdGFjayBiZWZvcmVcbiAqIHVwZGF0aW5nIGV4ZWN1dGlvbi5cbiAqXG4gKiBOZXh0LCBpdCBhZGRzIHRoZSBFbnRlciBvcGNvZGUsIHdoaWNoIG1hcmtzIHRoZSBjdXJyZW50IHBvc2l0aW9uXG4gKiBpbiB0aGUgRE9NLCBhbmQgcmVtZW1iZXJzIHRoZSBjdXJyZW50ICRwYyAodGhlIG5leHQgaW5zdHJ1Y3Rpb24pXG4gKiBhcyB0aGUgZmlyc3QgaW5zdHJ1Y3Rpb24gdG8gZXhlY3V0ZSBkdXJpbmcgdXBkYXRpbmcgZXhlY3V0aW9uLlxuICpcbiAqIE5leHQsIGl0IHJ1bnMgYGJvZHlgLCB3aGljaCBhZGRzIHRoZSBvcGNvZGVzIHRoYXQgc2hvdWxkXG4gKiBleGVjdXRlIGJvdGggZHVyaW5nIGluaXRpYWwgZXhlY3V0aW9uIGFuZCBkdXJpbmcgdXBkYXRpbmcgZXhlY3V0aW9uLlxuICogSWYgdGhlIGBib2R5YCB3aXNoZXMgdG8gZmluaXNoIGVhcmx5LCBpdCBzaG91bGQgSnVtcCB0byB0aGVcbiAqIGBGSU5BTExZYCBsYWJlbC5cbiAqXG4gKiBOZXh0LCBpdCBhZGRzIHRoZSBGSU5BTExZIGxhYmVsLCBmb2xsb3dlZCBieTpcbiAqXG4gKiAtIHRoZSBFeGl0IG9wY29kZSwgd2hpY2ggZmluYWxpemVzIHRoZSBtYXJrZWQgRE9NIHN0YXJ0ZWQgYnkgdGhlXG4gKiAgIEVudGVyIG9wY29kZS5cbiAqIC0gdGhlIFJldHVybiBvcGNvZGUsIHdoaWNoIHJldHVybnMgdG8gdGhlIGN1cnJlbnQgcmV0dXJuIHBvaW50XG4gKiAgICgkcmEpLlxuICpcbiAqIEZpbmFsbHksIGl0IGFkZHMgdGhlIEVORElOSVRJQUwgbGFiZWwgZm9sbG93ZWQgYnkgdGhlIFBvcEZyYW1lXG4gKiBpbnN0cnVjdGlvbiwgd2hpY2ggcmVzdG9yZXMgJGZwLCAkc3AgYW5kICRyYS5cbiAqXG4gKiAjIFVwZGF0aW5nIEV4ZWN1dGlvblxuICpcbiAqIFVwZGF0aW5nIGV4ZWN1dGlvbiBmb3IgdGhpcyBgcmVwbGF5YWJsZWAgb2NjdXJzIGlmIHRoZSBgYm9keWAgYWRkZWQgYW5cbiAqIGFzc2VydGlvbiwgdmlhIG9uZSBvZiB0aGUgYEp1bXBJZmAsIGBKdW1wVW5sZXNzYCBvciBgQXNzZXJ0U2FtZWAgb3Bjb2Rlcy5cbiAqXG4gKiBJZiwgZHVyaW5nIHVwZGF0aW5nIGV4ZWN1dG9uLCB0aGUgYXNzZXJ0aW9uIGZhaWxzLCB0aGUgaW5pdGlhbCBWTSBpc1xuICogcmVzdG9yZWQsIGFuZCB0aGUgc3RvcmVkIGFyZ3VtZW50cyBhcmUgcHVzaGVkIG9udG8gdGhlIHN0YWNrLiBUaGUgRE9NXG4gKiBiZXR3ZWVuIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIG1hcmtlcnMgaXMgY2xlYXJlZCwgYW5kIHRoZSBWTSdzIGN1cnNvclxuICogaXMgc2V0IHRvIHRoZSBhcmVhIGp1c3QgY2xlYXJlZC5cbiAqXG4gKiBUaGUgcmV0dXJuIHBvaW50ICgkcmEpIGlzIHNldCB0byAtMSwgdGhlIGV4aXQgaW5zdHJ1Y3Rpb24uXG4gKlxuICogRmluYWxseSwgdGhlICRwYyBpcyBzZXQgdG8gdG8gdGhlIGluc3RydWN0aW9uIHNhdmVkIG9mZiBieSB0aGVcbiAqIEVudGVyIG9wY29kZSBkdXJpbmcgaW5pdGlhbCBleGVjdXRpb24sIGFuZCBleGVjdXRpb24gcHJvY2VlZHMgYXNcbiAqIHVzdWFsLlxuICpcbiAqIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhhdCB3aGVuIGEgYFJldHVybmAgaW5zdHJ1Y3Rpb24gaXNcbiAqIGVuY291bnRlcmVkLCB0aGUgcHJvZ3JhbSBqdW1wcyB0byAtMSByYXRoZXIgdGhhbiB0aGUgRU5EIGxhYmVsLFxuICogYW5kIHRoZSBQb3BGcmFtZSBvcGNvZGUgaXMgbm90IG5lZWRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlcGxheWFibGUob3A6IFB1c2hTdGF0ZW1lbnRPcCwgYXJnczogKCkgPT4gbnVtYmVyLCBib2R5OiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gIC8vIFN0YXJ0IGEgbmV3IGxhYmVsIGZyYW1lLCB0byBnaXZlIEVORCBhbmQgUkVUVVJOXG4gIC8vIGEgdW5pcXVlIG1lYW5pbmcuXG5cbiAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5TdGFydExhYmVscyk7XG4gIG9wKE1hY2hpbmVPcC5QdXNoRnJhbWUpO1xuXG4gIC8vIElmIHRoZSBib2R5IGludm9rZXMgYSBibG9jaywgaXRzIHJldHVybiB3aWxsIHJldHVybiB0b1xuICAvLyBFTkQuIE90aGVyd2lzZSwgdGhlIHJldHVybiBpbiBSRVRVUk4gd2lsbCByZXR1cm4gdG8gRU5ELlxuICBvcChNYWNoaW5lT3AuUmV0dXJuVG8sIGxhYmVsT3BlcmFuZCgnRU5ESU5JVElBTCcpKTtcblxuICAvLyBQdXNoIHRoZSBhcmd1bWVudHMgb250byB0aGUgc3RhY2suIFRoZSBhcmdzKCkgZnVuY3Rpb25cbiAgLy8gdGVsbHMgdXMgaG93IG1hbnkgc3RhY2sgZWxlbWVudHMgdG8gcmV0YWluIGZvciByZS1leGVjdXRpb25cbiAgLy8gd2hlbiB1cGRhdGluZy5cbiAgbGV0IGNvdW50ID0gYXJncygpO1xuXG4gIC8vIFN0YXJ0IGEgbmV3IHVwZGF0aW5nIGNsb3N1cmUsIHJlbWVtYmVyaW5nIGBjb3VudGAgZWxlbWVudHNcbiAgLy8gZnJvbSB0aGUgc3RhY2suIEV2ZXJ5dGhpbmcgYWZ0ZXIgdGhpcyBwb2ludCwgYW5kIGJlZm9yZSBFTkQsXG4gIC8vIHdpbGwgZXhlY3V0ZSBib3RoIGluaXRpYWxseSBhbmQgdG8gdXBkYXRlIHRoZSBibG9jay5cbiAgLy9cbiAgLy8gVGhlIGVudGVyIGFuZCBleGl0IG9wY29kZXMgYWxzbyB0cmFjayB0aGUgYXJlYSBvZiB0aGUgRE9NXG4gIC8vIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGJsb2NrLiBJZiBhbiBhc3NlcnRpb24gaW5zaWRlIHRoZSBibG9ja1xuICAvLyBmYWlscyAoZm9yIGV4YW1wbGUsIHRoZSB0ZXN0IHZhbHVlIGNoYW5nZXMgZnJvbSB0cnVlIHRvIGZhbHNlXG4gIC8vIGluIGFuICNpZiksIHRoZSBET00gaXMgY2xlYXJlZCBhbmQgdGhlIHByb2dyYW0gaXMgcmUtZXhlY3V0ZWQsXG4gIC8vIHJlc3RvcmluZyBgY291bnRgIGVsZW1lbnRzIHRvIHRoZSBzdGFjayBhbmQgZXhlY3V0aW5nIHRoZVxuICAvLyBpbnN0cnVjdGlvbnMgYmV0d2VlbiB0aGUgZW50ZXIgYW5kIGV4aXQuXG4gIG9wKE9wLkVudGVyLCBjb3VudCk7XG5cbiAgLy8gRXZhbHVhdGUgdGhlIGJvZHkgb2YgdGhlIGJsb2NrLiBUaGUgYm9keSBvZiB0aGUgYmxvY2sgbWF5XG4gIC8vIHJldHVybiwgd2hpY2ggd2lsbCBqdW1wIGV4ZWN1dGlvbiB0byBFTkQgZHVyaW5nIGluaXRpYWxcbiAgLy8gZXhlY3V0aW9uLCBhbmQgZXhpdCB0aGUgdXBkYXRpbmcgcm91dGluZS5cbiAgYm9keSgpO1xuXG4gIC8vIEFsbCBleGVjdXRpb24gcGF0aHMgaW4gdGhlIGJvZHkgc2hvdWxkIHJ1biB0aGUgRklOQUxMWSBvbmNlXG4gIC8vIHRoZXkgYXJlIGRvbmUuIEl0IGlzIGV4ZWN1dGVkIGJvdGggZHVyaW5nIGluaXRpYWwgZXhlY3V0aW9uXG4gIC8vIGFuZCBkdXJpbmcgdXBkYXRpbmcgZXhlY3V0aW9uLlxuICBvcChIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLkxhYmVsLCAnRklOQUxMWScpO1xuXG4gIC8vIEZpbmFsaXplIHRoZSBET00uXG4gIG9wKE9wLkV4aXQpO1xuXG4gIC8vIEluIGluaXRpYWwgZXhlY3V0aW9uLCB0aGlzIGlzIGEgbm9vcDogaXQgcmV0dXJucyB0byB0aGVcbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93aW5nIG9wY29kZS4gSW4gdXBkYXRpbmcgZXhlY3V0aW9uLCB0aGlzXG4gIC8vIGV4aXRzIHRoZSB1cGRhdGluZyByb3V0aW5lLlxuICBvcChNYWNoaW5lT3AuUmV0dXJuKTtcblxuICAvLyBDbGVhbnVwIGNvZGUgZm9yIHRoZSBibG9jay4gUnVucyBvbiBpbml0aWFsIGV4ZWN1dGlvblxuICAvLyBidXQgbm90IG9uIHVwZGF0aW5nLlxuICBvcChIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLkxhYmVsLCAnRU5ESU5JVElBTCcpO1xuICBvcChNYWNoaW5lT3AuUG9wRnJhbWUpO1xuICBvcChIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLlN0b3BMYWJlbHMpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiB0aGUgYHJlcGxheWFibGVgIGNvbnZlbmllbmNlIHRoYXQgYWxsb3dzIHRoZVxuICogY2FsbGVyIHRvIHByb3ZpZGUgZGlmZmVyZW50IGNvZGUgYmFzZWQgdXBvbiB3aGV0aGVyIHRoZSBpdGVtIGF0XG4gKiB0aGUgdG9wIG9mIHRoZSBzdGFjayBpcyB0cnVlIG9yIGZhbHNlLlxuICpcbiAqIEFzIGluIGByZXBsYXlhYmxlYCwgdGhlIGBpZlRydWVgIGFuZCBgaWZGYWxzZWAgY29kZSBjYW4gaW52b2tlIGByZXR1cm5gLlxuICpcbiAqIER1cmluZyB0aGUgaW5pdGlhbCBleGVjdXRpb24sIGEgYHJldHVybmAgd2lsbCBjb250aW51ZSBleGVjdXRpb25cbiAqIGluIHRoZSBjbGVhbnVwIGNvZGUsIHdoaWNoIGZpbmFsaXplcyB0aGUgY3VycmVudCBET00gYmxvY2sgYW5kIHBvcHNcbiAqIHRoZSBjdXJyZW50IGZyYW1lLlxuICpcbiAqIER1cmluZyB0aGUgdXBkYXRpbmcgZXhlY3V0aW9uLCBhIGByZXR1cm5gIHdpbGwgZXhpdCB0aGUgdXBkYXRpbmdcbiAqIHJvdXRpbmUsIGFzIGl0IGNhbiByZXVzZSB0aGUgRE9NIGJsb2NrIGFuZCBpcyBhbHdheXMgb25seSBhIHNpbmdsZVxuICogZnJhbWUgZGVlcC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJlcGxheWFibGVJZihcbiAgb3A6IFB1c2hTdGF0ZW1lbnRPcCxcbiAgYXJnczogKCkgPT4gbnVtYmVyLFxuICBpZlRydWU6ICgpID0+IHZvaWQsXG4gIGlmRmFsc2U/OiAoKSA9PiB2b2lkXG4pOiB2b2lkIHtcbiAgcmV0dXJuIFJlcGxheWFibGUob3AsIGFyZ3MsICgpID0+IHtcbiAgICAvLyBJZiB0aGUgY29uZGl0aW9uYWwgaXMgZmFsc2UsIGp1bXAgdG8gdGhlIEVMU0UgbGFiZWwuXG4gICAgb3AoT3AuSnVtcFVubGVzcywgbGFiZWxPcGVyYW5kKCdFTFNFJykpO1xuICAgIC8vIE90aGVyd2lzZSwgZXhlY3V0ZSB0aGUgY29kZSBhc3NvY2lhdGVkIHdpdGggdGhlIHRydWUgYnJhbmNoLlxuICAgIGlmVHJ1ZSgpO1xuICAgIC8vIFdlJ3JlIGRvbmUsIHNvIHJldHVybi4gSW4gdGhlIGluaXRpYWwgZXhlY3V0aW9uLCB0aGlzIHJ1bnNcbiAgICAvLyB0aGUgY2xlYW51cCBjb2RlLiBJbiB0aGUgdXBkYXRpbmcgVk0sIGl0IGV4aXRzIHRoZSB1cGRhdGluZ1xuICAgIC8vIHJvdXRpbmUuXG4gICAgb3AoTWFjaGluZU9wLkp1bXAsIGxhYmVsT3BlcmFuZCgnRklOQUxMWScpKTtcbiAgICBvcChIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLkxhYmVsLCAnRUxTRScpO1xuXG4gICAgLy8gSWYgdGhlIGNvbmRpdGlvbmFsIGlzIGZhbHNlLCBhbmQgY29kZSBhc3NvY2lhdGllZCBpdGggdGhlXG4gICAgLy8gZmFsc2UgYnJhbmNoIHdhcyBwcm92aWRlZCwgZXhlY3V0ZSBpdC4gSWYgdGhlcmUgd2FzIG5vIGNvZGVcbiAgICAvLyBhc3NvY2lhdGVkIHdpdGggdGhlIGZhbHNlIGJyYW5jaCwganVtcGluZyB0byB0aGUgZWxzZSBzdGF0ZW1lbnRcbiAgICAvLyBoYXMgbm8gb3RoZXIgYmVoYXZpb3IuXG4gICAgaWYgKGlmRmFsc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWZGYWxzZSgpO1xuICAgIH1cbiAgfSk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9