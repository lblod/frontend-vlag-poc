function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import { dict, assign } from '@glimmer/util';
export var NamedBlocksImpl = /*#__PURE__*/function () {
  function NamedBlocksImpl(blocks) {
    this.blocks = blocks;
    this.names = blocks ? Object.keys(blocks) : [];
  }

  var _proto = NamedBlocksImpl.prototype;

  _proto.get = function get(name) {
    if (!this.blocks) return null;
    return this.blocks[name] || null;
  };

  _proto.has = function has(name) {
    var blocks = this.blocks;
    return blocks !== null && name in blocks;
  };

  _proto["with"] = function _with(name, block) {
    var blocks = this.blocks;

    if (blocks) {
      var _assign;

      return new NamedBlocksImpl(assign({}, blocks, (_assign = {}, _assign[name] = block, _assign)));
    } else {
      var _NamedBlocksImpl;

      return new NamedBlocksImpl((_NamedBlocksImpl = {}, _NamedBlocksImpl[name] = block, _NamedBlocksImpl));
    }
  };

  _createClass(NamedBlocksImpl, [{
    key: "hasAny",
    get: function get() {
      return this.blocks !== null;
    }
  }]);

  return NamedBlocksImpl;
}();
export var EMPTY_BLOCKS = new NamedBlocksImpl(null);
export function namedBlocks(blocks) {
  if (blocks === null) {
    return EMPTY_BLOCKS;
  }

  var out = dict();
  var keys = blocks[0],
      values = blocks[1];

  for (var i = 0; i < keys.length; i++) {
    out[keys[i]] = values[i];
  }

  return new NamedBlocksImpl(out);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUNBLFNBQUEsSUFBQSxFQUFBLE1BQUEsUUFBQSxlQUFBO0FBTUEsV0FBTSxlQUFOO0FBR0UsMkJBQUEsTUFBQSxFQUFtRDtBQUEvQixTQUFBLE1BQUEsR0FBQSxNQUFBO0FBQ2xCLFNBQUEsS0FBQSxHQUFhLE1BQU0sR0FBRyxNQUFNLENBQU4sSUFBQSxDQUFILE1BQUcsQ0FBSCxHQUFuQixFQUFBO0FBQ0Q7O0FBTEg7O0FBQUEsU0FPRSxHQVBGLEdBT0UsYUFBRyxJQUFILEVBQWdCO0FBQ2QsUUFBSSxDQUFDLEtBQUwsTUFBQSxFQUFrQixPQUFBLElBQUE7QUFFbEIsV0FBTyxLQUFBLE1BQUEsQ0FBQSxJQUFBLEtBQVAsSUFBQTtBQUNELEdBWEg7O0FBQUEsU0FhRSxHQWJGLEdBYUUsYUFBRyxJQUFILEVBQWdCO0FBQUEsUUFDUixNQURRLEdBQ2QsSUFEYyxDQUNSLE1BRFE7QUFFZCxXQUFPLE1BQU0sS0FBTixJQUFBLElBQW1CLElBQUksSUFBOUIsTUFBQTtBQUNELEdBaEJIOztBQUFBLG1CQWtCRSxlQUFJLElBQUosRUFBSSxLQUFKLEVBQXVEO0FBQUEsUUFDL0MsTUFEK0MsR0FDckQsSUFEcUQsQ0FDL0MsTUFEK0M7O0FBR3JELFFBQUEsTUFBQSxFQUFZO0FBQUE7O0FBQ1YsYUFBTyxJQUFBLGVBQUEsQ0FBb0IsTUFBTSxDQUFBLEVBQUEsRUFBQSxNQUFBLHlCQUFlLElBQWYsSUFBdUIsS0FBdkIsV0FBMUIsQ0FBUDtBQURGLEtBQUEsTUFFTztBQUFBOztBQUNMLGFBQU8sSUFBQSxlQUFBLDBDQUFzQixJQUF0QixJQUE4QixLQUE5QixvQkFBUDtBQUNEO0FBQ0YsR0ExQkg7O0FBQUE7QUFBQTtBQUFBLHdCQTRCWTtBQUNSLGFBQU8sS0FBQSxNQUFBLEtBQVAsSUFBQTtBQUNEO0FBOUJIOztBQUFBO0FBQUE7QUFpQ0EsT0FBTyxJQUFNLFlBQVksR0FBRyxJQUFBLGVBQUEsQ0FBckIsSUFBcUIsQ0FBckI7QUFFUCxPQUFNLFNBQUEsV0FBQSxDQUFBLE1BQUEsRUFBb0Q7QUFDeEQsTUFBSSxNQUFNLEtBQVYsSUFBQSxFQUFxQjtBQUNuQixXQUFBLFlBQUE7QUFDRDs7QUFFRCxNQUFJLEdBQUcsR0FBb0IsSUFBM0IsRUFBQTtBQUx3RCxNQU9wRCxJQVBvRCxHQU94RCxNQVB3RDtBQUFBLE1BT3BELE1BUG9ELEdBT3hELE1BUHdEOztBQVN4RCxPQUFLLElBQUksQ0FBQyxHQUFWLENBQUEsRUFBZ0IsQ0FBQyxHQUFHLElBQUksQ0FBeEIsTUFBQSxFQUFpQyxDQUFqQyxFQUFBLEVBQXNDO0FBQ3BDLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBUixDQUFRLENBQUwsQ0FBSCxHQUFlLE1BQU0sQ0FBckIsQ0FBcUIsQ0FBckI7QUFDRDs7QUFFRCxTQUFPLElBQUEsZUFBQSxDQUFQLEdBQU8sQ0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmFtZWRCbG9ja3MsIE9wdGlvbiwgV2lyZUZvcm1hdCwgU2VyaWFsaXplZElubGluZUJsb2NrIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBkaWN0LCBhc3NpZ24gfSBmcm9tICdAZ2xpbW1lci91dGlsJztcblxuaW50ZXJmYWNlIE5hbWVkQmxvY2tzRGljdCB7XG4gIFtrZXk6IHN0cmluZ106IE9wdGlvbjxXaXJlRm9ybWF0LlNlcmlhbGl6ZWRJbmxpbmVCbG9jaz47XG59XG5cbmV4cG9ydCBjbGFzcyBOYW1lZEJsb2Nrc0ltcGwgaW1wbGVtZW50cyBOYW1lZEJsb2NrcyB7XG4gIHB1YmxpYyBuYW1lczogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBibG9ja3M6IE9wdGlvbjxOYW1lZEJsb2Nrc0RpY3Q+KSB7XG4gICAgdGhpcy5uYW1lcyA9IGJsb2NrcyA/IE9iamVjdC5rZXlzKGJsb2NrcykgOiBbXTtcbiAgfVxuXG4gIGdldChuYW1lOiBzdHJpbmcpOiBPcHRpb248U2VyaWFsaXplZElubGluZUJsb2NrPiB7XG4gICAgaWYgKCF0aGlzLmJsb2NrcykgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gdGhpcy5ibG9ja3NbbmFtZV0gfHwgbnVsbDtcbiAgfVxuXG4gIGhhcyhuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBsZXQgeyBibG9ja3MgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGJsb2NrcyAhPT0gbnVsbCAmJiBuYW1lIGluIGJsb2NrcztcbiAgfVxuXG4gIHdpdGgobmFtZTogc3RyaW5nLCBibG9jazogT3B0aW9uPFNlcmlhbGl6ZWRJbmxpbmVCbG9jaz4pOiBOYW1lZEJsb2NrcyB7XG4gICAgbGV0IHsgYmxvY2tzIH0gPSB0aGlzO1xuXG4gICAgaWYgKGJsb2Nrcykge1xuICAgICAgcmV0dXJuIG5ldyBOYW1lZEJsb2Nrc0ltcGwoYXNzaWduKHt9LCBibG9ja3MsIHsgW25hbWVdOiBibG9jayB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgTmFtZWRCbG9ja3NJbXBsKHsgW25hbWVdOiBibG9jayB9KTtcbiAgICB9XG4gIH1cblxuICBnZXQgaGFzQW55KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmJsb2NrcyAhPT0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgRU1QVFlfQkxPQ0tTID0gbmV3IE5hbWVkQmxvY2tzSW1wbChudWxsKTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVkQmxvY2tzKGJsb2NrczogV2lyZUZvcm1hdC5Db3JlLkJsb2Nrcyk6IE5hbWVkQmxvY2tzIHtcbiAgaWYgKGJsb2NrcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBFTVBUWV9CTE9DS1M7XG4gIH1cblxuICBsZXQgb3V0OiBOYW1lZEJsb2Nrc0RpY3QgPSBkaWN0KCk7XG5cbiAgbGV0IFtrZXlzLCB2YWx1ZXNdID0gYmxvY2tzO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG91dFtrZXlzW2ldXSA9IHZhbHVlc1tpXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgTmFtZWRCbG9ja3NJbXBsKG91dCk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9