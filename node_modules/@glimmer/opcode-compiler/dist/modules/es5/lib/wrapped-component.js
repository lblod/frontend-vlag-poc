import { templateCompilationContext } from './opcode-builder/context';
import { meta } from './opcode-builder/helpers/shared';
import { ATTRS_BLOCK, WrappedComponent } from './opcode-builder/helpers/components';
import { debugCompiler } from './compiler';
import { encodeOp } from './opcode-builder/encoder';
export var WrappedBuilder = /*#__PURE__*/function () {
  function WrappedBuilder(layout, moduleName) {
    this.layout = layout;
    this.moduleName = moduleName;
    this.compiled = null;
    var block = layout.block;
    var symbols = block[1],
        hasEval = block[2];
    symbols = symbols.slice(); // ensure ATTRS_BLOCK is always included (only once) in the list of symbols

    var attrsBlockIndex = symbols.indexOf(ATTRS_BLOCK);

    if (attrsBlockIndex === -1) {
      this.attrsBlockNumber = symbols.push(ATTRS_BLOCK);
    } else {
      this.attrsBlockNumber = attrsBlockIndex + 1;
    }

    this.symbolTable = {
      hasEval: hasEval,
      symbols: symbols
    };
  }

  var _proto = WrappedBuilder.prototype;

  _proto.compile = function compile(syntax) {
    if (this.compiled !== null) return this.compiled;
    var m = meta(this.layout);
    var context = templateCompilationContext(syntax, m);
    var encoder = context.encoder,
        _context$program = context.program,
        constants = _context$program.constants,
        resolver = _context$program.resolver;

    function pushOp() {
      for (var _len = arguments.length, op = new Array(_len), _key = 0; _key < _len; _key++) {
        op[_key] = arguments[_key];
      }

      encodeOp(encoder, constants, resolver, m, op);
    }

    WrappedComponent(pushOp, this.layout, this.attrsBlockNumber);
    var handle = context.encoder.commit(m.size);

    if (typeof handle !== 'number') {
      return handle;
    }

    this.compiled = handle;

    if (false
    /* LOCAL_SHOULD_LOG */
    ) {
        debugCompiler(context, handle);
      }

    return handle;
  };

  return WrappedBuilder;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvd3JhcHBlZC1jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBV0EsU0FBQSwwQkFBQSxRQUFBLDBCQUFBO0FBQ0EsU0FBQSxJQUFBLFFBQUEsaUNBQUE7QUFDQSxTQUFBLFdBQUEsRUFBQSxnQkFBQSxRQUFBLHFDQUFBO0FBRUEsU0FBQSxhQUFBLFFBQUEsWUFBQTtBQUNBLFNBQUEsUUFBQSxRQUFBLDBCQUFBO0FBR0EsV0FBTSxjQUFOO0FBS0UsMEJBQUEsTUFBQSxFQUFBLFVBQUEsRUFBd0U7QUFBcEQsU0FBQSxNQUFBLEdBQUEsTUFBQTtBQUFrQyxTQUFBLFVBQUEsR0FBQSxVQUFBO0FBSDlDLFNBQUEsUUFBQSxHQUFBLElBQUE7QUFHZ0UsUUFDaEUsS0FEZ0UsR0FDdEUsTUFEc0UsQ0FDaEUsS0FEZ0U7QUFBQSxRQUVsRSxPQUZrRSxHQUV0RSxLQUZzRTtBQUFBLFFBRWxFLE9BRmtFLEdBRXRFLEtBRnNFO0FBSXRFLElBQUEsT0FBTyxHQUFHLE9BQU8sQ0FKcUQsS0FJNUQsRUFBVixDQUpzRSxDQU10RTs7QUFDQSxRQUFJLGVBQWUsR0FBRyxPQUFPLENBQVAsT0FBQSxDQUF0QixXQUFzQixDQUF0Qjs7QUFDQSxRQUFJLGVBQWUsS0FBSyxDQUF4QixDQUFBLEVBQTRCO0FBQzFCLFdBQUEsZ0JBQUEsR0FBd0IsT0FBTyxDQUFQLElBQUEsQ0FBeEIsV0FBd0IsQ0FBeEI7QUFERixLQUFBLE1BRU87QUFDTCxXQUFBLGdCQUFBLEdBQXdCLGVBQWUsR0FBdkMsQ0FBQTtBQUNEOztBQUVELFNBQUEsV0FBQSxHQUFtQjtBQUNqQixNQUFBLE9BRGlCLEVBQ2pCLE9BRGlCO0FBRWpCLE1BQUEsT0FBQSxFQUFBO0FBRmlCLEtBQW5CO0FBSUQ7O0FBdkJIOztBQUFBLFNBeUJFLE9BekJGLEdBeUJFLGlCQUFPLE1BQVAsRUFBNkM7QUFDM0MsUUFBSSxLQUFBLFFBQUEsS0FBSixJQUFBLEVBQTRCLE9BQU8sS0FBUCxRQUFBO0FBRTVCLFFBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFiLE1BQVksQ0FBWjtBQUNBLFFBQUksT0FBTyxHQUFHLDBCQUEwQixDQUFBLE1BQUEsRUFBeEMsQ0FBd0MsQ0FBeEM7QUFKMkMsUUFNdkMsT0FOdUMsR0FNM0MsT0FOMkMsQ0FNdkMsT0FOdUM7QUFBQSwyQkFNM0MsT0FOMkMsQ0FRekMsT0FSeUM7QUFBQSxRQVFoQyxTQVJnQyxvQkFRaEMsU0FSZ0M7QUFBQSxRQVFuQixRQVJtQixvQkFRbkIsUUFSbUI7O0FBVzNDLGFBQUEsTUFBQSxHQUFxRTtBQUFBLHdDQUFyRSxFQUFxRTtBQUFyRSxRQUFBLEVBQXFFO0FBQUE7O0FBQ25FLE1BQUEsUUFBUSxDQUFBLE9BQUEsRUFBQSxTQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsRUFBUixFQUFRLENBQVI7QUFDRDs7QUFFRCxJQUFBLGdCQUFnQixDQUFBLE1BQUEsRUFBUyxLQUFULE1BQUEsRUFBc0IsS0FBdEMsZ0JBQWdCLENBQWhCO0FBRUEsUUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFQLE9BQUEsQ0FBQSxNQUFBLENBQXVCLENBQUMsQ0FBckMsSUFBYSxDQUFiOztBQUVBLFFBQUksT0FBQSxNQUFBLEtBQUosUUFBQSxFQUFnQztBQUM5QixhQUFBLE1BQUE7QUFDRDs7QUFFRCxTQUFBLFFBQUEsR0FBQSxNQUFBOztBQUVBLFFBQUE7QUFBQTtBQUFBLE1BQXNCO0FBQ3BCLFFBQUEsYUFBYSxDQUFBLE9BQUEsRUFBYixNQUFhLENBQWI7QUFDRDs7QUFFRCxXQUFBLE1BQUE7QUFDRCxHQXZESDs7QUFBQTtBQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgUHJvZ3JhbVN5bWJvbFRhYmxlLFxuICBDb21waWxhYmxlUHJvZ3JhbSxcbiAgTGF5b3V0V2l0aENvbnRleHQsXG4gIE9wdGlvbixcbiAgQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIEhhbmRsZVJlc3VsdCxcbiAgQnVpbGRlck9wLFxuICBIaWdoTGV2ZWxPcCxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbmltcG9ydCB7IHRlbXBsYXRlQ29tcGlsYXRpb25Db250ZXh0IH0gZnJvbSAnLi9vcGNvZGUtYnVpbGRlci9jb250ZXh0JztcbmltcG9ydCB7IG1ldGEgfSBmcm9tICcuL29wY29kZS1idWlsZGVyL2hlbHBlcnMvc2hhcmVkJztcbmltcG9ydCB7IEFUVFJTX0JMT0NLLCBXcmFwcGVkQ29tcG9uZW50IH0gZnJvbSAnLi9vcGNvZGUtYnVpbGRlci9oZWxwZXJzL2NvbXBvbmVudHMnO1xuaW1wb3J0IHsgTE9DQUxfU0hPVUxEX0xPRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7IGRlYnVnQ29tcGlsZXIgfSBmcm9tICcuL2NvbXBpbGVyJztcbmltcG9ydCB7IGVuY29kZU9wIH0gZnJvbSAnLi9vcGNvZGUtYnVpbGRlci9lbmNvZGVyJztcbmltcG9ydCB7IEhpZ2hMZXZlbFN0YXRlbWVudE9wIH0gZnJvbSAnLi9zeW50YXgvY29tcGlsZXJzJztcblxuZXhwb3J0IGNsYXNzIFdyYXBwZWRCdWlsZGVyIGltcGxlbWVudHMgQ29tcGlsYWJsZVByb2dyYW0ge1xuICBwdWJsaWMgc3ltYm9sVGFibGU6IFByb2dyYW1TeW1ib2xUYWJsZTtcbiAgcHJpdmF0ZSBjb21waWxlZDogT3B0aW9uPG51bWJlcj4gPSBudWxsO1xuICBwcml2YXRlIGF0dHJzQmxvY2tOdW1iZXI6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGxheW91dDogTGF5b3V0V2l0aENvbnRleHQsIHB1YmxpYyBtb2R1bGVOYW1lOiBzdHJpbmcpIHtcbiAgICBsZXQgeyBibG9jayB9ID0gbGF5b3V0O1xuICAgIGxldCBbLCBzeW1ib2xzLCBoYXNFdmFsXSA9IGJsb2NrO1xuXG4gICAgc3ltYm9scyA9IHN5bWJvbHMuc2xpY2UoKTtcblxuICAgIC8vIGVuc3VyZSBBVFRSU19CTE9DSyBpcyBhbHdheXMgaW5jbHVkZWQgKG9ubHkgb25jZSkgaW4gdGhlIGxpc3Qgb2Ygc3ltYm9sc1xuICAgIGxldCBhdHRyc0Jsb2NrSW5kZXggPSBzeW1ib2xzLmluZGV4T2YoQVRUUlNfQkxPQ0spO1xuICAgIGlmIChhdHRyc0Jsb2NrSW5kZXggPT09IC0xKSB7XG4gICAgICB0aGlzLmF0dHJzQmxvY2tOdW1iZXIgPSBzeW1ib2xzLnB1c2goQVRUUlNfQkxPQ0spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF0dHJzQmxvY2tOdW1iZXIgPSBhdHRyc0Jsb2NrSW5kZXggKyAxO1xuICAgIH1cblxuICAgIHRoaXMuc3ltYm9sVGFibGUgPSB7XG4gICAgICBoYXNFdmFsLFxuICAgICAgc3ltYm9scyxcbiAgICB9O1xuICB9XG5cbiAgY29tcGlsZShzeW50YXg6IENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0KTogSGFuZGxlUmVzdWx0IHtcbiAgICBpZiAodGhpcy5jb21waWxlZCAhPT0gbnVsbCkgcmV0dXJuIHRoaXMuY29tcGlsZWQ7XG5cbiAgICBsZXQgbSA9IG1ldGEodGhpcy5sYXlvdXQpO1xuICAgIGxldCBjb250ZXh0ID0gdGVtcGxhdGVDb21waWxhdGlvbkNvbnRleHQoc3ludGF4LCBtKTtcblxuICAgIGxldCB7XG4gICAgICBlbmNvZGVyLFxuICAgICAgcHJvZ3JhbTogeyBjb25zdGFudHMsIHJlc29sdmVyIH0sXG4gICAgfSA9IGNvbnRleHQ7XG5cbiAgICBmdW5jdGlvbiBwdXNoT3AoLi4ub3A6IEJ1aWxkZXJPcCB8IEhpZ2hMZXZlbE9wIHwgSGlnaExldmVsU3RhdGVtZW50T3ApIHtcbiAgICAgIGVuY29kZU9wKGVuY29kZXIsIGNvbnN0YW50cywgcmVzb2x2ZXIsIG0sIG9wIGFzIEJ1aWxkZXJPcCB8IEhpZ2hMZXZlbE9wKTtcbiAgICB9XG5cbiAgICBXcmFwcGVkQ29tcG9uZW50KHB1c2hPcCwgdGhpcy5sYXlvdXQsIHRoaXMuYXR0cnNCbG9ja051bWJlcik7XG5cbiAgICBsZXQgaGFuZGxlID0gY29udGV4dC5lbmNvZGVyLmNvbW1pdChtLnNpemUpO1xuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGUgIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gaGFuZGxlO1xuICAgIH1cblxuICAgIHRoaXMuY29tcGlsZWQgPSBoYW5kbGU7XG5cbiAgICBpZiAoTE9DQUxfU0hPVUxEX0xPRykge1xuICAgICAgZGVidWdDb21waWxlcihjb250ZXh0LCBoYW5kbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGU7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=