import { labelOperand } from '../operands';
export function SwitchCases(op, bootstrap, callback) {
  // Setup the switch DSL
  let clauses = [];
  let count = 0;

  function when(match, callback) {
    clauses.push({
      match,
      callback,
      label: `CLAUSE${count++}`
    });
  } // Call the callback


  callback(when); // Emit the opcodes for the switch

  op(69
  /* Enter */
  , 1);
  bootstrap();
  op(1001
  /* StartLabels */
  ); // First, emit the jump opcodes. We don't need a jump for the last
  // opcode, since it bleeds directly into its clause.

  for (let clause of clauses.slice(0, -1)) {
    op(67
    /* JumpEq */
    , labelOperand(clause.label), clause.match);
  } // Enumerate the clauses in reverse order. Earlier matches will
  // require fewer checks.


  for (let i = clauses.length - 1; i >= 0; i--) {
    let clause = clauses[i];
    op(1000
    /* Label */
    , clause.label);
    op(34
    /* Pop */
    , 1);
    clause.callback(); // The first match is special: it is placed directly before the END
    // label, so no additional jump is needed at the end of it.

    if (i !== 0) {
      op(4
      /* Jump */
      , labelOperand('END'));
    }
  }

  op(1000
  /* Label */
  , 'END');
  op(1002
  /* StopLabels */
  );
  op(70
  /* Exit */
  );
}
/**
 * A convenience for pushing some arguments on the stack and
 * running some code if the code needs to be re-executed during
 * updating execution if some of the arguments have changed.
 *
 * # Initial Execution
 *
 * The `args` function should push zero or more arguments onto
 * the stack and return the number of arguments pushed.
 *
 * The `body` function provides the instructions to execute both
 * during initial execution and during updating execution.
 *
 * Internally, this function starts by pushing a new frame, so
 * that the body can return and sets the return point ($ra) to
 * the ENDINITIAL label.
 *
 * It then executes the `args` function, which adds instructions
 * responsible for pushing the arguments for the block to the
 * stack. These arguments will be restored to the stack before
 * updating execution.
 *
 * Next, it adds the Enter opcode, which marks the current position
 * in the DOM, and remembers the current $pc (the next instruction)
 * as the first instruction to execute during updating execution.
 *
 * Next, it runs `body`, which adds the opcodes that should
 * execute both during initial execution and during updating execution.
 * If the `body` wishes to finish early, it should Jump to the
 * `FINALLY` label.
 *
 * Next, it adds the FINALLY label, followed by:
 *
 * - the Exit opcode, which finalizes the marked DOM started by the
 *   Enter opcode.
 * - the Return opcode, which returns to the current return point
 *   ($ra).
 *
 * Finally, it adds the ENDINITIAL label followed by the PopFrame
 * instruction, which restores $fp, $sp and $ra.
 *
 * # Updating Execution
 *
 * Updating execution for this `replayable` occurs if the `body` added an
 * assertion, via one of the `JumpIf`, `JumpUnless` or `AssertSame` opcodes.
 *
 * If, during updating executon, the assertion fails, the initial VM is
 * restored, and the stored arguments are pushed onto the stack. The DOM
 * between the starting and ending markers is cleared, and the VM's cursor
 * is set to the area just cleared.
 *
 * The return point ($ra) is set to -1, the exit instruction.
 *
 * Finally, the $pc is set to to the instruction saved off by the
 * Enter opcode during initial execution, and execution proceeds as
 * usual.
 *
 * The only difference is that when a `Return` instruction is
 * encountered, the program jumps to -1 rather than the END label,
 * and the PopFrame opcode is not needed.
 */

export function Replayable(op, args, body) {
  // Start a new label frame, to give END and RETURN
  // a unique meaning.
  op(1001
  /* StartLabels */
  );
  op(0
  /* PushFrame */
  ); // If the body invokes a block, its return will return to
  // END. Otherwise, the return in RETURN will return to END.

  op(6
  /* ReturnTo */
  , labelOperand('ENDINITIAL')); // Push the arguments onto the stack. The args() function
  // tells us how many stack elements to retain for re-execution
  // when updating.

  let count = args(); // Start a new updating closure, remembering `count` elements
  // from the stack. Everything after this point, and before END,
  // will execute both initially and to update the block.
  //
  // The enter and exit opcodes also track the area of the DOM
  // associated with this block. If an assertion inside the block
  // fails (for example, the test value changes from true to false
  // in an #if), the DOM is cleared and the program is re-executed,
  // restoring `count` elements to the stack and executing the
  // instructions between the enter and exit.

  op(69
  /* Enter */
  , count); // Evaluate the body of the block. The body of the block may
  // return, which will jump execution to END during initial
  // execution, and exit the updating routine.

  body(); // All execution paths in the body should run the FINALLY once
  // they are done. It is executed both during initial execution
  // and during updating execution.

  op(1000
  /* Label */
  , 'FINALLY'); // Finalize the DOM.

  op(70
  /* Exit */
  ); // In initial execution, this is a noop: it returns to the
  // immediately following opcode. In updating execution, this
  // exits the updating routine.

  op(5
  /* Return */
  ); // Cleanup code for the block. Runs on initial execution
  // but not on updating.

  op(1000
  /* Label */
  , 'ENDINITIAL');
  op(1
  /* PopFrame */
  );
  op(1002
  /* StopLabels */
  );
}
/**
 * A specialized version of the `replayable` convenience that allows the
 * caller to provide different code based upon whether the item at
 * the top of the stack is true or false.
 *
 * As in `replayable`, the `ifTrue` and `ifFalse` code can invoke `return`.
 *
 * During the initial execution, a `return` will continue execution
 * in the cleanup code, which finalizes the current DOM block and pops
 * the current frame.
 *
 * During the updating execution, a `return` will exit the updating
 * routine, as it can reuse the DOM block and is always only a single
 * frame deep.
 */

export function ReplayableIf(op, args, ifTrue, ifFalse) {
  return Replayable(op, args, () => {
    // If the conditional is false, jump to the ELSE label.
    op(66
    /* JumpUnless */
    , labelOperand('ELSE')); // Otherwise, execute the code associated with the true branch.

    ifTrue(); // We're done, so return. In the initial execution, this runs
    // the cleanup code. In the updating VM, it exits the updating
    // routine.

    op(4
    /* Jump */
    , labelOperand('FINALLY'));
    op(1000
    /* Label */
    , 'ELSE'); // If the conditional is false, and code associatied ith the
    // false branch was provided, execute it. If there was no code
    // associated with the false branch, jumping to the else statement
    // has no other behavior.

    if (ifFalse !== undefined) {
      ifFalse();
    }
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9jb25kaXRpb25hbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLFlBQVQsUUFBNkIsYUFBN0I7QUFNQSxPQUFNLFNBQVUsV0FBVixDQUNKLEVBREksRUFFSixTQUZJLEVBR0osUUFISSxFQUcwQjtBQUU5QjtBQUNBLE1BQUksT0FBTyxHQUFrRSxFQUE3RTtBQUVBLE1BQUksS0FBSyxHQUFHLENBQVo7O0FBRUEsV0FBUyxJQUFULENBQWMsS0FBZCxFQUE2QixRQUE3QixFQUFpRDtBQUMvQyxJQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWE7QUFBRSxNQUFBLEtBQUY7QUFBUyxNQUFBLFFBQVQ7QUFBbUIsTUFBQSxLQUFLLEVBQUUsU0FBUyxLQUFLLEVBQUU7QUFBMUMsS0FBYjtBQUNELEdBVDZCLENBVzlCOzs7QUFDQSxFQUFBLFFBQVEsQ0FBQyxJQUFELENBQVIsQ0FaOEIsQ0FjOUI7O0FBQ0EsRUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLElBQVcsQ0FBWCxDQUFGO0FBQ0EsRUFBQSxTQUFTO0FBQ1QsRUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLEdBQUYsQ0FqQjhCLENBbUI5QjtBQUNBOztBQUNBLE9BQUssSUFBSSxNQUFULElBQW1CLE9BQU8sQ0FBQyxLQUFSLENBQWMsQ0FBZCxFQUFpQixDQUFDLENBQWxCLENBQW5CLEVBQXlDO0FBQ3ZDLElBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxNQUFZLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBUixDQUF4QixFQUF3QyxNQUFNLENBQUMsS0FBL0MsQ0FBRjtBQUNELEdBdkI2QixDQXlCOUI7QUFDQTs7O0FBQ0EsT0FBSyxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBUixHQUFpQixDQUE5QixFQUFpQyxDQUFDLElBQUksQ0FBdEMsRUFBeUMsQ0FBQyxFQUExQyxFQUE4QztBQUM1QyxRQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBRCxDQUFwQjtBQUVBLElBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxNQUErQixNQUFNLENBQUMsS0FBdEMsQ0FBRjtBQUNBLElBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxNQUFTLENBQVQsQ0FBRjtBQUNBLElBQUEsTUFBTSxDQUFDLFFBQVAsR0FMNEMsQ0FPNUM7QUFDQTs7QUFDQSxRQUFJLENBQUMsS0FBSyxDQUFWLEVBQWE7QUFDWCxNQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsUUFBaUIsWUFBWSxDQUFDLEtBQUQsQ0FBN0IsQ0FBRjtBQUNEO0FBQ0Y7O0FBRUQsRUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLElBQStCLEtBQS9CLENBQUY7QUFDQSxFQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsR0FBRjtBQUNBLEVBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxHQUFGO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2REEsT0FBTSxTQUFVLFVBQVYsQ0FBcUIsRUFBckIsRUFBMEMsSUFBMUMsRUFBOEQsSUFBOUQsRUFBOEU7QUFDbEY7QUFDQTtBQUVBLEVBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxHQUFGO0FBQ0EsRUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLEdBQUYsQ0FMa0YsQ0FPbEY7QUFDQTs7QUFDQSxFQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsSUFBcUIsWUFBWSxDQUFDLFlBQUQsQ0FBakMsQ0FBRixDQVRrRixDQVdsRjtBQUNBO0FBQ0E7O0FBQ0EsTUFBSSxLQUFLLEdBQUcsSUFBSSxFQUFoQixDQWRrRixDQWdCbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsRUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLElBQVcsS0FBWCxDQUFGLENBMUJrRixDQTRCbEY7QUFDQTtBQUNBOztBQUNBLEVBQUEsSUFBSSxHQS9COEUsQ0FpQ2xGO0FBQ0E7QUFDQTs7QUFDQSxFQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsSUFBK0IsU0FBL0IsQ0FBRixDQXBDa0YsQ0FzQ2xGOztBQUNBLEVBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxHQUFGLENBdkNrRixDQXlDbEY7QUFDQTtBQUNBOztBQUNBLEVBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxHQUFGLENBNUNrRixDQThDbEY7QUFDQTs7QUFDQSxFQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsSUFBK0IsWUFBL0IsQ0FBRjtBQUNBLEVBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxHQUFGO0FBQ0EsRUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLEdBQUY7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsT0FBTSxTQUFVLFlBQVYsQ0FDSixFQURJLEVBRUosSUFGSSxFQUdKLE1BSEksRUFJSixPQUpJLEVBSWdCO0FBRXBCLFNBQU8sVUFBVSxDQUFDLEVBQUQsRUFBSyxJQUFMLEVBQVcsTUFBSztBQUMvQjtBQUNBLElBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxNQUFnQixZQUFZLENBQUMsTUFBRCxDQUE1QixDQUFGLENBRitCLENBRy9COztBQUNBLElBQUEsTUFBTSxHQUp5QixDQUsvQjtBQUNBO0FBQ0E7O0FBQ0EsSUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLE1BQWlCLFlBQVksQ0FBQyxTQUFELENBQTdCLENBQUY7QUFDQSxJQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsTUFBK0IsTUFBL0IsQ0FBRixDQVQrQixDQVcvQjtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxRQUFJLE9BQU8sS0FBSyxTQUFoQixFQUEyQjtBQUN6QixNQUFBLE9BQU87QUFDUjtBQUNGLEdBbEJnQixDQUFqQjtBQW1CRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxhYmVsT3BlcmFuZCB9IGZyb20gJy4uL29wZXJhbmRzJztcbmltcG9ydCB7IE9wLCBNYWNoaW5lT3AsIEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFB1c2hTdGF0ZW1lbnRPcCB9IGZyb20gJy4uLy4uL3N5bnRheC9jb21waWxlcnMnO1xuXG5leHBvcnQgdHlwZSBXaGVuID0gKG1hdGNoOiBudW1iZXIsIGNhbGxiYWNrOiAoKSA9PiB2b2lkKSA9PiB2b2lkO1xuXG5leHBvcnQgZnVuY3Rpb24gU3dpdGNoQ2FzZXMoXG4gIG9wOiBQdXNoU3RhdGVtZW50T3AsXG4gIGJvb3RzdHJhcDogKCkgPT4gdm9pZCxcbiAgY2FsbGJhY2s6ICh3aGVuOiBXaGVuKSA9PiB2b2lkXG4pOiB2b2lkIHtcbiAgLy8gU2V0dXAgdGhlIHN3aXRjaCBEU0xcbiAgbGV0IGNsYXVzZXM6IEFycmF5PHsgbWF0Y2g6IG51bWJlcjsgbGFiZWw6IHN0cmluZzsgY2FsbGJhY2s6ICgpID0+IHZvaWQgfT4gPSBbXTtcblxuICBsZXQgY291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIHdoZW4obWF0Y2g6IG51bWJlciwgY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBjbGF1c2VzLnB1c2goeyBtYXRjaCwgY2FsbGJhY2ssIGxhYmVsOiBgQ0xBVVNFJHtjb3VudCsrfWAgfSk7XG4gIH1cblxuICAvLyBDYWxsIHRoZSBjYWxsYmFja1xuICBjYWxsYmFjayh3aGVuKTtcblxuICAvLyBFbWl0IHRoZSBvcGNvZGVzIGZvciB0aGUgc3dpdGNoXG4gIG9wKE9wLkVudGVyLCAxKTtcbiAgYm9vdHN0cmFwKCk7XG4gIG9wKEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUuU3RhcnRMYWJlbHMpO1xuXG4gIC8vIEZpcnN0LCBlbWl0IHRoZSBqdW1wIG9wY29kZXMuIFdlIGRvbid0IG5lZWQgYSBqdW1wIGZvciB0aGUgbGFzdFxuICAvLyBvcGNvZGUsIHNpbmNlIGl0IGJsZWVkcyBkaXJlY3RseSBpbnRvIGl0cyBjbGF1c2UuXG4gIGZvciAobGV0IGNsYXVzZSBvZiBjbGF1c2VzLnNsaWNlKDAsIC0xKSkge1xuICAgIG9wKE9wLkp1bXBFcSwgbGFiZWxPcGVyYW5kKGNsYXVzZS5sYWJlbCksIGNsYXVzZS5tYXRjaCk7XG4gIH1cblxuICAvLyBFbnVtZXJhdGUgdGhlIGNsYXVzZXMgaW4gcmV2ZXJzZSBvcmRlci4gRWFybGllciBtYXRjaGVzIHdpbGxcbiAgLy8gcmVxdWlyZSBmZXdlciBjaGVja3MuXG4gIGZvciAobGV0IGkgPSBjbGF1c2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IGNsYXVzZSA9IGNsYXVzZXNbaV07XG5cbiAgICBvcChIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLkxhYmVsLCBjbGF1c2UubGFiZWwpO1xuICAgIG9wKE9wLlBvcCwgMSk7XG4gICAgY2xhdXNlLmNhbGxiYWNrKCk7XG5cbiAgICAvLyBUaGUgZmlyc3QgbWF0Y2ggaXMgc3BlY2lhbDogaXQgaXMgcGxhY2VkIGRpcmVjdGx5IGJlZm9yZSB0aGUgRU5EXG4gICAgLy8gbGFiZWwsIHNvIG5vIGFkZGl0aW9uYWwganVtcCBpcyBuZWVkZWQgYXQgdGhlIGVuZCBvZiBpdC5cbiAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgb3AoTWFjaGluZU9wLkp1bXAsIGxhYmVsT3BlcmFuZCgnRU5EJykpO1xuICAgIH1cbiAgfVxuXG4gIG9wKEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUuTGFiZWwsICdFTkQnKTtcbiAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5TdG9wTGFiZWxzKTtcbiAgb3AoT3AuRXhpdCk7XG59XG5cbi8qKlxuICogQSBjb252ZW5pZW5jZSBmb3IgcHVzaGluZyBzb21lIGFyZ3VtZW50cyBvbiB0aGUgc3RhY2sgYW5kXG4gKiBydW5uaW5nIHNvbWUgY29kZSBpZiB0aGUgY29kZSBuZWVkcyB0byBiZSByZS1leGVjdXRlZCBkdXJpbmdcbiAqIHVwZGF0aW5nIGV4ZWN1dGlvbiBpZiBzb21lIG9mIHRoZSBhcmd1bWVudHMgaGF2ZSBjaGFuZ2VkLlxuICpcbiAqICMgSW5pdGlhbCBFeGVjdXRpb25cbiAqXG4gKiBUaGUgYGFyZ3NgIGZ1bmN0aW9uIHNob3VsZCBwdXNoIHplcm8gb3IgbW9yZSBhcmd1bWVudHMgb250b1xuICogdGhlIHN0YWNrIGFuZCByZXR1cm4gdGhlIG51bWJlciBvZiBhcmd1bWVudHMgcHVzaGVkLlxuICpcbiAqIFRoZSBgYm9keWAgZnVuY3Rpb24gcHJvdmlkZXMgdGhlIGluc3RydWN0aW9ucyB0byBleGVjdXRlIGJvdGhcbiAqIGR1cmluZyBpbml0aWFsIGV4ZWN1dGlvbiBhbmQgZHVyaW5nIHVwZGF0aW5nIGV4ZWN1dGlvbi5cbiAqXG4gKiBJbnRlcm5hbGx5LCB0aGlzIGZ1bmN0aW9uIHN0YXJ0cyBieSBwdXNoaW5nIGEgbmV3IGZyYW1lLCBzb1xuICogdGhhdCB0aGUgYm9keSBjYW4gcmV0dXJuIGFuZCBzZXRzIHRoZSByZXR1cm4gcG9pbnQgKCRyYSkgdG9cbiAqIHRoZSBFTkRJTklUSUFMIGxhYmVsLlxuICpcbiAqIEl0IHRoZW4gZXhlY3V0ZXMgdGhlIGBhcmdzYCBmdW5jdGlvbiwgd2hpY2ggYWRkcyBpbnN0cnVjdGlvbnNcbiAqIHJlc3BvbnNpYmxlIGZvciBwdXNoaW5nIHRoZSBhcmd1bWVudHMgZm9yIHRoZSBibG9jayB0byB0aGVcbiAqIHN0YWNrLiBUaGVzZSBhcmd1bWVudHMgd2lsbCBiZSByZXN0b3JlZCB0byB0aGUgc3RhY2sgYmVmb3JlXG4gKiB1cGRhdGluZyBleGVjdXRpb24uXG4gKlxuICogTmV4dCwgaXQgYWRkcyB0aGUgRW50ZXIgb3Bjb2RlLCB3aGljaCBtYXJrcyB0aGUgY3VycmVudCBwb3NpdGlvblxuICogaW4gdGhlIERPTSwgYW5kIHJlbWVtYmVycyB0aGUgY3VycmVudCAkcGMgKHRoZSBuZXh0IGluc3RydWN0aW9uKVxuICogYXMgdGhlIGZpcnN0IGluc3RydWN0aW9uIHRvIGV4ZWN1dGUgZHVyaW5nIHVwZGF0aW5nIGV4ZWN1dGlvbi5cbiAqXG4gKiBOZXh0LCBpdCBydW5zIGBib2R5YCwgd2hpY2ggYWRkcyB0aGUgb3Bjb2RlcyB0aGF0IHNob3VsZFxuICogZXhlY3V0ZSBib3RoIGR1cmluZyBpbml0aWFsIGV4ZWN1dGlvbiBhbmQgZHVyaW5nIHVwZGF0aW5nIGV4ZWN1dGlvbi5cbiAqIElmIHRoZSBgYm9keWAgd2lzaGVzIHRvIGZpbmlzaCBlYXJseSwgaXQgc2hvdWxkIEp1bXAgdG8gdGhlXG4gKiBgRklOQUxMWWAgbGFiZWwuXG4gKlxuICogTmV4dCwgaXQgYWRkcyB0aGUgRklOQUxMWSBsYWJlbCwgZm9sbG93ZWQgYnk6XG4gKlxuICogLSB0aGUgRXhpdCBvcGNvZGUsIHdoaWNoIGZpbmFsaXplcyB0aGUgbWFya2VkIERPTSBzdGFydGVkIGJ5IHRoZVxuICogICBFbnRlciBvcGNvZGUuXG4gKiAtIHRoZSBSZXR1cm4gb3Bjb2RlLCB3aGljaCByZXR1cm5zIHRvIHRoZSBjdXJyZW50IHJldHVybiBwb2ludFxuICogICAoJHJhKS5cbiAqXG4gKiBGaW5hbGx5LCBpdCBhZGRzIHRoZSBFTkRJTklUSUFMIGxhYmVsIGZvbGxvd2VkIGJ5IHRoZSBQb3BGcmFtZVxuICogaW5zdHJ1Y3Rpb24sIHdoaWNoIHJlc3RvcmVzICRmcCwgJHNwIGFuZCAkcmEuXG4gKlxuICogIyBVcGRhdGluZyBFeGVjdXRpb25cbiAqXG4gKiBVcGRhdGluZyBleGVjdXRpb24gZm9yIHRoaXMgYHJlcGxheWFibGVgIG9jY3VycyBpZiB0aGUgYGJvZHlgIGFkZGVkIGFuXG4gKiBhc3NlcnRpb24sIHZpYSBvbmUgb2YgdGhlIGBKdW1wSWZgLCBgSnVtcFVubGVzc2Agb3IgYEFzc2VydFNhbWVgIG9wY29kZXMuXG4gKlxuICogSWYsIGR1cmluZyB1cGRhdGluZyBleGVjdXRvbiwgdGhlIGFzc2VydGlvbiBmYWlscywgdGhlIGluaXRpYWwgVk0gaXNcbiAqIHJlc3RvcmVkLCBhbmQgdGhlIHN0b3JlZCBhcmd1bWVudHMgYXJlIHB1c2hlZCBvbnRvIHRoZSBzdGFjay4gVGhlIERPTVxuICogYmV0d2VlbiB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyBtYXJrZXJzIGlzIGNsZWFyZWQsIGFuZCB0aGUgVk0ncyBjdXJzb3JcbiAqIGlzIHNldCB0byB0aGUgYXJlYSBqdXN0IGNsZWFyZWQuXG4gKlxuICogVGhlIHJldHVybiBwb2ludCAoJHJhKSBpcyBzZXQgdG8gLTEsIHRoZSBleGl0IGluc3RydWN0aW9uLlxuICpcbiAqIEZpbmFsbHksIHRoZSAkcGMgaXMgc2V0IHRvIHRvIHRoZSBpbnN0cnVjdGlvbiBzYXZlZCBvZmYgYnkgdGhlXG4gKiBFbnRlciBvcGNvZGUgZHVyaW5nIGluaXRpYWwgZXhlY3V0aW9uLCBhbmQgZXhlY3V0aW9uIHByb2NlZWRzIGFzXG4gKiB1c3VhbC5cbiAqXG4gKiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgd2hlbiBhIGBSZXR1cm5gIGluc3RydWN0aW9uIGlzXG4gKiBlbmNvdW50ZXJlZCwgdGhlIHByb2dyYW0ganVtcHMgdG8gLTEgcmF0aGVyIHRoYW4gdGhlIEVORCBsYWJlbCxcbiAqIGFuZCB0aGUgUG9wRnJhbWUgb3Bjb2RlIGlzIG5vdCBuZWVkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSZXBsYXlhYmxlKG9wOiBQdXNoU3RhdGVtZW50T3AsIGFyZ3M6ICgpID0+IG51bWJlciwgYm9keTogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAvLyBTdGFydCBhIG5ldyBsYWJlbCBmcmFtZSwgdG8gZ2l2ZSBFTkQgYW5kIFJFVFVSTlxuICAvLyBhIHVuaXF1ZSBtZWFuaW5nLlxuXG4gIG9wKEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUuU3RhcnRMYWJlbHMpO1xuICBvcChNYWNoaW5lT3AuUHVzaEZyYW1lKTtcblxuICAvLyBJZiB0aGUgYm9keSBpbnZva2VzIGEgYmxvY2ssIGl0cyByZXR1cm4gd2lsbCByZXR1cm4gdG9cbiAgLy8gRU5ELiBPdGhlcndpc2UsIHRoZSByZXR1cm4gaW4gUkVUVVJOIHdpbGwgcmV0dXJuIHRvIEVORC5cbiAgb3AoTWFjaGluZU9wLlJldHVyblRvLCBsYWJlbE9wZXJhbmQoJ0VORElOSVRJQUwnKSk7XG5cbiAgLy8gUHVzaCB0aGUgYXJndW1lbnRzIG9udG8gdGhlIHN0YWNrLiBUaGUgYXJncygpIGZ1bmN0aW9uXG4gIC8vIHRlbGxzIHVzIGhvdyBtYW55IHN0YWNrIGVsZW1lbnRzIHRvIHJldGFpbiBmb3IgcmUtZXhlY3V0aW9uXG4gIC8vIHdoZW4gdXBkYXRpbmcuXG4gIGxldCBjb3VudCA9IGFyZ3MoKTtcblxuICAvLyBTdGFydCBhIG5ldyB1cGRhdGluZyBjbG9zdXJlLCByZW1lbWJlcmluZyBgY291bnRgIGVsZW1lbnRzXG4gIC8vIGZyb20gdGhlIHN0YWNrLiBFdmVyeXRoaW5nIGFmdGVyIHRoaXMgcG9pbnQsIGFuZCBiZWZvcmUgRU5ELFxuICAvLyB3aWxsIGV4ZWN1dGUgYm90aCBpbml0aWFsbHkgYW5kIHRvIHVwZGF0ZSB0aGUgYmxvY2suXG4gIC8vXG4gIC8vIFRoZSBlbnRlciBhbmQgZXhpdCBvcGNvZGVzIGFsc28gdHJhY2sgdGhlIGFyZWEgb2YgdGhlIERPTVxuICAvLyBhc3NvY2lhdGVkIHdpdGggdGhpcyBibG9jay4gSWYgYW4gYXNzZXJ0aW9uIGluc2lkZSB0aGUgYmxvY2tcbiAgLy8gZmFpbHMgKGZvciBleGFtcGxlLCB0aGUgdGVzdCB2YWx1ZSBjaGFuZ2VzIGZyb20gdHJ1ZSB0byBmYWxzZVxuICAvLyBpbiBhbiAjaWYpLCB0aGUgRE9NIGlzIGNsZWFyZWQgYW5kIHRoZSBwcm9ncmFtIGlzIHJlLWV4ZWN1dGVkLFxuICAvLyByZXN0b3JpbmcgYGNvdW50YCBlbGVtZW50cyB0byB0aGUgc3RhY2sgYW5kIGV4ZWN1dGluZyB0aGVcbiAgLy8gaW5zdHJ1Y3Rpb25zIGJldHdlZW4gdGhlIGVudGVyIGFuZCBleGl0LlxuICBvcChPcC5FbnRlciwgY291bnQpO1xuXG4gIC8vIEV2YWx1YXRlIHRoZSBib2R5IG9mIHRoZSBibG9jay4gVGhlIGJvZHkgb2YgdGhlIGJsb2NrIG1heVxuICAvLyByZXR1cm4sIHdoaWNoIHdpbGwganVtcCBleGVjdXRpb24gdG8gRU5EIGR1cmluZyBpbml0aWFsXG4gIC8vIGV4ZWN1dGlvbiwgYW5kIGV4aXQgdGhlIHVwZGF0aW5nIHJvdXRpbmUuXG4gIGJvZHkoKTtcblxuICAvLyBBbGwgZXhlY3V0aW9uIHBhdGhzIGluIHRoZSBib2R5IHNob3VsZCBydW4gdGhlIEZJTkFMTFkgb25jZVxuICAvLyB0aGV5IGFyZSBkb25lLiBJdCBpcyBleGVjdXRlZCBib3RoIGR1cmluZyBpbml0aWFsIGV4ZWN1dGlvblxuICAvLyBhbmQgZHVyaW5nIHVwZGF0aW5nIGV4ZWN1dGlvbi5cbiAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5MYWJlbCwgJ0ZJTkFMTFknKTtcblxuICAvLyBGaW5hbGl6ZSB0aGUgRE9NLlxuICBvcChPcC5FeGl0KTtcblxuICAvLyBJbiBpbml0aWFsIGV4ZWN1dGlvbiwgdGhpcyBpcyBhIG5vb3A6IGl0IHJldHVybnMgdG8gdGhlXG4gIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2luZyBvcGNvZGUuIEluIHVwZGF0aW5nIGV4ZWN1dGlvbiwgdGhpc1xuICAvLyBleGl0cyB0aGUgdXBkYXRpbmcgcm91dGluZS5cbiAgb3AoTWFjaGluZU9wLlJldHVybik7XG5cbiAgLy8gQ2xlYW51cCBjb2RlIGZvciB0aGUgYmxvY2suIFJ1bnMgb24gaW5pdGlhbCBleGVjdXRpb25cbiAgLy8gYnV0IG5vdCBvbiB1cGRhdGluZy5cbiAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5MYWJlbCwgJ0VORElOSVRJQUwnKTtcbiAgb3AoTWFjaGluZU9wLlBvcEZyYW1lKTtcbiAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5TdG9wTGFiZWxzKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgdGhlIGByZXBsYXlhYmxlYCBjb252ZW5pZW5jZSB0aGF0IGFsbG93cyB0aGVcbiAqIGNhbGxlciB0byBwcm92aWRlIGRpZmZlcmVudCBjb2RlIGJhc2VkIHVwb24gd2hldGhlciB0aGUgaXRlbSBhdFxuICogdGhlIHRvcCBvZiB0aGUgc3RhY2sgaXMgdHJ1ZSBvciBmYWxzZS5cbiAqXG4gKiBBcyBpbiBgcmVwbGF5YWJsZWAsIHRoZSBgaWZUcnVlYCBhbmQgYGlmRmFsc2VgIGNvZGUgY2FuIGludm9rZSBgcmV0dXJuYC5cbiAqXG4gKiBEdXJpbmcgdGhlIGluaXRpYWwgZXhlY3V0aW9uLCBhIGByZXR1cm5gIHdpbGwgY29udGludWUgZXhlY3V0aW9uXG4gKiBpbiB0aGUgY2xlYW51cCBjb2RlLCB3aGljaCBmaW5hbGl6ZXMgdGhlIGN1cnJlbnQgRE9NIGJsb2NrIGFuZCBwb3BzXG4gKiB0aGUgY3VycmVudCBmcmFtZS5cbiAqXG4gKiBEdXJpbmcgdGhlIHVwZGF0aW5nIGV4ZWN1dGlvbiwgYSBgcmV0dXJuYCB3aWxsIGV4aXQgdGhlIHVwZGF0aW5nXG4gKiByb3V0aW5lLCBhcyBpdCBjYW4gcmV1c2UgdGhlIERPTSBibG9jayBhbmQgaXMgYWx3YXlzIG9ubHkgYSBzaW5nbGVcbiAqIGZyYW1lIGRlZXAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSZXBsYXlhYmxlSWYoXG4gIG9wOiBQdXNoU3RhdGVtZW50T3AsXG4gIGFyZ3M6ICgpID0+IG51bWJlcixcbiAgaWZUcnVlOiAoKSA9PiB2b2lkLFxuICBpZkZhbHNlPzogKCkgPT4gdm9pZFxuKTogdm9pZCB7XG4gIHJldHVybiBSZXBsYXlhYmxlKG9wLCBhcmdzLCAoKSA9PiB7XG4gICAgLy8gSWYgdGhlIGNvbmRpdGlvbmFsIGlzIGZhbHNlLCBqdW1wIHRvIHRoZSBFTFNFIGxhYmVsLlxuICAgIG9wKE9wLkp1bXBVbmxlc3MsIGxhYmVsT3BlcmFuZCgnRUxTRScpKTtcbiAgICAvLyBPdGhlcndpc2UsIGV4ZWN1dGUgdGhlIGNvZGUgYXNzb2NpYXRlZCB3aXRoIHRoZSB0cnVlIGJyYW5jaC5cbiAgICBpZlRydWUoKTtcbiAgICAvLyBXZSdyZSBkb25lLCBzbyByZXR1cm4uIEluIHRoZSBpbml0aWFsIGV4ZWN1dGlvbiwgdGhpcyBydW5zXG4gICAgLy8gdGhlIGNsZWFudXAgY29kZS4gSW4gdGhlIHVwZGF0aW5nIFZNLCBpdCBleGl0cyB0aGUgdXBkYXRpbmdcbiAgICAvLyByb3V0aW5lLlxuICAgIG9wKE1hY2hpbmVPcC5KdW1wLCBsYWJlbE9wZXJhbmQoJ0ZJTkFMTFknKSk7XG4gICAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5MYWJlbCwgJ0VMU0UnKTtcblxuICAgIC8vIElmIHRoZSBjb25kaXRpb25hbCBpcyBmYWxzZSwgYW5kIGNvZGUgYXNzb2NpYXRpZWQgaXRoIHRoZVxuICAgIC8vIGZhbHNlIGJyYW5jaCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQuIElmIHRoZXJlIHdhcyBubyBjb2RlXG4gICAgLy8gYXNzb2NpYXRlZCB3aXRoIHRoZSBmYWxzZSBicmFuY2gsIGp1bXBpbmcgdG8gdGhlIGVsc2Ugc3RhdGVtZW50XG4gICAgLy8gaGFzIG5vIG90aGVyIGJlaGF2aW9yLlxuICAgIGlmIChpZkZhbHNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmRmFsc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==