import { DEBUG } from '@glimmer/env';
import { assert, debugToString } from '@glimmer/util';

function isGetLikeTuple(opcode) {
  return Array.isArray(opcode) && opcode.length === 2;
}

function makeResolutionTypeVerifier(typeToVerify) {
  return opcode => {
    if (!isGetLikeTuple(opcode)) return false;
    let type = opcode[0];
    return type === 31
    /* GetStrictFree */
    || type === 32
    /* GetTemplateSymbol */
    || type === typeToVerify;
  };
}

export const isGetFreeComponent = makeResolutionTypeVerifier(39
/* GetFreeAsComponentHead */
);
export const isGetFreeModifier = makeResolutionTypeVerifier(38
/* GetFreeAsModifierHead */
);
export const isGetFreeHelper = makeResolutionTypeVerifier(37
/* GetFreeAsHelperHead */
);
export const isGetFreeComponentOrHelper = makeResolutionTypeVerifier(35
/* GetFreeAsComponentOrHelperHead */
);
export const isGetFreeOptionalHelper = makeResolutionTypeVerifier(36
/* GetFreeAsHelperHeadOrThisFallback */
);
export function isGetFreeDeprecatedHelper(opcode) {
  return Array.isArray(opcode) && opcode[0] === 99
  /* GetFreeAsDeprecatedHelperHeadOrThisFallback */
  ;
}
export const isGetFreeOptionalComponentOrHelper = makeResolutionTypeVerifier(34
/* GetFreeAsComponentOrHelperHeadOrThisFallback */
);

function assertResolverInvariants(meta) {
  if (DEBUG) {
    if (!meta.upvars) {
      throw new Error('Attempted to resolve a component, helper, or modifier, but no free vars were found');
    }

    if (!meta.owner) {
      throw new Error('Attempted to resolve a component, helper, or modifier, but no owner was associated with the template it was being resolved from');
    }
  }

  return meta;
}
/**
 * <Foo/>
 * <Foo></Foo>
 * <Foo @arg={{true}} />
 */


export function resolveComponent(resolver, constants, meta, [, expr, then]) {
  (false && assert(isGetFreeComponent(expr), 'Attempted to resolve a component with incorrect opcode'));
  let type = expr[0];

  if (DEBUG && expr[0] === 31
  /* GetStrictFree */
  ) {
      throw new Error(`Attempted to resolve a component in a strict mode template, but that value was not in scope: ${meta.upvars[expr[1]]}`);
    }

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      let {
        scopeValues,
        owner
      } = meta;
      let definition = scopeValues[expr[1]];
      then(constants.component(definition, owner));
    } else {
    let {
      upvars,
      owner
    } = assertResolverInvariants(meta);
    let name = upvars[expr[1]];
    let definition = resolver.lookupComponent(name, owner);

    if (DEBUG && (typeof definition !== 'object' || definition === null)) {
      throw new Error(`Attempted to resolve \`${name}\`, which was expected to be a component, but nothing was found.`);
    }

    then(constants.resolvedComponent(definition, name));
  }
}
/**
 * (helper)
 * (helper arg)
 */

export function resolveHelper(resolver, constants, meta, [, expr, then]) {
  (false && assert(isGetFreeHelper(expr), 'Attempted to resolve a helper with incorrect opcode'));
  let type = expr[0];

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      let {
        scopeValues
      } = meta;
      let definition = scopeValues[expr[1]];
      then(constants.helper(definition));
    } else if (type === 31
  /* GetStrictFree */
  ) {
      then(lookupBuiltInHelper(expr, resolver, meta, constants, 'helper'));
    } else {
    let {
      upvars,
      owner
    } = assertResolverInvariants(meta);
    let name = upvars[expr[1]];
    let helper = resolver.lookupHelper(name, owner);

    if (DEBUG && helper === null) {
      throw new Error(`Attempted to resolve \`${name}\`, which was expected to be a helper, but nothing was found.`);
    }

    then(constants.helper(helper, name));
  }
}
/**
 * <div {{modifier}}/>
 * <div {{modifier arg}}/>
 * <Foo {{modifier}}/>
 */

export function resolveModifier(resolver, constants, meta, [, expr, then]) {
  (false && assert(isGetFreeModifier(expr), 'Attempted to resolve a modifier with incorrect opcode'));
  let type = expr[0];

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      let {
        scopeValues
      } = meta;
      let definition = scopeValues[expr[1]];
      then(constants.modifier(definition));
    } else if (type === 31
  /* GetStrictFree */
  ) {
      let {
        upvars
      } = assertResolverInvariants(meta);
      let name = upvars[expr[1]];
      let modifier = resolver.lookupBuiltInModifier(name);

      if (DEBUG && modifier === null) {
        throw new Error(`Attempted to resolve a modifier in a strict mode template, but it was not in scope: ${name}`);
      }

      then(constants.modifier(modifier, name));
    } else {
    let {
      upvars,
      owner
    } = assertResolverInvariants(meta);
    let name = upvars[expr[1]];
    let modifier = resolver.lookupModifier(name, owner);

    if (DEBUG && modifier === null) {
      throw new Error(`Attempted to resolve \`${name}\`, which was expected to be a modifier, but nothing was found.`);
    }

    then(constants.modifier(modifier, name));
  }
}
/**
 * {{component-or-helper arg}}
 */

export function resolveComponentOrHelper(resolver, constants, meta, [, expr, {
  ifComponent,
  ifHelper
}]) {
  (false && assert(isGetFreeComponentOrHelper(expr), 'Attempted to resolve a component or helper with incorrect opcode'));
  let type = expr[0];

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      let {
        scopeValues,
        owner
      } = meta;
      let definition = scopeValues[expr[1]];
      let component = constants.component(definition, owner, true);

      if (component !== null) {
        ifComponent(component);
        return;
      }

      let helper = constants.helper(definition, null, true);

      if (DEBUG && helper === null) {
        throw new Error(`Attempted to use a value as either a component or helper, but it did not have a component manager or helper manager associated with it. The value was: ${debugToString(definition)}`);
      }

      ifHelper(helper);
    } else if (type === 31
  /* GetStrictFree */
  ) {
      ifHelper(lookupBuiltInHelper(expr, resolver, meta, constants, 'component or helper'));
    } else {
    let {
      upvars,
      owner
    } = assertResolverInvariants(meta);
    let name = upvars[expr[1]];
    let definition = resolver.lookupComponent(name, owner);

    if (definition !== null) {
      ifComponent(constants.resolvedComponent(definition, name));
    } else {
      let helper = resolver.lookupHelper(name, owner);

      if (DEBUG && helper === null) {
        throw new Error(`Attempted to resolve \`${name}\`, which was expected to be a component or helper, but nothing was found.`);
      }

      ifHelper(constants.helper(helper, name));
    }
  }
}
/**
 * <Foo @arg={{helper}}>
 */

export function resolveOptionalHelper(resolver, constants, meta, [, expr, {
  ifHelper
}]) {
  (false && assert(isGetFreeOptionalHelper(expr) || isGetFreeDeprecatedHelper(expr), 'Attempted to resolve a helper with incorrect opcode'));
  let {
    upvars,
    owner
  } = assertResolverInvariants(meta);
  let name = upvars[expr[1]];
  let helper = resolver.lookupHelper(name, owner);

  if (helper) {
    ifHelper(constants.helper(helper, name), name, meta.moduleName);
  }
}
/**
 * {{maybeHelperOrComponent}}
 */

export function resolveOptionalComponentOrHelper(resolver, constants, meta, [, expr, {
  ifComponent,
  ifHelper,
  ifValue
}]) {
  (false && assert(isGetFreeOptionalComponentOrHelper(expr), 'Attempted to resolve an optional component or helper with incorrect opcode'));
  let type = expr[0];

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      let {
        scopeValues,
        owner
      } = meta;
      let definition = scopeValues[expr[1]];

      if (typeof definition !== 'function' && (typeof definition !== 'object' || definition === null)) {
        // The value is not an object, so it can't be a component or helper.
        ifValue(constants.value(definition));
        return;
      }

      let component = constants.component(definition, owner, true);

      if (component !== null) {
        ifComponent(component);
        return;
      }

      let helper = constants.helper(definition, null, true);

      if (helper !== null) {
        ifHelper(helper);
        return;
      }

      ifValue(constants.value(definition));
    } else if (type === 31
  /* GetStrictFree */
  ) {
      ifHelper(lookupBuiltInHelper(expr, resolver, meta, constants, 'value'));
    } else {
    let {
      upvars,
      owner
    } = assertResolverInvariants(meta);
    let name = upvars[expr[1]];
    let definition = resolver.lookupComponent(name, owner);

    if (definition !== null) {
      ifComponent(constants.resolvedComponent(definition, name));
      return;
    }

    let helper = resolver.lookupHelper(name, owner);

    if (helper !== null) {
      ifHelper(constants.helper(helper, name));
    }
  }
}

function lookupBuiltInHelper(expr, resolver, meta, constants, type) {
  let {
    upvars
  } = assertResolverInvariants(meta);
  let name = upvars[expr[1]];
  let helper = resolver.lookupBuiltInHelper(name);

  if (DEBUG && helper === null) {
    // Keyword helper did not exist, which means that we're attempting to use a
    // value of some kind that is not in scope
    throw new Error(`Attempted to resolve a ${type} in a strict mode template, but that value was not in scope: ${meta.upvars[expr[1]]}`);
  }

  return constants.helper(helper, name);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9yZXNvbHV0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFNBQVMsS0FBVCxRQUFzQixjQUF0QjtBQWdCQSxTQUFTLE1BQVQsRUFBaUIsYUFBakIsUUFBOEMsZUFBOUM7O0FBRUEsU0FBUyxjQUFULENBQXdCLE1BQXhCLEVBQXNEO0FBQ3BELFNBQU8sS0FBSyxDQUFDLE9BQU4sQ0FBYyxNQUFkLEtBQXlCLE1BQU0sQ0FBQyxNQUFQLEtBQWtCLENBQWxEO0FBQ0Q7O0FBRUQsU0FBUywwQkFBVCxDQUFvQyxZQUFwQyxFQUE2RDtBQUMzRCxTQUNFLE1BREssSUFFNEQ7QUFDakUsUUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFELENBQW5CLEVBQTZCLE9BQU8sS0FBUDtBQUU3QixRQUFJLElBQUksR0FBRyxNQUFNLENBQUMsQ0FBRCxDQUFqQjtBQUVBLFdBQ0UsSUFBSSxLQUFBO0FBQUE7QUFBSixPQUNBLElBQUksS0FBQTtBQUFBO0FBREosT0FFQSxJQUFJLEtBQUssWUFIWDtBQUtELEdBWkQ7QUFhRDs7QUFFRCxPQUFPLE1BQU0sa0JBQWtCLEdBQUcsMEJBQTBCLENBQUE7QUFBQTtBQUFBLENBQXJEO0FBRVAsT0FBTyxNQUFNLGlCQUFpQixHQUFHLDBCQUEwQixDQUFBO0FBQUE7QUFBQSxDQUFwRDtBQUVQLE9BQU8sTUFBTSxlQUFlLEdBQUcsMEJBQTBCLENBQUE7QUFBQTtBQUFBLENBQWxEO0FBRVAsT0FBTyxNQUFNLDBCQUEwQixHQUFHLDBCQUEwQixDQUFBO0FBQUE7QUFBQSxDQUE3RDtBQUlQLE9BQU8sTUFBTSx1QkFBdUIsR0FBRywwQkFBMEIsQ0FBQTtBQUFBO0FBQUEsQ0FBMUQ7QUFJUCxPQUFNLFNBQVUseUJBQVYsQ0FDSixNQURJLEVBQzBCO0FBRTlCLFNBQ0UsS0FBSyxDQUFDLE9BQU4sQ0FB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O0FBQzVCO0FBQ0E7QUFDQSxVQUFNLElBQUksS0FBSixDQUNKLDBCQUEwQixJQUFJLGdFQUM1QixJQUFJLENBQUMsTUFBTCxDQUFhLElBQUksQ0FBQyxDQUFELENBQWpCLENBQ0YsRUFISSxDQUFOO0FBS0Q7O0FBRUQsU0FBTyxTQUFTLENBQUMsTUFBVixDQUFpQixNQUFqQixFQUEwQixJQUExQixDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQge1xuICBDb21waWxlVGltZUNvbnN0YW50cyxcbiAgQ29tcGlsZVRpbWVSZXNvbHZlcixcbiAgQ29udGFpbmluZ01ldGFkYXRhLFxuICBFeHByZXNzaW9ucyxcbiAgT3duZXIsXG4gIFJlc29sdmVDb21wb25lbnRPcCxcbiAgUmVzb2x2ZUNvbXBvbmVudE9ySGVscGVyT3AsXG4gIFJlc29sdmVIZWxwZXJPcCxcbiAgUmVzb2x2ZU1vZGlmaWVyT3AsXG4gIFJlc29sdmVPcHRpb25hbENvbXBvbmVudE9ySGVscGVyT3AsXG4gIFJlc29sdmVPcHRpb25hbEhlbHBlck9wLFxuICBTZXhwT3Bjb2RlcyxcbiAgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0LCBkZWJ1Z1RvU3RyaW5nLCBleHBlY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcblxuZnVuY3Rpb24gaXNHZXRMaWtlVHVwbGUob3Bjb2RlOiBFeHByZXNzaW9ucy5FeHByZXNzaW9uKTogb3Bjb2RlIGlzIEV4cHJlc3Npb25zLlR1cGxlRXhwcmVzc2lvbiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG9wY29kZSkgJiYgb3Bjb2RlLmxlbmd0aCA9PT0gMjtcbn1cblxuZnVuY3Rpb24gbWFrZVJlc29sdXRpb25UeXBlVmVyaWZpZXIodHlwZVRvVmVyaWZ5OiBTZXhwT3Bjb2Rlcykge1xuICByZXR1cm4gKFxuICAgIG9wY29kZTogRXhwcmVzc2lvbnMuRXhwcmVzc2lvblxuICApOiBvcGNvZGUgaXMgRXhwcmVzc2lvbnMuR2V0RnJlZSB8IEV4cHJlc3Npb25zLkdldFRlbXBsYXRlU3ltYm9sID0+IHtcbiAgICBpZiAoIWlzR2V0TGlrZVR1cGxlKG9wY29kZSkpIHJldHVybiBmYWxzZTtcblxuICAgIGxldCB0eXBlID0gb3Bjb2RlWzBdO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFN0cmljdEZyZWUgfHxcbiAgICAgIHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFRlbXBsYXRlU3ltYm9sIHx8XG4gICAgICB0eXBlID09PSB0eXBlVG9WZXJpZnlcbiAgICApO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgaXNHZXRGcmVlQ29tcG9uZW50ID0gbWFrZVJlc29sdXRpb25UeXBlVmVyaWZpZXIoU2V4cE9wY29kZXMuR2V0RnJlZUFzQ29tcG9uZW50SGVhZCk7XG5cbmV4cG9ydCBjb25zdCBpc0dldEZyZWVNb2RpZmllciA9IG1ha2VSZXNvbHV0aW9uVHlwZVZlcmlmaWVyKFNleHBPcGNvZGVzLkdldEZyZWVBc01vZGlmaWVySGVhZCk7XG5cbmV4cG9ydCBjb25zdCBpc0dldEZyZWVIZWxwZXIgPSBtYWtlUmVzb2x1dGlvblR5cGVWZXJpZmllcihTZXhwT3Bjb2Rlcy5HZXRGcmVlQXNIZWxwZXJIZWFkKTtcblxuZXhwb3J0IGNvbnN0IGlzR2V0RnJlZUNvbXBvbmVudE9ySGVscGVyID0gbWFrZVJlc29sdXRpb25UeXBlVmVyaWZpZXIoXG4gIFNleHBPcGNvZGVzLkdldEZyZWVBc0NvbXBvbmVudE9ySGVscGVySGVhZFxuKTtcblxuZXhwb3J0IGNvbnN0IGlzR2V0RnJlZU9wdGlvbmFsSGVscGVyID0gbWFrZVJlc29sdXRpb25UeXBlVmVyaWZpZXIoXG4gIFNleHBPcGNvZGVzLkdldEZyZWVBc0hlbHBlckhlYWRPclRoaXNGYWxsYmFja1xuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzR2V0RnJlZURlcHJlY2F0ZWRIZWxwZXIoXG4gIG9wY29kZTogRXhwcmVzc2lvbnMuRXhwcmVzc2lvblxuKTogb3Bjb2RlIGlzIEV4cHJlc3Npb25zLkdldFBhdGhGcmVlQXNEZXByZWNhdGVkSGVscGVySGVhZE9yVGhpc0ZhbGxiYWNrIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KG9wY29kZSkgJiYgb3Bjb2RlWzBdID09PSBTZXhwT3Bjb2Rlcy5HZXRGcmVlQXNEZXByZWNhdGVkSGVscGVySGVhZE9yVGhpc0ZhbGxiYWNrXG4gICk7XG59XG5cbmV4cG9ydCBjb25zdCBpc0dldEZyZWVPcHRpb25hbENvbXBvbmVudE9ySGVscGVyID0gbWFrZVJlc29sdXRpb25UeXBlVmVyaWZpZXIoXG4gIFNleHBPcGNvZGVzLkdldEZyZWVBc0NvbXBvbmVudE9ySGVscGVySGVhZE9yVGhpc0ZhbGxiYWNrXG4pO1xuXG5pbnRlcmZhY2UgUmVzb2x2ZWRDb250YWluaW5nTWV0YWRhdGEgZXh0ZW5kcyBDb250YWluaW5nTWV0YWRhdGEge1xuICBvd25lcjogT3duZXI7XG4gIHVwdmFyczogc3RyaW5nW107XG59XG5cbmZ1bmN0aW9uIGFzc2VydFJlc29sdmVySW52YXJpYW50cyhtZXRhOiBDb250YWluaW5nTWV0YWRhdGEpOiBSZXNvbHZlZENvbnRhaW5pbmdNZXRhZGF0YSB7XG4gIGlmIChERUJVRykge1xuICAgIGlmICghbWV0YS51cHZhcnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0F0dGVtcHRlZCB0byByZXNvbHZlIGEgY29tcG9uZW50LCBoZWxwZXIsIG9yIG1vZGlmaWVyLCBidXQgbm8gZnJlZSB2YXJzIHdlcmUgZm91bmQnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghbWV0YS5vd25lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBjb21wb25lbnQsIGhlbHBlciwgb3IgbW9kaWZpZXIsIGJ1dCBubyBvd25lciB3YXMgYXNzb2NpYXRlZCB3aXRoIHRoZSB0ZW1wbGF0ZSBpdCB3YXMgYmVpbmcgcmVzb2x2ZWQgZnJvbSdcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChtZXRhIGFzIHVua25vd24pIGFzIFJlc29sdmVkQ29udGFpbmluZ01ldGFkYXRhO1xufVxuXG4vKipcbiAqIDxGb28vPlxuICogPEZvbz48L0Zvbz5cbiAqIDxGb28gQGFyZz17e3RydWV9fSAvPlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudChcbiAgcmVzb2x2ZXI6IENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIGNvbnN0YW50czogQ29tcGlsZVRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICBbLCBleHByLCB0aGVuXTogUmVzb2x2ZUNvbXBvbmVudE9wXG4pOiB2b2lkIHtcbiAgYXNzZXJ0KGlzR2V0RnJlZUNvbXBvbmVudChleHByKSwgJ0F0dGVtcHRlZCB0byByZXNvbHZlIGEgY29tcG9uZW50IHdpdGggaW5jb3JyZWN0IG9wY29kZScpO1xuXG4gIGxldCB0eXBlID0gZXhwclswXTtcblxuICBpZiAoREVCVUcgJiYgZXhwclswXSA9PT0gU2V4cE9wY29kZXMuR2V0U3RyaWN0RnJlZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRlbXBsYXRlLCBidXQgdGhhdCB2YWx1ZSB3YXMgbm90IGluIHNjb3BlOiAke1xuICAgICAgICBtZXRhLnVwdmFycyFbZXhwclsxXV1cbiAgICAgIH1gXG4gICAgKTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRUZW1wbGF0ZVN5bWJvbCkge1xuICAgIGxldCB7IHNjb3BlVmFsdWVzLCBvd25lciB9ID0gbWV0YTtcbiAgICBsZXQgZGVmaW5pdGlvbiA9IGV4cGVjdChzY29wZVZhbHVlcywgJ0JVRzogc2NvcGVWYWx1ZXMgbXVzdCBleGlzdCBpZiB0ZW1wbGF0ZSBzeW1ib2wgaXMgdXNlZCcpW1xuICAgICAgZXhwclsxXVxuICAgIF07XG5cbiAgICB0aGVuKFxuICAgICAgY29uc3RhbnRzLmNvbXBvbmVudChcbiAgICAgICAgZGVmaW5pdGlvbiBhcyBvYmplY3QsXG4gICAgICAgIGV4cGVjdChvd25lciwgJ0JVRzogZXhwZWN0ZWQgb3duZXIgd2hlbiByZXNvbHZpbmcgY29tcG9uZW50IGRlZmluaXRpb24nKVxuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHsgdXB2YXJzLCBvd25lciB9ID0gYXNzZXJ0UmVzb2x2ZXJJbnZhcmlhbnRzKG1ldGEpO1xuXG4gICAgbGV0IG5hbWUgPSB1cHZhcnNbZXhwclsxXV07XG4gICAgbGV0IGRlZmluaXRpb24gPSByZXNvbHZlci5sb29rdXBDb21wb25lbnQobmFtZSwgb3duZXIpITtcblxuICAgIGlmIChERUJVRyAmJiAodHlwZW9mIGRlZmluaXRpb24gIT09ICdvYmplY3QnIHx8IGRlZmluaXRpb24gPT09IG51bGwpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBcXGAke25hbWV9XFxgLCB3aGljaCB3YXMgZXhwZWN0ZWQgdG8gYmUgYSBjb21wb25lbnQsIGJ1dCBub3RoaW5nIHdhcyBmb3VuZC5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoZW4oY29uc3RhbnRzLnJlc29sdmVkQ29tcG9uZW50KGRlZmluaXRpb24sIG5hbWUpKTtcbiAgfVxufVxuXG4vKipcbiAqIChoZWxwZXIpXG4gKiAoaGVscGVyIGFyZylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVIZWxwZXIoXG4gIHJlc29sdmVyOiBDb21waWxlVGltZVJlc29sdmVyLFxuICBjb25zdGFudHM6IENvbXBpbGVUaW1lQ29uc3RhbnRzICYgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG4gIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgWywgZXhwciwgdGhlbl06IFJlc29sdmVIZWxwZXJPcFxuKTogdm9pZCB7XG4gIGFzc2VydChpc0dldEZyZWVIZWxwZXIoZXhwciksICdBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhIGhlbHBlciB3aXRoIGluY29ycmVjdCBvcGNvZGUnKTtcblxuICBsZXQgdHlwZSA9IGV4cHJbMF07XG5cbiAgaWYgKHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFRlbXBsYXRlU3ltYm9sKSB7XG4gICAgbGV0IHsgc2NvcGVWYWx1ZXMgfSA9IG1ldGE7XG4gICAgbGV0IGRlZmluaXRpb24gPSBleHBlY3Qoc2NvcGVWYWx1ZXMsICdCVUc6IHNjb3BlVmFsdWVzIG11c3QgZXhpc3QgaWYgdGVtcGxhdGUgc3ltYm9sIGlzIHVzZWQnKVtcbiAgICAgIGV4cHJbMV1cbiAgICBdO1xuXG4gICAgdGhlbihjb25zdGFudHMuaGVscGVyKGRlZmluaXRpb24gYXMgb2JqZWN0KSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gU2V4cE9wY29kZXMuR2V0U3RyaWN0RnJlZSkge1xuICAgIHRoZW4oXG4gICAgICBsb29rdXBCdWlsdEluSGVscGVyKGV4cHIgYXMgRXhwcmVzc2lvbnMuR2V0U3RyaWN0RnJlZSwgcmVzb2x2ZXIsIG1ldGEsIGNvbnN0YW50cywgJ2hlbHBlcicpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgeyB1cHZhcnMsIG93bmVyIH0gPSBhc3NlcnRSZXNvbHZlckludmFyaWFudHMobWV0YSk7XG5cbiAgICBsZXQgbmFtZSA9IHVwdmFyc1tleHByWzFdXTtcbiAgICBsZXQgaGVscGVyID0gcmVzb2x2ZXIubG9va3VwSGVscGVyKG5hbWUsIG93bmVyISkhO1xuXG4gICAgaWYgKERFQlVHICYmIGhlbHBlciA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQXR0ZW1wdGVkIHRvIHJlc29sdmUgXFxgJHtuYW1lfVxcYCwgd2hpY2ggd2FzIGV4cGVjdGVkIHRvIGJlIGEgaGVscGVyLCBidXQgbm90aGluZyB3YXMgZm91bmQuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGVuKGNvbnN0YW50cy5oZWxwZXIoaGVscGVyLCBuYW1lKSk7XG4gIH1cbn1cblxuLyoqXG4gKiA8ZGl2IHt7bW9kaWZpZXJ9fS8+XG4gKiA8ZGl2IHt7bW9kaWZpZXIgYXJnfX0vPlxuICogPEZvbyB7e21vZGlmaWVyfX0vPlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVyKFxuICByZXNvbHZlcjogQ29tcGlsZVRpbWVSZXNvbHZlcixcbiAgY29uc3RhbnRzOiBDb21waWxlVGltZUNvbnN0YW50cyAmIFJlc29sdXRpb25UaW1lQ29uc3RhbnRzLFxuICBtZXRhOiBDb250YWluaW5nTWV0YWRhdGEsXG4gIFssIGV4cHIsIHRoZW5dOiBSZXNvbHZlTW9kaWZpZXJPcFxuKTogdm9pZCB7XG4gIGFzc2VydChpc0dldEZyZWVNb2RpZmllcihleHByKSwgJ0F0dGVtcHRlZCB0byByZXNvbHZlIGEgbW9kaWZpZXIgd2l0aCBpbmNvcnJlY3Qgb3Bjb2RlJyk7XG5cbiAgbGV0IHR5cGUgPSBleHByWzBdO1xuXG4gIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRUZW1wbGF0ZVN5bWJvbCkge1xuICAgIGxldCB7IHNjb3BlVmFsdWVzIH0gPSBtZXRhO1xuICAgIGxldCBkZWZpbml0aW9uID0gZXhwZWN0KHNjb3BlVmFsdWVzLCAnQlVHOiBzY29wZVZhbHVlcyBtdXN0IGV4aXN0IGlmIHRlbXBsYXRlIHN5bWJvbCBpcyB1c2VkJylbXG4gICAgICBleHByWzFdXG4gICAgXTtcblxuICAgIHRoZW4oY29uc3RhbnRzLm1vZGlmaWVyKGRlZmluaXRpb24gYXMgb2JqZWN0KSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gU2V4cE9wY29kZXMuR2V0U3RyaWN0RnJlZSkge1xuICAgIGxldCB7IHVwdmFycyB9ID0gYXNzZXJ0UmVzb2x2ZXJJbnZhcmlhbnRzKG1ldGEpO1xuICAgIGxldCBuYW1lID0gdXB2YXJzW2V4cHJbMV1dO1xuICAgIGxldCBtb2RpZmllciA9IHJlc29sdmVyLmxvb2t1cEJ1aWx0SW5Nb2RpZmllcihuYW1lKTtcblxuICAgIGlmIChERUJVRyAmJiBtb2RpZmllciA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBtb2RpZmllciBpbiBhIHN0cmljdCBtb2RlIHRlbXBsYXRlLCBidXQgaXQgd2FzIG5vdCBpbiBzY29wZTogJHtuYW1lfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhlbihjb25zdGFudHMubW9kaWZpZXIobW9kaWZpZXIhLCBuYW1lKSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHsgdXB2YXJzLCBvd25lciB9ID0gYXNzZXJ0UmVzb2x2ZXJJbnZhcmlhbnRzKG1ldGEpO1xuICAgIGxldCBuYW1lID0gdXB2YXJzW2V4cHJbMV1dO1xuICAgIGxldCBtb2RpZmllciA9IHJlc29sdmVyLmxvb2t1cE1vZGlmaWVyKG5hbWUsIG93bmVyKSE7XG5cbiAgICBpZiAoREVCVUcgJiYgbW9kaWZpZXIgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEF0dGVtcHRlZCB0byByZXNvbHZlIFxcYCR7bmFtZX1cXGAsIHdoaWNoIHdhcyBleHBlY3RlZCB0byBiZSBhIG1vZGlmaWVyLCBidXQgbm90aGluZyB3YXMgZm91bmQuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGVuKGNvbnN0YW50cy5tb2RpZmllcihtb2RpZmllciwgbmFtZSkpO1xuICB9XG59XG5cbi8qKlxuICoge3tjb21wb25lbnQtb3ItaGVscGVyIGFyZ319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50T3JIZWxwZXIoXG4gIHJlc29sdmVyOiBDb21waWxlVGltZVJlc29sdmVyLFxuICBjb25zdGFudHM6IENvbXBpbGVUaW1lQ29uc3RhbnRzICYgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG4gIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgWywgZXhwciwgeyBpZkNvbXBvbmVudCwgaWZIZWxwZXIgfV06IFJlc29sdmVDb21wb25lbnRPckhlbHBlck9wXG4pOiB2b2lkIHtcbiAgYXNzZXJ0KFxuICAgIGlzR2V0RnJlZUNvbXBvbmVudE9ySGVscGVyKGV4cHIpLFxuICAgICdBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhIGNvbXBvbmVudCBvciBoZWxwZXIgd2l0aCBpbmNvcnJlY3Qgb3Bjb2RlJ1xuICApO1xuXG4gIGxldCB0eXBlID0gZXhwclswXTtcblxuICBpZiAodHlwZSA9PT0gU2V4cE9wY29kZXMuR2V0VGVtcGxhdGVTeW1ib2wpIHtcbiAgICBsZXQgeyBzY29wZVZhbHVlcywgb3duZXIgfSA9IG1ldGE7XG4gICAgbGV0IGRlZmluaXRpb24gPSBleHBlY3Qoc2NvcGVWYWx1ZXMsICdCVUc6IHNjb3BlVmFsdWVzIG11c3QgZXhpc3QgaWYgdGVtcGxhdGUgc3ltYm9sIGlzIHVzZWQnKVtcbiAgICAgIGV4cHJbMV1cbiAgICBdO1xuXG4gICAgbGV0IGNvbXBvbmVudCA9IGNvbnN0YW50cy5jb21wb25lbnQoXG4gICAgICBkZWZpbml0aW9uIGFzIG9iamVjdCxcbiAgICAgIGV4cGVjdChvd25lciwgJ0JVRzogZXhwZWN0ZWQgb3duZXIgd2hlbiByZXNvbHZpbmcgY29tcG9uZW50IGRlZmluaXRpb24nKSxcbiAgICAgIHRydWVcbiAgICApO1xuXG4gICAgaWYgKGNvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWZDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgaGVscGVyID0gY29uc3RhbnRzLmhlbHBlcihkZWZpbml0aW9uIGFzIG9iamVjdCwgbnVsbCwgdHJ1ZSk7XG5cbiAgICBpZiAoREVCVUcgJiYgaGVscGVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBdHRlbXB0ZWQgdG8gdXNlIGEgdmFsdWUgYXMgZWl0aGVyIGEgY29tcG9uZW50IG9yIGhlbHBlciwgYnV0IGl0IGRpZCBub3QgaGF2ZSBhIGNvbXBvbmVudCBtYW5hZ2VyIG9yIGhlbHBlciBtYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCBpdC4gVGhlIHZhbHVlIHdhczogJHtkZWJ1Z1RvU3RyaW5nIShcbiAgICAgICAgICBkZWZpbml0aW9uXG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZkhlbHBlcihleHBlY3QoaGVscGVyLCAnQlVHOiBoZWxwZXIgbXVzdCBleGlzdCcpKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRTdHJpY3RGcmVlKSB7XG4gICAgaWZIZWxwZXIoXG4gICAgICBsb29rdXBCdWlsdEluSGVscGVyKFxuICAgICAgICBleHByIGFzIEV4cHJlc3Npb25zLkdldFN0cmljdEZyZWUsXG4gICAgICAgIHJlc29sdmVyLFxuICAgICAgICBtZXRhLFxuICAgICAgICBjb25zdGFudHMsXG4gICAgICAgICdjb21wb25lbnQgb3IgaGVscGVyJ1xuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHsgdXB2YXJzLCBvd25lciB9ID0gYXNzZXJ0UmVzb2x2ZXJJbnZhcmlhbnRzKG1ldGEpO1xuXG4gICAgbGV0IG5hbWUgPSB1cHZhcnNbZXhwclsxXV07XG4gICAgbGV0IGRlZmluaXRpb24gPSByZXNvbHZlci5sb29rdXBDb21wb25lbnQobmFtZSwgb3duZXIpO1xuXG4gICAgaWYgKGRlZmluaXRpb24gIT09IG51bGwpIHtcbiAgICAgIGlmQ29tcG9uZW50KGNvbnN0YW50cy5yZXNvbHZlZENvbXBvbmVudChkZWZpbml0aW9uLCBuYW1lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBoZWxwZXIgPSByZXNvbHZlci5sb29rdXBIZWxwZXIobmFtZSwgb3duZXIpO1xuXG4gICAgICBpZiAoREVCVUcgJiYgaGVscGVyID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHJlc29sdmUgXFxgJHtuYW1lfVxcYCwgd2hpY2ggd2FzIGV4cGVjdGVkIHRvIGJlIGEgY29tcG9uZW50IG9yIGhlbHBlciwgYnV0IG5vdGhpbmcgd2FzIGZvdW5kLmBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWZIZWxwZXIoY29uc3RhbnRzLmhlbHBlcihoZWxwZXIhLCBuYW1lKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogPEZvbyBAYXJnPXt7aGVscGVyfX0+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlT3B0aW9uYWxIZWxwZXIoXG4gIHJlc29sdmVyOiBDb21waWxlVGltZVJlc29sdmVyLFxuICBjb25zdGFudHM6IENvbXBpbGVUaW1lQ29uc3RhbnRzICYgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG4gIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgWywgZXhwciwgeyBpZkhlbHBlciB9XTogUmVzb2x2ZU9wdGlvbmFsSGVscGVyT3Bcbik6IHZvaWQge1xuICBhc3NlcnQoXG4gICAgaXNHZXRGcmVlT3B0aW9uYWxIZWxwZXIoZXhwcikgfHwgaXNHZXRGcmVlRGVwcmVjYXRlZEhlbHBlcihleHByKSxcbiAgICAnQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBoZWxwZXIgd2l0aCBpbmNvcnJlY3Qgb3Bjb2RlJ1xuICApO1xuICBsZXQgeyB1cHZhcnMsIG93bmVyIH0gPSBhc3NlcnRSZXNvbHZlckludmFyaWFudHMobWV0YSk7XG5cbiAgbGV0IG5hbWUgPSB1cHZhcnNbZXhwclsxXV07XG4gIGxldCBoZWxwZXIgPSByZXNvbHZlci5sb29rdXBIZWxwZXIobmFtZSwgb3duZXIpO1xuXG4gIGlmIChoZWxwZXIpIHtcbiAgICBpZkhlbHBlcihjb25zdGFudHMuaGVscGVyKGhlbHBlciwgbmFtZSksIG5hbWUsIG1ldGEubW9kdWxlTmFtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiB7e21heWJlSGVscGVyT3JDb21wb25lbnR9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU9wdGlvbmFsQ29tcG9uZW50T3JIZWxwZXIoXG4gIHJlc29sdmVyOiBDb21waWxlVGltZVJlc29sdmVyLFxuICBjb25zdGFudHM6IENvbXBpbGVUaW1lQ29uc3RhbnRzICYgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG4gIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgWywgZXhwciwgeyBpZkNvbXBvbmVudCwgaWZIZWxwZXIsIGlmVmFsdWUgfV06IFJlc29sdmVPcHRpb25hbENvbXBvbmVudE9ySGVscGVyT3Bcbik6IHZvaWQge1xuICBhc3NlcnQoXG4gICAgaXNHZXRGcmVlT3B0aW9uYWxDb21wb25lbnRPckhlbHBlcihleHByKSxcbiAgICAnQXR0ZW1wdGVkIHRvIHJlc29sdmUgYW4gb3B0aW9uYWwgY29tcG9uZW50IG9yIGhlbHBlciB3aXRoIGluY29ycmVjdCBvcGNvZGUnXG4gICk7XG5cbiAgbGV0IHR5cGUgPSBleHByWzBdO1xuXG4gIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRUZW1wbGF0ZVN5bWJvbCkge1xuICAgIGxldCB7IHNjb3BlVmFsdWVzLCBvd25lciB9ID0gbWV0YTtcbiAgICBsZXQgZGVmaW5pdGlvbiA9IGV4cGVjdChzY29wZVZhbHVlcywgJ0JVRzogc2NvcGVWYWx1ZXMgbXVzdCBleGlzdCBpZiB0ZW1wbGF0ZSBzeW1ib2wgaXMgdXNlZCcpW1xuICAgICAgZXhwclsxXVxuICAgIF07XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2YgZGVmaW5pdGlvbiAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKHR5cGVvZiBkZWZpbml0aW9uICE9PSAnb2JqZWN0JyB8fCBkZWZpbml0aW9uID09PSBudWxsKVxuICAgICkge1xuICAgICAgLy8gVGhlIHZhbHVlIGlzIG5vdCBhbiBvYmplY3QsIHNvIGl0IGNhbid0IGJlIGEgY29tcG9uZW50IG9yIGhlbHBlci5cbiAgICAgIGlmVmFsdWUoY29uc3RhbnRzLnZhbHVlKGRlZmluaXRpb24pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY29tcG9uZW50ID0gY29uc3RhbnRzLmNvbXBvbmVudChcbiAgICAgIGRlZmluaXRpb24sXG4gICAgICBleHBlY3Qob3duZXIsICdCVUc6IGV4cGVjdGVkIG93bmVyIHdoZW4gcmVzb2x2aW5nIGNvbXBvbmVudCBkZWZpbml0aW9uJyksXG4gICAgICB0cnVlXG4gICAgKTtcblxuICAgIGlmIChjb21wb25lbnQgIT09IG51bGwpIHtcbiAgICAgIGlmQ29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGhlbHBlciA9IGNvbnN0YW50cy5oZWxwZXIoZGVmaW5pdGlvbiwgbnVsbCwgdHJ1ZSk7XG5cbiAgICBpZiAoaGVscGVyICE9PSBudWxsKSB7XG4gICAgICBpZkhlbHBlcihoZWxwZXIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmVmFsdWUoY29uc3RhbnRzLnZhbHVlKGRlZmluaXRpb24pKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRTdHJpY3RGcmVlKSB7XG4gICAgaWZIZWxwZXIoXG4gICAgICBsb29rdXBCdWlsdEluSGVscGVyKGV4cHIgYXMgRXhwcmVzc2lvbnMuR2V0U3RyaWN0RnJlZSwgcmVzb2x2ZXIsIG1ldGEsIGNvbnN0YW50cywgJ3ZhbHVlJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxldCB7IHVwdmFycywgb3duZXIgfSA9IGFzc2VydFJlc29sdmVySW52YXJpYW50cyhtZXRhKTtcblxuICAgIGxldCBuYW1lID0gdXB2YXJzW2V4cHJbMV1dO1xuICAgIGxldCBkZWZpbml0aW9uID0gcmVzb2x2ZXIubG9va3VwQ29tcG9uZW50KG5hbWUsIG93bmVyKTtcblxuICAgIGlmIChkZWZpbml0aW9uICE9PSBudWxsKSB7XG4gICAgICBpZkNvbXBvbmVudChjb25zdGFudHMucmVzb2x2ZWRDb21wb25lbnQoZGVmaW5pdGlvbiwgbmFtZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBoZWxwZXIgPSByZXNvbHZlci5sb29rdXBIZWxwZXIobmFtZSwgb3duZXIpO1xuXG4gICAgaWYgKGhlbHBlciAhPT0gbnVsbCkge1xuICAgICAgaWZIZWxwZXIoY29uc3RhbnRzLmhlbHBlcihoZWxwZXIsIG5hbWUpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbG9va3VwQnVpbHRJbkhlbHBlcihcbiAgZXhwcjogRXhwcmVzc2lvbnMuR2V0U3RyaWN0RnJlZSxcbiAgcmVzb2x2ZXI6IENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgY29uc3RhbnRzOiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgdHlwZTogc3RyaW5nXG4pOiBudW1iZXIge1xuICBsZXQgeyB1cHZhcnMgfSA9IGFzc2VydFJlc29sdmVySW52YXJpYW50cyhtZXRhKTtcblxuICBsZXQgbmFtZSA9IHVwdmFyc1tleHByWzFdXTtcbiAgbGV0IGhlbHBlciA9IHJlc29sdmVyLmxvb2t1cEJ1aWx0SW5IZWxwZXIobmFtZSk7XG5cbiAgaWYgKERFQlVHICYmIGhlbHBlciA9PT0gbnVsbCkge1xuICAgIC8vIEtleXdvcmQgaGVscGVyIGRpZCBub3QgZXhpc3QsIHdoaWNoIG1lYW5zIHRoYXQgd2UncmUgYXR0ZW1wdGluZyB0byB1c2UgYVxuICAgIC8vIHZhbHVlIG9mIHNvbWUga2luZCB0aGF0IGlzIG5vdCBpbiBzY29wZVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhICR7dHlwZX0gaW4gYSBzdHJpY3QgbW9kZSB0ZW1wbGF0ZSwgYnV0IHRoYXQgdmFsdWUgd2FzIG5vdCBpbiBzY29wZTogJHtcbiAgICAgICAgbWV0YS51cHZhcnMhW2V4cHJbMV1dXG4gICAgICB9YFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gY29uc3RhbnRzLmhlbHBlcihoZWxwZXIhLCBuYW1lKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=