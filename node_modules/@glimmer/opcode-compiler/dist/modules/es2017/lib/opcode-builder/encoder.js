import { InstructionEncoderImpl } from '@glimmer/encoder';
import { isMachineOp } from '@glimmer/vm';
import { Stack, dict, EMPTY_STRING_ARRAY, encodeHandle, assert } from '@glimmer/util';
import { resolveComponent, resolveComponentOrHelper, resolveHelper, resolveModifier, resolveOptionalComponentOrHelper, resolveOptionalHelper } from './helpers/resolution';
import { compilableBlock } from '../compilable-template';
import { DEBUG } from '@glimmer/env';
export class Labels {
  constructor() {
    this.labels = dict();
    this.targets = [];
  }

  label(name, index) {
    this.labels[name] = index;
  }

  target(at, target) {
    this.targets.push({
      at,
      target
    });
  }

  patch(heap) {
    let {
      targets,
      labels
    } = this;

    for (let i = 0; i < targets.length; i++) {
      let {
        at,
        target
      } = targets[i];
      let address = labels[target] - at;
      (false && assert(heap.getbyaddr(at) === -1, 'Expected heap to contain a placeholder, but it did not'));
      heap.setbyaddr(at, address);
    }
  }

}
export function encodeOp(encoder, constants, resolver, meta, op) {
  if (isBuilderOpcode(op[0])) {
    let [type, ...operands] = op;
    encoder.push(constants, type, ...operands);
  } else {
    switch (op[0]) {
      case 1000
      /* Label */
      :
        return encoder.label(op[1]);

      case 1001
      /* StartLabels */
      :
        return encoder.startLabels();

      case 1002
      /* StopLabels */
      :
        return encoder.stopLabels();

      case 1004
      /* ResolveComponent */
      :
        return resolveComponent(resolver, constants, meta, op);

      case 1003
      /* ResolveModifier */
      :
        return resolveModifier(resolver, constants, meta, op);

      case 1005
      /* ResolveHelper */
      :
        return resolveHelper(resolver, constants, meta, op);

      case 1007
      /* ResolveComponentOrHelper */
      :
        return resolveComponentOrHelper(resolver, constants, meta, op);

      case 1006
      /* ResolveOptionalHelper */
      :
        return resolveOptionalHelper(resolver, constants, meta, op);

      case 1008
      /* ResolveOptionalComponentOrHelper */
      :
        return resolveOptionalComponentOrHelper(resolver, constants, meta, op);

      case 1010
      /* ResolveLocal */
      :
        let freeVar = op[1];
        let name = meta.upvars[freeVar];
        let andThen = op[2];
        andThen(name, meta.moduleName);
        break;

      case 1011
      /* ResolveTemplateLocal */
      :
        let [, valueIndex, then] = op;
        let value = meta.scopeValues[valueIndex];
        then(constants.value(value));
        break;

      case 1009
      /* ResolveFree */
      :
        if (DEBUG) {
          let [, upvarIndex] = op;
          let freeName = meta.upvars[upvarIndex];
          throw new Error(`Attempted to resolve a value in a strict mode template, but that value was not in scope: ${freeName}`);
        }

        break;

      default:
        throw new Error(`Unexpected high level opcode ${op[0]}`);
    }
  }
}
export class EncoderImpl {
  constructor(heap, meta, stdlib) {
    this.heap = heap;
    this.meta = meta;
    this.stdlib = stdlib;
    this.labelsStack = new Stack();
    this.encoder = new InstructionEncoderImpl([]);
    this.errors = [];
    this.handle = heap.malloc();
  }

  error(error) {
    this.encoder.encode(30
    /* Primitive */
    , 0);
    this.errors.push(error);
  }

  commit(size) {
    let handle = this.handle;
    this.heap.push(5
    /* Return */
    | 1024
    /* MACHINE_MASK */
    );
    this.heap.finishMalloc(handle, size);

    if (this.errors.length) {
      return {
        errors: this.errors,
        handle
      };
    } else {
      return handle;
    }
  }

  push(constants, type, ...args) {
    let {
      heap
    } = this;

    if (DEBUG && type > 255
    /* TYPE_SIZE */
    ) {
        throw new Error(`Opcode type over 8-bits. Got ${type}.`);
      }

    let machine = isMachineOp(type) ? 1024
    /* MACHINE_MASK */
    : 0;
    let first = type | machine | args.length << 8
    /* ARG_SHIFT */
    ;
    heap.push(first);

    for (let i = 0; i < args.length; i++) {
      let op = args[i];
      heap.push(this.operand(constants, op));
    }
  }

  operand(constants, operand) {
    if (typeof operand === 'number') {
      return operand;
    }

    if (typeof operand === 'object' && operand !== null) {
      if (Array.isArray(operand)) {
        return encodeHandle(constants.array(operand));
      } else {
        switch (operand.type) {
          case 1
          /* Label */
          :
            this.currentLabels.target(this.heap.offset, operand.value);
            return -1;

          case 2
          /* IsStrictMode */
          :
            return encodeHandle(constants.value(this.meta.isStrictMode));

          case 3
          /* EvalSymbols */
          :
            return encodeHandle(constants.array(this.meta.evalSymbols || EMPTY_STRING_ARRAY));

          case 4
          /* Block */
          :
            return encodeHandle(constants.value(compilableBlock(operand.value, this.meta)));

          case 5
          /* StdLib */
          :
            return this.stdlib[operand.value];

          case 6
          /* NonSmallInt */
          :
          case 7
          /* SymbolTable */
          :
          case 8
          /* Layout */
          :
            return constants.value(operand.value);
        }
      }
    }

    return encodeHandle(constants.value(operand));
  }

  get currentLabels() {
    return this.labelsStack.current;
  }

  label(name) {
    this.currentLabels.label(name, this.heap.offset + 1);
  }

  startLabels() {
    this.labelsStack.push(new Labels());
  }

  stopLabels() {
    let label = this.labelsStack.pop();
    label.patch(this.heap);
  }

}

function isBuilderOpcode(op) {
  return op < 1000
  /* Start */
  ;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvb3Bjb2RlLWJ1aWxkZXIvZW5jb2Rlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLHNCQUFULFFBQXVDLGtCQUF2QztBQXlCQSxTQUFTLFdBQVQsUUFBNEIsYUFBNUI7QUFDQSxTQUFTLEtBQVQsRUFBZ0IsSUFBaEIsRUFBOEIsa0JBQTlCLEVBQWtELFlBQWxELEVBQWdFLE1BQWhFLFFBQThFLGVBQTlFO0FBQ0EsU0FDRSxnQkFERixFQUVFLHdCQUZGLEVBR0UsYUFIRixFQUlFLGVBSkYsRUFLRSxnQ0FMRixFQU1FLHFCQU5GLFFBT08sc0JBUFA7QUFRQSxTQUFTLGVBQVQsUUFBZ0Msd0JBQWhDO0FBQ0EsU0FBUyxLQUFULFFBQXNCLGNBQXRCO0FBRUEsT0FBTSxNQUFPLE1BQVAsQ0FBYTtBQUFuQixFQUFBLFdBQUEsR0FBQTtBQUNFLFNBQUEsTUFBQSxHQUF1QixJQUFJLEVBQTNCO0FBQ0EsU0FBQSxPQUFBLEdBQWlELEVBQWpEO0FBcUJEOztBQW5CQyxFQUFBLEtBQUssQ0FBQyxJQUFELEVBQWUsS0FBZixFQUE0QjtBQUMvQixTQUFLLE1BQUwsQ0FBWSxJQUFaLElBQW9CLEtBQXBCO0FBQ0Q7O0FBRUQsRUFBQSxNQUFNLENBQUMsRUFBRCxFQUFhLE1BQWIsRUFBMkI7QUFDL0IsU0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQjtBQUFFLE1BQUEsRUFBRjtBQUFNLE1BQUE7QUFBTixLQUFsQjtBQUNEOztBQUVELEVBQUEsS0FBSyxDQUFDLElBQUQsRUFBc0I7QUFDekIsUUFBSTtBQUFFLE1BQUEsT0FBRjtBQUFXLE1BQUE7QUFBWCxRQUFzQixJQUExQjs7QUFDQSxTQUFLLElBQUksQ0FBQyxHQUFHLENBQWIsRUFBZ0IsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUE1QixFQUFvQyxDQUFDLEVBQXJDLEVBQXlDO0FBQ3ZDLFVBQUk7QUFBRSxRQUFB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QTtBQUNSLFFBQUksS0FBSyxHQUFVLEtBQUssV0FBTCxDQUFpQixHQUFqQixFQUFuQjtBQUNBLElBQUEsS0FBSyxDQUFDLEtBQU4sQ0FBWSxLQUFLLElBQWpCO0FBQ0Q7O0FBN0dxQjs7QUFnSHhCLFNBQVMsZUFBVCxDQUF5QixFQUF6QixFQUFtQztBQUNqQyxTQUFPLEVBQUUsR0FBQTtBQUFBO0FBQVQ7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluc3RydWN0aW9uRW5jb2RlckltcGwgfSBmcm9tICdAZ2xpbW1lci9lbmNvZGVyJztcbmltcG9ydCB7XG4gIENvbXBpbGVUaW1lQ29uc3RhbnRzLFxuICBPcGVyYW5kLFxuICBDb21waWxlVGltZUhlYXAsXG4gIE9wLFxuICBCdWlsZGVyT3Bjb2RlLFxuICBIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLFxuICBNYWNoaW5lT3AsXG4gIFNpbmdsZUJ1aWxkZXJPcGVyYW5kLFxuICBFbmNvZGVyLFxuICBIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLFxuICBIaWdoTGV2ZWxPcCxcbiAgT3Bjb2RlU2l6ZSxcbiAgSW5zdHJ1Y3Rpb25FbmNvZGVyLFxuICBEaWN0LFxuICBFbmNvZGVyRXJyb3IsXG4gIEhhbmRsZVJlc3VsdCxcbiAgQnVpbGRlck9wLFxuICBDb21waWxlVGltZVJlc29sdmVyLFxuICBDb250YWluaW5nTWV0YWRhdGEsXG4gIEhpZ2hMZXZlbE9wZXJhbmQsXG4gIFNURExpYixcbiAgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgaXNNYWNoaW5lT3AgfSBmcm9tICdAZ2xpbW1lci92bSc7XG5pbXBvcnQgeyBTdGFjaywgZGljdCwgZXhwZWN0LCBFTVBUWV9TVFJJTkdfQVJSQVksIGVuY29kZUhhbmRsZSwgYXNzZXJ0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQge1xuICByZXNvbHZlQ29tcG9uZW50LFxuICByZXNvbHZlQ29tcG9uZW50T3JIZWxwZXIsXG4gIHJlc29sdmVIZWxwZXIsXG4gIHJlc29sdmVNb2RpZmllcixcbiAgcmVzb2x2ZU9wdGlvbmFsQ29tcG9uZW50T3JIZWxwZXIsXG4gIHJlc29sdmVPcHRpb25hbEhlbHBlcixcbn0gZnJvbSAnLi9oZWxwZXJzL3Jlc29sdXRpb24nO1xuaW1wb3J0IHsgY29tcGlsYWJsZUJsb2NrIH0gZnJvbSAnLi4vY29tcGlsYWJsZS10ZW1wbGF0ZSc7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5cbmV4cG9ydCBjbGFzcyBMYWJlbHMge1xuICBsYWJlbHM6IERpY3Q8bnVtYmVyPiA9IGRpY3QoKTtcbiAgdGFyZ2V0czogQXJyYXk8eyBhdDogbnVtYmVyOyB0YXJnZXQ6IHN0cmluZyB9PiA9IFtdO1xuXG4gIGxhYmVsKG5hbWU6IHN0cmluZywgaW5kZXg6IG51bWJlcikge1xuICAgIHRoaXMubGFiZWxzW25hbWVdID0gaW5kZXg7XG4gIH1cblxuICB0YXJnZXQoYXQ6IG51bWJlciwgdGFyZ2V0OiBzdHJpbmcpIHtcbiAgICB0aGlzLnRhcmdldHMucHVzaCh7IGF0LCB0YXJnZXQgfSk7XG4gIH1cblxuICBwYXRjaChoZWFwOiBDb21waWxlVGltZUhlYXApOiB2b2lkIHtcbiAgICBsZXQgeyB0YXJnZXRzLCBsYWJlbHMgfSA9IHRoaXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgeyBhdCwgdGFyZ2V0IH0gPSB0YXJnZXRzW2ldO1xuICAgICAgbGV0IGFkZHJlc3MgPSBsYWJlbHNbdGFyZ2V0XSAtIGF0O1xuXG4gICAgICBhc3NlcnQoaGVhcC5nZXRieWFkZHIoYXQpID09PSAtMSwgJ0V4cGVjdGVkIGhlYXAgdG8gY29udGFpbiBhIHBsYWNlaG9sZGVyLCBidXQgaXQgZGlkIG5vdCcpO1xuXG4gICAgICBoZWFwLnNldGJ5YWRkcihhdCwgYWRkcmVzcyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVPcChcbiAgZW5jb2RlcjogRW5jb2RlcixcbiAgY29uc3RhbnRzOiBDb21waWxlVGltZUNvbnN0YW50cyAmIFJlc29sdXRpb25UaW1lQ29uc3RhbnRzLFxuICByZXNvbHZlcjogQ29tcGlsZVRpbWVSZXNvbHZlcixcbiAgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICBvcDogQnVpbGRlck9wIHwgSGlnaExldmVsT3Bcbik6IHZvaWQge1xuICBpZiAoaXNCdWlsZGVyT3Bjb2RlKG9wWzBdKSkge1xuICAgIGxldCBbdHlwZSwgLi4ub3BlcmFuZHNdID0gb3A7XG4gICAgZW5jb2Rlci5wdXNoKGNvbnN0YW50cywgdHlwZSwgLi4uKG9wZXJhbmRzIGFzIFNpbmdsZUJ1aWxkZXJPcGVyYW5kW10pKTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICBjYXNlIEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUuTGFiZWw6XG4gICAgICAgIHJldHVybiBlbmNvZGVyLmxhYmVsKG9wWzFdKTtcbiAgICAgIGNhc2UgSGlnaExldmVsQnVpbGRlck9wY29kZS5TdGFydExhYmVsczpcbiAgICAgICAgcmV0dXJuIGVuY29kZXIuc3RhcnRMYWJlbHMoKTtcbiAgICAgIGNhc2UgSGlnaExldmVsQnVpbGRlck9wY29kZS5TdG9wTGFiZWxzOlxuICAgICAgICByZXR1cm4gZW5jb2Rlci5zdG9wTGFiZWxzKCk7XG5cbiAgICAgIGNhc2UgSGlnaExldmVsUmVzb2x1dGlvbk9wY29kZS5SZXNvbHZlQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gcmVzb2x2ZUNvbXBvbmVudChyZXNvbHZlciwgY29uc3RhbnRzLCBtZXRhLCBvcCk7XG4gICAgICBjYXNlIEhpZ2hMZXZlbFJlc29sdXRpb25PcGNvZGUuUmVzb2x2ZU1vZGlmaWVyOlxuICAgICAgICByZXR1cm4gcmVzb2x2ZU1vZGlmaWVyKHJlc29sdmVyLCBjb25zdGFudHMsIG1ldGEsIG9wKTtcbiAgICAgIGNhc2UgSGlnaExldmVsUmVzb2x1dGlvbk9wY29kZS5SZXNvbHZlSGVscGVyOlxuICAgICAgICByZXR1cm4gcmVzb2x2ZUhlbHBlcihyZXNvbHZlciwgY29uc3RhbnRzLCBtZXRhLCBvcCk7XG4gICAgICBjYXNlIEhpZ2hMZXZlbFJlc29sdXRpb25PcGNvZGUuUmVzb2x2ZUNvbXBvbmVudE9ySGVscGVyOlxuICAgICAgICByZXR1cm4gcmVzb2x2ZUNvbXBvbmVudE9ySGVscGVyKHJlc29sdmVyLCBjb25zdGFudHMsIG1ldGEsIG9wKTtcbiAgICAgIGNhc2UgSGlnaExldmVsUmVzb2x1dGlvbk9wY29kZS5SZXNvbHZlT3B0aW9uYWxIZWxwZXI6XG4gICAgICAgIHJldHVybiByZXNvbHZlT3B0aW9uYWxIZWxwZXIocmVzb2x2ZXIsIGNvbnN0YW50cywgbWV0YSwgb3ApO1xuICAgICAgY2FzZSBIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVPcHRpb25hbENvbXBvbmVudE9ySGVscGVyOlxuICAgICAgICByZXR1cm4gcmVzb2x2ZU9wdGlvbmFsQ29tcG9uZW50T3JIZWxwZXIocmVzb2x2ZXIsIGNvbnN0YW50cywgbWV0YSwgb3ApO1xuXG4gICAgICBjYXNlIEhpZ2hMZXZlbFJlc29sdXRpb25PcGNvZGUuUmVzb2x2ZUxvY2FsOlxuICAgICAgICBsZXQgZnJlZVZhciA9IG9wWzFdO1xuICAgICAgICBsZXQgbmFtZSA9IGV4cGVjdChtZXRhLnVwdmFycywgJ0JVRzogYXR0ZW1wdGVkIHRvIHJlc29sdmUgdmFsdWUgYnV0IG5vIHVwdmFycyBmb3VuZCcpW1xuICAgICAgICAgIGZyZWVWYXJcbiAgICAgICAgXTtcblxuICAgICAgICBsZXQgYW5kVGhlbiA9IG9wWzJdO1xuXG4gICAgICAgIGFuZFRoZW4obmFtZSwgbWV0YS5tb2R1bGVOYW1lKTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVUZW1wbGF0ZUxvY2FsOlxuICAgICAgICBsZXQgWywgdmFsdWVJbmRleCwgdGhlbl0gPSBvcDtcbiAgICAgICAgbGV0IHZhbHVlID0gZXhwZWN0KFxuICAgICAgICAgIG1ldGEuc2NvcGVWYWx1ZXMsXG4gICAgICAgICAgJ0JVRzogQXR0ZW1wdGVkIHRvIGdlY3QgYSB0ZW1wbGF0ZSBsb2NhbCwgYnV0IHRlbXBsYXRlIGRvZXMgbm90IGhhdmUgYW55J1xuICAgICAgICApW3ZhbHVlSW5kZXhdO1xuXG4gICAgICAgIHRoZW4oY29uc3RhbnRzLnZhbHVlKHZhbHVlKSk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgSGlnaExldmVsUmVzb2x1dGlvbk9wY29kZS5SZXNvbHZlRnJlZTpcbiAgICAgICAgaWYgKERFQlVHKSB7XG4gICAgICAgICAgbGV0IFssIHVwdmFySW5kZXhdID0gb3A7XG4gICAgICAgICAgbGV0IGZyZWVOYW1lID0gZXhwZWN0KG1ldGEudXB2YXJzLCAnQlVHOiBhdHRlbXB0ZWQgdG8gcmVzb2x2ZSB2YWx1ZSBidXQgbm8gdXB2YXJzIGZvdW5kJylbXG4gICAgICAgICAgICB1cHZhckluZGV4XG4gICAgICAgICAgXTtcblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhIHZhbHVlIGluIGEgc3RyaWN0IG1vZGUgdGVtcGxhdGUsIGJ1dCB0aGF0IHZhbHVlIHdhcyBub3QgaW4gc2NvcGU6ICR7ZnJlZU5hbWV9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBoaWdoIGxldmVsIG9wY29kZSAke29wWzBdfWApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRW5jb2RlckltcGwgaW1wbGVtZW50cyBFbmNvZGVyIHtcbiAgcHJpdmF0ZSBsYWJlbHNTdGFjayA9IG5ldyBTdGFjazxMYWJlbHM+KCk7XG4gIHByaXZhdGUgZW5jb2RlcjogSW5zdHJ1Y3Rpb25FbmNvZGVyID0gbmV3IEluc3RydWN0aW9uRW5jb2RlckltcGwoW10pO1xuICBwcml2YXRlIGVycm9yczogRW5jb2RlckVycm9yW10gPSBbXTtcbiAgcHJpdmF0ZSBoYW5kbGU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGhlYXA6IENvbXBpbGVUaW1lSGVhcCxcbiAgICBwcml2YXRlIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgICBwcml2YXRlIHN0ZGxpYj86IFNURExpYlxuICApIHtcbiAgICB0aGlzLmhhbmRsZSA9IGhlYXAubWFsbG9jKCk7XG4gIH1cblxuICBlcnJvcihlcnJvcjogRW5jb2RlckVycm9yKTogdm9pZCB7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShPcC5QcmltaXRpdmUsIDApO1xuICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyb3IpO1xuICB9XG5cbiAgY29tbWl0KHNpemU6IG51bWJlcik6IEhhbmRsZVJlc3VsdCB7XG4gICAgbGV0IGhhbmRsZSA9IHRoaXMuaGFuZGxlO1xuXG4gICAgdGhpcy5oZWFwLnB1c2goTWFjaGluZU9wLlJldHVybiB8IE9wY29kZVNpemUuTUFDSElORV9NQVNLKTtcbiAgICB0aGlzLmhlYXAuZmluaXNoTWFsbG9jKGhhbmRsZSwgc2l6ZSk7XG5cbiAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4geyBlcnJvcnM6IHRoaXMuZXJyb3JzLCBoYW5kbGUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICB9XG4gIH1cblxuICBwdXNoKFxuICAgIGNvbnN0YW50czogQ29tcGlsZVRpbWVDb25zdGFudHMsXG4gICAgdHlwZTogQnVpbGRlck9wY29kZSxcbiAgICAuLi5hcmdzOiBTaW5nbGVCdWlsZGVyT3BlcmFuZFtdXG4gICk6IHZvaWQge1xuICAgIGxldCB7IGhlYXAgfSA9IHRoaXM7XG5cbiAgICBpZiAoREVCVUcgJiYgKHR5cGUgYXMgbnVtYmVyKSA+IE9wY29kZVNpemUuVFlQRV9TSVpFKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9wY29kZSB0eXBlIG92ZXIgOC1iaXRzLiBHb3QgJHt0eXBlfS5gKTtcbiAgICB9XG5cbiAgICBsZXQgbWFjaGluZSA9IGlzTWFjaGluZU9wKHR5cGUpID8gT3Bjb2RlU2l6ZS5NQUNISU5FX01BU0sgOiAwO1xuICAgIGxldCBmaXJzdCA9IHR5cGUgfCBtYWNoaW5lIHwgKGFyZ3MubGVuZ3RoIDw8IE9wY29kZVNpemUuQVJHX1NISUZUKTtcblxuICAgIGhlYXAucHVzaChmaXJzdCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBvcCA9IGFyZ3NbaV07XG4gICAgICBoZWFwLnB1c2godGhpcy5vcGVyYW5kKGNvbnN0YW50cywgb3ApKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9wZXJhbmQoY29uc3RhbnRzOiBDb21waWxlVGltZUNvbnN0YW50cywgb3BlcmFuZDogU2luZ2xlQnVpbGRlck9wZXJhbmQpOiBPcGVyYW5kIHtcbiAgICBpZiAodHlwZW9mIG9wZXJhbmQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gb3BlcmFuZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wZXJhbmQgPT09ICdvYmplY3QnICYmIG9wZXJhbmQgIT09IG51bGwpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wZXJhbmQpKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVIYW5kbGUoY29uc3RhbnRzLmFycmF5KG9wZXJhbmQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAob3BlcmFuZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBIaWdoTGV2ZWxPcGVyYW5kLkxhYmVsOlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50TGFiZWxzLnRhcmdldCh0aGlzLmhlYXAub2Zmc2V0LCBvcGVyYW5kLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAtMTtcblxuICAgICAgICAgIGNhc2UgSGlnaExldmVsT3BlcmFuZC5Jc1N0cmljdE1vZGU6XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlSGFuZGxlKGNvbnN0YW50cy52YWx1ZSh0aGlzLm1ldGEuaXNTdHJpY3RNb2RlKSk7XG5cbiAgICAgICAgICBjYXNlIEhpZ2hMZXZlbE9wZXJhbmQuRXZhbFN5bWJvbHM6XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlSGFuZGxlKGNvbnN0YW50cy5hcnJheSh0aGlzLm1ldGEuZXZhbFN5bWJvbHMgfHwgRU1QVFlfU1RSSU5HX0FSUkFZKSk7XG5cbiAgICAgICAgICBjYXNlIEhpZ2hMZXZlbE9wZXJhbmQuQmxvY2s6XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlSGFuZGxlKGNvbnN0YW50cy52YWx1ZShjb21waWxhYmxlQmxvY2sob3BlcmFuZC52YWx1ZSwgdGhpcy5tZXRhKSkpO1xuXG4gICAgICAgICAgY2FzZSBIaWdoTGV2ZWxPcGVyYW5kLlN0ZExpYjpcbiAgICAgICAgICAgIHJldHVybiBleHBlY3QoXG4gICAgICAgICAgICAgIHRoaXMuc3RkbGliLFxuICAgICAgICAgICAgICAnYXR0ZW1wdGVkIHRvIGVuY29kZSBhIHN0ZGxpYiBvcGVyYW5kLCBidXQgdGhlIGVuY29kZXIgZGlkIG5vdCBoYXZlIGEgc3RkbGliLiBBcmUgeW91IGN1cnJlbnRseSBidWlsZGluZyB0aGUgc3RkbGliPydcbiAgICAgICAgICAgIClbb3BlcmFuZC52YWx1ZV07XG5cbiAgICAgICAgICBjYXNlIEhpZ2hMZXZlbE9wZXJhbmQuTm9uU21hbGxJbnQ6XG4gICAgICAgICAgY2FzZSBIaWdoTGV2ZWxPcGVyYW5kLlN5bWJvbFRhYmxlOlxuICAgICAgICAgIGNhc2UgSGlnaExldmVsT3BlcmFuZC5MYXlvdXQ6XG4gICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzLnZhbHVlKG9wZXJhbmQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kZUhhbmRsZShjb25zdGFudHMudmFsdWUob3BlcmFuZCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgY3VycmVudExhYmVscygpOiBMYWJlbHMge1xuICAgIHJldHVybiBleHBlY3QodGhpcy5sYWJlbHNTdGFjay5jdXJyZW50LCAnYnVnOiBub3QgaW4gYSBsYWJlbCBzdGFjaycpO1xuICB9XG5cbiAgbGFiZWwobmFtZTogc3RyaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50TGFiZWxzLmxhYmVsKG5hbWUsIHRoaXMuaGVhcC5vZmZzZXQgKyAxKTtcbiAgfVxuXG4gIHN0YXJ0TGFiZWxzKCkge1xuICAgIHRoaXMubGFiZWxzU3RhY2sucHVzaChuZXcgTGFiZWxzKCkpO1xuICB9XG5cbiAgc3RvcExhYmVscygpIHtcbiAgICBsZXQgbGFiZWwgPSBleHBlY3QodGhpcy5sYWJlbHNTdGFjay5wb3AoKSwgJ3VuYmFsYW5jZWQgcHVzaCBhbmQgcG9wIGxhYmVscycpO1xuICAgIGxhYmVsLnBhdGNoKHRoaXMuaGVhcCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNCdWlsZGVyT3Bjb2RlKG9wOiBudW1iZXIpOiBvcCBpcyBCdWlsZGVyT3Bjb2RlIHtcbiAgcmV0dXJuIG9wIDwgSGlnaExldmVsQnVpbGRlck9wY29kZS5TdGFydDtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=