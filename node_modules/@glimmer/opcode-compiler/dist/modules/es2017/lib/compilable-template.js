import { meta } from './opcode-builder/helpers/shared';
import { EMPTY_ARRAY } from '@glimmer/util';
import { templateCompilationContext } from './opcode-builder/context';
import { debugCompiler } from './compiler';
import { STATEMENTS } from './syntax/statements';
import { encodeOp } from './opcode-builder/encoder';
export const PLACEHOLDER_HANDLE = -1;

class CompilableTemplateImpl {
  constructor(statements, meta, // Part of CompilableTemplate
  symbolTable, // Used for debugging
  moduleName = 'plain block') {
    this.statements = statements;
    this.meta = meta;
    this.symbolTable = symbolTable;
    this.moduleName = moduleName;
    this.compiled = null;
  } // Part of CompilableTemplate


  compile(context) {
    return maybeCompile(this, context);
  }

}

export function compilable(layout, moduleName) {
  let [statements, symbols, hasEval] = layout.block;
  return new CompilableTemplateImpl(statements, meta(layout), {
    symbols,
    hasEval
  }, moduleName);
}

function maybeCompile(compilable, context) {
  if (compilable.compiled !== null) return compilable.compiled;
  compilable.compiled = PLACEHOLDER_HANDLE;
  let {
    statements,
    meta
  } = compilable;
  let result = compileStatements(statements, meta, context);
  compilable.compiled = result;
  return result;
}

export function compileStatements(statements, meta, syntaxContext) {
  let sCompiler = STATEMENTS;
  let context = templateCompilationContext(syntaxContext, meta);
  let {
    encoder,
    program: {
      constants,
      resolver
    }
  } = context;

  function pushOp(...op) {
    encodeOp(encoder, constants, resolver, meta, op);
  }

  for (let i = 0; i < statements.length; i++) {
    sCompiler.compile(pushOp, statements[i]);
  }

  let handle = context.encoder.commit(meta.size);

  if (false
  /* LOCAL_SHOULD_LOG */
  ) {
    debugCompiler(context, handle);
  }

  return handle;
}
export function compilableBlock(block, containing) {
  return new CompilableTemplateImpl(block[0], containing, {
    parameters: block[1] || EMPTY_ARRAY
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvY29tcGlsYWJsZS10ZW1wbGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFrQkEsU0FBUyxJQUFULFFBQXFCLGlDQUFyQjtBQUNBLFNBQVMsV0FBVCxRQUE0QixlQUE1QjtBQUNBLFNBQVMsMEJBQVQsUUFBMkMsMEJBQTNDO0FBRUEsU0FBUyxhQUFULFFBQThCLFlBQTlCO0FBQ0EsU0FBUyxVQUFULFFBQTJCLHFCQUEzQjtBQUVBLFNBQVMsUUFBVCxRQUF5QiwwQkFBekI7QUFFQSxPQUFPLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxDQUE1Qjs7QUFFUCxNQUFNLHNCQUFOLENBQTRCO0FBRzFCLEVBQUEsV0FBQSxDQUNXLFVBRFgsRUFFVyxJQUZYLEVBR0U7QUFDUyxFQUFBLFdBSlgsRUFLRTtBQUNTLEVBQUEsVUFBQSxHQUFhLGFBTnhCLEVBTXFDO0FBTDFCLFNBQUEsVUFBQSxHQUFBLFVBQUE7QUFDQSxTQUFBLElBQUEsR0FBQSxJQUFBO0FBRUEsU0FBQSxXQUFBLEdBQUEsV0FBQTtBQUVBLFNBQUEsVUFBQSxHQUFBLFVBQUE7QUFSWCxTQUFBLFFBQUEsR0FBaUMsSUFBakM7QUFTSSxHQVZzQixDQVkxQjs7O0FBQ0EsRUFBQSxPQUFPLENBQUMsT0FBRCxFQUF1QztBQUM1QyxXQUFPLFlBQVksQ0FBQyxJQUFELEVBQU8sT0FBUCxDQUFuQjtBQUNEOztBQWZ5Qjs7QUFrQjVCLE9BQU0sU0FBVSxVQUFWLENBQXFCLE1BQXJCLEVBQWdELFVBQWhELEVBQWtFO0FBQ3RFLE1BQUksQ0FBQyxVQUFELEVBQWEsT0FBYixFQUFzQixPQUF0QixJQUFpQyxNQUFNLENBQUMsS0FBNUM7QUFDQSxTQUFPLElBQUksc0JBQUosQ0FDTCxVQURLLEVBRUwsSUFBSSxDQUFDLE1BQUQsQ0FGQyxFQUdMO0FBQ0UsSUFBQSxPQURGO0FBRUUsSUFBQTtBQUZGLEdBSEssRUFPTCxVQVBLLENBQVA7QUFTRDs7QUFFRCxTQUFTLFlBQVQsQ0FDRSxVQURGLEVBRUUsT0FGRixFQUV3QztBQUV0QyxNQUFJLFVBQVUsQ0FBQyxRQUFYLEtBQXdCLElBQTVCLEVBQWtDLE9BQU8sVUFBVSxDQUFDLFFBQWxCO0FBRWxDLEVBQUEsVUFBVSxDQUFDLFFBQVgsR0FBc0Isa0JBQXRCO0FBRUEsTUFBSTtBQUFFLElBQUEsVUFBRjtBQUFjLElBQUE7QUFBZCxNQUF1QixVQUEzQjtBQUVBLE1BQUksTUFBTSxHQUFHLGlCQUFpQixDQUFDLFVBQUQsRUFBYSxJQUFiLEVBQW1CLE9BQW5CLENBQTlCO0FBQ0EsRUFBQSxVQUFVLENBQUMsUUFBWCxHQUFzQixNQUF0QjtBQUVBLFNBQU8sTUFBUDtBQUNEOztBQUVELE9BQU0sU0FBVSxpQkFBVixDQUNKLFVBREksRUFFSixJQUZJLEVBR0osYUFISSxFQUd3QztBQUU1QyxNQUFJLFNBQVMsR0FBRyxVQUFoQjtBQUNBLE1BQUksT0FBTyxHQUFHLDBCQUEwQixDQUFDLGFBQUQsRUFBZ0IsSUFBaEIsQ0FBeEM7QUFFQSxNQUFJO0FBQ0YsSUFBQSxPQURFO0FBRUYsSUFBQSxPQUFPLEVBQUU7QUFBRSxNQUFBLFNBQUY7QUFBYSxNQUFBO0FBQWI7QUFGUCxNQUdBLE9BSEo7O0FBS0EsV0FBUyxNQUFULENBQWdCLEdBQUcsRUFBbkIsRUFBcUU7QUFDbkUsSUFBQSxRQUFRLENBQUMsT0FBRCxFQUFVLFNBQVYsRUFBcUIsUUFBckIsRUFBK0IsSUFBL0IsRUFBcUMsRUFBckMsQ0FBUjtBQUNEOztBQUVELE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBYixFQUFnQixDQUFDLEdBQUcsVUFBVSxDQUFDLE1BQS9CLEVBQXVDLENBQUMsRUFBeEMsRUFBNEM7QUFDMUMsSUFBQSxTQUFTLENBQUMsT0FBVixDQUFrQixNQUFsQixFQUEwQixVQUFVLENBQUMsQ0FBRCxDQUFwQztBQUNEOztBQUVELE1BQUksTUFBTSxHQUFHLE9BQU8sQ0FBQyxPQUFSLENBQWdCLE1BQWhCLENBQXVCLElBQUksQ0FBQyxJQUE1QixDQUFiOztBQUVBO0FBQUE7QUFBQSxJQUFzQjtBQUNwQixJQUFBLGFBQWEsQ0FBQyxPQUFELEVBQVUsTUFBVixDQUFiO0FBQ0Q7O0FBRUQsU0FBTyxNQUFQO0FBQ0Q7QUFFRCxPQUFNLFNBQVUsZUFBVixDQUNKLEtBREksRUFFSixVQUZJLEVBRTBCO0FBRTlCLFNBQU8sSUFBSSxzQkFBSixDQUE2QyxLQUFLLENBQUMsQ0FBRCxDQUFsRCxFQUF1RCxVQUF2RCxFQUFtRTtBQUN4RSxJQUFBLFVBQVUsRUFBRSxLQUFLLENBQUMsQ0FBRCxDQUFMLElBQWE7QUFEK0MsR0FBbkUsQ0FBUDtBQUdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgT3B0aW9uLFxuICBMYXlvdXRXaXRoQ29udGV4dCxcbiAgQ29udGFpbmluZ01ldGFkYXRhLFxuICBTZXJpYWxpemVkSW5saW5lQmxvY2ssXG4gIFdpcmVGb3JtYXQsXG4gIFN5bWJvbFRhYmxlLFxuICBDb21waWxhYmxlVGVtcGxhdGUsXG4gIFN0YXRlbWVudCxcbiAgQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIENvbXBpbGFibGVCbG9jayxcbiAgQ29tcGlsYWJsZVByb2dyYW0sXG4gIEhhbmRsZVJlc3VsdCxcbiAgQmxvY2tTeW1ib2xUYWJsZSxcbiAgU2VyaWFsaXplZEJsb2NrLFxuICBCdWlsZGVyT3AsXG4gIEhpZ2hMZXZlbE9wLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IG1ldGEgfSBmcm9tICcuL29wY29kZS1idWlsZGVyL2hlbHBlcnMvc2hhcmVkJztcbmltcG9ydCB7IEVNUFRZX0FSUkFZIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyB0ZW1wbGF0ZUNvbXBpbGF0aW9uQ29udGV4dCB9IGZyb20gJy4vb3Bjb2RlLWJ1aWxkZXIvY29udGV4dCc7XG5pbXBvcnQgeyBMT0NBTF9TSE9VTERfTE9HIH0gZnJvbSAnQGdsaW1tZXIvbG9jYWwtZGVidWctZmxhZ3MnO1xuaW1wb3J0IHsgZGVidWdDb21waWxlciB9IGZyb20gJy4vY29tcGlsZXInO1xuaW1wb3J0IHsgU1RBVEVNRU5UUyB9IGZyb20gJy4vc3ludGF4L3N0YXRlbWVudHMnO1xuaW1wb3J0IHsgSGlnaExldmVsU3RhdGVtZW50T3AgfSBmcm9tICcuL3N5bnRheC9jb21waWxlcnMnO1xuaW1wb3J0IHsgZW5jb2RlT3AgfSBmcm9tICcuL29wY29kZS1idWlsZGVyL2VuY29kZXInO1xuXG5leHBvcnQgY29uc3QgUExBQ0VIT0xERVJfSEFORExFID0gLTE7XG5cbmNsYXNzIENvbXBpbGFibGVUZW1wbGF0ZUltcGw8UyBleHRlbmRzIFN5bWJvbFRhYmxlPiBpbXBsZW1lbnRzIENvbXBpbGFibGVUZW1wbGF0ZTxTPiB7XG4gIGNvbXBpbGVkOiBPcHRpb248SGFuZGxlUmVzdWx0PiA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgc3RhdGVtZW50czogV2lyZUZvcm1hdC5TdGF0ZW1lbnRbXSxcbiAgICByZWFkb25seSBtZXRhOiBDb250YWluaW5nTWV0YWRhdGEsXG4gICAgLy8gUGFydCBvZiBDb21waWxhYmxlVGVtcGxhdGVcbiAgICByZWFkb25seSBzeW1ib2xUYWJsZTogUyxcbiAgICAvLyBVc2VkIGZvciBkZWJ1Z2dpbmdcbiAgICByZWFkb25seSBtb2R1bGVOYW1lID0gJ3BsYWluIGJsb2NrJ1xuICApIHt9XG5cbiAgLy8gUGFydCBvZiBDb21waWxhYmxlVGVtcGxhdGVcbiAgY29tcGlsZShjb250ZXh0OiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCk6IEhhbmRsZVJlc3VsdCB7XG4gICAgcmV0dXJuIG1heWJlQ29tcGlsZSh0aGlzLCBjb250ZXh0KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsYWJsZShsYXlvdXQ6IExheW91dFdpdGhDb250ZXh0LCBtb2R1bGVOYW1lOiBzdHJpbmcpOiBDb21waWxhYmxlUHJvZ3JhbSB7XG4gIGxldCBbc3RhdGVtZW50cywgc3ltYm9scywgaGFzRXZhbF0gPSBsYXlvdXQuYmxvY2s7XG4gIHJldHVybiBuZXcgQ29tcGlsYWJsZVRlbXBsYXRlSW1wbChcbiAgICBzdGF0ZW1lbnRzLFxuICAgIG1ldGEobGF5b3V0KSxcbiAgICB7XG4gICAgICBzeW1ib2xzLFxuICAgICAgaGFzRXZhbCxcbiAgICB9LFxuICAgIG1vZHVsZU5hbWVcbiAgKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVDb21waWxlKFxuICBjb21waWxhYmxlOiBDb21waWxhYmxlVGVtcGxhdGVJbXBsPFN5bWJvbFRhYmxlPixcbiAgY29udGV4dDogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHRcbik6IEhhbmRsZVJlc3VsdCB7XG4gIGlmIChjb21waWxhYmxlLmNvbXBpbGVkICE9PSBudWxsKSByZXR1cm4gY29tcGlsYWJsZS5jb21waWxlZCE7XG5cbiAgY29tcGlsYWJsZS5jb21waWxlZCA9IFBMQUNFSE9MREVSX0hBTkRMRTtcblxuICBsZXQgeyBzdGF0ZW1lbnRzLCBtZXRhIH0gPSBjb21waWxhYmxlO1xuXG4gIGxldCByZXN1bHQgPSBjb21waWxlU3RhdGVtZW50cyhzdGF0ZW1lbnRzLCBtZXRhLCBjb250ZXh0KTtcbiAgY29tcGlsYWJsZS5jb21waWxlZCA9IHJlc3VsdDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZVN0YXRlbWVudHMoXG4gIHN0YXRlbWVudHM6IFN0YXRlbWVudFtdLFxuICBtZXRhOiBDb250YWluaW5nTWV0YWRhdGEsXG4gIHN5bnRheENvbnRleHQ6IENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0XG4pOiBIYW5kbGVSZXN1bHQge1xuICBsZXQgc0NvbXBpbGVyID0gU1RBVEVNRU5UUztcbiAgbGV0IGNvbnRleHQgPSB0ZW1wbGF0ZUNvbXBpbGF0aW9uQ29udGV4dChzeW50YXhDb250ZXh0LCBtZXRhKTtcblxuICBsZXQge1xuICAgIGVuY29kZXIsXG4gICAgcHJvZ3JhbTogeyBjb25zdGFudHMsIHJlc29sdmVyIH0sXG4gIH0gPSBjb250ZXh0O1xuXG4gIGZ1bmN0aW9uIHB1c2hPcCguLi5vcDogQnVpbGRlck9wIHwgSGlnaExldmVsT3AgfCBIaWdoTGV2ZWxTdGF0ZW1lbnRPcCkge1xuICAgIGVuY29kZU9wKGVuY29kZXIsIGNvbnN0YW50cywgcmVzb2x2ZXIsIG1ldGEsIG9wIGFzIEJ1aWxkZXJPcCB8IEhpZ2hMZXZlbE9wKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHNDb21waWxlci5jb21waWxlKHB1c2hPcCwgc3RhdGVtZW50c1tpXSk7XG4gIH1cblxuICBsZXQgaGFuZGxlID0gY29udGV4dC5lbmNvZGVyLmNvbW1pdChtZXRhLnNpemUpO1xuXG4gIGlmIChMT0NBTF9TSE9VTERfTE9HKSB7XG4gICAgZGVidWdDb21waWxlcihjb250ZXh0LCBoYW5kbGUpO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGFibGVCbG9jayhcbiAgYmxvY2s6IFNlcmlhbGl6ZWRJbmxpbmVCbG9jayB8IFNlcmlhbGl6ZWRCbG9jayxcbiAgY29udGFpbmluZzogQ29udGFpbmluZ01ldGFkYXRhXG4pOiBDb21waWxhYmxlQmxvY2sge1xuICByZXR1cm4gbmV3IENvbXBpbGFibGVUZW1wbGF0ZUltcGw8QmxvY2tTeW1ib2xUYWJsZT4oYmxvY2tbMF0sIGNvbnRhaW5pbmcsIHtcbiAgICBwYXJhbWV0ZXJzOiBibG9ja1sxXSB8fCAoRU1QVFlfQVJSQVkgYXMgbnVtYmVyW10pLFxuICB9KTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=