"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isGetFreeDeprecatedHelper = isGetFreeDeprecatedHelper;
exports.resolveComponent = resolveComponent;
exports.resolveHelper = resolveHelper;
exports.resolveModifier = resolveModifier;
exports.resolveComponentOrHelper = resolveComponentOrHelper;
exports.resolveOptionalHelper = resolveOptionalHelper;
exports.resolveOptionalComponentOrHelper = resolveOptionalComponentOrHelper;
exports.isGetFreeOptionalComponentOrHelper = exports.isGetFreeOptionalHelper = exports.isGetFreeComponentOrHelper = exports.isGetFreeHelper = exports.isGetFreeModifier = exports.isGetFreeComponent = void 0;

var _env = require("@glimmer/env");

var _util = require("@glimmer/util");

function isGetLikeTuple(opcode) {
  return Array.isArray(opcode) && opcode.length === 2;
}

function makeResolutionTypeVerifier(typeToVerify) {
  return opcode => {
    if (!isGetLikeTuple(opcode)) return false;
    let type = opcode[0];
    return type === 31
    /* GetStrictFree */
    || type === 32
    /* GetTemplateSymbol */
    || type === typeToVerify;
  };
}

const isGetFreeComponent = makeResolutionTypeVerifier(39
/* GetFreeAsComponentHead */
);
exports.isGetFreeComponent = isGetFreeComponent;
const isGetFreeModifier = makeResolutionTypeVerifier(38
/* GetFreeAsModifierHead */
);
exports.isGetFreeModifier = isGetFreeModifier;
const isGetFreeHelper = makeResolutionTypeVerifier(37
/* GetFreeAsHelperHead */
);
exports.isGetFreeHelper = isGetFreeHelper;
const isGetFreeComponentOrHelper = makeResolutionTypeVerifier(35
/* GetFreeAsComponentOrHelperHead */
);
exports.isGetFreeComponentOrHelper = isGetFreeComponentOrHelper;
const isGetFreeOptionalHelper = makeResolutionTypeVerifier(36
/* GetFreeAsHelperHeadOrThisFallback */
);
exports.isGetFreeOptionalHelper = isGetFreeOptionalHelper;

function isGetFreeDeprecatedHelper(opcode) {
  return Array.isArray(opcode) && opcode[0] === 99
  /* GetFreeAsDeprecatedHelperHeadOrThisFallback */
  ;
}

const isGetFreeOptionalComponentOrHelper = makeResolutionTypeVerifier(34
/* GetFreeAsComponentOrHelperHeadOrThisFallback */
);
exports.isGetFreeOptionalComponentOrHelper = isGetFreeOptionalComponentOrHelper;

function assertResolverInvariants(meta) {
  if (_env.DEBUG) {
    if (!meta.upvars) {
      throw new Error('Attempted to resolve a component, helper, or modifier, but no free vars were found');
    }

    if (!meta.owner) {
      throw new Error('Attempted to resolve a component, helper, or modifier, but no owner was associated with the template it was being resolved from');
    }
  }

  return meta;
}
/**
 * <Foo/>
 * <Foo></Foo>
 * <Foo @arg={{true}} />
 */


function resolveComponent(resolver, constants, meta, [, expr, then]) {
  false && (0, _util.assert)(isGetFreeComponent(expr), 'Attempted to resolve a component with incorrect opcode');
  let type = expr[0];

  if (_env.DEBUG && expr[0] === 31
  /* GetStrictFree */
  ) {
      throw new Error(`Attempted to resolve a component in a strict mode template, but that value was not in scope: ${meta.upvars[expr[1]]}`);
    }

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      let {
        scopeValues,
        owner
      } = meta;
      let definition = scopeValues[expr[1]];
      then(constants.component(definition, owner));
    } else {
    let {
      upvars,
      owner
    } = assertResolverInvariants(meta);
    let name = upvars[expr[1]];
    let definition = resolver.lookupComponent(name, owner);

    if (_env.DEBUG && (typeof definition !== 'object' || definition === null)) {
      throw new Error(`Attempted to resolve \`${name}\`, which was expected to be a component, but nothing was found.`);
    }

    then(constants.resolvedComponent(definition, name));
  }
}
/**
 * (helper)
 * (helper arg)
 */


function resolveHelper(resolver, constants, meta, [, expr, then]) {
  false && (0, _util.assert)(isGetFreeHelper(expr), 'Attempted to resolve a helper with incorrect opcode');
  let type = expr[0];

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      let {
        scopeValues
      } = meta;
      let definition = scopeValues[expr[1]];
      then(constants.helper(definition));
    } else if (type === 31
  /* GetStrictFree */
  ) {
      then(lookupBuiltInHelper(expr, resolver, meta, constants, 'helper'));
    } else {
    let {
      upvars,
      owner
    } = assertResolverInvariants(meta);
    let name = upvars[expr[1]];
    let helper = resolver.lookupHelper(name, owner);

    if (_env.DEBUG && helper === null) {
      throw new Error(`Attempted to resolve \`${name}\`, which was expected to be a helper, but nothing was found.`);
    }

    then(constants.helper(helper, name));
  }
}
/**
 * <div {{modifier}}/>
 * <div {{modifier arg}}/>
 * <Foo {{modifier}}/>
 */


function resolveModifier(resolver, constants, meta, [, expr, then]) {
  false && (0, _util.assert)(isGetFreeModifier(expr), 'Attempted to resolve a modifier with incorrect opcode');
  let type = expr[0];

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      let {
        scopeValues
      } = meta;
      let definition = scopeValues[expr[1]];
      then(constants.modifier(definition));
    } else if (type === 31
  /* GetStrictFree */
  ) {
      let {
        upvars
      } = assertResolverInvariants(meta);
      let name = upvars[expr[1]];
      let modifier = resolver.lookupBuiltInModifier(name);

      if (_env.DEBUG && modifier === null) {
        throw new Error(`Attempted to resolve a modifier in a strict mode template, but it was not in scope: ${name}`);
      }

      then(constants.modifier(modifier, name));
    } else {
    let {
      upvars,
      owner
    } = assertResolverInvariants(meta);
    let name = upvars[expr[1]];
    let modifier = resolver.lookupModifier(name, owner);

    if (_env.DEBUG && modifier === null) {
      throw new Error(`Attempted to resolve \`${name}\`, which was expected to be a modifier, but nothing was found.`);
    }

    then(constants.modifier(modifier, name));
  }
}
/**
 * {{component-or-helper arg}}
 */


function resolveComponentOrHelper(resolver, constants, meta, [, expr, {
  ifComponent,
  ifHelper
}]) {
  false && (0, _util.assert)(isGetFreeComponentOrHelper(expr), 'Attempted to resolve a component or helper with incorrect opcode');
  let type = expr[0];

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      let {
        scopeValues,
        owner
      } = meta;
      let definition = scopeValues[expr[1]];
      let component = constants.component(definition, owner, true);

      if (component !== null) {
        ifComponent(component);
        return;
      }

      let helper = constants.helper(definition, null, true);

      if (_env.DEBUG && helper === null) {
        throw new Error(`Attempted to use a value as either a component or helper, but it did not have a component manager or helper manager associated with it. The value was: ${(0, _util.debugToString)(definition)}`);
      }

      ifHelper(helper);
    } else if (type === 31
  /* GetStrictFree */
  ) {
      ifHelper(lookupBuiltInHelper(expr, resolver, meta, constants, 'component or helper'));
    } else {
    let {
      upvars,
      owner
    } = assertResolverInvariants(meta);
    let name = upvars[expr[1]];
    let definition = resolver.lookupComponent(name, owner);

    if (definition !== null) {
      ifComponent(constants.resolvedComponent(definition, name));
    } else {
      let helper = resolver.lookupHelper(name, owner);

      if (_env.DEBUG && helper === null) {
        throw new Error(`Attempted to resolve \`${name}\`, which was expected to be a component or helper, but nothing was found.`);
      }

      ifHelper(constants.helper(helper, name));
    }
  }
}
/**
 * <Foo @arg={{helper}}>
 */


function resolveOptionalHelper(resolver, constants, meta, [, expr, {
  ifHelper
}]) {
  false && (0, _util.assert)(isGetFreeOptionalHelper(expr) || isGetFreeDeprecatedHelper(expr), 'Attempted to resolve a helper with incorrect opcode');
  let {
    upvars,
    owner
  } = assertResolverInvariants(meta);
  let name = upvars[expr[1]];
  let helper = resolver.lookupHelper(name, owner);

  if (helper) {
    ifHelper(constants.helper(helper, name), name, meta.moduleName);
  }
}
/**
 * {{maybeHelperOrComponent}}
 */


function resolveOptionalComponentOrHelper(resolver, constants, meta, [, expr, {
  ifComponent,
  ifHelper,
  ifValue
}]) {
  false && (0, _util.assert)(isGetFreeOptionalComponentOrHelper(expr), 'Attempted to resolve an optional component or helper with incorrect opcode');
  let type = expr[0];

  if (type === 32
  /* GetTemplateSymbol */
  ) {
      let {
        scopeValues,
        owner
      } = meta;
      let definition = scopeValues[expr[1]];

      if (typeof definition !== 'function' && (typeof definition !== 'object' || definition === null)) {
        // The value is not an object, so it can't be a component or helper.
        ifValue(constants.value(definition));
        return;
      }

      let component = constants.component(definition, owner, true);

      if (component !== null) {
        ifComponent(component);
        return;
      }

      let helper = constants.helper(definition, null, true);

      if (helper !== null) {
        ifHelper(helper);
        return;
      }

      ifValue(constants.value(definition));
    } else if (type === 31
  /* GetStrictFree */
  ) {
      ifHelper(lookupBuiltInHelper(expr, resolver, meta, constants, 'value'));
    } else {
    let {
      upvars,
      owner
    } = assertResolverInvariants(meta);
    let name = upvars[expr[1]];
    let definition = resolver.lookupComponent(name, owner);

    if (definition !== null) {
      ifComponent(constants.resolvedComponent(definition, name));
      return;
    }

    let helper = resolver.lookupHelper(name, owner);

    if (helper !== null) {
      ifHelper(constants.helper(helper, name));
    }
  }
}

function lookupBuiltInHelper(expr, resolver, meta, constants, type) {
  let {
    upvars
  } = assertResolverInvariants(meta);
  let name = upvars[expr[1]];
  let helper = resolver.lookupBuiltInHelper(name);

  if (_env.DEBUG && helper === null) {
    // Keyword helper did not exist, which means that we're attempting to use a
    // value of some kind that is not in scope
    throw new Error(`Attempted to resolve a ${type} in a strict mode template, but that value was not in scope: ${meta.upvars[expr[1]]}`);
  }

  return constants.helper(helper, name);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9yZXNvbHV0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBZ0JBOztBQUVBLFNBQUEsY0FBQSxDQUFBLE1BQUEsRUFBc0Q7QUFDcEQsU0FBTyxLQUFLLENBQUwsT0FBQSxDQUFBLE1BQUEsS0FBeUIsTUFBTSxDQUFOLE1BQUEsS0FBaEMsQ0FBQTtBQUNEOztBQUVELFNBQUEsMEJBQUEsQ0FBQSxZQUFBLEVBQTZEO0FBQzNELFNBQ0UsTUFESyxJQUU0RDtBQUNqRSxRQUFJLENBQUMsY0FBYyxDQUFuQixNQUFtQixDQUFuQixFQUE2QixPQUFBLEtBQUE7QUFFN0IsUUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFqQixDQUFpQixDQUFqQjtBQUVBLFdBQ0UsSUFBSSxLQUFBO0FBQUE7QUFBSixPQUNBLElBQUksS0FBQTtBQUFBO0FBREosT0FFQSxJQUFJLEtBSE4sWUFBQTtBQVBGLEdBQUE7QUFhRDs7QUFFTSxNQUFNLGtCQUFrQixHQUFHLDBCQUEwQixDQUFBO0FBQUE7QUFBQSxDQUFyRDs7QUFFQSxNQUFNLGlCQUFpQixHQUFHLDBCQUEwQixDQUFBO0FBQUE7QUFBQSxDQUFwRDs7QUFFQSxNQUFNLGVBQWUsR0FBRywwQkFBMEIsQ0FBQTtBQUFBO0FBQUEsQ0FBbEQ7O0FBRUEsTUFBTSwwQkFBMEIsR0FBRywwQkFBMEIsQ0FBQTtBQUFBO0FBQUEsQ0FBN0Q7O0FBSUEsTUFBTSx1QkFBdUIsR0FBRywwQkFBMEIsQ0FBQTtBQUFBO0FBQUEsQ0FBMUQ7OztBQUlELFNBQUEseUJBQUEsQ0FBQSxNQUFBLEVBQzBCO0FBRTlCLFNBQ0UsS0FBSyxDQUFMLE9BQUEsQ0FBQSxNQUFBLEtBQXlCLE1BQU0sQ0FBTixDQUFNLENBQU4sS0FBUztBQUFBO0FBRHBDO0FBR0Q7O0FBRU0sTUFBTSxrQ0FBa0MsR0FBRywwQkFBMEIsQ0FBQTtBQUFBO0FBQUEsQ0FBckU7OztBQVNQLFNBQUEsd0JBQUEsQ0FBQSxJQUFBLEVBQTBEO0FBQ3hELE1BQUEsVUFBQSxFQUFXO0FBQ1QsUUFBSSxDQUFDLElBQUksQ0FBVCxNQUFBLEVBQWtCO0FBQ2hCLFlBQU0sSUFBQSxLQUFBLENBQU4sb0ZBQU0sQ0FBTjtBQUdEOztBQUVELFFBQUksQ0FBQyxJQUFJLENBQVQsS0FBQSxFQUFpQjtBQUNmLFlBQU0sSUFBQSxLQUFBLENBQU4saUlBQU0sQ0FBTjtBQUdEO0FBQ0Y7O0FBRUQsU0FBQSxJQUFBO0FBQ0Q7QUFFRDs7Ozs7OztBQUtNLFNBQUEsZ0JBQUEsQ0FBQSxRQUFBLEVBQUEsU0FBQSxFQUFBLElBQUEsRUFJSixHQUFBLElBQUEsRUFKSSxJQUlKLENBSkksRUFJOEI7QUFBQSxXQUVsQyxrQkFBTyxrQkFBa0IsQ0FBbkIsSUFBbUIsQ0FBekIsRUFGa0Msd0RBRWxDLENBRmtDO0FBSWxDLE1BQUksSUFBSSxHQUFHLElBQUksQ0FBZixDQUFlLENBQWY7O0FBRUEsTUFBSSxjQUFTLElBQUksQ0FBSixDQUFJLENBQUosS0FBTztBQUFBO0FBQXBCLElBQW9EO0FBQ2xELFlBQU0sSUFBQSxLQUFBLENBQ0osZ0dBQ0UsSUFBSSxDQUFKLE1BQUEsQ0FBYSxJQUFJLENBQWpCLENBQWlCLENBQWpCLENBRkosRUFBTSxDQUFOO0FBS0Q7O0FBRUQsTUFBSSxJQUFJLEtBQUE7QUFBQTtBQUFSLElBQTRDO0FBQzFDLFVBQUk7QUFBQSxRQUFBLFdBQUE7QUFBZSxRQUFBO0FBQWYsVUFBSixJQUFBO0FBQ0EsVUFBSSxVQUFVLEdBQVUsV0FBUCxDQUNmLElBQUksQ0FETixDQUNNLENBRFcsQ0FBakI7QUFJQSxNQUFBLElBQUksQ0FDRixTQUFTLENBQVQsU0FBQSxDQUFBLFVBQUEsRUFERixLQUNFLENBREUsQ0FBSjtBQU5GLEtBQUEsTUFZTztBQUNMLFFBQUk7QUFBQSxNQUFBLE1BQUE7QUFBVSxNQUFBO0FBQVYsUUFBb0Isd0JBQXdCLENBQWhELElBQWdELENBQWhEO0FBRUEsUUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBdEIsQ0FBc0IsQ0FBTCxDQUFqQjtBQUNBLFFBQUksVUFBVSxHQUFHLFFBQVEsQ0FBUixlQUFBLENBQUEsSUFBQSxFQUFqQixLQUFpQixDQUFqQjs7QUFFQSxRQUFJLGVBQVUsT0FBQSxVQUFBLEtBQUEsUUFBQSxJQUFrQyxVQUFVLEtBQTFELElBQUksQ0FBSixFQUFzRTtBQUNwRSxZQUFNLElBQUEsS0FBQSxDQUNKLDBCQUEwQixJQUQ1QixrRUFBTSxDQUFOO0FBR0Q7O0FBRUQsSUFBQSxJQUFJLENBQUMsU0FBUyxDQUFULGlCQUFBLENBQUEsVUFBQSxFQUFMLElBQUssQ0FBRCxDQUFKO0FBQ0Q7QUFDRjtBQUVEOzs7Ozs7QUFJTSxTQUFBLGFBQUEsQ0FBQSxRQUFBLEVBQUEsU0FBQSxFQUFBLElBQUEsRUFJSixHQUFBLElBQUEsRUFKSSxJQUlKLENBSkksRUFJMkI7QUFBQSxXQUUvQixrQkFBTyxlQUFlLENBQWhCLElBQWdCLENBQXRCLEVBRitCLHFEQUUvQixDQUYrQjtBQUkvQixNQUFJLElBQUksR0FBRyxJQUFJLENBQWYsQ0FBZSxDQUFmOztBQUVBLE1BQUksSUFBSSxLQUFBO0FBQUE7QUFBUixJQUE0QztBQUMxQyxVQUFJO0FBQUUsUUFBQTtBQUFGLFVBQUosSUFBQTtBQUNBLFVBQUksVUFBVSxHQUFVLFdBQVAsQ0FDZixJQUFJLENBRE4sQ0FDTSxDQURXLENBQWpCO0FBSUEsTUFBQSxJQUFJLENBQUMsU0FBUyxDQUFULE1BQUEsQ0FBTCxVQUFLLENBQUQsQ0FBSjtBQU5GLEtBQUEsTUFPTyxJQUFJLElBQUksS0FBQTtBQUFBO0FBQVIsSUFBd0M7QUFDN0MsTUFBQSxJQUFJLENBQ0YsbUJBQW1CLENBQUEsSUFBQSxFQUFBLFFBQUEsRUFBQSxJQUFBLEVBQUEsU0FBQSxFQURyQixRQUNxQixDQURqQixDQUFKO0FBREssS0FBQSxNQUlBO0FBQ0wsUUFBSTtBQUFBLE1BQUEsTUFBQTtBQUFVLE1BQUE7QUFBVixRQUFvQix3QkFBd0IsQ0FBaEQsSUFBZ0QsQ0FBaEQ7QUFFQSxRQUFJLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUF0QixDQUFzQixDQUFMLENBQWpCO0FBQ0EsUUFBSSxNQUFNLEdBQUcsUUFBUSxDQUFSLFlBQUEsQ0FBQSxJQUFBLEVBQWIsS0FBYSxDQUFiOztBQUVBLFFBQUksY0FBUyxNQUFNLEtBQW5CLElBQUEsRUFBOEI7QUFDNUIsWUFBTSxJQUFBLEtBQUEsQ0FDSiwwQkFBMEIsSUFENUIsK0RBQU0sQ0FBTjtBQUdEOztBQUVELElBQUEsSUFBSSxDQUFDLFNBQVMsQ0FBVCxNQUFBLENBQUEsTUFBQSxFQUFMLElBQUssQ0FBRCxDQUFKO0FBQ0Q7QUFDRjtBQUVEOzs7Ozs7O0FBS00sU0FBQSxlQUFBLENBQUEsUUFBQSxFQUFBLFNBQUEsRUFBQSxJQUFBLEVBSUosR0FBQSxJQUFBLEVBSkksSUFJSixDQUpJLEVBSTZCO0FBQUEsV0FFakMsa0JBQU8saUJBQWlCLENBQWxCLElBQWtCLENBQXhCLEVBRmlDLHVEQUVqQyxDQUZpQztBQUlqQyxNQUFJLElBQUksR0FBRyxJQUFJLENBQWYsQ0FBZSxDQUFmOztBQUVBLE1BQUksSUFBSSxLQUFBO0FBQUE7QUFBUixJQUE0QztBQUMxQyxVQUFJO0FBQUUsUUFBQTtBQUFGLFVBQUosSUFBQTtBQUNBLFVBQUksVUFBVSxHQUFVLFdBQVAsQ0FDZixJQUFJLENBRE4sQ0FDTSxDQURXLENBQWpCO0FBSUEsTUFBQSxJQUFJLENBQUMsU0FBUyxDQUFULFFBQUEsQ0FBTCxVQUFLLENBQUQsQ0FBSjtBQU5GLEtBQUEsTUFPTyxJQUFJLElBQUksS0FBQTtBQUFBO0FBQVIsSUFBd0M7QUFDN0MsVUFBSTtBQUFFLFFBQUE7QUFBRixVQUFhLHdCQUF3QixDQUF6QyxJQUF5QyxDQUF6QztBQUNBLFVBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQXRCLENBQXNCLENBQUwsQ0FBakI7QUFDQSxVQUFJLFFBQVEsR0FBRyxRQUFRLENBQVIscUJBQUEsQ0FBZixJQUFlLENBQWY7O0FBRUEsVUFBSSxjQUFTLFFBQVEsS0FBckIsSUFBQSxFQUFnQztBQUM5QixjQUFNLElBQUEsS0FBQSxDQUNKLHVGQUF1RixJQUR6RixFQUFNLENBQU47QUFHRDs7QUFFRCxNQUFBLElBQUksQ0FBQyxTQUFTLENBQVQsUUFBQSxDQUFBLFFBQUEsRUFBTCxJQUFLLENBQUQsQ0FBSjtBQVhLLEtBQUEsTUFZQTtBQUNMLFFBQUk7QUFBQSxNQUFBLE1BQUE7QUFBVSxNQUFBO0FBQVYsUUFBb0Isd0JBQXdCLENBQWhELElBQWdELENBQWhEO0FBQ0EsUUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBdEIsQ0FBc0IsQ0FBTCxDQUFqQjtBQUNBLFFBQUksUUFBUSxHQUFHLFFBQVEsQ0FBUixjQUFBLENBQUEsSUFBQSxFQUFmLEtBQWUsQ0FBZjs7QUFFQSxRQUFJLGNBQVMsUUFBUSxLQUFyQixJQUFBLEVBQWdDO0FBQzlCLFlBQU0sSUFBQSxLQUFBLENBQ0osMEJBQTBCLElBRDVCLGlFQUFNLENBQU47QUFHRDs7QUFFRCxJQUFBLElBQUksQ0FBQyxTQUFTLENBQVQsUUFBQSxDQUFBLFFBQUEsRUFBTCxJQUFLLENBQUQsQ0FBSjtBQUNEO0FBQ0Y7QUFFRDs7Ozs7QUFHTSxTQUFBLHdCQUFBLENBQUEsUUFBQSxFQUFBLFNBQUEsRUFBQSxJQUFBLEVBSUosR0FBQSxJQUFBLEVBQVM7QUFBQSxFQUFBLFdBQUE7QUFBZSxFQUFBO0FBQWYsQ0FBVCxDQUpJLEVBSTJEO0FBQUEsV0FFL0Qsa0JBQ0UsMEJBQTBCLENBRHRCLElBQ3NCLENBRDVCLEVBRitELGtFQUUvRCxDQUYrRDtBQU8vRCxNQUFJLElBQUksR0FBRyxJQUFJLENBQWYsQ0FBZSxDQUFmOztBQUVBLE1BQUksSUFBSSxLQUFBO0FBQUE7QUFBUixJQUE0QztBQUMxQyxVQUFJO0FBQUEsUUFBQSxXQUFBO0FBQWUsUUFBQTtBQUFmLFVBQUosSUFBQTtBQUNBLFVBQUksVUFBVSxHQUFVLFdBQVAsQ0FDZixJQUFJLENBRE4sQ0FDTSxDQURXLENBQWpCO0FBSUEsVUFBSSxTQUFTLEdBQUcsU0FBUyxDQUFULFNBQUEsQ0FBQSxVQUFBLEVBQUEsS0FBQSxFQUFoQixJQUFnQixDQUFoQjs7QUFNQSxVQUFJLFNBQVMsS0FBYixJQUFBLEVBQXdCO0FBQ3RCLFFBQUEsV0FBVyxDQUFYLFNBQVcsQ0FBWDtBQUNBO0FBQ0Q7O0FBRUQsVUFBSSxNQUFNLEdBQUcsU0FBUyxDQUFULE1BQUEsQ0FBQSxVQUFBLEVBQUEsSUFBQSxFQUFiLElBQWEsQ0FBYjs7QUFFQSxVQUFJLGNBQVMsTUFBTSxLQUFuQixJQUFBLEVBQThCO0FBQzVCLGNBQU0sSUFBQSxLQUFBLENBQ0osMEpBQTBKLHlCQUFjLFVBQWQsQ0FENUosRUFBTSxDQUFOO0FBS0Q7O0FBRUQsTUFBQSxRQUFRLENBQVIsTUFBUSxDQUFSO0FBM0JGLEtBQUEsTUE0Qk8sSUFBSSxJQUFJLEtBQUE7QUFBQTtBQUFSLElBQXdDO0FBQzdDLE1BQUEsUUFBUSxDQUNOLG1CQUFtQixDQUFBLElBQUEsRUFBQSxRQUFBLEVBQUEsSUFBQSxFQUFBLFNBQUEsRUFEckIscUJBQ3FCLENBRGIsQ0FBUjtBQURLLEtBQUEsTUFVQTtBQUNMLFFBQUk7QUFBQSxNQUFBLE1BQUE7QUFBVSxNQUFBO0FBQVYsUUFBb0Isd0JBQXdCLENBQWhELElBQWdELENBQWhEO0FBRUEsUUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBdEIsQ0FBc0IsQ0FBTCxDQUFqQjtBQUNBLFFBQUksVUFBVSxHQUFHLFFBQVEsQ0FBUixlQUFBLENBQUEsSUFBQSxFQUFqQixLQUFpQixDQUFqQjs7QUFFQSxRQUFJLFVBQVUsS0FBZCxJQUFBLEVBQXlCO0FBQ3ZCLE1BQUEsV0FBVyxDQUFDLFNBQVMsQ0FBVCxpQkFBQSxDQUFBLFVBQUEsRUFBWixJQUFZLENBQUQsQ0FBWDtBQURGLEtBQUEsTUFFTztBQUNMLFVBQUksTUFBTSxHQUFHLFFBQVEsQ0FBUixZQUFBLENBQUEsSUFBQSxFQUFiLEtBQWEsQ0FBYjs7QUFFQSxVQUFJLGNBQVMsTUFBTSxLQUFuQixJQUFBLEVBQThCO0FBQzVCLGNBQU0sSUFBQSxLQUFBLENBQ0osMEJBQTBCLElBRDVCLDRFQUFNLENBQU47QUFHRDs7QUFFRCxNQUFBLFFBQVEsQ0FBQyxTQUFTLENBQVQsTUFBQSxDQUFBLE1BQUEsRUFBVCxJQUFTLENBQUQsQ0FBUjtBQUNEO0FBQ0Y7QUFDRjtBQUVEOzs7OztBQUdNLFNBQUEscUJBQUEsQ0FBQSxRQUFBLEVBQUEsU0FBQSxFQUFBLElBQUEsRUFJSixHQUFBLElBQUEsRUFBUztBQUFFLEVBQUE7QUFBRixDQUFULENBSkksRUFJMkM7QUFBQSxXQUUvQyxrQkFDRSx1QkFBdUIsQ0FBdkIsSUFBdUIsQ0FBdkIsSUFBaUMseUJBQXlCLENBRHRELElBQ3NELENBRDVELEVBRitDLHFEQUUvQyxDQUYrQztBQU0vQyxNQUFJO0FBQUEsSUFBQSxNQUFBO0FBQVUsSUFBQTtBQUFWLE1BQW9CLHdCQUF3QixDQUFoRCxJQUFnRCxDQUFoRDtBQUVBLE1BQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQXRCLENBQXNCLENBQUwsQ0FBakI7QUFDQSxNQUFJLE1BQU0sR0FBRyxRQUFRLENBQVIsWUFBQSxDQUFBLElBQUEsRUFBYixLQUFhLENBQWI7O0FBRUEsTUFBQSxNQUFBLEVBQVk7QUFDVixJQUFBLFFBQVEsQ0FBQyxTQUFTLENBQVQsTUFBQSxDQUFBLE1BQUEsRUFBRCxJQUFDLENBQUQsRUFBQSxJQUFBLEVBQXVDLElBQUksQ0FBbkQsVUFBUSxDQUFSO0FBQ0Q7QUFDRjtBQUVEOzs7OztBQUdNLFNBQUEsZ0NBQUEsQ0FBQSxRQUFBLEVBQUEsU0FBQSxFQUFBLElBQUEsRUFJSixHQUFBLElBQUEsRUFBUztBQUFBLEVBQUEsV0FBQTtBQUFBLEVBQUEsUUFBQTtBQUF5QixFQUFBO0FBQXpCLENBQVQsQ0FKSSxFQUk0RTtBQUFBLFdBRWhGLGtCQUNFLGtDQUFrQyxDQUQ5QixJQUM4QixDQURwQyxFQUZnRiw0RUFFaEYsQ0FGZ0Y7QUFPaEYsTUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFmLENBQWUsQ0FBZjs7QUFFQSxNQUFJLElBQUksS0FBQTtBQUFBO0FBQVIsSUFBNEM7QUFDMUMsVUFBSTtBQUFBLFFBQUEsV0FBQTtBQUFlLFFBQUE7QUFBZixVQUFKLElBQUE7QUFDQSxVQUFJLFVBQVUsR0FBVSxXQUFQLENBQ2YsSUFBSSxDQUROLENBQ00sQ0FEVyxDQUFqQjs7QUFJQSxVQUNFLE9BQUEsVUFBQSxLQUFBLFVBQUEsS0FDQyxPQUFBLFVBQUEsS0FBQSxRQUFBLElBQWtDLFVBQVUsS0FGL0MsSUFDRSxDQURGLEVBR0U7QUFDQTtBQUNBLFFBQUEsT0FBTyxDQUFDLFNBQVMsQ0FBVCxLQUFBLENBQVIsVUFBUSxDQUFELENBQVA7QUFDQTtBQUNEOztBQUVELFVBQUksU0FBUyxHQUFHLFNBQVMsQ0FBVCxTQUFBLENBQUEsVUFBQSxFQUFBLEtBQUEsRUFBaEIsSUFBZ0IsQ0FBaEI7O0FBTUEsVUFBSSxTQUFTLEtBQWIsSUFBQSxFQUF3QjtBQUN0QixRQUFBLFdBQVcsQ0FBWCxTQUFXLENBQVg7QUFDQTtBQUNEOztBQUVELFVBQUksTUFBTSxHQUFHLFNBQVMsQ0FBVCxNQUFBLENBQUEsVUFBQSxFQUFBLElBQUEsRUFBYixJQUFhLENBQWI7O0FBRUEsVUFBSSxNQUFNLEtBQVYsSUFBQSxFQUFxQjtBQUNuQixRQUFBLFFBQVEsQ0FBUixNQUFRLENBQVI7QUFDQTtBQUNEOztBQUVELE1BQUEsT0FBTyxDQUFDLFNBQVMsQ0FBVCxLQUFBLENBQVIsVUFBUSxDQUFELENBQVA7QUFqQ0YsS0FBQSxNQWtDTyxJQUFJLElBQUksS0FBQTtBQUFBO0FBQVIsSUFBd0M7QUFDN0MsTUFBQSxRQUFRLENBQ04sbUJBQW1CLENBQUEsSUFBQSxFQUFBLFFBQUEsRUFBQSxJQUFBLEVBQUEsU0FBQSxFQURyQixPQUNxQixDQURiLENBQVI7QUFESyxLQUFBLE1BSUE7QUFDTCxRQUFJO0FBQUEsTUFBQSxNQUFBO0FBQVUsTUFBQTtBQUFWLFFBQW9CLHdCQUF3QixDQUFoRCxJQUFnRCxDQUFoRDtBQUVBLFFBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQXRCLENBQXNCLENBQUwsQ0FBakI7QUFDQSxRQUFJLFVBQVUsR0FBRyxRQUFRLENBQVIsZUFBQSxDQUFBLElBQUEsRUFBakIsS0FBaUIsQ0FBakI7O0FBRUEsUUFBSSxVQUFVLEtBQWQsSUFBQSxFQUF5QjtBQUN2QixNQUFBLFdBQVcsQ0FBQyxTQUFTLENBQVQsaUJBQUEsQ0FBQSxVQUFBLEVBQVosSUFBWSxDQUFELENBQVg7QUFDQTtBQUNEOztBQUVELFFBQUksTUFBTSxHQUFHLFFBQVEsQ0FBUixZQUFBLENBQUEsSUFBQSxFQUFiLEtBQWEsQ0FBYjs7QUFFQSxRQUFJLE1BQU0sS0FBVixJQUFBLEVBQXFCO0FBQ25CLE1BQUEsUUFBUSxDQUFDLFNBQVMsQ0FBVCxNQUFBLENBQUEsTUFBQSxFQUFULElBQVMsQ0FBRCxDQUFSO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQUEsbUJBQUEsQ0FBQSxJQUFBLEVBQUEsUUFBQSxFQUFBLElBQUEsRUFBQSxTQUFBLEVBQUEsSUFBQSxFQUtjO0FBRVosTUFBSTtBQUFFLElBQUE7QUFBRixNQUFhLHdCQUF3QixDQUF6QyxJQUF5QyxDQUF6QztBQUVBLE1BQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQXRCLENBQXNCLENBQUwsQ0FBakI7QUFDQSxNQUFJLE1BQU0sR0FBRyxRQUFRLENBQVIsbUJBQUEsQ0FBYixJQUFhLENBQWI7O0FBRUEsTUFBSSxjQUFTLE1BQU0sS0FBbkIsSUFBQSxFQUE4QjtBQUM1QjtBQUNBO0FBQ0EsVUFBTSxJQUFBLEtBQUEsQ0FDSiwwQkFBMEIsSUFBSSxnRUFDNUIsSUFBSSxDQUFKLE1BQUEsQ0FBYSxJQUFJLENBQWpCLENBQWlCLENBQWpCLENBRkosRUFBTSxDQUFOO0FBS0Q7O0FBRUQsU0FBTyxTQUFTLENBQVQsTUFBQSxDQUFBLE1BQUEsRUFBUCxJQUFPLENBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7XG4gIENvbXBpbGVUaW1lQ29uc3RhbnRzLFxuICBDb21waWxlVGltZVJlc29sdmVyLFxuICBDb250YWluaW5nTWV0YWRhdGEsXG4gIEV4cHJlc3Npb25zLFxuICBPd25lcixcbiAgUmVzb2x2ZUNvbXBvbmVudE9wLFxuICBSZXNvbHZlQ29tcG9uZW50T3JIZWxwZXJPcCxcbiAgUmVzb2x2ZUhlbHBlck9wLFxuICBSZXNvbHZlTW9kaWZpZXJPcCxcbiAgUmVzb2x2ZU9wdGlvbmFsQ29tcG9uZW50T3JIZWxwZXJPcCxcbiAgUmVzb2x2ZU9wdGlvbmFsSGVscGVyT3AsXG4gIFNleHBPcGNvZGVzLFxuICBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBhc3NlcnQsIGRlYnVnVG9TdHJpbmcsIGV4cGVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5mdW5jdGlvbiBpc0dldExpa2VUdXBsZShvcGNvZGU6IEV4cHJlc3Npb25zLkV4cHJlc3Npb24pOiBvcGNvZGUgaXMgRXhwcmVzc2lvbnMuVHVwbGVFeHByZXNzaW9uIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkob3Bjb2RlKSAmJiBvcGNvZGUubGVuZ3RoID09PSAyO1xufVxuXG5mdW5jdGlvbiBtYWtlUmVzb2x1dGlvblR5cGVWZXJpZmllcih0eXBlVG9WZXJpZnk6IFNleHBPcGNvZGVzKSB7XG4gIHJldHVybiAoXG4gICAgb3Bjb2RlOiBFeHByZXNzaW9ucy5FeHByZXNzaW9uXG4gICk6IG9wY29kZSBpcyBFeHByZXNzaW9ucy5HZXRGcmVlIHwgRXhwcmVzc2lvbnMuR2V0VGVtcGxhdGVTeW1ib2wgPT4ge1xuICAgIGlmICghaXNHZXRMaWtlVHVwbGUob3Bjb2RlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgbGV0IHR5cGUgPSBvcGNvZGVbMF07XG5cbiAgICByZXR1cm4gKFxuICAgICAgdHlwZSA9PT0gU2V4cE9wY29kZXMuR2V0U3RyaWN0RnJlZSB8fFxuICAgICAgdHlwZSA9PT0gU2V4cE9wY29kZXMuR2V0VGVtcGxhdGVTeW1ib2wgfHxcbiAgICAgIHR5cGUgPT09IHR5cGVUb1ZlcmlmeVxuICAgICk7XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBpc0dldEZyZWVDb21wb25lbnQgPSBtYWtlUmVzb2x1dGlvblR5cGVWZXJpZmllcihTZXhwT3Bjb2Rlcy5HZXRGcmVlQXNDb21wb25lbnRIZWFkKTtcblxuZXhwb3J0IGNvbnN0IGlzR2V0RnJlZU1vZGlmaWVyID0gbWFrZVJlc29sdXRpb25UeXBlVmVyaWZpZXIoU2V4cE9wY29kZXMuR2V0RnJlZUFzTW9kaWZpZXJIZWFkKTtcblxuZXhwb3J0IGNvbnN0IGlzR2V0RnJlZUhlbHBlciA9IG1ha2VSZXNvbHV0aW9uVHlwZVZlcmlmaWVyKFNleHBPcGNvZGVzLkdldEZyZWVBc0hlbHBlckhlYWQpO1xuXG5leHBvcnQgY29uc3QgaXNHZXRGcmVlQ29tcG9uZW50T3JIZWxwZXIgPSBtYWtlUmVzb2x1dGlvblR5cGVWZXJpZmllcihcbiAgU2V4cE9wY29kZXMuR2V0RnJlZUFzQ29tcG9uZW50T3JIZWxwZXJIZWFkXG4pO1xuXG5leHBvcnQgY29uc3QgaXNHZXRGcmVlT3B0aW9uYWxIZWxwZXIgPSBtYWtlUmVzb2x1dGlvblR5cGVWZXJpZmllcihcbiAgU2V4cE9wY29kZXMuR2V0RnJlZUFzSGVscGVySGVhZE9yVGhpc0ZhbGxiYWNrXG4pO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNHZXRGcmVlRGVwcmVjYXRlZEhlbHBlcihcbiAgb3Bjb2RlOiBFeHByZXNzaW9ucy5FeHByZXNzaW9uXG4pOiBvcGNvZGUgaXMgRXhwcmVzc2lvbnMuR2V0UGF0aEZyZWVBc0RlcHJlY2F0ZWRIZWxwZXJIZWFkT3JUaGlzRmFsbGJhY2sge1xuICByZXR1cm4gKFxuICAgIEFycmF5LmlzQXJyYXkob3Bjb2RlKSAmJiBvcGNvZGVbMF0gPT09IFNleHBPcGNvZGVzLkdldEZyZWVBc0RlcHJlY2F0ZWRIZWxwZXJIZWFkT3JUaGlzRmFsbGJhY2tcbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzR2V0RnJlZU9wdGlvbmFsQ29tcG9uZW50T3JIZWxwZXIgPSBtYWtlUmVzb2x1dGlvblR5cGVWZXJpZmllcihcbiAgU2V4cE9wY29kZXMuR2V0RnJlZUFzQ29tcG9uZW50T3JIZWxwZXJIZWFkT3JUaGlzRmFsbGJhY2tcbik7XG5cbmludGVyZmFjZSBSZXNvbHZlZENvbnRhaW5pbmdNZXRhZGF0YSBleHRlbmRzIENvbnRhaW5pbmdNZXRhZGF0YSB7XG4gIG93bmVyOiBPd25lcjtcbiAgdXB2YXJzOiBzdHJpbmdbXTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVzb2x2ZXJJbnZhcmlhbnRzKG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSk6IFJlc29sdmVkQ29udGFpbmluZ01ldGFkYXRhIHtcbiAgaWYgKERFQlVHKSB7XG4gICAgaWYgKCFtZXRhLnVwdmFycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBjb21wb25lbnQsIGhlbHBlciwgb3IgbW9kaWZpZXIsIGJ1dCBubyBmcmVlIHZhcnMgd2VyZSBmb3VuZCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFtZXRhLm93bmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhIGNvbXBvbmVudCwgaGVscGVyLCBvciBtb2RpZmllciwgYnV0IG5vIG93bmVyIHdhcyBhc3NvY2lhdGVkIHdpdGggdGhlIHRlbXBsYXRlIGl0IHdhcyBiZWluZyByZXNvbHZlZCBmcm9tJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKG1ldGEgYXMgdW5rbm93bikgYXMgUmVzb2x2ZWRDb250YWluaW5nTWV0YWRhdGE7XG59XG5cbi8qKlxuICogPEZvby8+XG4gKiA8Rm9vPjwvRm9vPlxuICogPEZvbyBAYXJnPXt7dHJ1ZX19IC8+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KFxuICByZXNvbHZlcjogQ29tcGlsZVRpbWVSZXNvbHZlcixcbiAgY29uc3RhbnRzOiBDb21waWxlVGltZUNvbnN0YW50cyAmIFJlc29sdXRpb25UaW1lQ29uc3RhbnRzLFxuICBtZXRhOiBDb250YWluaW5nTWV0YWRhdGEsXG4gIFssIGV4cHIsIHRoZW5dOiBSZXNvbHZlQ29tcG9uZW50T3Bcbik6IHZvaWQge1xuICBhc3NlcnQoaXNHZXRGcmVlQ29tcG9uZW50KGV4cHIpLCAnQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBjb21wb25lbnQgd2l0aCBpbmNvcnJlY3Qgb3Bjb2RlJyk7XG5cbiAgbGV0IHR5cGUgPSBleHByWzBdO1xuXG4gIGlmIChERUJVRyAmJiBleHByWzBdID09PSBTZXhwT3Bjb2Rlcy5HZXRTdHJpY3RGcmVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRlZCB0byByZXNvbHZlIGEgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdGVtcGxhdGUsIGJ1dCB0aGF0IHZhbHVlIHdhcyBub3QgaW4gc2NvcGU6ICR7XG4gICAgICAgIG1ldGEudXB2YXJzIVtleHByWzFdXVxuICAgICAgfWBcbiAgICApO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFRlbXBsYXRlU3ltYm9sKSB7XG4gICAgbGV0IHsgc2NvcGVWYWx1ZXMsIG93bmVyIH0gPSBtZXRhO1xuICAgIGxldCBkZWZpbml0aW9uID0gZXhwZWN0KHNjb3BlVmFsdWVzLCAnQlVHOiBzY29wZVZhbHVlcyBtdXN0IGV4aXN0IGlmIHRlbXBsYXRlIHN5bWJvbCBpcyB1c2VkJylbXG4gICAgICBleHByWzFdXG4gICAgXTtcblxuICAgIHRoZW4oXG4gICAgICBjb25zdGFudHMuY29tcG9uZW50KFxuICAgICAgICBkZWZpbml0aW9uIGFzIG9iamVjdCxcbiAgICAgICAgZXhwZWN0KG93bmVyLCAnQlVHOiBleHBlY3RlZCBvd25lciB3aGVuIHJlc29sdmluZyBjb21wb25lbnQgZGVmaW5pdGlvbicpXG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgeyB1cHZhcnMsIG93bmVyIH0gPSBhc3NlcnRSZXNvbHZlckludmFyaWFudHMobWV0YSk7XG5cbiAgICBsZXQgbmFtZSA9IHVwdmFyc1tleHByWzFdXTtcbiAgICBsZXQgZGVmaW5pdGlvbiA9IHJlc29sdmVyLmxvb2t1cENvbXBvbmVudChuYW1lLCBvd25lcikhO1xuXG4gICAgaWYgKERFQlVHICYmICh0eXBlb2YgZGVmaW5pdGlvbiAhPT0gJ29iamVjdCcgfHwgZGVmaW5pdGlvbiA9PT0gbnVsbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEF0dGVtcHRlZCB0byByZXNvbHZlIFxcYCR7bmFtZX1cXGAsIHdoaWNoIHdhcyBleHBlY3RlZCB0byBiZSBhIGNvbXBvbmVudCwgYnV0IG5vdGhpbmcgd2FzIGZvdW5kLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhlbihjb25zdGFudHMucmVzb2x2ZWRDb21wb25lbnQoZGVmaW5pdGlvbiwgbmFtZSkpO1xuICB9XG59XG5cbi8qKlxuICogKGhlbHBlcilcbiAqIChoZWxwZXIgYXJnKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUhlbHBlcihcbiAgcmVzb2x2ZXI6IENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIGNvbnN0YW50czogQ29tcGlsZVRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICBbLCBleHByLCB0aGVuXTogUmVzb2x2ZUhlbHBlck9wXG4pOiB2b2lkIHtcbiAgYXNzZXJ0KGlzR2V0RnJlZUhlbHBlcihleHByKSwgJ0F0dGVtcHRlZCB0byByZXNvbHZlIGEgaGVscGVyIHdpdGggaW5jb3JyZWN0IG9wY29kZScpO1xuXG4gIGxldCB0eXBlID0gZXhwclswXTtcblxuICBpZiAodHlwZSA9PT0gU2V4cE9wY29kZXMuR2V0VGVtcGxhdGVTeW1ib2wpIHtcbiAgICBsZXQgeyBzY29wZVZhbHVlcyB9ID0gbWV0YTtcbiAgICBsZXQgZGVmaW5pdGlvbiA9IGV4cGVjdChzY29wZVZhbHVlcywgJ0JVRzogc2NvcGVWYWx1ZXMgbXVzdCBleGlzdCBpZiB0ZW1wbGF0ZSBzeW1ib2wgaXMgdXNlZCcpW1xuICAgICAgZXhwclsxXVxuICAgIF07XG5cbiAgICB0aGVuKGNvbnN0YW50cy5oZWxwZXIoZGVmaW5pdGlvbiBhcyBvYmplY3QpKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRTdHJpY3RGcmVlKSB7XG4gICAgdGhlbihcbiAgICAgIGxvb2t1cEJ1aWx0SW5IZWxwZXIoZXhwciBhcyBFeHByZXNzaW9ucy5HZXRTdHJpY3RGcmVlLCByZXNvbHZlciwgbWV0YSwgY29uc3RhbnRzLCAnaGVscGVyJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxldCB7IHVwdmFycywgb3duZXIgfSA9IGFzc2VydFJlc29sdmVySW52YXJpYW50cyhtZXRhKTtcblxuICAgIGxldCBuYW1lID0gdXB2YXJzW2V4cHJbMV1dO1xuICAgIGxldCBoZWxwZXIgPSByZXNvbHZlci5sb29rdXBIZWxwZXIobmFtZSwgb3duZXIhKSE7XG5cbiAgICBpZiAoREVCVUcgJiYgaGVscGVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBcXGAke25hbWV9XFxgLCB3aGljaCB3YXMgZXhwZWN0ZWQgdG8gYmUgYSBoZWxwZXIsIGJ1dCBub3RoaW5nIHdhcyBmb3VuZC5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoZW4oY29uc3RhbnRzLmhlbHBlcihoZWxwZXIsIG5hbWUpKTtcbiAgfVxufVxuXG4vKipcbiAqIDxkaXYge3ttb2RpZmllcn19Lz5cbiAqIDxkaXYge3ttb2RpZmllciBhcmd9fS8+XG4gKiA8Rm9vIHt7bW9kaWZpZXJ9fS8+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlTW9kaWZpZXIoXG4gIHJlc29sdmVyOiBDb21waWxlVGltZVJlc29sdmVyLFxuICBjb25zdGFudHM6IENvbXBpbGVUaW1lQ29uc3RhbnRzICYgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG4gIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgWywgZXhwciwgdGhlbl06IFJlc29sdmVNb2RpZmllck9wXG4pOiB2b2lkIHtcbiAgYXNzZXJ0KGlzR2V0RnJlZU1vZGlmaWVyKGV4cHIpLCAnQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBtb2RpZmllciB3aXRoIGluY29ycmVjdCBvcGNvZGUnKTtcblxuICBsZXQgdHlwZSA9IGV4cHJbMF07XG5cbiAgaWYgKHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFRlbXBsYXRlU3ltYm9sKSB7XG4gICAgbGV0IHsgc2NvcGVWYWx1ZXMgfSA9IG1ldGE7XG4gICAgbGV0IGRlZmluaXRpb24gPSBleHBlY3Qoc2NvcGVWYWx1ZXMsICdCVUc6IHNjb3BlVmFsdWVzIG11c3QgZXhpc3QgaWYgdGVtcGxhdGUgc3ltYm9sIGlzIHVzZWQnKVtcbiAgICAgIGV4cHJbMV1cbiAgICBdO1xuXG4gICAgdGhlbihjb25zdGFudHMubW9kaWZpZXIoZGVmaW5pdGlvbiBhcyBvYmplY3QpKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRTdHJpY3RGcmVlKSB7XG4gICAgbGV0IHsgdXB2YXJzIH0gPSBhc3NlcnRSZXNvbHZlckludmFyaWFudHMobWV0YSk7XG4gICAgbGV0IG5hbWUgPSB1cHZhcnNbZXhwclsxXV07XG4gICAgbGV0IG1vZGlmaWVyID0gcmVzb2x2ZXIubG9va3VwQnVpbHRJbk1vZGlmaWVyKG5hbWUpO1xuXG4gICAgaWYgKERFQlVHICYmIG1vZGlmaWVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhIG1vZGlmaWVyIGluIGEgc3RyaWN0IG1vZGUgdGVtcGxhdGUsIGJ1dCBpdCB3YXMgbm90IGluIHNjb3BlOiAke25hbWV9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGVuKGNvbnN0YW50cy5tb2RpZmllcihtb2RpZmllciEsIG5hbWUpKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgeyB1cHZhcnMsIG93bmVyIH0gPSBhc3NlcnRSZXNvbHZlckludmFyaWFudHMobWV0YSk7XG4gICAgbGV0IG5hbWUgPSB1cHZhcnNbZXhwclsxXV07XG4gICAgbGV0IG1vZGlmaWVyID0gcmVzb2x2ZXIubG9va3VwTW9kaWZpZXIobmFtZSwgb3duZXIpITtcblxuICAgIGlmIChERUJVRyAmJiBtb2RpZmllciA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQXR0ZW1wdGVkIHRvIHJlc29sdmUgXFxgJHtuYW1lfVxcYCwgd2hpY2ggd2FzIGV4cGVjdGVkIHRvIGJlIGEgbW9kaWZpZXIsIGJ1dCBub3RoaW5nIHdhcyBmb3VuZC5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoZW4oY29uc3RhbnRzLm1vZGlmaWVyKG1vZGlmaWVyLCBuYW1lKSk7XG4gIH1cbn1cblxuLyoqXG4gKiB7e2NvbXBvbmVudC1vci1oZWxwZXIgYXJnfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRPckhlbHBlcihcbiAgcmVzb2x2ZXI6IENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIGNvbnN0YW50czogQ29tcGlsZVRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICBbLCBleHByLCB7IGlmQ29tcG9uZW50LCBpZkhlbHBlciB9XTogUmVzb2x2ZUNvbXBvbmVudE9ySGVscGVyT3Bcbik6IHZvaWQge1xuICBhc3NlcnQoXG4gICAgaXNHZXRGcmVlQ29tcG9uZW50T3JIZWxwZXIoZXhwciksXG4gICAgJ0F0dGVtcHRlZCB0byByZXNvbHZlIGEgY29tcG9uZW50IG9yIGhlbHBlciB3aXRoIGluY29ycmVjdCBvcGNvZGUnXG4gICk7XG5cbiAgbGV0IHR5cGUgPSBleHByWzBdO1xuXG4gIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRUZW1wbGF0ZVN5bWJvbCkge1xuICAgIGxldCB7IHNjb3BlVmFsdWVzLCBvd25lciB9ID0gbWV0YTtcbiAgICBsZXQgZGVmaW5pdGlvbiA9IGV4cGVjdChzY29wZVZhbHVlcywgJ0JVRzogc2NvcGVWYWx1ZXMgbXVzdCBleGlzdCBpZiB0ZW1wbGF0ZSBzeW1ib2wgaXMgdXNlZCcpW1xuICAgICAgZXhwclsxXVxuICAgIF07XG5cbiAgICBsZXQgY29tcG9uZW50ID0gY29uc3RhbnRzLmNvbXBvbmVudChcbiAgICAgIGRlZmluaXRpb24gYXMgb2JqZWN0LFxuICAgICAgZXhwZWN0KG93bmVyLCAnQlVHOiBleHBlY3RlZCBvd25lciB3aGVuIHJlc29sdmluZyBjb21wb25lbnQgZGVmaW5pdGlvbicpLFxuICAgICAgdHJ1ZVxuICAgICk7XG5cbiAgICBpZiAoY29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgICBpZkNvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBoZWxwZXIgPSBjb25zdGFudHMuaGVscGVyKGRlZmluaXRpb24gYXMgb2JqZWN0LCBudWxsLCB0cnVlKTtcblxuICAgIGlmIChERUJVRyAmJiBoZWxwZXIgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEF0dGVtcHRlZCB0byB1c2UgYSB2YWx1ZSBhcyBlaXRoZXIgYSBjb21wb25lbnQgb3IgaGVscGVyLCBidXQgaXQgZGlkIG5vdCBoYXZlIGEgY29tcG9uZW50IG1hbmFnZXIgb3IgaGVscGVyIG1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIGl0LiBUaGUgdmFsdWUgd2FzOiAke2RlYnVnVG9TdHJpbmchKFxuICAgICAgICAgIGRlZmluaXRpb25cbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmSGVscGVyKGV4cGVjdChoZWxwZXIsICdCVUc6IGhlbHBlciBtdXN0IGV4aXN0JykpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFN0cmljdEZyZWUpIHtcbiAgICBpZkhlbHBlcihcbiAgICAgIGxvb2t1cEJ1aWx0SW5IZWxwZXIoXG4gICAgICAgIGV4cHIgYXMgRXhwcmVzc2lvbnMuR2V0U3RyaWN0RnJlZSxcbiAgICAgICAgcmVzb2x2ZXIsXG4gICAgICAgIG1ldGEsXG4gICAgICAgIGNvbnN0YW50cyxcbiAgICAgICAgJ2NvbXBvbmVudCBvciBoZWxwZXInXG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgeyB1cHZhcnMsIG93bmVyIH0gPSBhc3NlcnRSZXNvbHZlckludmFyaWFudHMobWV0YSk7XG5cbiAgICBsZXQgbmFtZSA9IHVwdmFyc1tleHByWzFdXTtcbiAgICBsZXQgZGVmaW5pdGlvbiA9IHJlc29sdmVyLmxvb2t1cENvbXBvbmVudChuYW1lLCBvd25lcik7XG5cbiAgICBpZiAoZGVmaW5pdGlvbiAhPT0gbnVsbCkge1xuICAgICAgaWZDb21wb25lbnQoY29uc3RhbnRzLnJlc29sdmVkQ29tcG9uZW50KGRlZmluaXRpb24sIG5hbWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGhlbHBlciA9IHJlc29sdmVyLmxvb2t1cEhlbHBlcihuYW1lLCBvd25lcik7XG5cbiAgICAgIGlmIChERUJVRyAmJiBoZWxwZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBcXGAke25hbWV9XFxgLCB3aGljaCB3YXMgZXhwZWN0ZWQgdG8gYmUgYSBjb21wb25lbnQgb3IgaGVscGVyLCBidXQgbm90aGluZyB3YXMgZm91bmQuYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZkhlbHBlcihjb25zdGFudHMuaGVscGVyKGhlbHBlciEsIG5hbWUpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiA8Rm9vIEBhcmc9e3toZWxwZXJ9fT5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVPcHRpb25hbEhlbHBlcihcbiAgcmVzb2x2ZXI6IENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIGNvbnN0YW50czogQ29tcGlsZVRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICBbLCBleHByLCB7IGlmSGVscGVyIH1dOiBSZXNvbHZlT3B0aW9uYWxIZWxwZXJPcFxuKTogdm9pZCB7XG4gIGFzc2VydChcbiAgICBpc0dldEZyZWVPcHRpb25hbEhlbHBlcihleHByKSB8fCBpc0dldEZyZWVEZXByZWNhdGVkSGVscGVyKGV4cHIpLFxuICAgICdBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhIGhlbHBlciB3aXRoIGluY29ycmVjdCBvcGNvZGUnXG4gICk7XG4gIGxldCB7IHVwdmFycywgb3duZXIgfSA9IGFzc2VydFJlc29sdmVySW52YXJpYW50cyhtZXRhKTtcblxuICBsZXQgbmFtZSA9IHVwdmFyc1tleHByWzFdXTtcbiAgbGV0IGhlbHBlciA9IHJlc29sdmVyLmxvb2t1cEhlbHBlcihuYW1lLCBvd25lcik7XG5cbiAgaWYgKGhlbHBlcikge1xuICAgIGlmSGVscGVyKGNvbnN0YW50cy5oZWxwZXIoaGVscGVyLCBuYW1lKSwgbmFtZSwgbWV0YS5tb2R1bGVOYW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIHt7bWF5YmVIZWxwZXJPckNvbXBvbmVudH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlT3B0aW9uYWxDb21wb25lbnRPckhlbHBlcihcbiAgcmVzb2x2ZXI6IENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIGNvbnN0YW50czogQ29tcGlsZVRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICBbLCBleHByLCB7IGlmQ29tcG9uZW50LCBpZkhlbHBlciwgaWZWYWx1ZSB9XTogUmVzb2x2ZU9wdGlvbmFsQ29tcG9uZW50T3JIZWxwZXJPcFxuKTogdm9pZCB7XG4gIGFzc2VydChcbiAgICBpc0dldEZyZWVPcHRpb25hbENvbXBvbmVudE9ySGVscGVyKGV4cHIpLFxuICAgICdBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhbiBvcHRpb25hbCBjb21wb25lbnQgb3IgaGVscGVyIHdpdGggaW5jb3JyZWN0IG9wY29kZSdcbiAgKTtcblxuICBsZXQgdHlwZSA9IGV4cHJbMF07XG5cbiAgaWYgKHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFRlbXBsYXRlU3ltYm9sKSB7XG4gICAgbGV0IHsgc2NvcGVWYWx1ZXMsIG93bmVyIH0gPSBtZXRhO1xuICAgIGxldCBkZWZpbml0aW9uID0gZXhwZWN0KHNjb3BlVmFsdWVzLCAnQlVHOiBzY29wZVZhbHVlcyBtdXN0IGV4aXN0IGlmIHRlbXBsYXRlIHN5bWJvbCBpcyB1c2VkJylbXG4gICAgICBleHByWzFdXG4gICAgXTtcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBkZWZpbml0aW9uICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICAodHlwZW9mIGRlZmluaXRpb24gIT09ICdvYmplY3QnIHx8IGRlZmluaXRpb24gPT09IG51bGwpXG4gICAgKSB7XG4gICAgICAvLyBUaGUgdmFsdWUgaXMgbm90IGFuIG9iamVjdCwgc28gaXQgY2FuJ3QgYmUgYSBjb21wb25lbnQgb3IgaGVscGVyLlxuICAgICAgaWZWYWx1ZShjb25zdGFudHMudmFsdWUoZGVmaW5pdGlvbikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjb21wb25lbnQgPSBjb25zdGFudHMuY29tcG9uZW50KFxuICAgICAgZGVmaW5pdGlvbixcbiAgICAgIGV4cGVjdChvd25lciwgJ0JVRzogZXhwZWN0ZWQgb3duZXIgd2hlbiByZXNvbHZpbmcgY29tcG9uZW50IGRlZmluaXRpb24nKSxcbiAgICAgIHRydWVcbiAgICApO1xuXG4gICAgaWYgKGNvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWZDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgaGVscGVyID0gY29uc3RhbnRzLmhlbHBlcihkZWZpbml0aW9uLCBudWxsLCB0cnVlKTtcblxuICAgIGlmIChoZWxwZXIgIT09IG51bGwpIHtcbiAgICAgIGlmSGVscGVyKGhlbHBlcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWZWYWx1ZShjb25zdGFudHMudmFsdWUoZGVmaW5pdGlvbikpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFN0cmljdEZyZWUpIHtcbiAgICBpZkhlbHBlcihcbiAgICAgIGxvb2t1cEJ1aWx0SW5IZWxwZXIoZXhwciBhcyBFeHByZXNzaW9ucy5HZXRTdHJpY3RGcmVlLCByZXNvbHZlciwgbWV0YSwgY29uc3RhbnRzLCAndmFsdWUnKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHsgdXB2YXJzLCBvd25lciB9ID0gYXNzZXJ0UmVzb2x2ZXJJbnZhcmlhbnRzKG1ldGEpO1xuXG4gICAgbGV0IG5hbWUgPSB1cHZhcnNbZXhwclsxXV07XG4gICAgbGV0IGRlZmluaXRpb24gPSByZXNvbHZlci5sb29rdXBDb21wb25lbnQobmFtZSwgb3duZXIpO1xuXG4gICAgaWYgKGRlZmluaXRpb24gIT09IG51bGwpIHtcbiAgICAgIGlmQ29tcG9uZW50KGNvbnN0YW50cy5yZXNvbHZlZENvbXBvbmVudChkZWZpbml0aW9uLCBuYW1lKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGhlbHBlciA9IHJlc29sdmVyLmxvb2t1cEhlbHBlcihuYW1lLCBvd25lcik7XG5cbiAgICBpZiAoaGVscGVyICE9PSBudWxsKSB7XG4gICAgICBpZkhlbHBlcihjb25zdGFudHMuaGVscGVyKGhlbHBlciwgbmFtZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBsb29rdXBCdWlsdEluSGVscGVyKFxuICBleHByOiBFeHByZXNzaW9ucy5HZXRTdHJpY3RGcmVlLFxuICByZXNvbHZlcjogQ29tcGlsZVRpbWVSZXNvbHZlcixcbiAgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICBjb25zdGFudHM6IFJlc29sdXRpb25UaW1lQ29uc3RhbnRzLFxuICB0eXBlOiBzdHJpbmdcbik6IG51bWJlciB7XG4gIGxldCB7IHVwdmFycyB9ID0gYXNzZXJ0UmVzb2x2ZXJJbnZhcmlhbnRzKG1ldGEpO1xuXG4gIGxldCBuYW1lID0gdXB2YXJzW2V4cHJbMV1dO1xuICBsZXQgaGVscGVyID0gcmVzb2x2ZXIubG9va3VwQnVpbHRJbkhlbHBlcihuYW1lKTtcblxuICBpZiAoREVCVUcgJiYgaGVscGVyID09PSBudWxsKSB7XG4gICAgLy8gS2V5d29yZCBoZWxwZXIgZGlkIG5vdCBleGlzdCwgd2hpY2ggbWVhbnMgdGhhdCB3ZSdyZSBhdHRlbXB0aW5nIHRvIHVzZSBhXG4gICAgLy8gdmFsdWUgb2Ygc29tZSBraW5kIHRoYXQgaXMgbm90IGluIHNjb3BlXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRlZCB0byByZXNvbHZlIGEgJHt0eXBlfSBpbiBhIHN0cmljdCBtb2RlIHRlbXBsYXRlLCBidXQgdGhhdCB2YWx1ZSB3YXMgbm90IGluIHNjb3BlOiAke1xuICAgICAgICBtZXRhLnVwdmFycyFbZXhwclsxXV1cbiAgICAgIH1gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjb25zdGFudHMuaGVscGVyKGhlbHBlciEsIG5hbWUpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==