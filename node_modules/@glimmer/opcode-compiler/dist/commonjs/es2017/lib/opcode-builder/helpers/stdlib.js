"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.main = main;
exports.StdAppend = StdAppend;
exports.compileStd = compileStd;

var _vm = require("@glimmer/vm");

var _components = require("./components");

var _stdlib = require("../stdlib");

var _encoder = require("../encoder");

var _conditional = require("./conditional");

var _vm2 = require("./vm");

function main(op) {
  op(75
  /* Main */
  , _vm.$s0);
  (0, _components.invokePreparedComponent)(op, false, false, true);
}
/**
 * Append content to the DOM. This standard function triages content and does the
 * right thing based upon whether it's a string, safe string, component, fragment
 * or node.
 *
 * @param trusting whether to interpolate a string as raw HTML (corresponds to
 * triple curlies)
 */


function StdAppend(op, trusting, nonDynamicAppend) {
  (0, _conditional.SwitchCases)(op, () => op(76
  /* ContentType */
  ), when => {
    when(2
    /* String */
    , () => {
      if (trusting) {
        op(68
        /* AssertSame */
        );
        op(43
        /* AppendHTML */
        );
      } else {
        op(47
        /* AppendText */
        );
      }
    });

    if (typeof nonDynamicAppend === 'number') {
      when(0
      /* Component */
      , () => {
        op(81
        /* ResolveCurriedComponent */
        );
        op(79
        /* PushDynamicComponentInstance */
        );
        (0, _components.InvokeBareComponent)(op);
      });
      when(1
      /* Helper */
      , () => {
        (0, _vm2.CallDynamic)(op, null, null, () => {
          op(3
          /* InvokeStatic */
          , nonDynamicAppend);
        });
      });
    } else {
      // when non-dynamic, we can no longer call the value (potentially because we've already called it)
      // this prevents infinite loops. We instead coerce the value, whatever it is, into the DOM.
      when(0
      /* Component */
      , () => {
        op(47
        /* AppendText */
        );
      });
      when(1
      /* Helper */
      , () => {
        op(47
        /* AppendText */
        );
      });
    }

    when(4
    /* SafeString */
    , () => {
      op(68
      /* AssertSame */
      );
      op(44
      /* AppendSafeHTML */
      );
    });
    when(5
    /* Fragment */
    , () => {
      op(68
      /* AssertSame */
      );
      op(45
      /* AppendDocumentFragment */
      );
    });
    when(6
    /* Node */
    , () => {
      op(68
      /* AssertSame */
      );
      op(46
      /* AppendNode */
      );
    });
  });
}

function compileStd(context) {
  let mainHandle = build(context, op => main(op));
  let trustingGuardedNonDynamicAppend = build(context, op => StdAppend(op, true, null));
  let cautiousGuardedNonDynamicAppend = build(context, op => StdAppend(op, false, null));
  let trustingGuardedDynamicAppend = build(context, op => StdAppend(op, true, trustingGuardedNonDynamicAppend));
  let cautiousGuardedDynamicAppend = build(context, op => StdAppend(op, false, cautiousGuardedNonDynamicAppend));
  return new _stdlib.StdLib(mainHandle, trustingGuardedDynamicAppend, cautiousGuardedDynamicAppend, trustingGuardedNonDynamicAppend, cautiousGuardedNonDynamicAppend);
}

const STDLIB_META = {
  evalSymbols: null,
  upvars: null,
  moduleName: 'stdlib',
  // TODO: ??
  scopeValues: null,
  isStrictMode: true,
  owner: null,
  size: 0
};

function build(program, callback) {
  let {
    constants,
    heap,
    resolver
  } = program;
  let encoder = new _encoder.EncoderImpl(heap, STDLIB_META);

  function pushOp(...op) {
    (0, _encoder.encodeOp)(encoder, constants, resolver, STDLIB_META, op);
  }

  callback(pushOp);
  let result = encoder.commit(0);

  if (typeof result !== 'number') {
    // This shouldn't be possible
    throw new Error(`Unexpected errors compiling std`);
  } else {
    return result;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9zdGRsaWIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBU0E7O0FBRUE7O0FBRU0sU0FBQSxJQUFBLENBQUEsRUFBQSxFQUFrQztBQUN0QyxFQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsSUFBRixPQUFFLENBQUY7QUFDQSwyQ0FBdUIsRUFBdkIsRUFBdUIsS0FBdkIsRUFBdUIsS0FBdkIsRUFBQSxJQUFBO0FBQ0Q7QUFFRDs7Ozs7Ozs7OztBQVFNLFNBQUEsU0FBQSxDQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsZ0JBQUEsRUFHMkI7QUFFL0IsZ0NBQVcsRUFBWCxFQUVFLE1BQU0sRUFBRSxDQUFBO0FBQUE7QUFBQSxHQUZWLEVBR0csSUFBRCxJQUFTO0FBQ1AsSUFBQSxJQUFJLENBQUE7QUFBQTtBQUFBLE1BQXFCLE1BQUs7QUFDNUIsVUFBQSxRQUFBLEVBQWM7QUFDWixRQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsU0FBRjtBQUNBLFFBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxTQUFGO0FBRkYsT0FBQSxNQUdPO0FBQ0wsUUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLFNBQUY7QUFDRDtBQU5ILEtBQUksQ0FBSjs7QUFTQSxRQUFJLE9BQUEsZ0JBQUEsS0FBSixRQUFBLEVBQTBDO0FBQ3hDLE1BQUEsSUFBSSxDQUFBO0FBQUE7QUFBQSxRQUF3QixNQUFLO0FBQy9CLFFBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxTQUFGO0FBQ0EsUUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLFNBQUY7QUFDQSw2Q0FBQSxFQUFBO0FBSEYsT0FBSSxDQUFKO0FBTUEsTUFBQSxJQUFJLENBQUE7QUFBQTtBQUFBLFFBQXFCLE1BQUs7QUFDNUIsOEJBQVcsRUFBWCxFQUFXLElBQVgsRUFBVyxJQUFYLEVBQTRCLE1BQUs7QUFDL0IsVUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLFlBQUYsZ0JBQUUsQ0FBRjtBQURGLFNBQUE7QUFERixPQUFJLENBQUo7QUFQRixLQUFBLE1BWU87QUFDTDtBQUNBO0FBQ0EsTUFBQSxJQUFJLENBQUE7QUFBQTtBQUFBLFFBQXdCLE1BQUs7QUFDL0IsUUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLFNBQUY7QUFERixPQUFJLENBQUo7QUFJQSxNQUFBLElBQUksQ0FBQTtBQUFBO0FBQUEsUUFBcUIsTUFBSztBQUM1QixRQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsU0FBRjtBQURGLE9BQUksQ0FBSjtBQUdEOztBQUVELElBQUEsSUFBSSxDQUFBO0FBQUE7QUFBQSxNQUF5QixNQUFLO0FBQ2hDLE1BQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxPQUFGO0FBQ0EsTUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLE9BQUY7QUFGRixLQUFJLENBQUo7QUFLQSxJQUFBLElBQUksQ0FBQTtBQUFBO0FBQUEsTUFBdUIsTUFBSztBQUM5QixNQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsT0FBRjtBQUNBLE1BQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxPQUFGO0FBRkYsS0FBSSxDQUFKO0FBS0EsSUFBQSxJQUFJLENBQUE7QUFBQTtBQUFBLE1BQW1CLE1BQUs7QUFDMUIsTUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLE9BQUY7QUFDQSxNQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsT0FBRjtBQUZGLEtBQUksQ0FBSjtBQS9DSixHQUFBO0FBcUREOztBQUVLLFNBQUEsVUFBQSxDQUFBLE9BQUEsRUFBMkQ7QUFDL0QsTUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFBLE9BQUEsRUFBVyxFQUFELElBQVEsSUFBSSxDQUE1QyxFQUE0QyxDQUF0QixDQUF0QjtBQUNBLE1BQUksK0JBQStCLEdBQUcsS0FBSyxDQUFBLE9BQUEsRUFBVyxFQUFELElBQVEsU0FBUyxDQUFBLEVBQUEsRUFBQSxJQUFBLEVBQXRFLElBQXNFLENBQTNCLENBQTNDO0FBQ0EsTUFBSSwrQkFBK0IsR0FBRyxLQUFLLENBQUEsT0FBQSxFQUFXLEVBQUQsSUFBUSxTQUFTLENBQUEsRUFBQSxFQUFBLEtBQUEsRUFBdEUsSUFBc0UsQ0FBM0IsQ0FBM0M7QUFFQSxNQUFJLDRCQUE0QixHQUFHLEtBQUssQ0FBQSxPQUFBLEVBQVcsRUFBRCxJQUNoRCxTQUFTLENBQUEsRUFBQSxFQUFBLElBQUEsRUFEWCwrQkFDVyxDQUQ2QixDQUF4QztBQUdBLE1BQUksNEJBQTRCLEdBQUcsS0FBSyxDQUFBLE9BQUEsRUFBVyxFQUFELElBQ2hELFNBQVMsQ0FBQSxFQUFBLEVBQUEsS0FBQSxFQURYLCtCQUNXLENBRDZCLENBQXhDO0FBSUEsU0FBTyxJQUFBLGNBQUEsQ0FBQSxVQUFBLEVBQUEsNEJBQUEsRUFBQSw0QkFBQSxFQUFBLCtCQUFBLEVBQVAsK0JBQU8sQ0FBUDtBQU9EOztBQUVELE1BQU0sV0FBVyxHQUFHO0FBQ2xCLEVBQUEsV0FBVyxFQURPLElBQUE7QUFFbEIsRUFBQSxNQUFNLEVBRlksSUFBQTtBQUdsQixFQUFBLFVBQVUsRUFIUSxRQUFBO0FBS2xCO0FBQ0EsRUFBQSxXQUFXLEVBTk8sSUFBQTtBQU9sQixFQUFBLFlBQVksRUFQTSxJQUFBO0FBUWxCLEVBQUEsS0FBSyxFQVJhLElBQUE7QUFTbEIsRUFBQSxJQUFJLEVBQUU7QUFUWSxDQUFwQjs7QUFZQSxTQUFBLEtBQUEsQ0FBQSxPQUFBLEVBQUEsUUFBQSxFQUV5QztBQUV2QyxNQUFJO0FBQUEsSUFBQSxTQUFBO0FBQUEsSUFBQSxJQUFBO0FBQW1CLElBQUE7QUFBbkIsTUFBSixPQUFBO0FBQ0EsTUFBSSxPQUFPLEdBQUcsSUFBQSxvQkFBQSxDQUFBLElBQUEsRUFBZCxXQUFjLENBQWQ7O0FBRUEsV0FBQSxNQUFBLENBQWdCLEdBQWhCLEVBQUEsRUFBcUU7QUFDbkUsMkJBQVEsT0FBUixFQUFRLFNBQVIsRUFBUSxRQUFSLEVBQVEsV0FBUixFQUFBLEVBQUE7QUFDRDs7QUFFRCxFQUFBLFFBQVEsQ0FBUixNQUFRLENBQVI7QUFFQSxNQUFJLE1BQU0sR0FBRyxPQUFPLENBQVAsTUFBQSxDQUFiLENBQWEsQ0FBYjs7QUFFQSxNQUFJLE9BQUEsTUFBQSxLQUFKLFFBQUEsRUFBZ0M7QUFDOUI7QUFDQSxVQUFNLElBQUEsS0FBQSxDQUFOLGlDQUFNLENBQU47QUFGRixHQUFBLE1BR087QUFDTCxXQUFBLE1BQUE7QUFDRDtBQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgJHMwIH0gZnJvbSAnQGdsaW1tZXIvdm0nO1xuXG5pbXBvcnQgeyBpbnZva2VQcmVwYXJlZENvbXBvbmVudCwgSW52b2tlQmFyZUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cyc7XG5pbXBvcnQgeyBTdGRMaWIgfSBmcm9tICcuLi9zdGRsaWInO1xuaW1wb3J0IHsgZW5jb2RlT3AsIEVuY29kZXJJbXBsIH0gZnJvbSAnLi4vZW5jb2Rlcic7XG5pbXBvcnQge1xuICBDb250ZW50VHlwZSxcbiAgT3AsXG4gIENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0LFxuICBIaWdoTGV2ZWxPcCxcbiAgQnVpbGRlck9wLFxuICBNYWNoaW5lT3AsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgU3dpdGNoQ2FzZXMgfSBmcm9tICcuL2NvbmRpdGlvbmFsJztcbmltcG9ydCB7IEhpZ2hMZXZlbFN0YXRlbWVudE9wLCBQdXNoU3RhdGVtZW50T3AgfSBmcm9tICcuLi8uLi9zeW50YXgvY29tcGlsZXJzJztcbmltcG9ydCB7IENhbGxEeW5hbWljIH0gZnJvbSAnLi92bSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWluKG9wOiBQdXNoU3RhdGVtZW50T3ApOiB2b2lkIHtcbiAgb3AoT3AuTWFpbiwgJHMwKTtcbiAgaW52b2tlUHJlcGFyZWRDb21wb25lbnQob3AsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQXBwZW5kIGNvbnRlbnQgdG8gdGhlIERPTS4gVGhpcyBzdGFuZGFyZCBmdW5jdGlvbiB0cmlhZ2VzIGNvbnRlbnQgYW5kIGRvZXMgdGhlXG4gKiByaWdodCB0aGluZyBiYXNlZCB1cG9uIHdoZXRoZXIgaXQncyBhIHN0cmluZywgc2FmZSBzdHJpbmcsIGNvbXBvbmVudCwgZnJhZ21lbnRcbiAqIG9yIG5vZGUuXG4gKlxuICogQHBhcmFtIHRydXN0aW5nIHdoZXRoZXIgdG8gaW50ZXJwb2xhdGUgYSBzdHJpbmcgYXMgcmF3IEhUTUwgKGNvcnJlc3BvbmRzIHRvXG4gKiB0cmlwbGUgY3VybGllcylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFN0ZEFwcGVuZChcbiAgb3A6IFB1c2hTdGF0ZW1lbnRPcCxcbiAgdHJ1c3Rpbmc6IGJvb2xlYW4sXG4gIG5vbkR5bmFtaWNBcHBlbmQ6IG51bWJlciB8IG51bGxcbik6IHZvaWQge1xuICBTd2l0Y2hDYXNlcyhcbiAgICBvcCxcbiAgICAoKSA9PiBvcChPcC5Db250ZW50VHlwZSksXG4gICAgKHdoZW4pID0+IHtcbiAgICAgIHdoZW4oQ29udGVudFR5cGUuU3RyaW5nLCAoKSA9PiB7XG4gICAgICAgIGlmICh0cnVzdGluZykge1xuICAgICAgICAgIG9wKE9wLkFzc2VydFNhbWUpO1xuICAgICAgICAgIG9wKE9wLkFwcGVuZEhUTUwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wKE9wLkFwcGVuZFRleHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBub25EeW5hbWljQXBwZW5kID09PSAnbnVtYmVyJykge1xuICAgICAgICB3aGVuKENvbnRlbnRUeXBlLkNvbXBvbmVudCwgKCkgPT4ge1xuICAgICAgICAgIG9wKE9wLlJlc29sdmVDdXJyaWVkQ29tcG9uZW50KTtcbiAgICAgICAgICBvcChPcC5QdXNoRHluYW1pY0NvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgICAgICBJbnZva2VCYXJlQ29tcG9uZW50KG9wKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2hlbihDb250ZW50VHlwZS5IZWxwZXIsICgpID0+IHtcbiAgICAgICAgICBDYWxsRHluYW1pYyhvcCwgbnVsbCwgbnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgb3AoTWFjaGluZU9wLkludm9rZVN0YXRpYywgbm9uRHluYW1pY0FwcGVuZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2hlbiBub24tZHluYW1pYywgd2UgY2FuIG5vIGxvbmdlciBjYWxsIHRoZSB2YWx1ZSAocG90ZW50aWFsbHkgYmVjYXVzZSB3ZSd2ZSBhbHJlYWR5IGNhbGxlZCBpdClcbiAgICAgICAgLy8gdGhpcyBwcmV2ZW50cyBpbmZpbml0ZSBsb29wcy4gV2UgaW5zdGVhZCBjb2VyY2UgdGhlIHZhbHVlLCB3aGF0ZXZlciBpdCBpcywgaW50byB0aGUgRE9NLlxuICAgICAgICB3aGVuKENvbnRlbnRUeXBlLkNvbXBvbmVudCwgKCkgPT4ge1xuICAgICAgICAgIG9wKE9wLkFwcGVuZFRleHQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB3aGVuKENvbnRlbnRUeXBlLkhlbHBlciwgKCkgPT4ge1xuICAgICAgICAgIG9wKE9wLkFwcGVuZFRleHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgd2hlbihDb250ZW50VHlwZS5TYWZlU3RyaW5nLCAoKSA9PiB7XG4gICAgICAgIG9wKE9wLkFzc2VydFNhbWUpO1xuICAgICAgICBvcChPcC5BcHBlbmRTYWZlSFRNTCk7XG4gICAgICB9KTtcblxuICAgICAgd2hlbihDb250ZW50VHlwZS5GcmFnbWVudCwgKCkgPT4ge1xuICAgICAgICBvcChPcC5Bc3NlcnRTYW1lKTtcbiAgICAgICAgb3AoT3AuQXBwZW5kRG9jdW1lbnRGcmFnbWVudCk7XG4gICAgICB9KTtcblxuICAgICAgd2hlbihDb250ZW50VHlwZS5Ob2RlLCAoKSA9PiB7XG4gICAgICAgIG9wKE9wLkFzc2VydFNhbWUpO1xuICAgICAgICBvcChPcC5BcHBlbmROb2RlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVTdGQoY29udGV4dDogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQpOiBTdGRMaWIge1xuICBsZXQgbWFpbkhhbmRsZSA9IGJ1aWxkKGNvbnRleHQsIChvcCkgPT4gbWFpbihvcCkpO1xuICBsZXQgdHJ1c3RpbmdHdWFyZGVkTm9uRHluYW1pY0FwcGVuZCA9IGJ1aWxkKGNvbnRleHQsIChvcCkgPT4gU3RkQXBwZW5kKG9wLCB0cnVlLCBudWxsKSk7XG4gIGxldCBjYXV0aW91c0d1YXJkZWROb25EeW5hbWljQXBwZW5kID0gYnVpbGQoY29udGV4dCwgKG9wKSA9PiBTdGRBcHBlbmQob3AsIGZhbHNlLCBudWxsKSk7XG5cbiAgbGV0IHRydXN0aW5nR3VhcmRlZER5bmFtaWNBcHBlbmQgPSBidWlsZChjb250ZXh0LCAob3ApID0+XG4gICAgU3RkQXBwZW5kKG9wLCB0cnVlLCB0cnVzdGluZ0d1YXJkZWROb25EeW5hbWljQXBwZW5kKVxuICApO1xuICBsZXQgY2F1dGlvdXNHdWFyZGVkRHluYW1pY0FwcGVuZCA9IGJ1aWxkKGNvbnRleHQsIChvcCkgPT5cbiAgICBTdGRBcHBlbmQob3AsIGZhbHNlLCBjYXV0aW91c0d1YXJkZWROb25EeW5hbWljQXBwZW5kKVxuICApO1xuXG4gIHJldHVybiBuZXcgU3RkTGliKFxuICAgIG1haW5IYW5kbGUsXG4gICAgdHJ1c3RpbmdHdWFyZGVkRHluYW1pY0FwcGVuZCxcbiAgICBjYXV0aW91c0d1YXJkZWREeW5hbWljQXBwZW5kLFxuICAgIHRydXN0aW5nR3VhcmRlZE5vbkR5bmFtaWNBcHBlbmQsXG4gICAgY2F1dGlvdXNHdWFyZGVkTm9uRHluYW1pY0FwcGVuZFxuICApO1xufVxuXG5jb25zdCBTVERMSUJfTUVUQSA9IHtcbiAgZXZhbFN5bWJvbHM6IG51bGwsXG4gIHVwdmFyczogbnVsbCxcbiAgbW9kdWxlTmFtZTogJ3N0ZGxpYicsXG5cbiAgLy8gVE9ETzogPz9cbiAgc2NvcGVWYWx1ZXM6IG51bGwsXG4gIGlzU3RyaWN0TW9kZTogdHJ1ZSxcbiAgb3duZXI6IG51bGwsXG4gIHNpemU6IDAsXG59O1xuXG5mdW5jdGlvbiBidWlsZChcbiAgcHJvZ3JhbTogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIGNhbGxiYWNrOiAob3A6IFB1c2hTdGF0ZW1lbnRPcCkgPT4gdm9pZFxuKTogbnVtYmVyIHtcbiAgbGV0IHsgY29uc3RhbnRzLCBoZWFwLCByZXNvbHZlciB9ID0gcHJvZ3JhbTtcbiAgbGV0IGVuY29kZXIgPSBuZXcgRW5jb2RlckltcGwoaGVhcCwgU1RETElCX01FVEEpO1xuXG4gIGZ1bmN0aW9uIHB1c2hPcCguLi5vcDogQnVpbGRlck9wIHwgSGlnaExldmVsT3AgfCBIaWdoTGV2ZWxTdGF0ZW1lbnRPcCkge1xuICAgIGVuY29kZU9wKGVuY29kZXIsIGNvbnN0YW50cywgcmVzb2x2ZXIsIFNURExJQl9NRVRBLCBvcCBhcyBCdWlsZGVyT3AgfCBIaWdoTGV2ZWxPcCk7XG4gIH1cblxuICBjYWxsYmFjayhwdXNoT3ApO1xuXG4gIGxldCByZXN1bHQgPSBlbmNvZGVyLmNvbW1pdCgwKTtcblxuICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ251bWJlcicpIHtcbiAgICAvLyBUaGlzIHNob3VsZG4ndCBiZSBwb3NzaWJsZVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBlcnJvcnMgY29tcGlsaW5nIHN0ZGApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=