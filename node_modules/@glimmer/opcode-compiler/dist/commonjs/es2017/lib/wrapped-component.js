"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WrappedBuilder = void 0;

var _context = require("./opcode-builder/context");

var _shared = require("./opcode-builder/helpers/shared");

var _components = require("./opcode-builder/helpers/components");

var _compiler = require("./compiler");

var _encoder = require("./opcode-builder/encoder");

class WrappedBuilder {
  constructor(layout, moduleName) {
    this.layout = layout;
    this.moduleName = moduleName;
    this.compiled = null;
    let {
      block
    } = layout;
    let [, symbols, hasEval] = block;
    symbols = symbols.slice(); // ensure ATTRS_BLOCK is always included (only once) in the list of symbols

    let attrsBlockIndex = symbols.indexOf(_components.ATTRS_BLOCK);

    if (attrsBlockIndex === -1) {
      this.attrsBlockNumber = symbols.push(_components.ATTRS_BLOCK);
    } else {
      this.attrsBlockNumber = attrsBlockIndex + 1;
    }

    this.symbolTable = {
      hasEval,
      symbols
    };
  }

  compile(syntax) {
    if (this.compiled !== null) return this.compiled;
    let m = (0, _shared.meta)(this.layout);
    let context = (0, _context.templateCompilationContext)(syntax, m);
    let {
      encoder,
      program: {
        constants,
        resolver
      }
    } = context;

    function pushOp(...op) {
      (0, _encoder.encodeOp)(encoder, constants, resolver, m, op);
    }

    (0, _components.WrappedComponent)(pushOp, this.layout, this.attrsBlockNumber);
    let handle = context.encoder.commit(m.size);

    if (typeof handle !== 'number') {
      return handle;
    }

    this.compiled = handle;

    if (false
    /* LOCAL_SHOULD_LOG */
    ) {
        (0, _compiler.debugCompiler)(context, handle);
      }

    return handle;
  }

}

exports.WrappedBuilder = WrappedBuilder;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvd3JhcHBlZC1jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVdBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUdNLE1BQUEsY0FBQSxDQUFxQjtBQUt6QixFQUFBLFdBQUEsQ0FBQSxNQUFBLEVBQUEsVUFBQSxFQUF3RTtBQUFwRCxTQUFBLE1BQUEsR0FBQSxNQUFBO0FBQWtDLFNBQUEsVUFBQSxHQUFBLFVBQUE7QUFIOUMsU0FBQSxRQUFBLEdBQUEsSUFBQTtBQUlOLFFBQUk7QUFBRSxNQUFBO0FBQUYsUUFBSixNQUFBO0FBQ0EsUUFBSSxHQUFBLE9BQUEsRUFBQSxPQUFBLElBQUosS0FBQTtBQUVBLElBQUEsT0FBTyxHQUFHLE9BQU8sQ0FKcUQsS0FJNUQsRUFBVixDQUpzRSxDQU10RTs7QUFDQSxRQUFJLGVBQWUsR0FBRyxPQUFPLENBQVAsT0FBQSxDQUF0Qix1QkFBc0IsQ0FBdEI7O0FBQ0EsUUFBSSxlQUFlLEtBQUssQ0FBeEIsQ0FBQSxFQUE0QjtBQUMxQixXQUFBLGdCQUFBLEdBQXdCLE9BQU8sQ0FBUCxJQUFBLENBQXhCLHVCQUF3QixDQUF4QjtBQURGLEtBQUEsTUFFTztBQUNMLFdBQUEsZ0JBQUEsR0FBd0IsZUFBZSxHQUF2QyxDQUFBO0FBQ0Q7O0FBRUQsU0FBQSxXQUFBLEdBQW1CO0FBQUEsTUFBQSxPQUFBO0FBRWpCLE1BQUE7QUFGaUIsS0FBbkI7QUFJRDs7QUFFRCxFQUFBLE9BQU8sQ0FBQSxNQUFBLEVBQXNDO0FBQzNDLFFBQUksS0FBQSxRQUFBLEtBQUosSUFBQSxFQUE0QixPQUFPLEtBQVAsUUFBQTtBQUU1QixRQUFJLENBQUMsR0FBRyxrQkFBSyxLQUFiLE1BQVEsQ0FBUjtBQUNBLFFBQUksT0FBTyxHQUFHLHlDQUEwQixNQUExQixFQUFkLENBQWMsQ0FBZDtBQUVBLFFBQUk7QUFBQSxNQUFBLE9BQUE7QUFFRixNQUFBLE9BQU8sRUFBRTtBQUFBLFFBQUEsU0FBQTtBQUFhLFFBQUE7QUFBYjtBQUZQLFFBQUosT0FBQTs7QUFLQSxhQUFBLE1BQUEsQ0FBZ0IsR0FBaEIsRUFBQSxFQUFxRTtBQUNuRSw2QkFBUSxPQUFSLEVBQVEsU0FBUixFQUFRLFFBQVIsRUFBUSxDQUFSLEVBQUEsRUFBQTtBQUNEOztBQUVELHNDQUFnQixNQUFoQixFQUF5QixLQUFULE1BQWhCLEVBQXNDLEtBQXRDLGdCQUFBO0FBRUEsUUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFQLE9BQUEsQ0FBQSxNQUFBLENBQXVCLENBQUMsQ0FBckMsSUFBYSxDQUFiOztBQUVBLFFBQUksT0FBQSxNQUFBLEtBQUosUUFBQSxFQUFnQztBQUM5QixhQUFBLE1BQUE7QUFDRDs7QUFFRCxTQUFBLFFBQUEsR0FBQSxNQUFBOztBQUVBLFFBQUE7QUFBQTtBQUFBLE1BQXNCO0FBQ3BCLHFDQUFhLE9BQWIsRUFBQSxNQUFBO0FBQ0Q7O0FBRUQsV0FBQSxNQUFBO0FBQ0Q7O0FBdkR3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFByb2dyYW1TeW1ib2xUYWJsZSxcbiAgQ29tcGlsYWJsZVByb2dyYW0sXG4gIExheW91dFdpdGhDb250ZXh0LFxuICBPcHRpb24sXG4gIENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0LFxuICBIYW5kbGVSZXN1bHQsXG4gIEJ1aWxkZXJPcCxcbiAgSGlnaExldmVsT3AsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuXG5pbXBvcnQgeyB0ZW1wbGF0ZUNvbXBpbGF0aW9uQ29udGV4dCB9IGZyb20gJy4vb3Bjb2RlLWJ1aWxkZXIvY29udGV4dCc7XG5pbXBvcnQgeyBtZXRhIH0gZnJvbSAnLi9vcGNvZGUtYnVpbGRlci9oZWxwZXJzL3NoYXJlZCc7XG5pbXBvcnQgeyBBVFRSU19CTE9DSywgV3JhcHBlZENvbXBvbmVudCB9IGZyb20gJy4vb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9jb21wb25lbnRzJztcbmltcG9ydCB7IExPQ0FMX1NIT1VMRF9MT0cgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBkZWJ1Z0NvbXBpbGVyIH0gZnJvbSAnLi9jb21waWxlcic7XG5pbXBvcnQgeyBlbmNvZGVPcCB9IGZyb20gJy4vb3Bjb2RlLWJ1aWxkZXIvZW5jb2Rlcic7XG5pbXBvcnQgeyBIaWdoTGV2ZWxTdGF0ZW1lbnRPcCB9IGZyb20gJy4vc3ludGF4L2NvbXBpbGVycyc7XG5cbmV4cG9ydCBjbGFzcyBXcmFwcGVkQnVpbGRlciBpbXBsZW1lbnRzIENvbXBpbGFibGVQcm9ncmFtIHtcbiAgcHVibGljIHN5bWJvbFRhYmxlOiBQcm9ncmFtU3ltYm9sVGFibGU7XG4gIHByaXZhdGUgY29tcGlsZWQ6IE9wdGlvbjxudW1iZXI+ID0gbnVsbDtcbiAgcHJpdmF0ZSBhdHRyc0Jsb2NrTnVtYmVyOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBsYXlvdXQ6IExheW91dFdpdGhDb250ZXh0LCBwdWJsaWMgbW9kdWxlTmFtZTogc3RyaW5nKSB7XG4gICAgbGV0IHsgYmxvY2sgfSA9IGxheW91dDtcbiAgICBsZXQgWywgc3ltYm9scywgaGFzRXZhbF0gPSBibG9jaztcblxuICAgIHN5bWJvbHMgPSBzeW1ib2xzLnNsaWNlKCk7XG5cbiAgICAvLyBlbnN1cmUgQVRUUlNfQkxPQ0sgaXMgYWx3YXlzIGluY2x1ZGVkIChvbmx5IG9uY2UpIGluIHRoZSBsaXN0IG9mIHN5bWJvbHNcbiAgICBsZXQgYXR0cnNCbG9ja0luZGV4ID0gc3ltYm9scy5pbmRleE9mKEFUVFJTX0JMT0NLKTtcbiAgICBpZiAoYXR0cnNCbG9ja0luZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy5hdHRyc0Jsb2NrTnVtYmVyID0gc3ltYm9scy5wdXNoKEFUVFJTX0JMT0NLKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hdHRyc0Jsb2NrTnVtYmVyID0gYXR0cnNCbG9ja0luZGV4ICsgMTtcbiAgICB9XG5cbiAgICB0aGlzLnN5bWJvbFRhYmxlID0ge1xuICAgICAgaGFzRXZhbCxcbiAgICAgIHN5bWJvbHMsXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBpbGUoc3ludGF4OiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCk6IEhhbmRsZVJlc3VsdCB7XG4gICAgaWYgKHRoaXMuY29tcGlsZWQgIT09IG51bGwpIHJldHVybiB0aGlzLmNvbXBpbGVkO1xuXG4gICAgbGV0IG0gPSBtZXRhKHRoaXMubGF5b3V0KTtcbiAgICBsZXQgY29udGV4dCA9IHRlbXBsYXRlQ29tcGlsYXRpb25Db250ZXh0KHN5bnRheCwgbSk7XG5cbiAgICBsZXQge1xuICAgICAgZW5jb2RlcixcbiAgICAgIHByb2dyYW06IHsgY29uc3RhbnRzLCByZXNvbHZlciB9LFxuICAgIH0gPSBjb250ZXh0O1xuXG4gICAgZnVuY3Rpb24gcHVzaE9wKC4uLm9wOiBCdWlsZGVyT3AgfCBIaWdoTGV2ZWxPcCB8IEhpZ2hMZXZlbFN0YXRlbWVudE9wKSB7XG4gICAgICBlbmNvZGVPcChlbmNvZGVyLCBjb25zdGFudHMsIHJlc29sdmVyLCBtLCBvcCBhcyBCdWlsZGVyT3AgfCBIaWdoTGV2ZWxPcCk7XG4gICAgfVxuXG4gICAgV3JhcHBlZENvbXBvbmVudChwdXNoT3AsIHRoaXMubGF5b3V0LCB0aGlzLmF0dHJzQmxvY2tOdW1iZXIpO1xuXG4gICAgbGV0IGhhbmRsZSA9IGNvbnRleHQuZW5jb2Rlci5jb21taXQobS5zaXplKTtcblxuICAgIGlmICh0eXBlb2YgaGFuZGxlICE9PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBpbGVkID0gaGFuZGxlO1xuXG4gICAgaWYgKExPQ0FMX1NIT1VMRF9MT0cpIHtcbiAgICAgIGRlYnVnQ29tcGlsZXIoY29udGV4dCwgaGFuZGxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9