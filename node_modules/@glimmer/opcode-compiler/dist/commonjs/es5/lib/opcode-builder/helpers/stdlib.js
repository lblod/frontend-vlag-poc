"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.main = main;
exports.StdAppend = StdAppend;
exports.compileStd = compileStd;

var _vm = require("@glimmer/vm");

var _components = require("./components");

var _stdlib = require("../stdlib");

var _encoder = require("../encoder");

var _conditional = require("./conditional");

var _vm2 = require("./vm");

function main(op) {
  op(75
  /* Main */
  , _vm.$s0);
  (0, _components.invokePreparedComponent)(op, false, false, true);
}
/**
 * Append content to the DOM. This standard function triages content and does the
 * right thing based upon whether it's a string, safe string, component, fragment
 * or node.
 *
 * @param trusting whether to interpolate a string as raw HTML (corresponds to
 * triple curlies)
 */


function StdAppend(op, trusting, nonDynamicAppend) {
  (0, _conditional.SwitchCases)(op, function () {
    return op(76
    /* ContentType */
    );
  }, function (when) {
    when(2
    /* String */
    , function () {
      if (trusting) {
        op(68
        /* AssertSame */
        );
        op(43
        /* AppendHTML */
        );
      } else {
        op(47
        /* AppendText */
        );
      }
    });

    if (typeof nonDynamicAppend === 'number') {
      when(0
      /* Component */
      , function () {
        op(81
        /* ResolveCurriedComponent */
        );
        op(79
        /* PushDynamicComponentInstance */
        );
        (0, _components.InvokeBareComponent)(op);
      });
      when(1
      /* Helper */
      , function () {
        (0, _vm2.CallDynamic)(op, null, null, function () {
          op(3
          /* InvokeStatic */
          , nonDynamicAppend);
        });
      });
    } else {
      // when non-dynamic, we can no longer call the value (potentially because we've already called it)
      // this prevents infinite loops. We instead coerce the value, whatever it is, into the DOM.
      when(0
      /* Component */
      , function () {
        op(47
        /* AppendText */
        );
      });
      when(1
      /* Helper */
      , function () {
        op(47
        /* AppendText */
        );
      });
    }

    when(4
    /* SafeString */
    , function () {
      op(68
      /* AssertSame */
      );
      op(44
      /* AppendSafeHTML */
      );
    });
    when(5
    /* Fragment */
    , function () {
      op(68
      /* AssertSame */
      );
      op(45
      /* AppendDocumentFragment */
      );
    });
    when(6
    /* Node */
    , function () {
      op(68
      /* AssertSame */
      );
      op(46
      /* AppendNode */
      );
    });
  });
}

function compileStd(context) {
  var mainHandle = build(context, function (op) {
    return main(op);
  });
  var trustingGuardedNonDynamicAppend = build(context, function (op) {
    return StdAppend(op, true, null);
  });
  var cautiousGuardedNonDynamicAppend = build(context, function (op) {
    return StdAppend(op, false, null);
  });
  var trustingGuardedDynamicAppend = build(context, function (op) {
    return StdAppend(op, true, trustingGuardedNonDynamicAppend);
  });
  var cautiousGuardedDynamicAppend = build(context, function (op) {
    return StdAppend(op, false, cautiousGuardedNonDynamicAppend);
  });
  return new _stdlib.StdLib(mainHandle, trustingGuardedDynamicAppend, cautiousGuardedDynamicAppend, trustingGuardedNonDynamicAppend, cautiousGuardedNonDynamicAppend);
}

var STDLIB_META = {
  evalSymbols: null,
  upvars: null,
  moduleName: 'stdlib',
  // TODO: ??
  scopeValues: null,
  isStrictMode: true,
  owner: null,
  size: 0
};

function build(program, callback) {
  var constants = program.constants,
      heap = program.heap,
      resolver = program.resolver;
  var encoder = new _encoder.EncoderImpl(heap, STDLIB_META);

  function pushOp() {
    for (var _len = arguments.length, op = new Array(_len), _key = 0; _key < _len; _key++) {
      op[_key] = arguments[_key];
    }

    (0, _encoder.encodeOp)(encoder, constants, resolver, STDLIB_META, op);
  }

  callback(pushOp);
  var result = encoder.commit(0);

  if (typeof result !== 'number') {
    // This shouldn't be possible
    throw new Error("Unexpected errors compiling std");
  } else {
    return result;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9zdGRsaWIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBU0E7O0FBRUE7O0FBRU0sU0FBQSxJQUFBLENBQUEsRUFBQSxFQUFrQztBQUN0QyxFQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsSUFBRixPQUFFLENBQUY7QUFDQSwyQ0FBdUIsRUFBdkIsRUFBdUIsS0FBdkIsRUFBdUIsS0FBdkIsRUFBQSxJQUFBO0FBQ0Q7QUFFRDs7Ozs7Ozs7OztBQVFNLFNBQUEsU0FBQSxDQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsZ0JBQUEsRUFHMkI7QUFFL0IsZ0NBQVcsRUFBWCxFQUVFLFlBQUE7QUFBQSxXQUFNLEVBQUUsQ0FBQTtBQUFBO0FBQUEsS0FBUjtBQUZTLEdBQVgsRUFHRyxVQUFELElBQUMsRUFBUTtBQUNQLElBQUEsSUFBSSxDQUFBO0FBQUE7QUFBQSxNQUFxQixZQUFLO0FBQzVCLFVBQUEsUUFBQSxFQUFjO0FBQ1osUUFBQSxFQUFFLENBQUE7QUFBQTtBQUFBLFNBQUY7QUFDQSxRQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsU0FBRjtBQUZGLE9BQUEsTUFHTztBQUNMLFFBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxTQUFGO0FBQ0Q7QUFOSCxLQUFJLENBQUo7O0FBU0EsUUFBSSxPQUFBLGdCQUFBLEtBQUosUUFBQSxFQUEwQztBQUN4QyxNQUFBLElBQUksQ0FBQTtBQUFBO0FBQUEsUUFBd0IsWUFBSztBQUMvQixRQUFBLEVBQUUsQ0FBQTtBQUFBO0FBQUEsU0FBRjtBQUNBLFFBQUEsRUFBRSxDQUFBO0FBQUE7QUFBQSxTQUFGO0FBQ0EsNkNBQUEsRUFBQTtBQUhGLE9BQUksQ0FBSjtBQU1BLE1BQUEsSUFBSSxDQUFBO0FBQUE7QUFBQSxRQUFxQixZQUFL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QTtBQUFBLE1BRWhCLFFBRmdCLEdBRXZDLE9BRnVDLENBQUEsUUFBQTtBQUd2QyxNQUFJLE9BQU8sR0FBRyxJQUFBLG9CQUFBLENBQUEsSUFBQSxFQUFkLFdBQWMsQ0FBZDs7QUFFQSxXQUFBLE1BQUEsR0FBcUU7QUFBQSxTQUFBLElBQUEsSUFBQSxHQUFBLFNBQUEsQ0FBQSxNQUFBLEVBQXJFLEVBQXFFLEdBQUEsSUFBQSxLQUFBLENBQUEsSUFBQSxDQUFBLEVBQUEsSUFBQSxHQUFBLENBQUEsRUFBQSxJQUFBLEdBQUEsSUFBQSxFQUFBLElBQUEsRUFBQSxFQUFBO0FBQXJFLE1BQUEsRUFBcUUsQ0FBQSxJQUFBLENBQXJFLEdBQXFFLFNBQUEsQ0FBQSxJQUFBLENBQXJFO0FBQXFFOztBQUNuRSwyQkFBUSxPQUFSLEVBQVEsU0FBUixFQUFRLFFBQVIsRUFBUSxXQUFSLEVBQUEsRUFBQTtBQUNEOztBQUVELEVBQUEsUUFBUSxDQUFSLE1BQVEsQ0FBUjtBQUVBLE1BQUksTUFBTSxHQUFHLE9BQU8sQ0FBUCxNQUFBLENBQWIsQ0FBYSxDQUFiOztBQUVBLE1BQUksT0FBQSxNQUFBLEtBQUosUUFBQSxFQUFnQztBQUM5QjtBQUNBLFVBQU0sSUFBTixLQUFNLENBQU4saUNBQU0sQ0FBTjtBQUZGLEdBQUEsTUFHTztBQUNMLFdBQUEsTUFBQTtBQUNEO0FBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyAkczAgfSBmcm9tICdAZ2xpbW1lci92bSc7XG5cbmltcG9ydCB7IGludm9rZVByZXBhcmVkQ29tcG9uZW50LCBJbnZva2VCYXJlQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzJztcbmltcG9ydCB7IFN0ZExpYiB9IGZyb20gJy4uL3N0ZGxpYic7XG5pbXBvcnQgeyBlbmNvZGVPcCwgRW5jb2RlckltcGwgfSBmcm9tICcuLi9lbmNvZGVyJztcbmltcG9ydCB7XG4gIENvbnRlbnRUeXBlLFxuICBPcCxcbiAgQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIEhpZ2hMZXZlbE9wLFxuICBCdWlsZGVyT3AsXG4gIE1hY2hpbmVPcCxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBTd2l0Y2hDYXNlcyB9IGZyb20gJy4vY29uZGl0aW9uYWwnO1xuaW1wb3J0IHsgSGlnaExldmVsU3RhdGVtZW50T3AsIFB1c2hTdGF0ZW1lbnRPcCB9IGZyb20gJy4uLy4uL3N5bnRheC9jb21waWxlcnMnO1xuaW1wb3J0IHsgQ2FsbER5bmFtaWMgfSBmcm9tICcuL3ZtJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1haW4ob3A6IFB1c2hTdGF0ZW1lbnRPcCk6IHZvaWQge1xuICBvcChPcC5NYWluLCAkczApO1xuICBpbnZva2VQcmVwYXJlZENvbXBvbmVudChvcCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBBcHBlbmQgY29udGVudCB0byB0aGUgRE9NLiBUaGlzIHN0YW5kYXJkIGZ1bmN0aW9uIHRyaWFnZXMgY29udGVudCBhbmQgZG9lcyB0aGVcbiAqIHJpZ2h0IHRoaW5nIGJhc2VkIHVwb24gd2hldGhlciBpdCdzIGEgc3RyaW5nLCBzYWZlIHN0cmluZywgY29tcG9uZW50LCBmcmFnbWVudFxuICogb3Igbm9kZS5cbiAqXG4gKiBAcGFyYW0gdHJ1c3Rpbmcgd2hldGhlciB0byBpbnRlcnBvbGF0ZSBhIHN0cmluZyBhcyByYXcgSFRNTCAoY29ycmVzcG9uZHMgdG9cbiAqIHRyaXBsZSBjdXJsaWVzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gU3RkQXBwZW5kKFxuICBvcDogUHVzaFN0YXRlbWVudE9wLFxuICB0cnVzdGluZzogYm9vbGVhbixcbiAgbm9uRHluYW1pY0FwcGVuZDogbnVtYmVyIHwgbnVsbFxuKTogdm9pZCB7XG4gIFN3aXRjaENhc2VzKFxuICAgIG9wLFxuICAgICgpID0+IG9wKE9wLkNvbnRlbnRUeXBlKSxcbiAgICAod2hlbikgPT4ge1xuICAgICAgd2hlbihDb250ZW50VHlwZS5TdHJpbmcsICgpID0+IHtcbiAgICAgICAgaWYgKHRydXN0aW5nKSB7XG4gICAgICAgICAgb3AoT3AuQXNzZXJ0U2FtZSk7XG4gICAgICAgICAgb3AoT3AuQXBwZW5kSFRNTCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3AoT3AuQXBwZW5kVGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIG5vbkR5bmFtaWNBcHBlbmQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHdoZW4oQ29udGVudFR5cGUuQ29tcG9uZW50LCAoKSA9PiB7XG4gICAgICAgICAgb3AoT3AuUmVzb2x2ZUN1cnJpZWRDb21wb25lbnQpO1xuICAgICAgICAgIG9wKE9wLlB1c2hEeW5hbWljQ29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgICAgIEludm9rZUJhcmVDb21wb25lbnQob3ApO1xuICAgICAgICB9KTtcblxuICAgICAgICB3aGVuKENvbnRlbnRUeXBlLkhlbHBlciwgKCkgPT4ge1xuICAgICAgICAgIENhbGxEeW5hbWljKG9wLCBudWxsLCBudWxsLCAoKSA9PiB7XG4gICAgICAgICAgICBvcChNYWNoaW5lT3AuSW52b2tlU3RhdGljLCBub25EeW5hbWljQXBwZW5kKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3aGVuIG5vbi1keW5hbWljLCB3ZSBjYW4gbm8gbG9uZ2VyIGNhbGwgdGhlIHZhbHVlIChwb3RlbnRpYWxseSBiZWNhdXNlIHdlJ3ZlIGFscmVhZHkgY2FsbGVkIGl0KVxuICAgICAgICAvLyB0aGlzIHByZXZlbnRzIGluZmluaXRlIGxvb3BzLiBXZSBpbnN0ZWFkIGNvZXJjZSB0aGUgdmFsdWUsIHdoYXRldmVyIGl0IGlzLCBpbnRvIHRoZSBET00uXG4gICAgICAgIHdoZW4oQ29udGVudFR5cGUuQ29tcG9uZW50LCAoKSA9PiB7XG4gICAgICAgICAgb3AoT3AuQXBwZW5kVGV4dCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdoZW4oQ29udGVudFR5cGUuSGVscGVyLCAoKSA9PiB7XG4gICAgICAgICAgb3AoT3AuQXBwZW5kVGV4dCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB3aGVuKENvbnRlbnRUeXBlLlNhZmVTdHJpbmcsICgpID0+IHtcbiAgICAgICAgb3AoT3AuQXNzZXJ0U2FtZSk7XG4gICAgICAgIG9wKE9wLkFwcGVuZFNhZmVIVE1MKTtcbiAgICAgIH0pO1xuXG4gICAgICB3aGVuKENvbnRlbnRUeXBlLkZyYWdtZW50LCAoKSA9PiB7XG4gICAgICAgIG9wKE9wLkFzc2VydFNhbWUpO1xuICAgICAgICBvcChPcC5BcHBlbmREb2N1bWVudEZyYWdtZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICB3aGVuKENvbnRlbnRUeXBlLk5vZGUsICgpID0+IHtcbiAgICAgICAgb3AoT3AuQXNzZXJ0U2FtZSk7XG4gICAgICAgIG9wKE9wLkFwcGVuZE5vZGUpO1xuICAgICAgfSk7XG4gICAgfVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZVN0ZChjb250ZXh0OiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCk6IFN0ZExpYiB7XG4gIGxldCBtYWluSGFuZGxlID0gYnVpbGQoY29udGV4dCwgKG9wKSA9PiBtYWluKG9wKSk7XG4gIGxldCB0cnVzdGluZ0d1YXJkZWROb25EeW5hbWljQXBwZW5kID0gYnVpbGQoY29udGV4dCwgKG9wKSA9PiBTdGRBcHBlbmQob3AsIHRydWUsIG51bGwpKTtcbiAgbGV0IGNhdXRpb3VzR3VhcmRlZE5vbkR5bmFtaWNBcHBlbmQgPSBidWlsZChjb250ZXh0LCAob3ApID0+IFN0ZEFwcGVuZChvcCwgZmFsc2UsIG51bGwpKTtcblxuICBsZXQgdHJ1c3RpbmdHdWFyZGVkRHluYW1pY0FwcGVuZCA9IGJ1aWxkKGNvbnRleHQsIChvcCkgPT5cbiAgICBTdGRBcHBlbmQob3AsIHRydWUsIHRydXN0aW5nR3VhcmRlZE5vbkR5bmFtaWNBcHBlbmQpXG4gICk7XG4gIGxldCBjYXV0aW91c0d1YXJkZWREeW5hbWljQXBwZW5kID0gYnVpbGQoY29udGV4dCwgKG9wKSA9PlxuICAgIFN0ZEFwcGVuZChvcCwgZmFsc2UsIGNhdXRpb3VzR3VhcmRlZE5vbkR5bmFtaWNBcHBlbmQpXG4gICk7XG5cbiAgcmV0dXJuIG5ldyBTdGRMaWIoXG4gICAgbWFpbkhhbmRsZSxcbiAgICB0cnVzdGluZ0d1YXJkZWREeW5hbWljQXBwZW5kLFxuICAgIGNhdXRpb3VzR3VhcmRlZER5bmFtaWNBcHBlbmQsXG4gICAgdHJ1c3RpbmdHdWFyZGVkTm9uRHluYW1pY0FwcGVuZCxcbiAgICBjYXV0aW91c0d1YXJkZWROb25EeW5hbWljQXBwZW5kXG4gICk7XG59XG5cbmNvbnN0IFNURExJQl9NRVRBID0ge1xuICBldmFsU3ltYm9sczogbnVsbCxcbiAgdXB2YXJzOiBudWxsLFxuICBtb2R1bGVOYW1lOiAnc3RkbGliJyxcblxuICAvLyBUT0RPOiA/P1xuICBzY29wZVZhbHVlczogbnVsbCxcbiAgaXNTdHJpY3RNb2RlOiB0cnVlLFxuICBvd25lcjogbnVsbCxcbiAgc2l6ZTogMCxcbn07XG5cbmZ1bmN0aW9uIGJ1aWxkKFxuICBwcm9ncmFtOiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCxcbiAgY2FsbGJhY2s6IChvcDogUHVzaFN0YXRlbWVudE9wKSA9PiB2b2lkXG4pOiBudW1iZXIge1xuICBsZXQgeyBjb25zdGFudHMsIGhlYXAsIHJlc29sdmVyIH0gPSBwcm9ncmFtO1xuICBsZXQgZW5jb2RlciA9IG5ldyBFbmNvZGVySW1wbChoZWFwLCBTVERMSUJfTUVUQSk7XG5cbiAgZnVuY3Rpb24gcHVzaE9wKC4uLm9wOiBCdWlsZGVyT3AgfCBIaWdoTGV2ZWxPcCB8IEhpZ2hMZXZlbFN0YXRlbWVudE9wKSB7XG4gICAgZW5jb2RlT3AoZW5jb2RlciwgY29uc3RhbnRzLCByZXNvbHZlciwgU1RETElCX01FVEEsIG9wIGFzIEJ1aWxkZXJPcCB8IEhpZ2hMZXZlbE9wKTtcbiAgfVxuXG4gIGNhbGxiYWNrKHB1c2hPcCk7XG5cbiAgbGV0IHJlc3VsdCA9IGVuY29kZXIuY29tbWl0KDApO1xuXG4gIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAnbnVtYmVyJykge1xuICAgIC8vIFRoaXMgc2hvdWxkbid0IGJlIHBvc3NpYmxlXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGVycm9ycyBjb21waWxpbmcgc3RkYCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==