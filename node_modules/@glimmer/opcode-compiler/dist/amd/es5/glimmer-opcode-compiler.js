define('@glimmer/opcode-compiler', ['exports', '@glimmer/vm', '@glimmer/manager', '@glimmer/util', '@glimmer/global-context', '@glimmer/env', '@glimmer/encoder'], function (exports, vm, manager, util, globalContext, env, encoder) { 'use strict';

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
  var NamedBlocksImpl = /*#__PURE__*/function () {
    function NamedBlocksImpl(blocks) {
      this.blocks = blocks;
      this.names = blocks ? Object.keys(blocks) : [];
    }

    var _proto = NamedBlocksImpl.prototype;

    _proto.get = function get(name) {
      if (!this.blocks) return null;
      return this.blocks[name] || null;
    };

    _proto.has = function has(name) {
      var blocks = this.blocks;
      return blocks !== null && name in blocks;
    };

    _proto["with"] = function _with(name, block) {
      var blocks = this.blocks;

      if (blocks) {
        var _assign;

        return new NamedBlocksImpl(util.assign({}, blocks, (_assign = {}, _assign[name] = block, _assign)));
      } else {
        var _NamedBlocksImpl;

        return new NamedBlocksImpl((_NamedBlocksImpl = {}, _NamedBlocksImpl[name] = block, _NamedBlocksImpl));
      }
    };

    _createClass(NamedBlocksImpl, [{
      key: "hasAny",
      get: function get() {
        return this.blocks !== null;
      }
    }]);

    return NamedBlocksImpl;
  }();
  var EMPTY_BLOCKS = new NamedBlocksImpl(null);
  function namedBlocks(blocks) {
    if (blocks === null) {
      return EMPTY_BLOCKS;
    }

    var out = util.dict();
    var keys = blocks[0],
        values = blocks[1];

    for (var i = 0; i < keys.length; i++) {
      out[keys[i]] = values[i];
    }

    return new NamedBlocksImpl(out);
  }

  function labelOperand(value) {
    return {
      type: 1
      /* Label */
      ,
      value: value
    };
  }
  function evalSymbolsOperand() {
    return {
      type: 3
      /* EvalSymbols */
      ,
      value: undefined
    };
  }
  function isStrictMode() {
    return {
      type: 2
      /* IsStrictMode */
      ,
      value: undefined
    };
  }
  function blockOperand(value) {
    return {
      type: 4
      /* Block */
      ,
      value: value
    };
  }
  function stdlibOperand(value) {
    return {
      type: 5
      /* StdLib */
      ,
      value: value
    };
  }
  function nonSmallIntOperand(value) {
    return {
      type: 6
      /* NonSmallInt */
      ,
      value: value
    };
  }
  function symbolTableOperand(value) {
    return {
      type: 7
      /* SymbolTable */
      ,
      value: value
    };
  }
  function layoutOperand(value) {
    return {
      type: 8
      /* Layout */
      ,
      value: value
    };
  }

  function isGetLikeTuple(opcode) {
    return Array.isArray(opcode) && opcode.length === 2;
  }

  function makeResolutionTypeVerifier(typeToVerify) {
    return function (opcode) {
      if (!isGetLikeTuple(opcode)) return false;
      var type = opcode[0];
      return type === 31
      /* GetStrictFree */
      || type === 32
      /* GetTemplateSymbol */
      || type === typeToVerify;
    };
  }

  var isGetFreeComponent = makeResolutionTypeVerifier(39
  /* GetFreeAsComponentHead */
  );
  var isGetFreeModifier = makeResolutionTypeVerifier(38
  /* GetFreeAsModifierHead */
  );
  var isGetFreeHelper = makeResolutionTypeVerifier(37
  /* GetFreeAsHelperHead */
  );
  var isGetFreeComponentOrHelper = makeResolutionTypeVerifier(35
  /* GetFreeAsComponentOrHelperHead */
  );
  var isGetFreeOptionalComponentOrHelper = makeResolutionTypeVerifier(34
  /* GetFreeAsComponentOrHelperHeadOrThisFallback */
  );

  function assertResolverInvariants(meta) {
    if (env.DEBUG) {
      if (!meta.upvars) {
        throw new Error('Attempted to resolve a component, helper, or modifier, but no free vars were found');
      }

      if (!meta.owner) {
        throw new Error('Attempted to resolve a component, helper, or modifier, but no owner was associated with the template it was being resolved from');
      }
    }

    return meta;
  }
  /**
   * <Foo/>
   * <Foo></Foo>
   * <Foo @arg={{true}} />
   */


  function resolveComponent(resolver, constants, meta, _ref) {
    var expr = _ref[1],
        then = _ref[2];
    var type = expr[0];

    if (env.DEBUG && expr[0] === 31
    /* GetStrictFree */
    ) {
        throw new Error("Attempted to resolve a component in a strict mode template, but that value was not in scope: " + meta.upvars[expr[1]]);
      }

    if (type === 32
    /* GetTemplateSymbol */
    ) {
        var scopeValues = meta.scopeValues,
            owner = meta.owner;
        var definition = scopeValues[expr[1]];
        then(constants.component(definition, owner));
      } else {
      var _assertResolverInvari = assertResolverInvariants(meta),
          upvars = _assertResolverInvari.upvars,
          _owner = _assertResolverInvari.owner;

      var name = upvars[expr[1]];

      var _definition = resolver.lookupComponent(name, _owner);

      if (env.DEBUG && (typeof _definition !== 'object' || _definition === null)) {
        throw new Error("Attempted to resolve `" + name + "`, which was expected to be a component, but nothing was found.");
      }

      then(constants.resolvedComponent(_definition, name));
    }
  }
  /**
   * (helper)
   * (helper arg)
   */

  function resolveHelper(resolver, constants, meta, _ref2) {
    var expr = _ref2[1],
        then = _ref2[2];
    var type = expr[0];

    if (type === 32
    /* GetTemplateSymbol */
    ) {
        var scopeValues = meta.scopeValues;
        var definition = scopeValues[expr[1]];
        then(constants.helper(definition));
      } else if (type === 31
    /* GetStrictFree */
    ) {
        then(lookupBuiltInHelper(expr, resolver, meta, constants, 'helper'));
      } else {
      var _assertResolverInvari2 = assertResolverInvariants(meta),
          upvars = _assertResolverInvari2.upvars,
          owner = _assertResolverInvari2.owner;

      var name = upvars[expr[1]];
      var helper = resolver.lookupHelper(name, owner);

      if (env.DEBUG && helper === null) {
        throw new Error("Attempted to resolve `" + name + "`, which was expected to be a helper, but nothing was found.");
      }

      then(constants.helper(helper, name));
    }
  }
  /**
   * <div {{modifier}}/>
   * <div {{modifier arg}}/>
   * <Foo {{modifier}}/>
   */

  function resolveModifier(resolver, constants, meta, _ref3) {
    var expr = _ref3[1],
        then = _ref3[2];
    var type = expr[0];

    if (type === 32
    /* GetTemplateSymbol */
    ) {
        var scopeValues = meta.scopeValues;
        var definition = scopeValues[expr[1]];
        then(constants.modifier(definition));
      } else if (type === 31
    /* GetStrictFree */
    ) {
        var _assertResolverInvari3 = assertResolverInvariants(meta),
            upvars = _assertResolverInvari3.upvars;

        var name = upvars[expr[1]];
        var modifier = resolver.lookupBuiltInModifier(name);

        if (env.DEBUG && modifier === null) {
          throw new Error("Attempted to resolve a modifier in a strict mode template, but it was not in scope: " + name);
        }

        then(constants.modifier(modifier, name));
      } else {
      var _assertResolverInvari4 = assertResolverInvariants(meta),
          _upvars = _assertResolverInvari4.upvars,
          owner = _assertResolverInvari4.owner;

      var _name = _upvars[expr[1]];

      var _modifier = resolver.lookupModifier(_name, owner);

      if (env.DEBUG && _modifier === null) {
        throw new Error("Attempted to resolve `" + _name + "`, which was expected to be a modifier, but nothing was found.");
      }

      then(constants.modifier(_modifier, _name));
    }
  }
  /**
   * {{component-or-helper arg}}
   */

  function resolveComponentOrHelper(resolver, constants, meta, _ref4) {
    var expr = _ref4[1],
        _ref4$ = _ref4[2],
        ifComponent = _ref4$.ifComponent,
        ifHelper = _ref4$.ifHelper;
    var type = expr[0];

    if (type === 32
    /* GetTemplateSymbol */
    ) {
        var scopeValues = meta.scopeValues,
            owner = meta.owner;
        var definition = scopeValues[expr[1]];
        var component = constants.component(definition, owner, true);

        if (component !== null) {
          ifComponent(component);
          return;
        }

        var helper = constants.helper(definition, null, true);

        if (env.DEBUG && helper === null) {
          throw new Error("Attempted to use a value as either a component or helper, but it did not have a component manager or helper manager associated with it. The value was: " + util.debugToString(definition));
        }

        ifHelper(helper);
      } else if (type === 31
    /* GetStrictFree */
    ) {
        ifHelper(lookupBuiltInHelper(expr, resolver, meta, constants, 'component or helper'));
      } else {
      var _assertResolverInvari5 = assertResolverInvariants(meta),
          upvars = _assertResolverInvari5.upvars,
          _owner2 = _assertResolverInvari5.owner;

      var name = upvars[expr[1]];

      var _definition2 = resolver.lookupComponent(name, _owner2);

      if (_definition2 !== null) {
        ifComponent(constants.resolvedComponent(_definition2, name));
      } else {
        var _helper = resolver.lookupHelper(name, _owner2);

        if (env.DEBUG && _helper === null) {
          throw new Error("Attempted to resolve `" + name + "`, which was expected to be a component or helper, but nothing was found.");
        }

        ifHelper(constants.helper(_helper, name));
      }
    }
  }
  /**
   * <Foo @arg={{helper}}>
   */

  function resolveOptionalHelper(resolver, constants, meta, _ref5) {
    var expr = _ref5[1],
        ifHelper = _ref5[2].ifHelper;

    var _assertResolverInvari6 = assertResolverInvariants(meta),
        upvars = _assertResolverInvari6.upvars,
        owner = _assertResolverInvari6.owner;

    var name = upvars[expr[1]];
    var helper = resolver.lookupHelper(name, owner);

    if (helper) {
      ifHelper(constants.helper(helper, name), name, meta.moduleName);
    }
  }
  /**
   * {{maybeHelperOrComponent}}
   */

  function resolveOptionalComponentOrHelper(resolver, constants, meta, _ref6) {
    var expr = _ref6[1],
        _ref6$ = _ref6[2],
        ifComponent = _ref6$.ifComponent,
        ifHelper = _ref6$.ifHelper,
        ifValue = _ref6$.ifValue;
    var type = expr[0];

    if (type === 32
    /* GetTemplateSymbol */
    ) {
        var scopeValues = meta.scopeValues,
            owner = meta.owner;
        var definition = scopeValues[expr[1]];

        if (typeof definition !== 'function' && (typeof definition !== 'object' || definition === null)) {
          // The value is not an object, so it can't be a component or helper.
          ifValue(constants.value(definition));
          return;
        }

        var component = constants.component(definition, owner, true);

        if (component !== null) {
          ifComponent(component);
          return;
        }

        var helper = constants.helper(definition, null, true);

        if (helper !== null) {
          ifHelper(helper);
          return;
        }

        ifValue(constants.value(definition));
      } else if (type === 31
    /* GetStrictFree */
    ) {
        ifHelper(lookupBuiltInHelper(expr, resolver, meta, constants, 'value'));
      } else {
      var _assertResolverInvari7 = assertResolverInvariants(meta),
          upvars = _assertResolverInvari7.upvars,
          _owner3 = _assertResolverInvari7.owner;

      var name = upvars[expr[1]];

      var _definition3 = resolver.lookupComponent(name, _owner3);

      if (_definition3 !== null) {
        ifComponent(constants.resolvedComponent(_definition3, name));
        return;
      }

      var _helper2 = resolver.lookupHelper(name, _owner3);

      if (_helper2 !== null) {
        ifHelper(constants.helper(_helper2, name));
      }
    }
  }

  function lookupBuiltInHelper(expr, resolver, meta, constants, type) {
    var _assertResolverInvari8 = assertResolverInvariants(meta),
        upvars = _assertResolverInvari8.upvars;

    var name = upvars[expr[1]];
    var helper = resolver.lookupBuiltInHelper(name);

    if (env.DEBUG && helper === null) {
      // Keyword helper did not exist, which means that we're attempting to use a
      // value of some kind that is not in scope
      throw new Error("Attempted to resolve a " + type + " in a strict mode template, but that value was not in scope: " + meta.upvars[expr[1]]);
    }

    return constants.helper(helper, name);
  }

  var Compilers = /*#__PURE__*/function () {
    function Compilers() {
      this.names = {};
      this.funcs = [];
    }

    var _proto = Compilers.prototype;

    _proto.add = function add(name, func) {
      this.names[name] = this.funcs.push(func) - 1;
    };

    _proto.compile = function compile(op, sexp) {
      var name = sexp[0];
      var index = this.names[name];
      var func = this.funcs[index];
      func(op, sexp);
    };

    return Compilers;
  }();

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  var EXPRESSIONS = new Compilers();
  EXPRESSIONS.add(29
  /* Concat */
  , function (op, _ref) {
    var parts = _ref[1];

    for (var _iterator = _createForOfIteratorHelperLoose(parts), _step; !(_step = _iterator()).done;) {
      var part = _step.value;
      expr(op, part);
    }

    op(27
    /* Concat */
    , parts.length);
  });
  EXPRESSIONS.add(28
  /* Call */
  , function (op, _ref2) {
    var expression = _ref2[1],
        positional = _ref2[2],
        named = _ref2[3];

    if (isGetFreeHelper(expression)) {
      op(1005
      /* ResolveHelper */
      , expression, function (handle) {
        Call(op, handle, positional, named);
      });
    } else {
      expr(op, expression);
      CallDynamic(op, positional, named);
    }
  });
  EXPRESSIONS.add(50
  /* Curry */
  , function (op, _ref3) {
    var expr = _ref3[1],
        type = _ref3[2],
        positional = _ref3[3],
        named = _ref3[4];
    Curry(op, type, expr, positional, named);
  });
  EXPRESSIONS.add(30
  /* GetSymbol */
  , function (op, _ref4) {
    var sym = _ref4[1],
        path = _ref4[2];
    op(21
    /* GetVariable */
    , sym);
    withPath(op, path);
  });
  EXPRESSIONS.add(32
  /* GetTemplateSymbol */
  , function (op, _ref5) {
    var sym = _ref5[1],
        path = _ref5[2];
    op(1011
    /* ResolveTemplateLocal */
    , sym, function (handle) {
      op(29
      /* ConstantReference */
      , handle);
      withPath(op, path);
    });
  });
  EXPRESSIONS.add(31
  /* GetStrictFree */
  , function (op, _ref6) {
    var sym = _ref6[1],
        _path = _ref6[2];
    op(1009
    /* ResolveFree */
    , sym, function (_handle) {// TODO: Implement in strict mode
    });
  });
  EXPRESSIONS.add(34
  /* GetFreeAsComponentOrHelperHeadOrThisFallback */
  , function () {
    // TODO: The logic for this opcode currently exists in STATEMENTS.Append, since
    // we want different wrapping logic depending on if we are invoking a component,
    // helper, or {{this}} fallback. Eventually we fix the opcodes so that we can
    // traverse the subexpression tree like normal in this location.
    throw new Error('unimplemented opcode');
  });
  EXPRESSIONS.add(36
  /* GetFreeAsHelperHeadOrThisFallback */
  , function (op, expr) {
    // <div id={{baz}}>
    op(1010
    /* ResolveLocal */
    , expr[1], function (_name) {
      op(1006
      /* ResolveOptionalHelper */
      , expr, {
        ifHelper: function ifHelper(handle) {
          Call(op, handle, null, null);
        }
      });
    });
  });
  EXPRESSIONS.add(99
  /* GetFreeAsDeprecatedHelperHeadOrThisFallback */
  , function (op, expr) {
    // <Foo @bar={{baz}}>
    op(1010
    /* ResolveLocal */
    , expr[1], function (_name) {
      op(1006
      /* ResolveOptionalHelper */
      , expr, {
        ifHelper: function ifHelper(handle, name, moduleName) {
          globalContext.assert(expr[2] && expr[2].length === 1, '[BUG] Missing argument name');
          var arg = expr[2][0];
          globalContext.deprecate("The `" + name + "` helper was used in the `" + moduleName + "` template as `" + arg + "={{" + name + "}}`. " + ("This is ambigious between wanting the `" + arg + "` argument to be the `" + name + "` helper itself, ") + ("or the result of invoking the `" + name + "` helper (current behavior). ") + "This implicit invocation behavior has been deprecated.\n\n" + ("Instead, please explicitly invoke the helper with parenthesis, i.e. `" + arg + "={{(" + name + ")}}`.\n\n") + "Note: the parenthesis are only required in this exact scenario where an ambiguity is present \u2013 where " + ("`" + name + "` referes to a global helper (as opposed to a local variable), AND ") + ("the `" + name + "` helper invocation does not take any arguments, AND ") + "this occurs in a named argument position of a component invocation.\n\n" + "We expect this combination to be quite rare, as most helpers require at least one argument. " + "There is no need to refactor helper invocations in cases where this deprecation was not triggered.", false, {
            id: 'argument-less-helper-paren-less-invocation'
          });
          Call(op, handle, null, null);
        }
      });
    });
  });

  function withPath(op, path) {
    if (path === undefined || path.length === 0) return;

    for (var i = 0; i < path.length; i++) {
      op(22
      /* GetProperty */
      , path[i]);
    }
  }

  EXPRESSIONS.add(27
  /* Undefined */
  , function (op) {
    return PushPrimitiveReference(op, undefined);
  });
  EXPRESSIONS.add(48
  /* HasBlock */
  , function (op, _ref7) {
    var block = _ref7[1];
    expr(op, block);
    op(25
    /* HasBlock */
    );
  });
  EXPRESSIONS.add(49
  /* HasBlockParams */
  , function (op, _ref8) {
    var block = _ref8[1];
    expr(op, block);
    op(24
    /* SpreadBlock */
    );
    op(61
    /* CompileBlock */
    );
    op(26
    /* HasBlockParams */
    );
  });
  EXPRESSIONS.add(52
  /* IfInline */
  , function (op, _ref9) {
    var condition = _ref9[1],
        truthy = _ref9[2],
        falsy = _ref9[3];
    // Push in reverse order
    expr(op, falsy);
    expr(op, truthy);
    expr(op, condition);
    op(109
    /* IfInline */
    );
  });
  EXPRESSIONS.add(51
  /* Not */
  , function (op, _ref10) {
    var value = _ref10[1];
    expr(op, value);
    op(110
    /* Not */
    );
  });
  EXPRESSIONS.add(53
  /* GetDynamicVar */
  , function (op, _ref11) {
    var expression = _ref11[1];
    expr(op, expression);
    op(111
    /* GetDynamicVar */
    );
  });
  EXPRESSIONS.add(54
  /* Log */
  , function (op, _ref12) {
    var positional = _ref12[1];
    op(0
    /* PushFrame */
    );
    SimpleArgs(op, positional, null, false);
    op(112
    /* Log */
    );
    op(1
    /* PopFrame */
    );
    op(36
    /* Fetch */
    , vm.$v0);
  });

  function expr(op, expression) {
    if (Array.isArray(expression)) {
      EXPRESSIONS.compile(op, expression);
    } else {
      PushPrimitive(op, expression);
      op(31
      /* PrimitiveReference */
      );
    }
  }

  /**
   * Compile arguments, pushing an Arguments object onto the stack.
   *
   * @param args.params
   * @param args.hash
   * @param args.blocks
   * @param args.atNames
   */

  function CompileArgs(op, positional, named, blocks, atNames) {
    var blockNames = blocks.names;

    for (var i = 0; i < blockNames.length; i++) {
      PushYieldableBlock(op, blocks.get(blockNames[i]));
    }

    var count = CompilePositional(op, positional);
    var flags = count << 4;
    if (atNames) flags |= 8;

    if (blocks) {
      flags |= 7;
    }

    var names = util.EMPTY_ARRAY;

    if (named) {
      names = named[0];
      var val = named[1];

      for (var _i = 0; _i < val.length; _i++) {
        expr(op, val[_i]);
      }
    }

    op(82
    /* PushArgs */
    , names, blockNames, flags);
  }
  function SimpleArgs(op, positional, named, atNames) {
    if (positional === null && named === null) {
      op(83
      /* PushEmptyArgs */
      );
      return;
    }

    var count = CompilePositional(op, positional);
    var flags = count << 4;
    if (atNames) flags |= 8;
    var names = util.EMPTY_STRING_ARRAY;

    if (named) {
      names = named[0];
      var val = named[1];

      for (var i = 0; i < val.length; i++) {
        expr(op, val[i]);
      }
    }

    op(82
    /* PushArgs */
    , names, util.EMPTY_STRING_ARRAY, flags);
  }
  /**
   * Compile an optional list of positional arguments, which pushes each argument
   * onto the stack and returns the number of parameters compiled
   *
   * @param positional an optional list of positional arguments
   */

  function CompilePositional(op, positional) {
    if (positional === null) return 0;

    for (var i = 0; i < positional.length; i++) {
      expr(op, positional[i]);
    }

    return positional.length;
  }
  function meta(layout) {
    var _a, _b;

    var _layout$block = layout.block,
        symbols = _layout$block[1],
        upvars = _layout$block[3];
    return {
      evalSymbols: evalSymbols(layout),
      upvars: upvars,
      scopeValues: (_b = (_a = layout.scope) === null || _a === void 0 ? void 0 : _a.call(layout)) !== null && _b !== void 0 ? _b : null,
      isStrictMode: layout.isStrictMode,
      moduleName: layout.moduleName,
      owner: layout.owner,
      size: symbols.length
    };
  }
  function evalSymbols(layout) {
    var block = layout.block;
    var symbols = block[1],
        hasEval = block[2];
    return hasEval ? symbols : null;
  }

  /**
   * Push a reference onto the stack corresponding to a statically known primitive
   * @param value A JavaScript primitive (undefined, null, boolean, number or string)
   */

  function PushPrimitiveReference(op, value) {
    PushPrimitive(op, value);
    op(31
    /* PrimitiveReference */
    );
  }
  /**
   * Push an encoded representation of a JavaScript primitive on the stack
   *
   * @param value A JavaScript primitive (undefined, null, boolean, number or string)
   */

  function PushPrimitive(op, primitive) {
    var p = primitive;

    if (typeof p === 'number') {
      p = util.isSmallInt(p) ? util.encodeImmediate(p) : nonSmallIntOperand(p);
    }

    op(30
    /* Primitive */
    , p);
  }
  /**
   * Invoke a foreign function (a "helper") based on a statically known handle
   *
   * @param op The op creation function
   * @param handle A handle
   * @param positional An optional list of expressions to compile
   * @param named An optional list of named arguments (name + expression) to compile
   */

  function Call(op, handle, positional, named) {
    op(0
    /* PushFrame */
    );
    SimpleArgs(op, positional, named, false);
    op(16
    /* Helper */
    , handle);
    op(1
    /* PopFrame */
    );
    op(36
    /* Fetch */
    , vm.$v0);
  }
  /**
   * Invoke a foreign function (a "helper") based on a dynamically loaded definition
   *
   * @param op The op creation function
   * @param positional An optional list of expressions to compile
   * @param named An optional list of named arguments (name + expression) to compile
   */

  function CallDynamic(op, positional, named, append) {
    op(0
    /* PushFrame */
    );
    SimpleArgs(op, positional, named, false);
    op(33
    /* Dup */
    , vm.$fp, 1);
    op(107
    /* DynamicHelper */
    );

    if (append) {
      op(36
      /* Fetch */
      , vm.$v0);
      append();
      op(1
      /* PopFrame */
      );
      op(34
      /* Pop */
      , 1);
    } else {
      op(1
      /* PopFrame */
      );
      op(34
      /* Pop */
      , 1);
      op(36
      /* Fetch */
      , vm.$v0);
    }
  }
  /**
   * Evaluate statements in the context of new dynamic scope entries. Move entries from the
   * stack into named entries in the dynamic scope, then evaluate the statements, then pop
   * the dynamic scope
   *
   * @param names a list of dynamic scope names
   * @param block a function that returns a list of statements to evaluate
   */

  function DynamicScope(op, names, block) {
    op(59
    /* PushDynamicScope */
    );
    op(58
    /* BindDynamicScope */
    , names);
    block();
    op(60
    /* PopDynamicScope */
    );
  }
  function Curry(op, type, definition, positional, named) {
    op(0
    /* PushFrame */
    );
    SimpleArgs(op, positional, named, false);
    op(86
    /* CaptureArgs */
    );
    expr(op, definition);
    op(77
    /* Curry */
    , type, isStrictMode());
    op(1
    /* PopFrame */
    );
    op(36
    /* Fetch */
    , vm.$v0);
  }

  /**
   * Yield to a block located at a particular symbol location.
   *
   * @param to the symbol containing the block to yield to
   * @param params optional block parameters to yield to the block
   */

  function YieldBlock(op, to, positional) {
    SimpleArgs(op, positional, null, true);
    op(23
    /* GetBlock */
    , to);
    op(24
    /* SpreadBlock */
    );
    op(61
    /* CompileBlock */
    );
    op(64
    /* InvokeYield */
    );
    op(40
    /* PopScope */
    );
    op(1
    /* PopFrame */
    );
  }
  /**
   * Push an (optional) yieldable block onto the stack. The yieldable block must be known
   * statically at compile time.
   *
   * @param block An optional Compilable block
   */

  function PushYieldableBlock(op, block) {
    PushSymbolTable(op, block && block[1]);
    op(62
    /* PushBlockScope */
    );
    PushCompilable(op, block);
  }
  /**
   * Invoke a block that is known statically at compile time.
   *
   * @param block a Compilable block
   */

  function InvokeStaticBlock(op, block) {
    op(0
    /* PushFrame */
    );
    PushCompilable(op, block);
    op(61
    /* CompileBlock */
    );
    op(2
    /* InvokeVirtual */
    );
    op(1
    /* PopFrame */
    );
  }
  /**
   * Invoke a static block, preserving some number of stack entries for use in
   * updating.
   *
   * @param block A compilable block
   * @param callerCount A number of stack entries to preserve
   */

  function InvokeStaticBlockWithStack(op, block, callerCount) {
    var parameters = block[1];
    var calleeCount = parameters.length;
    var count = Math.min(callerCount, calleeCount);

    if (count === 0) {
      InvokeStaticBlock(op, block);
      return;
    }

    op(0
    /* PushFrame */
    );

    if (count) {
      op(39
      /* ChildScope */
      );

      for (var i = 0; i < count; i++) {
        op(33
        /* Dup */
        , vm.$fp, callerCount - i);
        op(19
        /* SetVariable */
        , parameters[i]);
      }
    }

    PushCompilable(op, block);
    op(61
    /* CompileBlock */
    );
    op(2
    /* InvokeVirtual */
    );

    if (count) {
      op(40
      /* PopScope */
      );
    }

    op(1
    /* PopFrame */
    );
  }
  function PushSymbolTable(op, parameters) {
    if (parameters !== null) {
      op(63
      /* PushSymbolTable */
      , symbolTableOperand({
        parameters: parameters
      }));
    } else {
      PushPrimitive(op, null);
    }
  }
  function PushCompilable(op, _block) {
    if (_block === null) {
      PushPrimitive(op, null);
    } else {
      op(28
      /* Constant */
      , blockOperand(_block));
    }
  }

  function _createForOfIteratorHelperLoose$1(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

  function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

  function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  function SwitchCases(op, bootstrap, callback) {
    // Setup the switch DSL
    var clauses = [];
    var count = 0;

    function when(match, callback) {
      clauses.push({
        match: match,
        callback: callback,
        label: "CLAUSE" + count++
      });
    } // Call the callback


    callback(when); // Emit the opcodes for the switch

    op(69
    /* Enter */
    , 1);
    bootstrap();
    op(1001
    /* StartLabels */
    ); // First, emit the jump opcodes. We don't need a jump for the last
    // opcode, since it bleeds directly into its clause.

    for (var _iterator = _createForOfIteratorHelperLoose$1(clauses.slice(0, -1)), _step; !(_step = _iterator()).done;) {
      var _clause = _step.value;
      op(67
      /* JumpEq */
      , labelOperand(_clause.label), _clause.match);
    } // Enumerate the clauses in reverse order. Earlier matches will
    // require fewer checks.


    for (var i = clauses.length - 1; i >= 0; i--) {
      var clause = clauses[i];
      op(1000
      /* Label */
      , clause.label);
      op(34
      /* Pop */
      , 1);
      clause.callback(); // The first match is special: it is placed directly before the END
      // label, so no additional jump is needed at the end of it.

      if (i !== 0) {
        op(4
        /* Jump */
        , labelOperand('END'));
      }
    }

    op(1000
    /* Label */
    , 'END');
    op(1002
    /* StopLabels */
    );
    op(70
    /* Exit */
    );
  }
  /**
   * A convenience for pushing some arguments on the stack and
   * running some code if the code needs to be re-executed during
   * updating execution if some of the arguments have changed.
   *
   * # Initial Execution
   *
   * The `args` function should push zero or more arguments onto
   * the stack and return the number of arguments pushed.
   *
   * The `body` function provides the instructions to execute both
   * during initial execution and during updating execution.
   *
   * Internally, this function starts by pushing a new frame, so
   * that the body can return and sets the return point ($ra) to
   * the ENDINITIAL label.
   *
   * It then executes the `args` function, which adds instructions
   * responsible for pushing the arguments for the block to the
   * stack. These arguments will be restored to the stack before
   * updating execution.
   *
   * Next, it adds the Enter opcode, which marks the current position
   * in the DOM, and remembers the current $pc (the next instruction)
   * as the first instruction to execute during updating execution.
   *
   * Next, it runs `body`, which adds the opcodes that should
   * execute both during initial execution and during updating execution.
   * If the `body` wishes to finish early, it should Jump to the
   * `FINALLY` label.
   *
   * Next, it adds the FINALLY label, followed by:
   *
   * - the Exit opcode, which finalizes the marked DOM started by the
   *   Enter opcode.
   * - the Return opcode, which returns to the current return point
   *   ($ra).
   *
   * Finally, it adds the ENDINITIAL label followed by the PopFrame
   * instruction, which restores $fp, $sp and $ra.
   *
   * # Updating Execution
   *
   * Updating execution for this `replayable` occurs if the `body` added an
   * assertion, via one of the `JumpIf`, `JumpUnless` or `AssertSame` opcodes.
   *
   * If, during updating executon, the assertion fails, the initial VM is
   * restored, and the stored arguments are pushed onto the stack. The DOM
   * between the starting and ending markers is cleared, and the VM's cursor
   * is set to the area just cleared.
   *
   * The return point ($ra) is set to -1, the exit instruction.
   *
   * Finally, the $pc is set to to the instruction saved off by the
   * Enter opcode during initial execution, and execution proceeds as
   * usual.
   *
   * The only difference is that when a `Return` instruction is
   * encountered, the program jumps to -1 rather than the END label,
   * and the PopFrame opcode is not needed.
   */

  function Replayable(op, args, body) {
    // Start a new label frame, to give END and RETURN
    // a unique meaning.
    op(1001
    /* StartLabels */
    );
    op(0
    /* PushFrame */
    ); // If the body invokes a block, its return will return to
    // END. Otherwise, the return in RETURN will return to END.

    op(6
    /* ReturnTo */
    , labelOperand('ENDINITIAL')); // Push the arguments onto the stack. The args() function
    // tells us how many stack elements to retain for re-execution
    // when updating.

    var count = args(); // Start a new updating closure, remembering `count` elements
    // from the stack. Everything after this point, and before END,
    // will execute both initially and to update the block.
    //
    // The enter and exit opcodes also track the area of the DOM
    // associated with this block. If an assertion inside the block
    // fails (for example, the test value changes from true to false
    // in an #if), the DOM is cleared and the program is re-executed,
    // restoring `count` elements to the stack and executing the
    // instructions between the enter and exit.

    op(69
    /* Enter */
    , count); // Evaluate the body of the block. The body of the block may
    // return, which will jump execution to END during initial
    // execution, and exit the updating routine.

    body(); // All execution paths in the body should run the FINALLY once
    // they are done. It is executed both during initial execution
    // and during updating execution.

    op(1000
    /* Label */
    , 'FINALLY'); // Finalize the DOM.

    op(70
    /* Exit */
    ); // In initial execution, this is a noop: it returns to the
    // immediately following opcode. In updating execution, this
    // exits the updating routine.

    op(5
    /* Return */
    ); // Cleanup code for the block. Runs on initial execution
    // but not on updating.

    op(1000
    /* Label */
    , 'ENDINITIAL');
    op(1
    /* PopFrame */
    );
    op(1002
    /* StopLabels */
    );
  }
  /**
   * A specialized version of the `replayable` convenience that allows the
   * caller to provide different code based upon whether the item at
   * the top of the stack is true or false.
   *
   * As in `replayable`, the `ifTrue` and `ifFalse` code can invoke `return`.
   *
   * During the initial execution, a `return` will continue execution
   * in the cleanup code, which finalizes the current DOM block and pops
   * the current frame.
   *
   * During the updating execution, a `return` will exit the updating
   * routine, as it can reuse the DOM block and is always only a single
   * frame deep.
   */

  function ReplayableIf(op, args, ifTrue, ifFalse) {
    return Replayable(op, args, function () {
      // If the conditional is false, jump to the ELSE label.
      op(66
      /* JumpUnless */
      , labelOperand('ELSE')); // Otherwise, execute the code associated with the true branch.

      ifTrue(); // We're done, so return. In the initial execution, this runs
      // the cleanup code. In the updating VM, it exits the updating
      // routine.

      op(4
      /* Jump */
      , labelOperand('FINALLY'));
      op(1000
      /* Label */
      , 'ELSE'); // If the conditional is false, and code associatied ith the
      // false branch was provided, execute it. If there was no code
      // associated with the false branch, jumping to the else statement
      // has no other behavior.

      if (ifFalse !== undefined) {
        ifFalse();
      }
    });
  }

  var ATTRS_BLOCK = '&attrs';
  function InvokeComponent(op, component, _elementBlock, positional, named, _blocks) {
    var compilable = component.compilable,
        capabilities = component.capabilities,
        handle = component.handle;
    var elementBlock = _elementBlock ? [_elementBlock, []] : null;
    var blocks = Array.isArray(_blocks) || _blocks === null ? namedBlocks(_blocks) : _blocks;

    if (compilable) {
      op(78
      /* PushComponentDefinition */
      , handle);
      InvokeStaticComponent(op, {
        capabilities: capabilities,
        layout: compilable,
        elementBlock: elementBlock,
        positional: positional,
        named: named,
        blocks: blocks
      });
    } else {
      op(78
      /* PushComponentDefinition */
      , handle);
      InvokeNonStaticComponent(op, {
        capabilities: capabilities,
        elementBlock: elementBlock,
        positional: positional,
        named: named,
        atNames: true,
        blocks: blocks
      });
    }
  }
  function InvokeDynamicComponent(op, definition, _elementBlock, positional, named, _blocks, atNames, curried) {
    var elementBlock = _elementBlock ? [_elementBlock, []] : null;
    var blocks = Array.isArray(_blocks) || _blocks === null ? namedBlocks(_blocks) : _blocks;
    Replayable(op, function () {
      expr(op, definition);
      op(33
      /* Dup */
      , vm.$sp, 0);
      return 2;
    }, function () {
      op(66
      /* JumpUnless */
      , labelOperand('ELSE'));

      if (curried) {
        op(81
        /* ResolveCurriedComponent */
        );
      } else {
        op(80
        /* ResolveDynamicComponent */
        , isStrictMode());
      }

      op(79
      /* PushDynamicComponentInstance */
      );
      InvokeNonStaticComponent(op, {
        capabilities: true,
        elementBlock: elementBlock,
        positional: positional,
        named: named,
        atNames: atNames,
        blocks: blocks
      });
      op(1000
      /* Label */
      , 'ELSE');
    });
  }

  function InvokeStaticComponent(op, _ref) {
    var capabilities = _ref.capabilities,
        layout = _ref.layout,
        elementBlock = _ref.elementBlock,
        positional = _ref.positional,
        named = _ref.named,
        blocks = _ref.blocks;
    var symbolTable = layout.symbolTable;
    var bailOut = symbolTable.hasEval || manager.hasCapability(capabilities, 4
    /* PrepareArgs */
    );

    if (bailOut) {
      InvokeNonStaticComponent(op, {
        capabilities: capabilities,
        elementBlock: elementBlock,
        positional: positional,
        named: named,
        atNames: true,
        blocks: blocks,
        layout: layout
      });
      return;
    }

    op(36
    /* Fetch */
    , vm.$s0);
    op(33
    /* Dup */
    , vm.$sp, 1);
    op(35
    /* Load */
    , vm.$s0);
    op(0
    /* PushFrame */
    ); // Setup arguments

    var symbols = symbolTable.symbols; // As we push values onto the stack, we store the symbols associated  with them
    // so that we can set them on the scope later on with SetVariable and SetBlock

    var blockSymbols = [];
    var argSymbols = [];
    var argNames = []; // First we push the blocks onto the stack

    var blockNames = blocks.names; // Starting with the attrs block, if it exists and is referenced in the component

    if (elementBlock !== null) {
      var symbol = symbols.indexOf(ATTRS_BLOCK);

      if (symbol !== -1) {
        PushYieldableBlock(op, elementBlock);
        blockSymbols.push(symbol);
      }
    } // Followed by the other blocks, if they exist and are referenced in the component.
    // Also store the index of the associated symbol.


    for (var i = 0; i < blockNames.length; i++) {
      var name = blockNames[i];

      var _symbol = symbols.indexOf("&" + name);

      if (_symbol !== -1) {
        PushYieldableBlock(op, blocks.get(name));
        blockSymbols.push(_symbol);
      }
    } // Next up we have arguments. If the component has the `createArgs` capability,
    // then it wants access to the arguments in JavaScript. We can't know whether
    // or not an argument is used, so we have to give access to all of them.


    if (manager.hasCapability(capabilities, 8
    /* CreateArgs */
    )) {
      // First we push positional arguments
      var count = CompilePositional(op, positional); // setup the flags with the count of positionals, and to indicate that atNames
      // are used

      var flags = count << 4;
      flags |= 8;
      var names = util.EMPTY_STRING_ARRAY; // Next, if named args exist, push them all. If they have an associated symbol
      // in the invoked component (e.g. they are used within its template), we push
      // that symbol. If not, we still push the expression as it may be used, and
      // we store the symbol as -1 (this is used later).

      if (named !== null) {
        names = named[0];
        var val = named[1];

        for (var _i = 0; _i < val.length; _i++) {
          var _symbol2 = symbols.indexOf(names[_i]);

          expr(op, val[_i]);
          argSymbols.push(_symbol2);
        }
      } // Finally, push the VM arguments themselves. These args won't need access
      // to blocks (they aren't accessible from userland anyways), so we push an
      // empty array instead of the actual block names.


      op(82
      /* PushArgs */
      , names, util.EMPTY_STRING_ARRAY, flags); // And push an extra pop operation to remove the args before we begin setting
      // variables on the local context

      argSymbols.push(-1);
    } else if (named !== null) {
      // If the component does not have the `createArgs` capability, then the only
      // expressions we need to push onto the stack are those that are actually
      // referenced in the template of the invoked component (e.g. have symbols).
      var _names = named[0];
      var _val = named[1];

      for (var _i2 = 0; _i2 < _val.length; _i2++) {
        var _name = _names[_i2];

        var _symbol3 = symbols.indexOf(_name);

        if (_symbol3 !== -1) {
          expr(op, _val[_i2]);
          argSymbols.push(_symbol3);
          argNames.push(_name);
        }
      }
    }

    op(97
    /* BeginComponentTransaction */
    , vm.$s0);

    if (manager.hasCapability(capabilities, 64
    /* DynamicScope */
    )) {
      op(59
      /* PushDynamicScope */
      );
    }

    if (manager.hasCapability(capabilities, 512
    /* CreateInstance */
    )) {
      op(87
      /* CreateComponent */
      , blocks.has('default') | 0, vm.$s0);
    }

    op(88
    /* RegisterComponentDestructor */
    , vm.$s0);

    if (manager.hasCapability(capabilities, 8
    /* CreateArgs */
    )) {
      op(90
      /* GetComponentSelf */
      , vm.$s0);
    } else {
      op(90
      /* GetComponentSelf */
      , vm.$s0, argNames);
    } // Setup the new root scope for the component


    op(37
    /* RootScope */
    , symbols.length + 1, Object.keys(blocks).length > 0 ? 1 : 0); // Pop the self reference off the stack and set it to the symbol for `this`
    // in the new scope. This is why all subsequent symbols are increased by one.

    op(19
    /* SetVariable */
    , 0); // Going in reverse, now we pop the args/blocks off the stack, starting with
    // arguments, and assign them to their symbols in the new scope.

    for (var _i3 = argSymbols.length - 1; _i3 >= 0; _i3--) {
      var _symbol4 = argSymbols[_i3];

      if (_symbol4 === -1) {
        // The expression was not bound to a local symbol, it was only pushed to be
        // used with VM args in the javascript side
        op(34
        /* Pop */
        , 1);
      } else {
        op(19
        /* SetVariable */
        , _symbol4 + 1);
      }
    } // if any positional params exist, pop them off the stack as well


    if (positional !== null) {
      op(34
      /* Pop */
      , positional.length);
    } // Finish up by popping off and assigning blocks


    for (var _i4 = blockSymbols.length - 1; _i4 >= 0; _i4--) {
      var _symbol5 = blockSymbols[_i4];
      op(20
      /* SetBlock */
      , _symbol5 + 1);
    }

    op(28
    /* Constant */
    , layoutOperand(layout));
    op(61
    /* CompileBlock */
    );
    op(2
    /* InvokeVirtual */
    );
    op(100
    /* DidRenderLayout */
    , vm.$s0);
    op(1
    /* PopFrame */
    );
    op(40
    /* PopScope */
    );

    if (manager.hasCapability(capabilities, 64
    /* DynamicScope */
    )) {
      op(60
      /* PopDynamicScope */
      );
    }

    op(98
    /* CommitComponentTransaction */
    );
    op(35
    /* Load */
    , vm.$s0);
  }

  function InvokeNonStaticComponent(op, _ref2) {
    var capabilities = _ref2.capabilities,
        elementBlock = _ref2.elementBlock,
        positional = _ref2.positional,
        named = _ref2.named,
        atNames = _ref2.atNames,
        namedBlocks = _ref2.blocks,
        layout = _ref2.layout;
    var bindableBlocks = !!namedBlocks;
    var bindableAtNames = capabilities === true || manager.hasCapability(capabilities, 4
    /* PrepareArgs */
    ) || !!(named && named[0].length !== 0);
    var blocks = namedBlocks["with"]('attrs', elementBlock);
    op(36
    /* Fetch */
    , vm.$s0);
    op(33
    /* Dup */
    , vm.$sp, 1);
    op(35
    /* Load */
    , vm.$s0);
    op(0
    /* PushFrame */
    );
    CompileArgs(op, positional, named, blocks, atNames);
    op(85
    /* PrepareArgs */
    , vm.$s0);
    invokePreparedComponent(op, blocks.has('default'), bindableBlocks, bindableAtNames, function () {
      if (layout) {
        op(63
        /* PushSymbolTable */
        , symbolTableOperand(layout.symbolTable));
        op(28
        /* Constant */
        , layoutOperand(layout));
        op(61
        /* CompileBlock */
        );
      } else {
        op(92
        /* GetComponentLayout */
        , vm.$s0);
      }

      op(95
      /* PopulateLayout */
      , vm.$s0);
    });
    op(35
    /* Load */
    , vm.$s0);
  }
  function WrappedComponent(op, layout, attrsBlockNumber) {
    op(1001
    /* StartLabels */
    );
    WithSavedRegister(op, vm.$s1, function () {
      op(91
      /* GetComponentTagName */
      , vm.$s0);
      op(31
      /* PrimitiveReference */
      );
      op(33
      /* Dup */
      , vm.$sp, 0);
    });
    op(66
    /* JumpUnless */
    , labelOperand('BODY'));
    op(36
    /* Fetch */
    , vm.$s1);
    op(89
    /* PutComponentOperations */
    );
    op(49
    /* OpenDynamicElement */
    );
    op(99
    /* DidCreateElement */
    , vm.$s0);
    YieldBlock(op, attrsBlockNumber, null);
    op(54
    /* FlushElement */
    );
    op(1000
    /* Label */
    , 'BODY');
    InvokeStaticBlock(op, [layout.block[0], []]);
    op(36
    /* Fetch */
    , vm.$s1);
    op(66
    /* JumpUnless */
    , labelOperand('END'));
    op(55
    /* CloseElement */
    );
    op(1000
    /* Label */
    , 'END');
    op(35
    /* Load */
    , vm.$s1);
    op(1002
    /* StopLabels */
    );
  }
  function invokePreparedComponent(op, hasBlock, bindableBlocks, bindableAtNames, populateLayout) {
    if (populateLayout === void 0) {
      populateLayout = null;
    }

    op(97
    /* BeginComponentTransaction */
    , vm.$s0);
    op(59
    /* PushDynamicScope */
    );
    op(87
    /* CreateComponent */
    , hasBlock | 0, vm.$s0); // this has to run after createComponent to allow
    // for late-bound layouts, but a caller is free
    // to populate the layout earlier if it wants to
    // and do nothing here.

    if (populateLayout) {
      populateLayout();
    }

    op(88
    /* RegisterComponentDestructor */
    , vm.$s0);
    op(90
    /* GetComponentSelf */
    , vm.$s0);
    op(38
    /* VirtualRootScope */
    , vm.$s0);
    op(19
    /* SetVariable */
    , 0);
    op(94
    /* SetupForEval */
    , vm.$s0);
    if (bindableAtNames) op(17
    /* SetNamedVariables */
    , vm.$s0);
    if (bindableBlocks) op(18
    /* SetBlocks */
    , vm.$s0);
    op(34
    /* Pop */
    , 1);
    op(96
    /* InvokeComponentLayout */
    , vm.$s0);
    op(100
    /* DidRenderLayout */
    , vm.$s0);
    op(1
    /* PopFrame */
    );
    op(40
    /* PopScope */
    );
    op(60
    /* PopDynamicScope */
    );
    op(98
    /* CommitComponentTransaction */
    );
  }
  function InvokeBareComponent(op) {
    op(36
    /* Fetch */
    , vm.$s0);
    op(33
    /* Dup */
    , vm.$sp, 1);
    op(35
    /* Load */
    , vm.$s0);
    op(0
    /* PushFrame */
    );
    op(83
    /* PushEmptyArgs */
    );
    op(85
    /* PrepareArgs */
    , vm.$s0);
    invokePreparedComponent(op, false, false, true, function () {
      op(92
      /* GetComponentLayout */
      , vm.$s0);
      op(95
      /* PopulateLayout */
      , vm.$s0);
    });
    op(35
    /* Load */
    , vm.$s0);
  }
  function WithSavedRegister(op, register, block) {
    op(36
    /* Fetch */
    , register);
    block();
    op(35
    /* Load */
    , register);
  }

  function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }

  var StdLib = /*#__PURE__*/function () {
    function StdLib(main, trustingGuardedAppend, cautiousGuardedAppend, trustingNonDynamicAppend, cautiousNonDynamicAppend) {
      this.main = main;
      this.trustingGuardedAppend = trustingGuardedAppend;
      this.cautiousGuardedAppend = cautiousGuardedAppend;
      this.trustingNonDynamicAppend = trustingNonDynamicAppend;
      this.cautiousNonDynamicAppend = cautiousNonDynamicAppend;
    }

    var _proto = StdLib.prototype;

    _proto.getAppend = function getAppend(trusting) {
      return trusting ? this.trustingGuardedAppend : this.cautiousGuardedAppend;
    };

    _createClass$1(StdLib, [{
      key: 'trusting-append',
      get: function get() {
        return this.trustingGuardedAppend;
      }
    }, {
      key: 'cautious-append',
      get: function get() {
        return this.cautiousGuardedAppend;
      }
    }, {
      key: 'trusting-non-dynamic-append',
      get: function get() {
        return this.trustingNonDynamicAppend;
      }
    }, {
      key: 'cautious-non-dynamic-append',
      get: function get() {
        return this.cautiousNonDynamicAppend;
      }
    }]);

    return StdLib;
  }();

  function programCompilationContext(artifacts, resolver) {
    return new CompileTimeCompilationContextImpl(artifacts, resolver);
  }
  function templateCompilationContext(program, meta) {
    var encoder = new EncoderImpl(program.heap, meta, program.stdlib);
    return {
      program: program,
      encoder: encoder,
      meta: meta
    };
  }

  var debugCompiler;

  var STATEMENTS = new Compilers();
  var INFLATE_ATTR_TABLE = ['class', 'id', 'value', 'name', 'type', 'style', 'href'];
  var INFLATE_TAG_TABLE = ['div', 'span', 'p', 'a'];
  function inflateTagName(tagName) {
    return typeof tagName === 'string' ? tagName : INFLATE_TAG_TABLE[tagName];
  }
  function inflateAttrName(attrName) {
    return typeof attrName === 'string' ? attrName : INFLATE_ATTR_TABLE[attrName];
  }
  STATEMENTS.add(3
  /* Comment */
  , function (op, sexp) {
    return op(42
    /* Comment */
    , sexp[1]);
  });
  STATEMENTS.add(13
  /* CloseElement */
  , function (op) {
    return op(55
    /* CloseElement */
    );
  });
  STATEMENTS.add(12
  /* FlushElement */
  , function (op) {
    return op(54
    /* FlushElement */
    );
  });
  STATEMENTS.add(4
  /* Modifier */
  , function (op, _ref) {
    var expression = _ref[1],
        positional = _ref[2],
        named = _ref[3];

    if (isGetFreeModifier(expression)) {
      op(1003
      /* ResolveModifier */
      , expression, function (handle) {
        op(0
        /* PushFrame */
        );
        SimpleArgs(op, positional, named, false);
        op(57
        /* Modifier */
        , handle);
        op(1
        /* PopFrame */
        );
      });
    } else {
      expr(op, expression);
      op(0
      /* PushFrame */
      );
      SimpleArgs(op, positional, named, false);
      op(33
      /* Dup */
      , vm.$fp, 1);
      op(108
      /* DynamicModifier */
      );
      op(1
      /* PopFrame */
      );
    }
  });
  STATEMENTS.add(14
  /* StaticAttr */
  , function (op, _ref2) {
    var name = _ref2[1],
        value = _ref2[2],
        namespace = _ref2[3];
    op(51
    /* StaticAttr */
    , inflateAttrName(name), value, namespace !== null && namespace !== void 0 ? namespace : null);
  });
  STATEMENTS.add(24
  /* StaticComponentAttr */
  , function (op, _ref3) {
    var name = _ref3[1],
        value = _ref3[2],
        namespace = _ref3[3];
    op(105
    /* StaticComponentAttr */
    , inflateAttrName(name), value, namespace !== null && namespace !== void 0 ? namespace : null);
  });
  STATEMENTS.add(15
  /* DynamicAttr */
  , function (op, _ref4) {
    var name = _ref4[1],
        value = _ref4[2],
        namespace = _ref4[3];
    expr(op, value);
    op(52
    /* DynamicAttr */
    , inflateAttrName(name), false, namespace !== null && namespace !== void 0 ? namespace : null);
  });
  STATEMENTS.add(22
  /* TrustingDynamicAttr */
  , function (op, _ref5) {
    var name = _ref5[1],
        value = _ref5[2],
        namespace = _ref5[3];
    expr(op, value);
    op(52
    /* DynamicAttr */
    , inflateAttrName(name), true, namespace !== null && namespace !== void 0 ? namespace : null);
  });
  STATEMENTS.add(16
  /* ComponentAttr */
  , function (op, _ref6) {
    var name = _ref6[1],
        value = _ref6[2],
        namespace = _ref6[3];
    expr(op, value);
    op(53
    /* ComponentAttr */
    , inflateAttrName(name), false, namespace !== null && namespace !== void 0 ? namespace : null);
  });
  STATEMENTS.add(23
  /* TrustingComponentAttr */
  , function (op, _ref7) {
    var name = _ref7[1],
        value = _ref7[2],
        namespace = _ref7[3];
    expr(op, value);
    op(53
    /* ComponentAttr */
    , inflateAttrName(name), true, namespace !== null && namespace !== void 0 ? namespace : null);
  });
  STATEMENTS.add(10
  /* OpenElement */
  , function (op, _ref8) {
    var tag = _ref8[1];
    op(48
    /* OpenElement */
    , inflateTagName(tag));
  });
  STATEMENTS.add(11
  /* OpenElementWithSplat */
  , function (op, _ref9) {
    var tag = _ref9[1];
    op(89
    /* PutComponentOperations */
    );
    op(48
    /* OpenElement */
    , inflateTagName(tag));
  });
  STATEMENTS.add(8
  /* Component */
  , function (op, _ref10) {
    var expr = _ref10[1],
        elementBlock = _ref10[2],
        named = _ref10[3],
        blocks = _ref10[4];

    if (isGetFreeComponent(expr)) {
      op(1004
      /* ResolveComponent */
      , expr, function (component) {
        InvokeComponent(op, component, elementBlock, null, named, blocks);
      });
    } else {
      // otherwise, the component name was an expression, so resolve the expression
      // and invoke it as a dynamic component
      InvokeDynamicComponent(op, expr, elementBlock, null, named, blocks, true, true);
    }
  });
  STATEMENTS.add(18
  /* Yield */
  , function (op, _ref11) {
    var to = _ref11[1],
        params = _ref11[2];
    return YieldBlock(op, to, params);
  });
  STATEMENTS.add(17
  /* AttrSplat */
  , function (op, _ref12) {
    var to = _ref12[1];
    return YieldBlock(op, to, null);
  });
  STATEMENTS.add(26
  /* Debugger */
  , function (op, _ref13) {
    var evalInfo = _ref13[1];
    return op(103
    /* Debugger */
    , evalSymbolsOperand(), evalInfo);
  });
  STATEMENTS.add(1
  /* Append */
  , function (op, _ref14) {
    var value = _ref14[1];

    // Special case for static values
    if (!Array.isArray(value)) {
      op(41
      /* Text */
      , value === null || value === undefined ? '' : String(value));
    } else if (isGetFreeOptionalComponentOrHelper(value)) {
      op(1008
      /* ResolveOptionalComponentOrHelper */
      , value, {
        ifComponent: function ifComponent(component) {
          InvokeComponent(op, component, null, null, null, null);
        },
        ifHelper: function ifHelper(handle) {
          op(0
          /* PushFrame */
          );
          Call(op, handle, null, null);
          op(3
          /* InvokeStatic */
          , stdlibOperand('cautious-non-dynamic-append'));
          op(1
          /* PopFrame */
          );
        },
        ifValue: function ifValue(handle) {
          op(0
          /* PushFrame */
          );
          op(29
          /* ConstantReference */
          , handle);
          op(3
          /* InvokeStatic */
          , stdlibOperand('cautious-non-dynamic-append'));
          op(1
          /* PopFrame */
          );
        }
      });
    } else if (value[0] === 28
    /* Call */
    ) {
        var expression = value[1],
            positional = value[2],
            named = value[3];

        if (isGetFreeComponentOrHelper(expression)) {
          op(1007
          /* ResolveComponentOrHelper */
          , expression, {
            ifComponent: function ifComponent(component) {
              InvokeComponent(op, component, null, positional, hashToArgs(named), null);
            },
            ifHelper: function ifHelper(handle) {
              op(0
              /* PushFrame */
              );
              Call(op, handle, positional, named);
              op(3
              /* InvokeStatic */
              , stdlibOperand('cautious-non-dynamic-append'));
              op(1
              /* PopFrame */
              );
            }
          });
        } else {
          SwitchCases(op, function () {
            expr(op, expression);
            op(106
            /* DynamicContentType */
            );
          }, function (when) {
            when(0
            /* Component */
            , function () {
              op(81
              /* ResolveCurriedComponent */
              );
              op(79
              /* PushDynamicComponentInstance */
              );
              InvokeNonStaticComponent(op, {
                capabilities: true,
                elementBlock: null,
                positional: positional,
                named: named,
                atNames: false,
                blocks: namedBlocks(null)
              });
            });
            when(1
            /* Helper */
            , function () {
              CallDynamic(op, positional, named, function () {
                op(3
                /* InvokeStatic */
                , stdlibOperand('cautious-non-dynamic-append'));
              });
            });
          });
        }
      } else {
      op(0
      /* PushFrame */
      );
      expr(op, value);
      op(3
      /* InvokeStatic */
      , stdlibOperand('cautious-append'));
      op(1
      /* PopFrame */
      );
    }
  });
  STATEMENTS.add(2
  /* TrustingAppend */
  , function (op, _ref15) {
    var value = _ref15[1];

    if (!Array.isArray(value)) {
      op(41
      /* Text */
      , value === null || value === undefined ? '' : String(value));
    } else {
      op(0
      /* PushFrame */
      );
      expr(op, value);
      op(3
      /* InvokeStatic */
      , stdlibOperand('trusting-append'));
      op(1
      /* PopFrame */
      );
    }
  });
  STATEMENTS.add(6
  /* Block */
  , function (op, _ref16) {
    var expr = _ref16[1],
        positional = _ref16[2],
        named = _ref16[3],
        blocks = _ref16[4];

    if (isGetFreeComponent(expr)) {
      op(1004
      /* ResolveComponent */
      , expr, function (component) {
        InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);
      });
    } else {
      InvokeDynamicComponent(op, expr, null, positional, named, blocks, false, false);
    }
  });
  STATEMENTS.add(40
  /* InElement */
  , function (op, _ref17) {
    var block = _ref17[1],
        guid = _ref17[2],
        destination = _ref17[3],
        insertBefore = _ref17[4];
    ReplayableIf(op, function () {
      expr(op, guid);

      if (insertBefore === undefined) {
        PushPrimitiveReference(op, undefined);
      } else {
        expr(op, insertBefore);
      }

      expr(op, destination);
      op(33
      /* Dup */
      , vm.$sp, 0);
      return 4;
    }, function () {
      op(50
      /* PushRemoteElement */
      );
      InvokeStaticBlock(op, block);
      op(56
      /* PopRemoteElement */
      );
    });
  });
  STATEMENTS.add(41
  /* If */
  , function (op, _ref18) {
    var condition = _ref18[1],
        block = _ref18[2],
        inverse = _ref18[3];
    return ReplayableIf(op, function () {
      expr(op, condition);
      op(71
      /* ToBoolean */
      );
      return 1;
    }, function () {
      InvokeStaticBlock(op, block);
    }, inverse ? function () {
      InvokeStaticBlock(op, inverse);
    } : undefined);
  });
  STATEMENTS.add(42
  /* Each */
  , function (op, _ref19) {
    var value = _ref19[1],
        key = _ref19[2],
        block = _ref19[3],
        inverse = _ref19[4];
    return Replayable(op, function () {
      if (key) {
        expr(op, key);
      } else {
        PushPrimitiveReference(op, null);
      }

      expr(op, value);
      return 2;
    }, function () {
      op(72
      /* EnterList */
      , labelOperand('BODY'), labelOperand('ELSE'));
      op(0
      /* PushFrame */
      );
      op(33
      /* Dup */
      , vm.$fp, 1);
      op(6
      /* ReturnTo */
      , labelOperand('ITER'));
      op(1000
      /* Label */
      , 'ITER');
      op(74
      /* Iterate */
      , labelOperand('BREAK'));
      op(1000
      /* Label */
      , 'BODY');
      InvokeStaticBlockWithStack(op, block, 2);
      op(34
      /* Pop */
      , 2);
      op(4
      /* Jump */
      , labelOperand('FINALLY'));
      op(1000
      /* Label */
      , 'BREAK');
      op(1
      /* PopFrame */
      );
      op(73
      /* ExitList */
      );
      op(4
      /* Jump */
      , labelOperand('FINALLY'));
      op(1000
      /* Label */
      , 'ELSE');

      if (inverse) {
        InvokeStaticBlock(op, inverse);
      }
    });
  });
  STATEMENTS.add(43
  /* With */
  , function (op, _ref20) {
    var value = _ref20[1],
        block = _ref20[2],
        inverse = _ref20[3];
    ReplayableIf(op, function () {
      expr(op, value);
      op(33
      /* Dup */
      , vm.$sp, 0);
      op(71
      /* ToBoolean */
      );
      return 2;
    }, function () {
      InvokeStaticBlockWithStack(op, block, 1);
    }, function () {
      if (inverse) {
        InvokeStaticBlock(op, inverse);
      }
    });
  });
  STATEMENTS.add(44
  /* Let */
  , function (op, _ref21) {
    var positional = _ref21[1],
        block = _ref21[2];
    var count = CompilePositional(op, positional);
    InvokeStaticBlockWithStack(op, block, count);
  });
  STATEMENTS.add(45
  /* WithDynamicVars */
  , function (op, _ref22) {
    var named = _ref22[1],
        block = _ref22[2];

    if (named) {
      var names = named[0],
          expressions = named[1];
      CompilePositional(op, expressions);
      DynamicScope(op, names, function () {
        InvokeStaticBlock(op, block);
      });
    } else {
      InvokeStaticBlock(op, block);
    }
  });
  STATEMENTS.add(46
  /* InvokeComponent */
  , function (op, _ref23) {
    var expr = _ref23[1],
        positional = _ref23[2],
        named = _ref23[3],
        blocks = _ref23[4];

    if (isGetFreeComponent(expr)) {
      op(1004
      /* ResolveComponent */
      , expr, function (component) {
        InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);
      });
    } else {
      InvokeDynamicComponent(op, expr, null, positional, named, blocks, false, false);
    }
  });

  function hashToArgs(hash) {
    if (hash === null) return null;
    var names = hash[0].map(function (key) {
      return "@" + key;
    });
    return [names, hash[1]];
  }

  var PLACEHOLDER_HANDLE = -1;

  var CompilableTemplateImpl = /*#__PURE__*/function () {
    function CompilableTemplateImpl(statements, meta, // Part of CompilableTemplate
    symbolTable, // Used for debugging
    moduleName) {
      if (moduleName === void 0) {
        moduleName = 'plain block';
      }

      this.statements = statements;
      this.meta = meta;
      this.symbolTable = symbolTable;
      this.moduleName = moduleName;
      this.compiled = null;
    } // Part of CompilableTemplate


    var _proto = CompilableTemplateImpl.prototype;

    _proto.compile = function compile(context) {
      return maybeCompile(this, context);
    };

    return CompilableTemplateImpl;
  }();

  function compilable(layout, moduleName) {
    var _layout$block = layout.block,
        statements = _layout$block[0],
        symbols = _layout$block[1],
        hasEval = _layout$block[2];
    return new CompilableTemplateImpl(statements, meta(layout), {
      symbols: symbols,
      hasEval: hasEval
    }, moduleName);
  }

  function maybeCompile(compilable, context) {
    if (compilable.compiled !== null) return compilable.compiled;
    compilable.compiled = PLACEHOLDER_HANDLE;
    var statements = compilable.statements,
        meta = compilable.meta;
    var result = compileStatements(statements, meta, context);
    compilable.compiled = result;
    return result;
  }

  function compileStatements(statements, meta, syntaxContext) {
    var sCompiler = STATEMENTS;
    var context = templateCompilationContext(syntaxContext, meta);
    var encoder = context.encoder,
        _context$program = context.program,
        constants = _context$program.constants,
        resolver = _context$program.resolver;

    function pushOp() {
      for (var _len = arguments.length, op = new Array(_len), _key = 0; _key < _len; _key++) {
        op[_key] = arguments[_key];
      }

      encodeOp(encoder, constants, resolver, meta, op);
    }

    for (var i = 0; i < statements.length; i++) {
      sCompiler.compile(pushOp, statements[i]);
    }

    var handle = context.encoder.commit(meta.size);

    return handle;
  }
  function compilableBlock(block, containing) {
    return new CompilableTemplateImpl(block[0], containing, {
      parameters: block[1] || util.EMPTY_ARRAY
    });
  }

  function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }
  var Labels = /*#__PURE__*/function () {
    function Labels() {
      this.labels = util.dict();
      this.targets = [];
    }

    var _proto = Labels.prototype;

    _proto.label = function label(name, index) {
      this.labels[name] = index;
    };

    _proto.target = function target(at, _target) {
      this.targets.push({
        at: at,
        target: _target
      });
    };

    _proto.patch = function patch(heap) {
      var targets = this.targets,
          labels = this.labels;

      for (var i = 0; i < targets.length; i++) {
        var _targets$i = targets[i],
            at = _targets$i.at,
            target = _targets$i.target;
        var address = labels[target] - at;
        heap.setbyaddr(at, address);
      }
    };

    return Labels;
  }();
  function encodeOp(encoder, constants, resolver, meta, op) {
    if (isBuilderOpcode(op[0])) {
      var type = op[0],
          operands = op.slice(1);
      encoder.push.apply(encoder, [constants, type].concat(operands));
    } else {
      switch (op[0]) {
        case 1000
        /* Label */
        :
          return encoder.label(op[1]);

        case 1001
        /* StartLabels */
        :
          return encoder.startLabels();

        case 1002
        /* StopLabels */
        :
          return encoder.stopLabels();

        case 1004
        /* ResolveComponent */
        :
          return resolveComponent(resolver, constants, meta, op);

        case 1003
        /* ResolveModifier */
        :
          return resolveModifier(resolver, constants, meta, op);

        case 1005
        /* ResolveHelper */
        :
          return resolveHelper(resolver, constants, meta, op);

        case 1007
        /* ResolveComponentOrHelper */
        :
          return resolveComponentOrHelper(resolver, constants, meta, op);

        case 1006
        /* ResolveOptionalHelper */
        :
          return resolveOptionalHelper(resolver, constants, meta, op);

        case 1008
        /* ResolveOptionalComponentOrHelper */
        :
          return resolveOptionalComponentOrHelper(resolver, constants, meta, op);

        case 1010
        /* ResolveLocal */
        :
          var freeVar = op[1];
          var name = meta.upvars[freeVar];
          var andThen = op[2];
          andThen(name, meta.moduleName);
          break;

        case 1011
        /* ResolveTemplateLocal */
        :
          var valueIndex = op[1],
              then = op[2];
          var value = meta.scopeValues[valueIndex];
          then(constants.value(value));
          break;

        case 1009
        /* ResolveFree */
        :
          if (env.DEBUG) {
            var upvarIndex = op[1];
            var freeName = meta.upvars[upvarIndex];
            throw new Error("Attempted to resolve a value in a strict mode template, but that value was not in scope: " + freeName);
          }

          break;

        default:
          throw new Error("Unexpected high level opcode " + op[0]);
      }
    }
  }
  var EncoderImpl = /*#__PURE__*/function () {
    function EncoderImpl(heap, meta, stdlib) {
      this.heap = heap;
      this.meta = meta;
      this.stdlib = stdlib;
      this.labelsStack = new util.Stack();
      this.encoder = new encoder.InstructionEncoderImpl([]);
      this.errors = [];
      this.handle = heap.malloc();
    }

    var _proto2 = EncoderImpl.prototype;

    _proto2.error = function error(_error) {
      this.encoder.encode(30
      /* Primitive */
      , 0);
      this.errors.push(_error);
    };

    _proto2.commit = function commit(size) {
      var handle = this.handle;
      this.heap.push(5
      /* Return */
      | 1024
      /* MACHINE_MASK */
      );
      this.heap.finishMalloc(handle, size);

      if (this.errors.length) {
        return {
          errors: this.errors,
          handle: handle
        };
      } else {
        return handle;
      }
    };

    _proto2.push = function push(constants, type) {
      var heap = this.heap;

      if (env.DEBUG && type > 255
      /* TYPE_SIZE */
      ) {
          throw new Error("Opcode type over 8-bits. Got " + type + ".");
        }

      var machine = vm.isMachineOp(type) ? 1024
      /* MACHINE_MASK */
      : 0;
      var first = type | machine | (arguments.length <= 2 ? 0 : arguments.length - 2) << 8
      /* ARG_SHIFT */
      ;
      heap.push(first);

      for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
        var op = i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2];
        heap.push(this.operand(constants, op));
      }
    };

    _proto2.operand = function operand(constants, _operand) {
      if (typeof _operand === 'number') {
        return _operand;
      }

      if (typeof _operand === 'object' && _operand !== null) {
        if (Array.isArray(_operand)) {
          return util.encodeHandle(constants.array(_operand));
        } else {
          switch (_operand.type) {
            case 1
            /* Label */
            :
              this.currentLabels.target(this.heap.offset, _operand.value);
              return -1;

            case 2
            /* IsStrictMode */
            :
              return util.encodeHandle(constants.value(this.meta.isStrictMode));

            case 3
            /* EvalSymbols */
            :
              return util.encodeHandle(constants.array(this.meta.evalSymbols || util.EMPTY_STRING_ARRAY));

            case 4
            /* Block */
            :
              return util.encodeHandle(constants.value(compilableBlock(_operand.value, this.meta)));

            case 5
            /* StdLib */
            :
              return this.stdlib[_operand.value];

            case 6
            /* NonSmallInt */
            :
            case 7
            /* SymbolTable */
            :
            case 8
            /* Layout */
            :
              return constants.value(_operand.value);
          }
        }
      }

      return util.encodeHandle(constants.value(_operand));
    };

    _proto2.label = function label(name) {
      this.currentLabels.label(name, this.heap.offset + 1);
    };

    _proto2.startLabels = function startLabels() {
      this.labelsStack.push(new Labels());
    };

    _proto2.stopLabels = function stopLabels() {
      var label = this.labelsStack.pop();
      label.patch(this.heap);
    };

    _createClass$2(EncoderImpl, [{
      key: "currentLabels",
      get: function get() {
        return this.labelsStack.current;
      }
    }]);

    return EncoderImpl;
  }();

  function isBuilderOpcode(op) {
    return op < 1000
    /* Start */
    ;
  }

  function main(op) {
    op(75
    /* Main */
    , vm.$s0);
    invokePreparedComponent(op, false, false, true);
  }
  /**
   * Append content to the DOM. This standard function triages content and does the
   * right thing based upon whether it's a string, safe string, component, fragment
   * or node.
   *
   * @param trusting whether to interpolate a string as raw HTML (corresponds to
   * triple curlies)
   */

  function StdAppend(op, trusting, nonDynamicAppend) {
    SwitchCases(op, function () {
      return op(76
      /* ContentType */
      );
    }, function (when) {
      when(2
      /* String */
      , function () {
        if (trusting) {
          op(68
          /* AssertSame */
          );
          op(43
          /* AppendHTML */
          );
        } else {
          op(47
          /* AppendText */
          );
        }
      });

      if (typeof nonDynamicAppend === 'number') {
        when(0
        /* Component */
        , function () {
          op(81
          /* ResolveCurriedComponent */
          );
          op(79
          /* PushDynamicComponentInstance */
          );
          InvokeBareComponent(op);
        });
        when(1
        /* Helper */
        , function () {
          CallDynamic(op, null, null, function () {
            op(3
            /* InvokeStatic */
            , nonDynamicAppend);
          });
        });
      } else {
        // when non-dynamic, we can no longer call the value (potentially because we've already called it)
        // this prevents infinite loops. We instead coerce the value, whatever it is, into the DOM.
        when(0
        /* Component */
        , function () {
          op(47
          /* AppendText */
          );
        });
        when(1
        /* Helper */
        , function () {
          op(47
          /* AppendText */
          );
        });
      }

      when(4
      /* SafeString */
      , function () {
        op(68
        /* AssertSame */
        );
        op(44
        /* AppendSafeHTML */
        );
      });
      when(5
      /* Fragment */
      , function () {
        op(68
        /* AssertSame */
        );
        op(45
        /* AppendDocumentFragment */
        );
      });
      when(6
      /* Node */
      , function () {
        op(68
        /* AssertSame */
        );
        op(46
        /* AppendNode */
        );
      });
    });
  }
  function compileStd(context) {
    var mainHandle = build(context, function (op) {
      return main(op);
    });
    var trustingGuardedNonDynamicAppend = build(context, function (op) {
      return StdAppend(op, true, null);
    });
    var cautiousGuardedNonDynamicAppend = build(context, function (op) {
      return StdAppend(op, false, null);
    });
    var trustingGuardedDynamicAppend = build(context, function (op) {
      return StdAppend(op, true, trustingGuardedNonDynamicAppend);
    });
    var cautiousGuardedDynamicAppend = build(context, function (op) {
      return StdAppend(op, false, cautiousGuardedNonDynamicAppend);
    });
    return new StdLib(mainHandle, trustingGuardedDynamicAppend, cautiousGuardedDynamicAppend, trustingGuardedNonDynamicAppend, cautiousGuardedNonDynamicAppend);
  }
  var STDLIB_META = {
    evalSymbols: null,
    upvars: null,
    moduleName: 'stdlib',
    // TODO: ??
    scopeValues: null,
    isStrictMode: true,
    owner: null,
    size: 0
  };

  function build(program, callback) {
    var constants = program.constants,
        heap = program.heap,
        resolver = program.resolver;
    var encoder = new EncoderImpl(heap, STDLIB_META);

    function pushOp() {
      for (var _len = arguments.length, op = new Array(_len), _key = 0; _key < _len; _key++) {
        op[_key] = arguments[_key];
      }

      encodeOp(encoder, constants, resolver, STDLIB_META, op);
    }

    callback(pushOp);
    var result = encoder.commit(0);

    if (typeof result !== 'number') {
      // This shouldn't be possible
      throw new Error("Unexpected errors compiling std");
    } else {
      return result;
    }
  }

  var CompileTimeCompilationContextImpl = function CompileTimeCompilationContextImpl(_ref, resolver) {
    var constants = _ref.constants,
        heap = _ref.heap;
    this.resolver = resolver;
    this.constants = constants;
    this.heap = heap;
    this.stdlib = compileStd(this);
  };

  var DEFAULT_CAPABILITIES = {
    dynamicLayout: true,
    dynamicTag: true,
    prepareArgs: true,
    createArgs: true,
    attributeHook: false,
    elementHook: false,
    dynamicScope: true,
    createCaller: false,
    updateHook: true,
    createInstance: true,
    wrapped: false,
    willDestroy: false,
    hasSubOwner: false
  };
  var MINIMAL_CAPABILITIES = {
    dynamicLayout: false,
    dynamicTag: false,
    prepareArgs: false,
    createArgs: false,
    attributeHook: false,
    elementHook: false,
    dynamicScope: false,
    createCaller: false,
    updateHook: false,
    createInstance: false,
    wrapped: false,
    willDestroy: false,
    hasSubOwner: false
  };

  var WrappedBuilder = /*#__PURE__*/function () {
    function WrappedBuilder(layout, moduleName) {
      this.layout = layout;
      this.moduleName = moduleName;
      this.compiled = null;
      var block = layout.block;
      var symbols = block[1],
          hasEval = block[2];
      symbols = symbols.slice(); // ensure ATTRS_BLOCK is always included (only once) in the list of symbols

      var attrsBlockIndex = symbols.indexOf(ATTRS_BLOCK);

      if (attrsBlockIndex === -1) {
        this.attrsBlockNumber = symbols.push(ATTRS_BLOCK);
      } else {
        this.attrsBlockNumber = attrsBlockIndex + 1;
      }

      this.symbolTable = {
        hasEval: hasEval,
        symbols: symbols
      };
    }

    var _proto = WrappedBuilder.prototype;

    _proto.compile = function compile(syntax) {
      if (this.compiled !== null) return this.compiled;
      var m = meta(this.layout);
      var context = templateCompilationContext(syntax, m);
      var encoder = context.encoder,
          _context$program = context.program,
          constants = _context$program.constants,
          resolver = _context$program.resolver;

      function pushOp() {
        for (var _len = arguments.length, op = new Array(_len), _key = 0; _key < _len; _key++) {
          op[_key] = arguments[_key];
        }

        encodeOp(encoder, constants, resolver, m, op);
      }

      WrappedComponent(pushOp, this.layout, this.attrsBlockNumber);
      var handle = context.encoder.commit(m.size);

      if (typeof handle !== 'number') {
        return handle;
      }

      this.compiled = handle;

      return handle;
    };

    return WrappedBuilder;
  }();

  function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$3(Constructor.prototype, protoProps); if (staticProps) _defineProperties$3(Constructor, staticProps); return Constructor; }
  var clientId = 0;
  var templateCacheCounters = {
    cacheHit: 0,
    cacheMiss: 0
  };
  /**
   * Wraps a template js in a template module to change it into a factory
   * that handles lazy parsing the template and to create per env singletons
   * of the template.
   */

  function templateFactory(_ref) {
    var templateId = _ref.id,
        moduleName = _ref.moduleName,
        block = _ref.block,
        scope = _ref.scope,
        isStrictMode = _ref.isStrictMode;
    // TODO(template-refactors): This should be removed in the near future, as it
    // appears that id is unused. It is currently kept for backwards compat reasons.
    var id = templateId || "client-" + clientId++; // TODO: This caches JSON serialized output once in case a template is
    // compiled by multiple owners, but we haven't verified if this is actually
    // helpful. We should benchmark this in the future.

    var parsedBlock;
    var ownerlessTemplate = null;
    var templateCache = new WeakMap();

    var factory = function factory(owner) {
      if (parsedBlock === undefined) {
        parsedBlock = JSON.parse(block);
      }

      if (owner === undefined) {
        if (ownerlessTemplate === null) {
          templateCacheCounters.cacheMiss++;
          ownerlessTemplate = new TemplateImpl({
            id: id,
            block: parsedBlock,
            moduleName: moduleName,
            owner: null,
            scope: scope,
            isStrictMode: isStrictMode
          });
        } else {
          templateCacheCounters.cacheHit++;
        }

        return ownerlessTemplate;
      }

      var result = templateCache.get(owner);

      if (result === undefined) {
        templateCacheCounters.cacheMiss++;
        result = new TemplateImpl({
          id: id,
          block: parsedBlock,
          moduleName: moduleName,
          owner: owner,
          scope: scope,
          isStrictMode: isStrictMode
        });
        templateCache.set(owner, result);
      } else {
        templateCacheCounters.cacheHit++;
      }

      return result;
    };

    factory.__id = id;
    factory.__meta = {
      moduleName: moduleName
    };
    return factory;
  }

  var TemplateImpl = /*#__PURE__*/function () {
    function TemplateImpl(parsedLayout) {
      this.parsedLayout = parsedLayout;
      this.result = 'ok';
      this.layout = null;
      this.wrappedLayout = null;
    }

    var _proto = TemplateImpl.prototype;

    _proto.asLayout = function asLayout() {
      if (this.layout) return this.layout;
      return this.layout = compilable(util.assign({}, this.parsedLayout), this.moduleName);
    };

    _proto.asWrappedLayout = function asWrappedLayout() {
      if (this.wrappedLayout) return this.wrappedLayout;
      return this.wrappedLayout = new WrappedBuilder(util.assign({}, this.parsedLayout), this.moduleName);
    };

    _createClass$3(TemplateImpl, [{
      key: "moduleName",
      get: function get() {
        return this.parsedLayout.moduleName;
      }
    }, {
      key: "id",
      get: function get() {
        return this.parsedLayout.id;
      } // TODO(template-refactors): This should be removed in the near future, it is
      // only being exposed for backwards compatibility

    }, {
      key: "referrer",
      get: function get() {
        return {
          moduleName: this.parsedLayout.moduleName,
          owner: this.parsedLayout.owner
        };
      }
    }]);

    return TemplateImpl;
  }();

  exports.CompileTimeCompilationContextImpl = CompileTimeCompilationContextImpl;
  exports.DEFAULT_CAPABILITIES = DEFAULT_CAPABILITIES;
  exports.EMPTY_BLOCKS = EMPTY_BLOCKS;
  exports.MINIMAL_CAPABILITIES = MINIMAL_CAPABILITIES;
  exports.StdLib = StdLib;
  exports.WrappedBuilder = WrappedBuilder;
  exports.compilable = compilable;
  exports.compileStatements = compileStatements;
  exports.compileStd = compileStd;
  exports.debugCompiler = debugCompiler;
  exports.invokeStaticBlock = InvokeStaticBlock;
  exports.invokeStaticBlockWithStack = InvokeStaticBlockWithStack;
  exports.meta = meta;
  exports.programCompilationContext = programCompilationContext;
  exports.templateCacheCounters = templateCacheCounters;
  exports.templateCompilationContext = templateCompilationContext;
  exports.templateFactory = templateFactory;

  Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci1vcGNvZGUtY29tcGlsZXIuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvdXRpbHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9vcGNvZGUtY29tcGlsZXIvbGliL29wY29kZS1idWlsZGVyL29wZXJhbmRzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvb3Bjb2RlLWNvbXBpbGVyL2xpYi9vcGNvZGUtYnVpbGRlci9oZWxwZXJzL3Jlc29sdXRpb24udHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9vcGNvZGUtY29tcGlsZXIvbGliL3N5bnRheC9jb21waWxlcnMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9vcGNvZGUtY29tcGlsZXIvbGliL3N5bnRheC9leHByZXNzaW9ucy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9leHByLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvb3Bjb2RlLWNvbXBpbGVyL2xpYi9vcGNvZGUtYnVpbGRlci9oZWxwZXJzL3NoYXJlZC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy92bS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9ibG9ja3MudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9vcGNvZGUtY29tcGlsZXIvbGliL29wY29kZS1idWlsZGVyL2hlbHBlcnMvY29uZGl0aW9uYWwudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9vcGNvZGUtY29tcGlsZXIvbGliL29wY29kZS1idWlsZGVyL2hlbHBlcnMvY29tcG9uZW50cy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvb3Bjb2RlLWJ1aWxkZXIvc3RkbGliLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvb3Bjb2RlLWNvbXBpbGVyL2xpYi9vcGNvZGUtYnVpbGRlci9jb250ZXh0LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvb3Bjb2RlLWNvbXBpbGVyL2xpYi9jb21waWxlci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvc3ludGF4L3N0YXRlbWVudHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9vcGNvZGUtY29tcGlsZXIvbGliL2NvbXBpbGFibGUtdGVtcGxhdGUudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9vcGNvZGUtY29tcGlsZXIvbGliL29wY29kZS1idWlsZGVyL2VuY29kZXIudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9vcGNvZGUtY29tcGlsZXIvbGliL29wY29kZS1idWlsZGVyL2hlbHBlcnMvc3RkbGliLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvb3Bjb2RlLWNvbXBpbGVyL2xpYi9wcm9ncmFtLWNvbnRleHQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9vcGNvZGUtY29tcGlsZXIvbGliL29wY29kZS1idWlsZGVyL2RlbGVnYXRlLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvb3Bjb2RlLWNvbXBpbGVyL2xpYi93cmFwcGVkLWNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL29wY29kZS1jb21waWxlci9saWIvdGVtcGxhdGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmFtZWRCbG9ja3MsIE9wdGlvbiwgV2lyZUZvcm1hdCwgU2VyaWFsaXplZElubGluZUJsb2NrIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBkaWN0LCBhc3NpZ24gfSBmcm9tICdAZ2xpbW1lci91dGlsJztcblxuaW50ZXJmYWNlIE5hbWVkQmxvY2tzRGljdCB7XG4gIFtrZXk6IHN0cmluZ106IE9wdGlvbjxXaXJlRm9ybWF0LlNlcmlhbGl6ZWRJbmxpbmVCbG9jaz47XG59XG5cbmV4cG9ydCBjbGFzcyBOYW1lZEJsb2Nrc0ltcGwgaW1wbGVtZW50cyBOYW1lZEJsb2NrcyB7XG4gIHB1YmxpYyBuYW1lczogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBibG9ja3M6IE9wdGlvbjxOYW1lZEJsb2Nrc0RpY3Q+KSB7XG4gICAgdGhpcy5uYW1lcyA9IGJsb2NrcyA/IE9iamVjdC5rZXlzKGJsb2NrcykgOiBbXTtcbiAgfVxuXG4gIGdldChuYW1lOiBzdHJpbmcpOiBPcHRpb248U2VyaWFsaXplZElubGluZUJsb2NrPiB7XG4gICAgaWYgKCF0aGlzLmJsb2NrcykgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gdGhpcy5ibG9ja3NbbmFtZV0gfHwgbnVsbDtcbiAgfVxuXG4gIGhhcyhuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBsZXQgeyBibG9ja3MgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGJsb2NrcyAhPT0gbnVsbCAmJiBuYW1lIGluIGJsb2NrcztcbiAgfVxuXG4gIHdpdGgobmFtZTogc3RyaW5nLCBibG9jazogT3B0aW9uPFNlcmlhbGl6ZWRJbmxpbmVCbG9jaz4pOiBOYW1lZEJsb2NrcyB7XG4gICAgbGV0IHsgYmxvY2tzIH0gPSB0aGlzO1xuXG4gICAgaWYgKGJsb2Nrcykge1xuICAgICAgcmV0dXJuIG5ldyBOYW1lZEJsb2Nrc0ltcGwoYXNzaWduKHt9LCBibG9ja3MsIHsgW25hbWVdOiBibG9jayB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgTmFtZWRCbG9ja3NJbXBsKHsgW25hbWVdOiBibG9jayB9KTtcbiAgICB9XG4gIH1cblxuICBnZXQgaGFzQW55KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmJsb2NrcyAhPT0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgRU1QVFlfQkxPQ0tTID0gbmV3IE5hbWVkQmxvY2tzSW1wbChudWxsKTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVkQmxvY2tzKGJsb2NrczogV2lyZUZvcm1hdC5Db3JlLkJsb2Nrcyk6IE5hbWVkQmxvY2tzIHtcbiAgaWYgKGJsb2NrcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBFTVBUWV9CTE9DS1M7XG4gIH1cblxuICBsZXQgb3V0OiBOYW1lZEJsb2Nrc0RpY3QgPSBkaWN0KCk7XG5cbiAgbGV0IFtrZXlzLCB2YWx1ZXNdID0gYmxvY2tzO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG91dFtrZXlzW2ldXSA9IHZhbHVlc1tpXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgTmFtZWRCbG9ja3NJbXBsKG91dCk7XG59XG4iLCJpbXBvcnQge1xuICBMYWJlbE9wZXJhbmQsXG4gIFNlcmlhbGl6ZWRJbmxpbmVCbG9jayxcbiAgRXZhbFN5bWJvbHNPcGVyYW5kLFxuICBIaWdoTGV2ZWxPcGVyYW5kLFxuICBCbG9ja09wZXJhbmQsXG4gIFN0ZExpYk9wZXJhbmQsXG4gIE5vblNtYWxsSW50T3BlcmFuZCxcbiAgU2VyaWFsaXplZEJsb2NrLFxuICBTeW1ib2xUYWJsZSxcbiAgU3ltYm9sVGFibGVPcGVyYW5kLFxuICBDb21waWxhYmxlVGVtcGxhdGUsXG4gIExheW91dE9wZXJhbmQsXG4gIElzU3RyaWN0TW9kZU9wZXJhbmQsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0LCBpc1NtYWxsSW50IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBsYWJlbE9wZXJhbmQodmFsdWU6IHN0cmluZyk6IExhYmVsT3BlcmFuZCB7XG4gIHJldHVybiB7IHR5cGU6IEhpZ2hMZXZlbE9wZXJhbmQuTGFiZWwsIHZhbHVlIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBldmFsU3ltYm9sc09wZXJhbmQoKTogRXZhbFN5bWJvbHNPcGVyYW5kIHtcbiAgcmV0dXJuIHsgdHlwZTogSGlnaExldmVsT3BlcmFuZC5FdmFsU3ltYm9scywgdmFsdWU6IHVuZGVmaW5lZCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpY3RNb2RlKCk6IElzU3RyaWN0TW9kZU9wZXJhbmQge1xuICByZXR1cm4geyB0eXBlOiBIaWdoTGV2ZWxPcGVyYW5kLklzU3RyaWN0TW9kZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmxvY2tPcGVyYW5kKHZhbHVlOiBTZXJpYWxpemVkSW5saW5lQmxvY2sgfCBTZXJpYWxpemVkQmxvY2spOiBCbG9ja09wZXJhbmQge1xuICByZXR1cm4geyB0eXBlOiBIaWdoTGV2ZWxPcGVyYW5kLkJsb2NrLCB2YWx1ZSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RkbGliT3BlcmFuZChcbiAgdmFsdWU6XG4gICAgfCAnbWFpbidcbiAgICB8ICd0cnVzdGluZy1hcHBlbmQnXG4gICAgfCAnY2F1dGlvdXMtYXBwZW5kJ1xuICAgIHwgJ3RydXN0aW5nLW5vbi1keW5hbWljLWFwcGVuZCdcbiAgICB8ICdjYXV0aW91cy1ub24tZHluYW1pYy1hcHBlbmQnXG4pOiBTdGRMaWJPcGVyYW5kIHtcbiAgcmV0dXJuIHsgdHlwZTogSGlnaExldmVsT3BlcmFuZC5TdGRMaWIsIHZhbHVlIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub25TbWFsbEludE9wZXJhbmQodmFsdWU6IG51bWJlcik6IE5vblNtYWxsSW50T3BlcmFuZCB7XG4gIGFzc2VydChcbiAgICAhaXNTbWFsbEludCh2YWx1ZSksXG4gICAgJ0F0dGVtcHRlZCB0byBtYWtlIGEgb3BlcmFuZCBmb3IgYW4gaW50IHRoYXQgd2FzIG5vdCBhIHNtYWxsIGludCwgeW91IHNob3VsZCBlbmNvZGUgdGhpcyBhcyBhbiBpbW1lZGlhdGUnXG4gICk7XG4gIHJldHVybiB7IHR5cGU6IEhpZ2hMZXZlbE9wZXJhbmQuTm9uU21hbGxJbnQsIHZhbHVlIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzeW1ib2xUYWJsZU9wZXJhbmQodmFsdWU6IFN5bWJvbFRhYmxlKTogU3ltYm9sVGFibGVPcGVyYW5kIHtcbiAgcmV0dXJuIHsgdHlwZTogSGlnaExldmVsT3BlcmFuZC5TeW1ib2xUYWJsZSwgdmFsdWUgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxheW91dE9wZXJhbmQodmFsdWU6IENvbXBpbGFibGVUZW1wbGF0ZSk6IExheW91dE9wZXJhbmQge1xuICByZXR1cm4geyB0eXBlOiBIaWdoTGV2ZWxPcGVyYW5kLkxheW91dCwgdmFsdWUgfTtcbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7XG4gIENvbXBpbGVUaW1lQ29uc3RhbnRzLFxuICBDb21waWxlVGltZVJlc29sdmVyLFxuICBDb250YWluaW5nTWV0YWRhdGEsXG4gIEV4cHJlc3Npb25zLFxuICBPd25lcixcbiAgUmVzb2x2ZUNvbXBvbmVudE9wLFxuICBSZXNvbHZlQ29tcG9uZW50T3JIZWxwZXJPcCxcbiAgUmVzb2x2ZUhlbHBlck9wLFxuICBSZXNvbHZlTW9kaWZpZXJPcCxcbiAgUmVzb2x2ZU9wdGlvbmFsQ29tcG9uZW50T3JIZWxwZXJPcCxcbiAgUmVzb2x2ZU9wdGlvbmFsSGVscGVyT3AsXG4gIFNleHBPcGNvZGVzLFxuICBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBhc3NlcnQsIGRlYnVnVG9TdHJpbmcsIGV4cGVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5mdW5jdGlvbiBpc0dldExpa2VUdXBsZShvcGNvZGU6IEV4cHJlc3Npb25zLkV4cHJlc3Npb24pOiBvcGNvZGUgaXMgRXhwcmVzc2lvbnMuVHVwbGVFeHByZXNzaW9uIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkob3Bjb2RlKSAmJiBvcGNvZGUubGVuZ3RoID09PSAyO1xufVxuXG5mdW5jdGlvbiBtYWtlUmVzb2x1dGlvblR5cGVWZXJpZmllcih0eXBlVG9WZXJpZnk6IFNleHBPcGNvZGVzKSB7XG4gIHJldHVybiAoXG4gICAgb3Bjb2RlOiBFeHByZXNzaW9ucy5FeHByZXNzaW9uXG4gICk6IG9wY29kZSBpcyBFeHByZXNzaW9ucy5HZXRGcmVlIHwgRXhwcmVzc2lvbnMuR2V0VGVtcGxhdGVTeW1ib2wgPT4ge1xuICAgIGlmICghaXNHZXRMaWtlVHVwbGUob3Bjb2RlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgbGV0IHR5cGUgPSBvcGNvZGVbMF07XG5cbiAgICByZXR1cm4gKFxuICAgICAgdHlwZSA9PT0gU2V4cE9wY29kZXMuR2V0U3RyaWN0RnJlZSB8fFxuICAgICAgdHlwZSA9PT0gU2V4cE9wY29kZXMuR2V0VGVtcGxhdGVTeW1ib2wgfHxcbiAgICAgIHR5cGUgPT09IHR5cGVUb1ZlcmlmeVxuICAgICk7XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBpc0dldEZyZWVDb21wb25lbnQgPSBtYWtlUmVzb2x1dGlvblR5cGVWZXJpZmllcihTZXhwT3Bjb2Rlcy5HZXRGcmVlQXNDb21wb25lbnRIZWFkKTtcblxuZXhwb3J0IGNvbnN0IGlzR2V0RnJlZU1vZGlmaWVyID0gbWFrZVJlc29sdXRpb25UeXBlVmVyaWZpZXIoU2V4cE9wY29kZXMuR2V0RnJlZUFzTW9kaWZpZXJIZWFkKTtcblxuZXhwb3J0IGNvbnN0IGlzR2V0RnJlZUhlbHBlciA9IG1ha2VSZXNvbHV0aW9uVHlwZVZlcmlmaWVyKFNleHBPcGNvZGVzLkdldEZyZWVBc0hlbHBlckhlYWQpO1xuXG5leHBvcnQgY29uc3QgaXNHZXRGcmVlQ29tcG9uZW50T3JIZWxwZXIgPSBtYWtlUmVzb2x1dGlvblR5cGVWZXJpZmllcihcbiAgU2V4cE9wY29kZXMuR2V0RnJlZUFzQ29tcG9uZW50T3JIZWxwZXJIZWFkXG4pO1xuXG5leHBvcnQgY29uc3QgaXNHZXRGcmVlT3B0aW9uYWxIZWxwZXIgPSBtYWtlUmVzb2x1dGlvblR5cGVWZXJpZmllcihcbiAgU2V4cE9wY29kZXMuR2V0RnJlZUFzSGVscGVySGVhZE9yVGhpc0ZhbGxiYWNrXG4pO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNHZXRGcmVlRGVwcmVjYXRlZEhlbHBlcihcbiAgb3Bjb2RlOiBFeHByZXNzaW9ucy5FeHByZXNzaW9uXG4pOiBvcGNvZGUgaXMgRXhwcmVzc2lvbnMuR2V0UGF0aEZyZWVBc0RlcHJlY2F0ZWRIZWxwZXJIZWFkT3JUaGlzRmFsbGJhY2sge1xuICByZXR1cm4gKFxuICAgIEFycmF5LmlzQXJyYXkob3Bjb2RlKSAmJiBvcGNvZGVbMF0gPT09IFNleHBPcGNvZGVzLkdldEZyZWVBc0RlcHJlY2F0ZWRIZWxwZXJIZWFkT3JUaGlzRmFsbGJhY2tcbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzR2V0RnJlZU9wdGlvbmFsQ29tcG9uZW50T3JIZWxwZXIgPSBtYWtlUmVzb2x1dGlvblR5cGVWZXJpZmllcihcbiAgU2V4cE9wY29kZXMuR2V0RnJlZUFzQ29tcG9uZW50T3JIZWxwZXJIZWFkT3JUaGlzRmFsbGJhY2tcbik7XG5cbmludGVyZmFjZSBSZXNvbHZlZENvbnRhaW5pbmdNZXRhZGF0YSBleHRlbmRzIENvbnRhaW5pbmdNZXRhZGF0YSB7XG4gIG93bmVyOiBPd25lcjtcbiAgdXB2YXJzOiBzdHJpbmdbXTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVzb2x2ZXJJbnZhcmlhbnRzKG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSk6IFJlc29sdmVkQ29udGFpbmluZ01ldGFkYXRhIHtcbiAgaWYgKERFQlVHKSB7XG4gICAgaWYgKCFtZXRhLnVwdmFycykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBjb21wb25lbnQsIGhlbHBlciwgb3IgbW9kaWZpZXIsIGJ1dCBubyBmcmVlIHZhcnMgd2VyZSBmb3VuZCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFtZXRhLm93bmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhIGNvbXBvbmVudCwgaGVscGVyLCBvciBtb2RpZmllciwgYnV0IG5vIG93bmVyIHdhcyBhc3NvY2lhdGVkIHdpdGggdGhlIHRlbXBsYXRlIGl0IHdhcyBiZWluZyByZXNvbHZlZCBmcm9tJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKG1ldGEgYXMgdW5rbm93bikgYXMgUmVzb2x2ZWRDb250YWluaW5nTWV0YWRhdGE7XG59XG5cbi8qKlxuICogPEZvby8+XG4gKiA8Rm9vPjwvRm9vPlxuICogPEZvbyBAYXJnPXt7dHJ1ZX19IC8+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KFxuICByZXNvbHZlcjogQ29tcGlsZVRpbWVSZXNvbHZlcixcbiAgY29uc3RhbnRzOiBDb21waWxlVGltZUNvbnN0YW50cyAmIFJlc29sdXRpb25UaW1lQ29uc3RhbnRzLFxuICBtZXRhOiBDb250YWluaW5nTWV0YWRhdGEsXG4gIFssIGV4cHIsIHRoZW5dOiBSZXNvbHZlQ29tcG9uZW50T3Bcbik6IHZvaWQge1xuICBhc3NlcnQoaXNHZXRGcmVlQ29tcG9uZW50KGV4cHIpLCAnQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBjb21wb25lbnQgd2l0aCBpbmNvcnJlY3Qgb3Bjb2RlJyk7XG5cbiAgbGV0IHR5cGUgPSBleHByWzBdO1xuXG4gIGlmIChERUJVRyAmJiBleHByWzBdID09PSBTZXhwT3Bjb2Rlcy5HZXRTdHJpY3RGcmVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRlZCB0byByZXNvbHZlIGEgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdGVtcGxhdGUsIGJ1dCB0aGF0IHZhbHVlIHdhcyBub3QgaW4gc2NvcGU6ICR7XG4gICAgICAgIG1ldGEudXB2YXJzIVtleHByWzFdXVxuICAgICAgfWBcbiAgICApO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFRlbXBsYXRlU3ltYm9sKSB7XG4gICAgbGV0IHsgc2NvcGVWYWx1ZXMsIG93bmVyIH0gPSBtZXRhO1xuICAgIGxldCBkZWZpbml0aW9uID0gZXhwZWN0KHNjb3BlVmFsdWVzLCAnQlVHOiBzY29wZVZhbHVlcyBtdXN0IGV4aXN0IGlmIHRlbXBsYXRlIHN5bWJvbCBpcyB1c2VkJylbXG4gICAgICBleHByWzFdXG4gICAgXTtcblxuICAgIHRoZW4oXG4gICAgICBjb25zdGFudHMuY29tcG9uZW50KFxuICAgICAgICBkZWZpbml0aW9uIGFzIG9iamVjdCxcbiAgICAgICAgZXhwZWN0KG93bmVyLCAnQlVHOiBleHBlY3RlZCBvd25lciB3aGVuIHJlc29sdmluZyBjb21wb25lbnQgZGVmaW5pdGlvbicpXG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgeyB1cHZhcnMsIG93bmVyIH0gPSBhc3NlcnRSZXNvbHZlckludmFyaWFudHMobWV0YSk7XG5cbiAgICBsZXQgbmFtZSA9IHVwdmFyc1tleHByWzFdXTtcbiAgICBsZXQgZGVmaW5pdGlvbiA9IHJlc29sdmVyLmxvb2t1cENvbXBvbmVudChuYW1lLCBvd25lcikhO1xuXG4gICAgaWYgKERFQlVHICYmICh0eXBlb2YgZGVmaW5pdGlvbiAhPT0gJ29iamVjdCcgfHwgZGVmaW5pdGlvbiA9PT0gbnVsbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEF0dGVtcHRlZCB0byByZXNvbHZlIFxcYCR7bmFtZX1cXGAsIHdoaWNoIHdhcyBleHBlY3RlZCB0byBiZSBhIGNvbXBvbmVudCwgYnV0IG5vdGhpbmcgd2FzIGZvdW5kLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhlbihjb25zdGFudHMucmVzb2x2ZWRDb21wb25lbnQoZGVmaW5pdGlvbiwgbmFtZSkpO1xuICB9XG59XG5cbi8qKlxuICogKGhlbHBlcilcbiAqIChoZWxwZXIgYXJnKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUhlbHBlcihcbiAgcmVzb2x2ZXI6IENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIGNvbnN0YW50czogQ29tcGlsZVRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICBbLCBleHByLCB0aGVuXTogUmVzb2x2ZUhlbHBlck9wXG4pOiB2b2lkIHtcbiAgYXNzZXJ0KGlzR2V0RnJlZUhlbHBlcihleHByKSwgJ0F0dGVtcHRlZCB0byByZXNvbHZlIGEgaGVscGVyIHdpdGggaW5jb3JyZWN0IG9wY29kZScpO1xuXG4gIGxldCB0eXBlID0gZXhwclswXTtcblxuICBpZiAodHlwZSA9PT0gU2V4cE9wY29kZXMuR2V0VGVtcGxhdGVTeW1ib2wpIHtcbiAgICBsZXQgeyBzY29wZVZhbHVlcyB9ID0gbWV0YTtcbiAgICBsZXQgZGVmaW5pdGlvbiA9IGV4cGVjdChzY29wZVZhbHVlcywgJ0JVRzogc2NvcGVWYWx1ZXMgbXVzdCBleGlzdCBpZiB0ZW1wbGF0ZSBzeW1ib2wgaXMgdXNlZCcpW1xuICAgICAgZXhwclsxXVxuICAgIF07XG5cbiAgICB0aGVuKGNvbnN0YW50cy5oZWxwZXIoZGVmaW5pdGlvbiBhcyBvYmplY3QpKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRTdHJpY3RGcmVlKSB7XG4gICAgdGhlbihcbiAgICAgIGxvb2t1cEJ1aWx0SW5IZWxwZXIoZXhwciBhcyBFeHByZXNzaW9ucy5HZXRTdHJpY3RGcmVlLCByZXNvbHZlciwgbWV0YSwgY29uc3RhbnRzLCAnaGVscGVyJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxldCB7IHVwdmFycywgb3duZXIgfSA9IGFzc2VydFJlc29sdmVySW52YXJpYW50cyhtZXRhKTtcblxuICAgIGxldCBuYW1lID0gdXB2YXJzW2V4cHJbMV1dO1xuICAgIGxldCBoZWxwZXIgPSByZXNvbHZlci5sb29rdXBIZWxwZXIobmFtZSwgb3duZXIhKSE7XG5cbiAgICBpZiAoREVCVUcgJiYgaGVscGVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBcXGAke25hbWV9XFxgLCB3aGljaCB3YXMgZXhwZWN0ZWQgdG8gYmUgYSBoZWxwZXIsIGJ1dCBub3RoaW5nIHdhcyBmb3VuZC5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoZW4oY29uc3RhbnRzLmhlbHBlcihoZWxwZXIsIG5hbWUpKTtcbiAgfVxufVxuXG4vKipcbiAqIDxkaXYge3ttb2RpZmllcn19Lz5cbiAqIDxkaXYge3ttb2RpZmllciBhcmd9fS8+XG4gKiA8Rm9vIHt7bW9kaWZpZXJ9fS8+XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlTW9kaWZpZXIoXG4gIHJlc29sdmVyOiBDb21waWxlVGltZVJlc29sdmVyLFxuICBjb25zdGFudHM6IENvbXBpbGVUaW1lQ29uc3RhbnRzICYgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG4gIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgWywgZXhwciwgdGhlbl06IFJlc29sdmVNb2RpZmllck9wXG4pOiB2b2lkIHtcbiAgYXNzZXJ0KGlzR2V0RnJlZU1vZGlmaWVyKGV4cHIpLCAnQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBtb2RpZmllciB3aXRoIGluY29ycmVjdCBvcGNvZGUnKTtcblxuICBsZXQgdHlwZSA9IGV4cHJbMF07XG5cbiAgaWYgKHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFRlbXBsYXRlU3ltYm9sKSB7XG4gICAgbGV0IHsgc2NvcGVWYWx1ZXMgfSA9IG1ldGE7XG4gICAgbGV0IGRlZmluaXRpb24gPSBleHBlY3Qoc2NvcGVWYWx1ZXMsICdCVUc6IHNjb3BlVmFsdWVzIG11c3QgZXhpc3QgaWYgdGVtcGxhdGUgc3ltYm9sIGlzIHVzZWQnKVtcbiAgICAgIGV4cHJbMV1cbiAgICBdO1xuXG4gICAgdGhlbihjb25zdGFudHMubW9kaWZpZXIoZGVmaW5pdGlvbiBhcyBvYmplY3QpKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRTdHJpY3RGcmVlKSB7XG4gICAgbGV0IHsgdXB2YXJzIH0gPSBhc3NlcnRSZXNvbHZlckludmFyaWFudHMobWV0YSk7XG4gICAgbGV0IG5hbWUgPSB1cHZhcnNbZXhwclsxXV07XG4gICAgbGV0IG1vZGlmaWVyID0gcmVzb2x2ZXIubG9va3VwQnVpbHRJbk1vZGlmaWVyKG5hbWUpO1xuXG4gICAgaWYgKERFQlVHICYmIG1vZGlmaWVyID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhIG1vZGlmaWVyIGluIGEgc3RyaWN0IG1vZGUgdGVtcGxhdGUsIGJ1dCBpdCB3YXMgbm90IGluIHNjb3BlOiAke25hbWV9YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGVuKGNvbnN0YW50cy5tb2RpZmllcihtb2RpZmllciEsIG5hbWUpKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgeyB1cHZhcnMsIG93bmVyIH0gPSBhc3NlcnRSZXNvbHZlckludmFyaWFudHMobWV0YSk7XG4gICAgbGV0IG5hbWUgPSB1cHZhcnNbZXhwclsxXV07XG4gICAgbGV0IG1vZGlmaWVyID0gcmVzb2x2ZXIubG9va3VwTW9kaWZpZXIobmFtZSwgb3duZXIpITtcblxuICAgIGlmIChERUJVRyAmJiBtb2RpZmllciA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQXR0ZW1wdGVkIHRvIHJlc29sdmUgXFxgJHtuYW1lfVxcYCwgd2hpY2ggd2FzIGV4cGVjdGVkIHRvIGJlIGEgbW9kaWZpZXIsIGJ1dCBub3RoaW5nIHdhcyBmb3VuZC5gXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoZW4oY29uc3RhbnRzLm1vZGlmaWVyKG1vZGlmaWVyLCBuYW1lKSk7XG4gIH1cbn1cblxuLyoqXG4gKiB7e2NvbXBvbmVudC1vci1oZWxwZXIgYXJnfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRPckhlbHBlcihcbiAgcmVzb2x2ZXI6IENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIGNvbnN0YW50czogQ29tcGlsZVRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICBbLCBleHByLCB7IGlmQ29tcG9uZW50LCBpZkhlbHBlciB9XTogUmVzb2x2ZUNvbXBvbmVudE9ySGVscGVyT3Bcbik6IHZvaWQge1xuICBhc3NlcnQoXG4gICAgaXNHZXRGcmVlQ29tcG9uZW50T3JIZWxwZXIoZXhwciksXG4gICAgJ0F0dGVtcHRlZCB0byByZXNvbHZlIGEgY29tcG9uZW50IG9yIGhlbHBlciB3aXRoIGluY29ycmVjdCBvcGNvZGUnXG4gICk7XG5cbiAgbGV0IHR5cGUgPSBleHByWzBdO1xuXG4gIGlmICh0eXBlID09PSBTZXhwT3Bjb2Rlcy5HZXRUZW1wbGF0ZVN5bWJvbCkge1xuICAgIGxldCB7IHNjb3BlVmFsdWVzLCBvd25lciB9ID0gbWV0YTtcbiAgICBsZXQgZGVmaW5pdGlvbiA9IGV4cGVjdChzY29wZVZhbHVlcywgJ0JVRzogc2NvcGVWYWx1ZXMgbXVzdCBleGlzdCBpZiB0ZW1wbGF0ZSBzeW1ib2wgaXMgdXNlZCcpW1xuICAgICAgZXhwclsxXVxuICAgIF07XG5cbiAgICBsZXQgY29tcG9uZW50ID0gY29uc3RhbnRzLmNvbXBvbmVudChcbiAgICAgIGRlZmluaXRpb24gYXMgb2JqZWN0LFxuICAgICAgZXhwZWN0KG93bmVyLCAnQlVHOiBleHBlY3RlZCBvd25lciB3aGVuIHJlc29sdmluZyBjb21wb25lbnQgZGVmaW5pdGlvbicpLFxuICAgICAgdHJ1ZVxuICAgICk7XG5cbiAgICBpZiAoY29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgICBpZkNvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBoZWxwZXIgPSBjb25zdGFudHMuaGVscGVyKGRlZmluaXRpb24gYXMgb2JqZWN0LCBudWxsLCB0cnVlKTtcblxuICAgIGlmIChERUJVRyAmJiBoZWxwZXIgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEF0dGVtcHRlZCB0byB1c2UgYSB2YWx1ZSBhcyBlaXRoZXIgYSBjb21wb25lbnQgb3IgaGVscGVyLCBidXQgaXQgZGlkIG5vdCBoYXZlIGEgY29tcG9uZW50IG1hbmFnZXIgb3IgaGVscGVyIG1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIGl0LiBUaGUgdmFsdWUgd2FzOiAke2RlYnVnVG9TdHJpbmchKFxuICAgICAgICAgIGRlZmluaXRpb25cbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmSGVscGVyKGV4cGVjdChoZWxwZXIsICdCVUc6IGhlbHBlciBtdXN0IGV4aXN0JykpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFN0cmljdEZyZWUpIHtcbiAgICBpZkhlbHBlcihcbiAgICAgIGxvb2t1cEJ1aWx0SW5IZWxwZXIoXG4gICAgICAgIGV4cHIgYXMgRXhwcmVzc2lvbnMuR2V0U3RyaWN0RnJlZSxcbiAgICAgICAgcmVzb2x2ZXIsXG4gICAgICAgIG1ldGEsXG4gICAgICAgIGNvbnN0YW50cyxcbiAgICAgICAgJ2NvbXBvbmVudCBvciBoZWxwZXInXG4gICAgICApXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgeyB1cHZhcnMsIG93bmVyIH0gPSBhc3NlcnRSZXNvbHZlckludmFyaWFudHMobWV0YSk7XG5cbiAgICBsZXQgbmFtZSA9IHVwdmFyc1tleHByWzFdXTtcbiAgICBsZXQgZGVmaW5pdGlvbiA9IHJlc29sdmVyLmxvb2t1cENvbXBvbmVudChuYW1lLCBvd25lcik7XG5cbiAgICBpZiAoZGVmaW5pdGlvbiAhPT0gbnVsbCkge1xuICAgICAgaWZDb21wb25lbnQoY29uc3RhbnRzLnJlc29sdmVkQ29tcG9uZW50KGRlZmluaXRpb24sIG5hbWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGhlbHBlciA9IHJlc29sdmVyLmxvb2t1cEhlbHBlcihuYW1lLCBvd25lcik7XG5cbiAgICAgIGlmIChERUJVRyAmJiBoZWxwZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBcXGAke25hbWV9XFxgLCB3aGljaCB3YXMgZXhwZWN0ZWQgdG8gYmUgYSBjb21wb25lbnQgb3IgaGVscGVyLCBidXQgbm90aGluZyB3YXMgZm91bmQuYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZkhlbHBlcihjb25zdGFudHMuaGVscGVyKGhlbHBlciEsIG5hbWUpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiA8Rm9vIEBhcmc9e3toZWxwZXJ9fT5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVPcHRpb25hbEhlbHBlcihcbiAgcmVzb2x2ZXI6IENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIGNvbnN0YW50czogQ29tcGlsZVRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICBbLCBleHByLCB7IGlmSGVscGVyIH1dOiBSZXNvbHZlT3B0aW9uYWxIZWxwZXJPcFxuKTogdm9pZCB7XG4gIGFzc2VydChcbiAgICBpc0dldEZyZWVPcHRpb25hbEhlbHBlcihleHByKSB8fCBpc0dldEZyZWVEZXByZWNhdGVkSGVscGVyKGV4cHIpLFxuICAgICdBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhIGhlbHBlciB3aXRoIGluY29ycmVjdCBvcGNvZGUnXG4gICk7XG4gIGxldCB7IHVwdmFycywgb3duZXIgfSA9IGFzc2VydFJlc29sdmVySW52YXJpYW50cyhtZXRhKTtcblxuICBsZXQgbmFtZSA9IHVwdmFyc1tleHByWzFdXTtcbiAgbGV0IGhlbHBlciA9IHJlc29sdmVyLmxvb2t1cEhlbHBlcihuYW1lLCBvd25lcik7XG5cbiAgaWYgKGhlbHBlcikge1xuICAgIGlmSGVscGVyKGNvbnN0YW50cy5oZWxwZXIoaGVscGVyLCBuYW1lKSwgbmFtZSwgbWV0YS5tb2R1bGVOYW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIHt7bWF5YmVIZWxwZXJPckNvbXBvbmVudH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlT3B0aW9uYWxDb21wb25lbnRPckhlbHBlcihcbiAgcmVzb2x2ZXI6IENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIGNvbnN0YW50czogQ29tcGlsZVRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICBbLCBleHByLCB7IGlmQ29tcG9uZW50LCBpZkhlbHBlciwgaWZWYWx1ZSB9XTogUmVzb2x2ZU9wdGlvbmFsQ29tcG9uZW50T3JIZWxwZXJPcFxuKTogdm9pZCB7XG4gIGFzc2VydChcbiAgICBpc0dldEZyZWVPcHRpb25hbENvbXBvbmVudE9ySGVscGVyKGV4cHIpLFxuICAgICdBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBhbiBvcHRpb25hbCBjb21wb25lbnQgb3IgaGVscGVyIHdpdGggaW5jb3JyZWN0IG9wY29kZSdcbiAgKTtcblxuICBsZXQgdHlwZSA9IGV4cHJbMF07XG5cbiAgaWYgKHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFRlbXBsYXRlU3ltYm9sKSB7XG4gICAgbGV0IHsgc2NvcGVWYWx1ZXMsIG93bmVyIH0gPSBtZXRhO1xuICAgIGxldCBkZWZpbml0aW9uID0gZXhwZWN0KHNjb3BlVmFsdWVzLCAnQlVHOiBzY29wZVZhbHVlcyBtdXN0IGV4aXN0IGlmIHRlbXBsYXRlIHN5bWJvbCBpcyB1c2VkJylbXG4gICAgICBleHByWzFdXG4gICAgXTtcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBkZWZpbml0aW9uICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICAodHlwZW9mIGRlZmluaXRpb24gIT09ICdvYmplY3QnIHx8IGRlZmluaXRpb24gPT09IG51bGwpXG4gICAgKSB7XG4gICAgICAvLyBUaGUgdmFsdWUgaXMgbm90IGFuIG9iamVjdCwgc28gaXQgY2FuJ3QgYmUgYSBjb21wb25lbnQgb3IgaGVscGVyLlxuICAgICAgaWZWYWx1ZShjb25zdGFudHMudmFsdWUoZGVmaW5pdGlvbikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjb21wb25lbnQgPSBjb25zdGFudHMuY29tcG9uZW50KFxuICAgICAgZGVmaW5pdGlvbixcbiAgICAgIGV4cGVjdChvd25lciwgJ0JVRzogZXhwZWN0ZWQgb3duZXIgd2hlbiByZXNvbHZpbmcgY29tcG9uZW50IGRlZmluaXRpb24nKSxcbiAgICAgIHRydWVcbiAgICApO1xuXG4gICAgaWYgKGNvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWZDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgaGVscGVyID0gY29uc3RhbnRzLmhlbHBlcihkZWZpbml0aW9uLCBudWxsLCB0cnVlKTtcblxuICAgIGlmIChoZWxwZXIgIT09IG51bGwpIHtcbiAgICAgIGlmSGVscGVyKGhlbHBlcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWZWYWx1ZShjb25zdGFudHMudmFsdWUoZGVmaW5pdGlvbikpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFNleHBPcGNvZGVzLkdldFN0cmljdEZyZWUpIHtcbiAgICBpZkhlbHBlcihcbiAgICAgIGxvb2t1cEJ1aWx0SW5IZWxwZXIoZXhwciBhcyBFeHByZXNzaW9ucy5HZXRTdHJpY3RGcmVlLCByZXNvbHZlciwgbWV0YSwgY29uc3RhbnRzLCAndmFsdWUnKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHsgdXB2YXJzLCBvd25lciB9ID0gYXNzZXJ0UmVzb2x2ZXJJbnZhcmlhbnRzKG1ldGEpO1xuXG4gICAgbGV0IG5hbWUgPSB1cHZhcnNbZXhwclsxXV07XG4gICAgbGV0IGRlZmluaXRpb24gPSByZXNvbHZlci5sb29rdXBDb21wb25lbnQobmFtZSwgb3duZXIpO1xuXG4gICAgaWYgKGRlZmluaXRpb24gIT09IG51bGwpIHtcbiAgICAgIGlmQ29tcG9uZW50KGNvbnN0YW50cy5yZXNvbHZlZENvbXBvbmVudChkZWZpbml0aW9uLCBuYW1lKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGhlbHBlciA9IHJlc29sdmVyLmxvb2t1cEhlbHBlcihuYW1lLCBvd25lcik7XG5cbiAgICBpZiAoaGVscGVyICE9PSBudWxsKSB7XG4gICAgICBpZkhlbHBlcihjb25zdGFudHMuaGVscGVyKGhlbHBlciwgbmFtZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBsb29rdXBCdWlsdEluSGVscGVyKFxuICBleHByOiBFeHByZXNzaW9ucy5HZXRTdHJpY3RGcmVlLFxuICByZXNvbHZlcjogQ29tcGlsZVRpbWVSZXNvbHZlcixcbiAgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICBjb25zdGFudHM6IFJlc29sdXRpb25UaW1lQ29uc3RhbnRzLFxuICB0eXBlOiBzdHJpbmdcbik6IG51bWJlciB7XG4gIGxldCB7IHVwdmFycyB9ID0gYXNzZXJ0UmVzb2x2ZXJJbnZhcmlhbnRzKG1ldGEpO1xuXG4gIGxldCBuYW1lID0gdXB2YXJzW2V4cHJbMV1dO1xuICBsZXQgaGVscGVyID0gcmVzb2x2ZXIubG9va3VwQnVpbHRJbkhlbHBlcihuYW1lKTtcblxuICBpZiAoREVCVUcgJiYgaGVscGVyID09PSBudWxsKSB7XG4gICAgLy8gS2V5d29yZCBoZWxwZXIgZGlkIG5vdCBleGlzdCwgd2hpY2ggbWVhbnMgdGhhdCB3ZSdyZSBhdHRlbXB0aW5nIHRvIHVzZSBhXG4gICAgLy8gdmFsdWUgb2Ygc29tZSBraW5kIHRoYXQgaXMgbm90IGluIHNjb3BlXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRlZCB0byByZXNvbHZlIGEgJHt0eXBlfSBpbiBhIHN0cmljdCBtb2RlIHRlbXBsYXRlLCBidXQgdGhhdCB2YWx1ZSB3YXMgbm90IGluIHNjb3BlOiAke1xuICAgICAgICBtZXRhLnVwdmFycyFbZXhwclsxXV1cbiAgICAgIH1gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjb25zdGFudHMuaGVscGVyKGhlbHBlciEsIG5hbWUpO1xufVxuIiwiaW1wb3J0IHsgQnVpbGRlck9wLCBIaWdoTGV2ZWxPcCwgU2V4cE9wY29kZSwgU2V4cE9wY29kZU1hcCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmV4cG9ydCB0eXBlIFB1c2hFeHByZXNzaW9uT3AgPSAoLi4ub3A6IEJ1aWxkZXJPcCB8IEhpZ2hMZXZlbE9wKSA9PiB2b2lkO1xuXG5kZWNsYXJlIGNvbnN0IFNUQVRFTUVOVDogdW5pcXVlIHN5bWJvbDtcblxuZXhwb3J0IHR5cGUgSGlnaExldmVsU3RhdGVtZW50T3AgPSBbeyBbU1RBVEVNRU5UXTogdW5kZWZpbmVkIH1dO1xuXG5leHBvcnQgdHlwZSBQdXNoU3RhdGVtZW50T3AgPSAoLi4ub3A6IEJ1aWxkZXJPcCB8IEhpZ2hMZXZlbE9wIHwgSGlnaExldmVsU3RhdGVtZW50T3ApID0+IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIENvbXBpbGVyRnVuY3Rpb248UHVzaE9wIGV4dGVuZHMgUHVzaEV4cHJlc3Npb25PcCwgVFNleHA+ID0gKFxuICBvcDogUHVzaE9wLFxuICBzZXhwOiBUU2V4cFxuKSA9PiB2b2lkO1xuXG5leHBvcnQgY2xhc3MgQ29tcGlsZXJzPFB1c2hPcCBleHRlbmRzIFB1c2hFeHByZXNzaW9uT3AsIFRTZXhwT3Bjb2RlcyBleHRlbmRzIFNleHBPcGNvZGU+IHtcbiAgcHJpdmF0ZSBuYW1lczoge1xuICAgIFtuYW1lOiBudW1iZXJdOiBudW1iZXI7XG4gIH0gPSB7fTtcblxuICBwcml2YXRlIGZ1bmNzOiBDb21waWxlckZ1bmN0aW9uPFB1c2hPcCwgYW55PltdID0gW107XG5cbiAgYWRkPFRTZXhwT3Bjb2RlIGV4dGVuZHMgVFNleHBPcGNvZGVzPihcbiAgICBuYW1lOiBUU2V4cE9wY29kZSxcbiAgICBmdW5jOiBDb21waWxlckZ1bmN0aW9uPFB1c2hPcCwgU2V4cE9wY29kZU1hcFtUU2V4cE9wY29kZV0+XG4gICk6IHZvaWQge1xuICAgIHRoaXMubmFtZXNbbmFtZV0gPSB0aGlzLmZ1bmNzLnB1c2goZnVuYykgLSAxO1xuICB9XG5cbiAgY29tcGlsZShvcDogUHVzaE9wLCBzZXhwOiBTZXhwT3Bjb2RlTWFwW1RTZXhwT3Bjb2Rlc10pOiB2b2lkIHtcbiAgICBsZXQgbmFtZSA9IHNleHBbMF07XG4gICAgbGV0IGluZGV4ID0gdGhpcy5uYW1lc1tuYW1lXTtcbiAgICBsZXQgZnVuYyA9IHRoaXMuZnVuY3NbaW5kZXhdO1xuICAgIGFzc2VydCghIWZ1bmMsIGBleHBlY3RlZCBhbiBpbXBsZW1lbnRhdGlvbiBmb3IgJHtzZXhwWzBdfWApO1xuXG4gICAgZnVuYyhvcCwgc2V4cCk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIEV4cHJlc3Npb25TZXhwT3Bjb2RlLFxuICBIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLFxuICBNYWNoaW5lT3AsXG4gIE9wLFxuICBTZXhwT3Bjb2Rlcyxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyAkdjAgfSBmcm9tICdAZ2xpbW1lci92bSc7XG5pbXBvcnQgeyBhc3NlcnQsIGRlcHJlY2F0ZSB9IGZyb20gJ0BnbGltbWVyL2dsb2JhbC1jb250ZXh0JztcbmltcG9ydCB7IGV4cHIgfSBmcm9tICcuLi9vcGNvZGUtYnVpbGRlci9oZWxwZXJzL2V4cHInO1xuaW1wb3J0IHsgaXNHZXRGcmVlSGVscGVyIH0gZnJvbSAnLi4vb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9yZXNvbHV0aW9uJztcbmltcG9ydCB7IFNpbXBsZUFyZ3MgfSBmcm9tICcuLi9vcGNvZGUtYnVpbGRlci9oZWxwZXJzL3NoYXJlZCc7XG5pbXBvcnQgeyBDYWxsLCBDYWxsRHluYW1pYywgQ3VycnksIFB1c2hQcmltaXRpdmVSZWZlcmVuY2UgfSBmcm9tICcuLi9vcGNvZGUtYnVpbGRlci9oZWxwZXJzL3ZtJztcbmltcG9ydCB7IENvbXBpbGVycywgUHVzaEV4cHJlc3Npb25PcCB9IGZyb20gJy4vY29tcGlsZXJzJztcblxuZXhwb3J0IGNvbnN0IEVYUFJFU1NJT05TID0gbmV3IENvbXBpbGVyczxQdXNoRXhwcmVzc2lvbk9wLCBFeHByZXNzaW9uU2V4cE9wY29kZT4oKTtcblxuRVhQUkVTU0lPTlMuYWRkKFNleHBPcGNvZGVzLkNvbmNhdCwgKG9wLCBbLCBwYXJ0c10pID0+IHtcbiAgZm9yIChsZXQgcGFydCBvZiBwYXJ0cykge1xuICAgIGV4cHIob3AsIHBhcnQpO1xuICB9XG5cbiAgb3AoT3AuQ29uY2F0LCBwYXJ0cy5sZW5ndGgpO1xufSk7XG5cbkVYUFJFU1NJT05TLmFkZChTZXhwT3Bjb2Rlcy5DYWxsLCAob3AsIFssIGV4cHJlc3Npb24sIHBvc2l0aW9uYWwsIG5hbWVkXSkgPT4ge1xuICBpZiAoaXNHZXRGcmVlSGVscGVyKGV4cHJlc3Npb24pKSB7XG4gICAgb3AoSGlnaExldmVsUmVzb2x1dGlvbk9wY29kZS5SZXNvbHZlSGVscGVyLCBleHByZXNzaW9uLCAoaGFuZGxlOiBudW1iZXIpID0+IHtcbiAgICAgIENhbGwob3AsIGhhbmRsZSwgcG9zaXRpb25hbCwgbmFtZWQpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGV4cHIob3AsIGV4cHJlc3Npb24pO1xuICAgIENhbGxEeW5hbWljKG9wLCBwb3NpdGlvbmFsLCBuYW1lZCk7XG4gIH1cbn0pO1xuXG5FWFBSRVNTSU9OUy5hZGQoU2V4cE9wY29kZXMuQ3VycnksIChvcCwgWywgZXhwciwgdHlwZSwgcG9zaXRpb25hbCwgbmFtZWRdKSA9PiB7XG4gIEN1cnJ5KG9wLCB0eXBlLCBleHByLCBwb3NpdGlvbmFsLCBuYW1lZCk7XG59KTtcblxuRVhQUkVTU0lPTlMuYWRkKFNleHBPcGNvZGVzLkdldFN5bWJvbCwgKG9wLCBbLCBzeW0sIHBhdGhdKSA9PiB7XG4gIG9wKE9wLkdldFZhcmlhYmxlLCBzeW0pO1xuICB3aXRoUGF0aChvcCwgcGF0aCk7XG59KTtcblxuRVhQUkVTU0lPTlMuYWRkKFNleHBPcGNvZGVzLkdldFRlbXBsYXRlU3ltYm9sLCAob3AsIFssIHN5bSwgcGF0aF0pID0+IHtcbiAgb3AoSGlnaExldmVsUmVzb2x1dGlvbk9wY29kZS5SZXNvbHZlVGVtcGxhdGVMb2NhbCwgc3ltLCAoaGFuZGxlOiBudW1iZXIpID0+IHtcbiAgICBvcChPcC5Db25zdGFudFJlZmVyZW5jZSwgaGFuZGxlKTtcbiAgICB3aXRoUGF0aChvcCwgcGF0aCk7XG4gIH0pO1xufSk7XG5cbkVYUFJFU1NJT05TLmFkZChTZXhwT3Bjb2Rlcy5HZXRTdHJpY3RGcmVlLCAob3AsIFssIHN5bSwgX3BhdGhdKSA9PiB7XG4gIG9wKEhpZ2hMZXZlbFJlc29sdXRpb25PcGNvZGUuUmVzb2x2ZUZyZWUsIHN5bSwgKF9oYW5kbGU6IHVua25vd24pID0+IHtcbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgaW4gc3RyaWN0IG1vZGVcbiAgfSk7XG59KTtcblxuRVhQUkVTU0lPTlMuYWRkKFNleHBPcGNvZGVzLkdldEZyZWVBc0NvbXBvbmVudE9ySGVscGVySGVhZE9yVGhpc0ZhbGxiYWNrLCAoKSA9PiB7XG4gIC8vIFRPRE86IFRoZSBsb2dpYyBmb3IgdGhpcyBvcGNvZGUgY3VycmVudGx5IGV4aXN0cyBpbiBTVEFURU1FTlRTLkFwcGVuZCwgc2luY2VcbiAgLy8gd2Ugd2FudCBkaWZmZXJlbnQgd3JhcHBpbmcgbG9naWMgZGVwZW5kaW5nIG9uIGlmIHdlIGFyZSBpbnZva2luZyBhIGNvbXBvbmVudCxcbiAgLy8gaGVscGVyLCBvciB7e3RoaXN9fSBmYWxsYmFjay4gRXZlbnR1YWxseSB3ZSBmaXggdGhlIG9wY29kZXMgc28gdGhhdCB3ZSBjYW5cbiAgLy8gdHJhdmVyc2UgdGhlIHN1YmV4cHJlc3Npb24gdHJlZSBsaWtlIG5vcm1hbCBpbiB0aGlzIGxvY2F0aW9uLlxuICB0aHJvdyBuZXcgRXJyb3IoJ3VuaW1wbGVtZW50ZWQgb3Bjb2RlJyk7XG59KTtcblxuRVhQUkVTU0lPTlMuYWRkKFNleHBPcGNvZGVzLkdldEZyZWVBc0hlbHBlckhlYWRPclRoaXNGYWxsYmFjaywgKG9wLCBleHByKSA9PiB7XG4gIC8vIDxkaXYgaWQ9e3tiYXp9fT5cblxuICBvcChIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVMb2NhbCwgZXhwclsxXSwgKF9uYW1lOiBzdHJpbmcpID0+IHtcbiAgICBvcChIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVPcHRpb25hbEhlbHBlciwgZXhwciwge1xuICAgICAgaWZIZWxwZXI6IChoYW5kbGU6IG51bWJlcikgPT4ge1xuICAgICAgICBDYWxsKG9wLCBoYW5kbGUsIG51bGwsIG51bGwpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuRVhQUkVTU0lPTlMuYWRkKFNleHBPcGNvZGVzLkdldEZyZWVBc0RlcHJlY2F0ZWRIZWxwZXJIZWFkT3JUaGlzRmFsbGJhY2ssIChvcCwgZXhwcikgPT4ge1xuICAvLyA8Rm9vIEBiYXI9e3tiYXp9fT5cblxuICBvcChIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVMb2NhbCwgZXhwclsxXSwgKF9uYW1lOiBzdHJpbmcpID0+IHtcbiAgICBvcChIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVPcHRpb25hbEhlbHBlciwgZXhwciwge1xuICAgICAgaWZIZWxwZXI6IChoYW5kbGU6IG51bWJlciwgbmFtZTogc3RyaW5nLCBtb2R1bGVOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgYXNzZXJ0KGV4cHJbMl0gJiYgZXhwclsyXS5sZW5ndGggPT09IDEsICdbQlVHXSBNaXNzaW5nIGFyZ3VtZW50IG5hbWUnKTtcblxuICAgICAgICBsZXQgYXJnID0gZXhwclsyXVswXTtcblxuICAgICAgICBkZXByZWNhdGUoXG4gICAgICAgICAgYFRoZSBcXGAke25hbWV9XFxgIGhlbHBlciB3YXMgdXNlZCBpbiB0aGUgXFxgJHttb2R1bGVOYW1lfVxcYCB0ZW1wbGF0ZSBhcyBcXGAke2FyZ309e3ske25hbWV9fX1cXGAuIGAgK1xuICAgICAgICAgICAgYFRoaXMgaXMgYW1iaWdpb3VzIGJldHdlZW4gd2FudGluZyB0aGUgXFxgJHthcmd9XFxgIGFyZ3VtZW50IHRvIGJlIHRoZSBcXGAke25hbWV9XFxgIGhlbHBlciBpdHNlbGYsIGAgK1xuICAgICAgICAgICAgYG9yIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIFxcYCR7bmFtZX1cXGAgaGVscGVyIChjdXJyZW50IGJlaGF2aW9yKS4gYCArXG4gICAgICAgICAgICBgVGhpcyBpbXBsaWNpdCBpbnZvY2F0aW9uIGJlaGF2aW9yIGhhcyBiZWVuIGRlcHJlY2F0ZWQuXFxuXFxuYCArXG4gICAgICAgICAgICBgSW5zdGVhZCwgcGxlYXNlIGV4cGxpY2l0bHkgaW52b2tlIHRoZSBoZWxwZXIgd2l0aCBwYXJlbnRoZXNpcywgaS5lLiBcXGAke2FyZ309e3soJHtuYW1lfSl9fVxcYC5cXG5cXG5gICtcbiAgICAgICAgICAgIGBOb3RlOiB0aGUgcGFyZW50aGVzaXMgYXJlIG9ubHkgcmVxdWlyZWQgaW4gdGhpcyBleGFjdCBzY2VuYXJpbyB3aGVyZSBhbiBhbWJpZ3VpdHkgaXMgcHJlc2VudCDigJMgd2hlcmUgYCArXG4gICAgICAgICAgICBgXFxgJHtuYW1lfVxcYCByZWZlcmVzIHRvIGEgZ2xvYmFsIGhlbHBlciAoYXMgb3Bwb3NlZCB0byBhIGxvY2FsIHZhcmlhYmxlKSwgQU5EIGAgK1xuICAgICAgICAgICAgYHRoZSBcXGAke25hbWV9XFxgIGhlbHBlciBpbnZvY2F0aW9uIGRvZXMgbm90IHRha2UgYW55IGFyZ3VtZW50cywgQU5EIGAgK1xuICAgICAgICAgICAgYHRoaXMgb2NjdXJzIGluIGEgbmFtZWQgYXJndW1lbnQgcG9zaXRpb24gb2YgYSBjb21wb25lbnQgaW52b2NhdGlvbi5cXG5cXG5gICtcbiAgICAgICAgICAgIGBXZSBleHBlY3QgdGhpcyBjb21iaW5hdGlvbiB0byBiZSBxdWl0ZSByYXJlLCBhcyBtb3N0IGhlbHBlcnMgcmVxdWlyZSBhdCBsZWFzdCBvbmUgYXJndW1lbnQuIGAgK1xuICAgICAgICAgICAgYFRoZXJlIGlzIG5vIG5lZWQgdG8gcmVmYWN0b3IgaGVscGVyIGludm9jYXRpb25zIGluIGNhc2VzIHdoZXJlIHRoaXMgZGVwcmVjYXRpb24gd2FzIG5vdCB0cmlnZ2VyZWQuYCxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogJ2FyZ3VtZW50LWxlc3MtaGVscGVyLXBhcmVuLWxlc3MtaW52b2NhdGlvbicsXG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIENhbGwob3AsIGhhbmRsZSwgbnVsbCwgbnVsbCk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5mdW5jdGlvbiB3aXRoUGF0aChvcDogUHVzaEV4cHJlc3Npb25PcCwgcGF0aD86IHN0cmluZ1tdKSB7XG4gIGlmIChwYXRoID09PSB1bmRlZmluZWQgfHwgcGF0aC5sZW5ndGggPT09IDApIHJldHVybjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBvcChPcC5HZXRQcm9wZXJ0eSwgcGF0aFtpXSk7XG4gIH1cbn1cblxuRVhQUkVTU0lPTlMuYWRkKFNleHBPcGNvZGVzLlVuZGVmaW5lZCwgKG9wKSA9PiBQdXNoUHJpbWl0aXZlUmVmZXJlbmNlKG9wLCB1bmRlZmluZWQpKTtcbkVYUFJFU1NJT05TLmFkZChTZXhwT3Bjb2Rlcy5IYXNCbG9jaywgKG9wLCBbLCBibG9ja10pID0+IHtcbiAgZXhwcihvcCwgYmxvY2spO1xuICBvcChPcC5IYXNCbG9jayk7XG59KTtcblxuRVhQUkVTU0lPTlMuYWRkKFNleHBPcGNvZGVzLkhhc0Jsb2NrUGFyYW1zLCAob3AsIFssIGJsb2NrXSkgPT4ge1xuICBleHByKG9wLCBibG9jayk7XG4gIG9wKE9wLlNwcmVhZEJsb2NrKTtcbiAgb3AoT3AuQ29tcGlsZUJsb2NrKTtcbiAgb3AoT3AuSGFzQmxvY2tQYXJhbXMpO1xufSk7XG5cbkVYUFJFU1NJT05TLmFkZChTZXhwT3Bjb2Rlcy5JZklubGluZSwgKG9wLCBbLCBjb25kaXRpb24sIHRydXRoeSwgZmFsc3ldKSA9PiB7XG4gIC8vIFB1c2ggaW4gcmV2ZXJzZSBvcmRlclxuICBleHByKG9wLCBmYWxzeSk7XG4gIGV4cHIob3AsIHRydXRoeSk7XG4gIGV4cHIob3AsIGNvbmRpdGlvbik7XG4gIG9wKE9wLklmSW5saW5lKTtcbn0pO1xuXG5FWFBSRVNTSU9OUy5hZGQoU2V4cE9wY29kZXMuTm90LCAob3AsIFssIHZhbHVlXSkgPT4ge1xuICBleHByKG9wLCB2YWx1ZSk7XG4gIG9wKE9wLk5vdCk7XG59KTtcblxuRVhQUkVTU0lPTlMuYWRkKFNleHBPcGNvZGVzLkdldER5bmFtaWNWYXIsIChvcCwgWywgZXhwcmVzc2lvbl0pID0+IHtcbiAgZXhwcihvcCwgZXhwcmVzc2lvbik7XG4gIG9wKE9wLkdldER5bmFtaWNWYXIpO1xufSk7XG5cbkVYUFJFU1NJT05TLmFkZChTZXhwT3Bjb2Rlcy5Mb2csIChvcCwgWywgcG9zaXRpb25hbF0pID0+IHtcbiAgb3AoTWFjaGluZU9wLlB1c2hGcmFtZSk7XG4gIFNpbXBsZUFyZ3Mob3AsIHBvc2l0aW9uYWwsIG51bGwsIGZhbHNlKTtcbiAgb3AoT3AuTG9nKTtcbiAgb3AoTWFjaGluZU9wLlBvcEZyYW1lKTtcbiAgb3AoT3AuRmV0Y2gsICR2MCk7XG59KTtcbiIsImltcG9ydCB7IE9wLCBXaXJlRm9ybWF0IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBQdXNoRXhwcmVzc2lvbk9wIH0gZnJvbSAnLi4vLi4vc3ludGF4L2NvbXBpbGVycyc7XG5pbXBvcnQgeyBFWFBSRVNTSU9OUyB9IGZyb20gJy4uLy4uL3N5bnRheC9leHByZXNzaW9ucyc7XG5pbXBvcnQgeyBQdXNoUHJpbWl0aXZlIH0gZnJvbSAnLi92bSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBleHByKG9wOiBQdXNoRXhwcmVzc2lvbk9wLCBleHByZXNzaW9uOiBXaXJlRm9ybWF0LkV4cHJlc3Npb24pOiB2b2lkIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXhwcmVzc2lvbikpIHtcbiAgICBFWFBSRVNTSU9OUy5jb21waWxlKG9wLCBleHByZXNzaW9uKTtcbiAgfSBlbHNlIHtcbiAgICBQdXNoUHJpbWl0aXZlKG9wLCBleHByZXNzaW9uKTtcbiAgICBvcChPcC5QcmltaXRpdmVSZWZlcmVuY2UpO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBDb250YWluaW5nTWV0YWRhdGEsXG4gIExheW91dFdpdGhDb250ZXh0LFxuICBPcCxcbiAgT3B0aW9uLFxuICBXaXJlRm9ybWF0LFxuICBOYW1lZEJsb2Nrcyxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBFTVBUWV9BUlJBWSwgRU1QVFlfU1RSSU5HX0FSUkFZIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBQdXNoWWllbGRhYmxlQmxvY2sgfSBmcm9tICcuL2Jsb2Nrcyc7XG5pbXBvcnQgeyBQdXNoRXhwcmVzc2lvbk9wLCBQdXNoU3RhdGVtZW50T3AgfSBmcm9tICcuLi8uLi9zeW50YXgvY29tcGlsZXJzJztcbmltcG9ydCB7IGV4cHIgfSBmcm9tICcuL2V4cHInO1xuXG4vKipcbiAqIENvbXBpbGUgYXJndW1lbnRzLCBwdXNoaW5nIGFuIEFyZ3VtZW50cyBvYmplY3Qgb250byB0aGUgc3RhY2suXG4gKlxuICogQHBhcmFtIGFyZ3MucGFyYW1zXG4gKiBAcGFyYW0gYXJncy5oYXNoXG4gKiBAcGFyYW0gYXJncy5ibG9ja3NcbiAqIEBwYXJhbSBhcmdzLmF0TmFtZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENvbXBpbGVBcmdzKFxuICBvcDogUHVzaFN0YXRlbWVudE9wLFxuICBwb3NpdGlvbmFsOiBXaXJlRm9ybWF0LkNvcmUuUGFyYW1zLFxuICBuYW1lZDogV2lyZUZvcm1hdC5Db3JlLkhhc2gsXG4gIGJsb2NrczogTmFtZWRCbG9ja3MsXG4gIGF0TmFtZXM6IGJvb2xlYW5cbik6IHZvaWQge1xuICBsZXQgYmxvY2tOYW1lczogc3RyaW5nW10gPSBibG9ja3MubmFtZXM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIFB1c2hZaWVsZGFibGVCbG9jayhvcCwgYmxvY2tzLmdldChibG9ja05hbWVzW2ldKSk7XG4gIH1cblxuICBsZXQgY291bnQgPSBDb21waWxlUG9zaXRpb25hbChvcCwgcG9zaXRpb25hbCk7XG5cbiAgbGV0IGZsYWdzID0gY291bnQgPDwgNDtcblxuICBpZiAoYXROYW1lcykgZmxhZ3MgfD0gMGIxMDAwO1xuXG4gIGlmIChibG9ja3MpIHtcbiAgICBmbGFncyB8PSAwYjExMTtcbiAgfVxuXG4gIGxldCBuYW1lcyA9IEVNUFRZX0FSUkFZIGFzIHJlYWRvbmx5IHN0cmluZ1tdO1xuXG4gIGlmIChuYW1lZCkge1xuICAgIG5hbWVzID0gbmFtZWRbMF07XG4gICAgbGV0IHZhbCA9IG5hbWVkWzFdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByKG9wLCB2YWxbaV0pO1xuICAgIH1cbiAgfVxuXG4gIG9wKE9wLlB1c2hBcmdzLCBuYW1lcyBhcyBzdHJpbmdbXSwgYmxvY2tOYW1lcywgZmxhZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gU2ltcGxlQXJncyhcbiAgb3A6IFB1c2hFeHByZXNzaW9uT3AsXG4gIHBvc2l0aW9uYWw6IE9wdGlvbjxXaXJlRm9ybWF0LkNvcmUuUGFyYW1zPixcbiAgbmFtZWQ6IE9wdGlvbjxXaXJlRm9ybWF0LkNvcmUuSGFzaD4sXG4gIGF0TmFtZXM6IGJvb2xlYW5cbik6IHZvaWQge1xuICBpZiAocG9zaXRpb25hbCA9PT0gbnVsbCAmJiBuYW1lZCA9PT0gbnVsbCkge1xuICAgIG9wKE9wLlB1c2hFbXB0eUFyZ3MpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBjb3VudCA9IENvbXBpbGVQb3NpdGlvbmFsKG9wLCBwb3NpdGlvbmFsKTtcblxuICBsZXQgZmxhZ3MgPSBjb3VudCA8PCA0O1xuXG4gIGlmIChhdE5hbWVzKSBmbGFncyB8PSAwYjEwMDA7XG5cbiAgbGV0IG5hbWVzID0gRU1QVFlfU1RSSU5HX0FSUkFZO1xuXG4gIGlmIChuYW1lZCkge1xuICAgIG5hbWVzID0gbmFtZWRbMF07XG4gICAgbGV0IHZhbCA9IG5hbWVkWzFdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHByKG9wLCB2YWxbaV0pO1xuICAgIH1cbiAgfVxuXG4gIG9wKE9wLlB1c2hBcmdzLCBuYW1lcyBhcyBzdHJpbmdbXSwgRU1QVFlfU1RSSU5HX0FSUkFZLCBmbGFncyk7XG59XG5cbi8qKlxuICogQ29tcGlsZSBhbiBvcHRpb25hbCBsaXN0IG9mIHBvc2l0aW9uYWwgYXJndW1lbnRzLCB3aGljaCBwdXNoZXMgZWFjaCBhcmd1bWVudFxuICogb250byB0aGUgc3RhY2sgYW5kIHJldHVybnMgdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzIGNvbXBpbGVkXG4gKlxuICogQHBhcmFtIHBvc2l0aW9uYWwgYW4gb3B0aW9uYWwgbGlzdCBvZiBwb3NpdGlvbmFsIGFyZ3VtZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gQ29tcGlsZVBvc2l0aW9uYWwoXG4gIG9wOiBQdXNoRXhwcmVzc2lvbk9wLFxuICBwb3NpdGlvbmFsOiBPcHRpb248V2lyZUZvcm1hdC5Db3JlLlBhcmFtcz5cbik6IG51bWJlciB7XG4gIGlmIChwb3NpdGlvbmFsID09PSBudWxsKSByZXR1cm4gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9uYWwubGVuZ3RoOyBpKyspIHtcbiAgICBleHByKG9wLCBwb3NpdGlvbmFsW2ldKTtcbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbmFsLmxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ldGEobGF5b3V0OiBMYXlvdXRXaXRoQ29udGV4dCk6IENvbnRhaW5pbmdNZXRhZGF0YSB7XG4gIGxldCBbLCBzeW1ib2xzLCAsIHVwdmFyc10gPSBsYXlvdXQuYmxvY2s7XG5cbiAgcmV0dXJuIHtcbiAgICBldmFsU3ltYm9sczogZXZhbFN5bWJvbHMobGF5b3V0KSxcbiAgICB1cHZhcnM6IHVwdmFycyxcbiAgICBzY29wZVZhbHVlczogbGF5b3V0LnNjb3BlPy4oKSA/PyBudWxsLFxuICAgIGlzU3RyaWN0TW9kZTogbGF5b3V0LmlzU3RyaWN0TW9kZSxcbiAgICBtb2R1bGVOYW1lOiBsYXlvdXQubW9kdWxlTmFtZSxcbiAgICBvd25lcjogbGF5b3V0Lm93bmVyLFxuICAgIHNpemU6IHN5bWJvbHMubGVuZ3RoLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZhbFN5bWJvbHMobGF5b3V0OiBMYXlvdXRXaXRoQ29udGV4dCk6IE9wdGlvbjxzdHJpbmdbXT4ge1xuICBsZXQgeyBibG9jayB9ID0gbGF5b3V0O1xuICBsZXQgWywgc3ltYm9scywgaGFzRXZhbF0gPSBibG9jaztcblxuICByZXR1cm4gaGFzRXZhbCA/IHN5bWJvbHMgOiBudWxsO1xufVxuIiwiaW1wb3J0IHsgJGZwLCAkdjAgfSBmcm9tICdAZ2xpbW1lci92bSc7XG5pbXBvcnQge1xuICBPcHRpb24sXG4gIE9wLFxuICBNYWNoaW5lT3AsXG4gIFdpcmVGb3JtYXQsXG4gIE5vblNtYWxsSW50T3BlcmFuZCxcbiAgQ3VycmllZFR5cGUsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgZW5jb2RlSW1tZWRpYXRlLCBpc1NtYWxsSW50IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBTaW1wbGVBcmdzIH0gZnJvbSAnLi9zaGFyZWQnO1xuaW1wb3J0IHsgUHVzaEV4cHJlc3Npb25PcCwgUHVzaFN0YXRlbWVudE9wIH0gZnJvbSAnLi4vLi4vc3ludGF4L2NvbXBpbGVycyc7XG5pbXBvcnQgeyBpc1N0cmljdE1vZGUsIG5vblNtYWxsSW50T3BlcmFuZCB9IGZyb20gJy4uL29wZXJhbmRzJztcbmltcG9ydCB7IGV4cHIgfSBmcm9tICcuL2V4cHInO1xuXG5leHBvcnQgdHlwZSBQcmltaXRpdmUgPSB1bmRlZmluZWQgfCBudWxsIHwgYm9vbGVhbiB8IG51bWJlciB8IHN0cmluZztcblxuZXhwb3J0IGludGVyZmFjZSBDb21waWxlSGVscGVyIHtcbiAgaGFuZGxlOiBudW1iZXI7XG4gIHBvc2l0aW9uYWw6IE9wdGlvbjxXaXJlRm9ybWF0LkNvcmUuUGFyYW1zPjtcbiAgbmFtZWQ6IFdpcmVGb3JtYXQuQ29yZS5IYXNoO1xufVxuXG4vKipcbiAqIFB1c2ggYSByZWZlcmVuY2Ugb250byB0aGUgc3RhY2sgY29ycmVzcG9uZGluZyB0byBhIHN0YXRpY2FsbHkga25vd24gcHJpbWl0aXZlXG4gKiBAcGFyYW0gdmFsdWUgQSBKYXZhU2NyaXB0IHByaW1pdGl2ZSAodW5kZWZpbmVkLCBudWxsLCBib29sZWFuLCBudW1iZXIgb3Igc3RyaW5nKVxuICovXG5leHBvcnQgZnVuY3Rpb24gUHVzaFByaW1pdGl2ZVJlZmVyZW5jZShvcDogUHVzaEV4cHJlc3Npb25PcCwgdmFsdWU6IFByaW1pdGl2ZSk6IHZvaWQge1xuICBQdXNoUHJpbWl0aXZlKG9wLCB2YWx1ZSk7XG4gIG9wKE9wLlByaW1pdGl2ZVJlZmVyZW5jZSk7XG59XG5cbi8qKlxuICogUHVzaCBhbiBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIGEgSmF2YVNjcmlwdCBwcmltaXRpdmUgb24gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgSmF2YVNjcmlwdCBwcmltaXRpdmUgKHVuZGVmaW5lZCwgbnVsbCwgYm9vbGVhbiwgbnVtYmVyIG9yIHN0cmluZylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFB1c2hQcmltaXRpdmUob3A6IFB1c2hFeHByZXNzaW9uT3AsIHByaW1pdGl2ZTogUHJpbWl0aXZlKTogdm9pZCB7XG4gIGxldCBwOiBQcmltaXRpdmUgfCBOb25TbWFsbEludE9wZXJhbmQgPSBwcmltaXRpdmU7XG5cbiAgaWYgKHR5cGVvZiBwID09PSAnbnVtYmVyJykge1xuICAgIHAgPSBpc1NtYWxsSW50KHApID8gZW5jb2RlSW1tZWRpYXRlKHApIDogbm9uU21hbGxJbnRPcGVyYW5kKHApO1xuICB9XG5cbiAgb3AoT3AuUHJpbWl0aXZlLCBwKTtcbn1cblxuLyoqXG4gKiBJbnZva2UgYSBmb3JlaWduIGZ1bmN0aW9uIChhIFwiaGVscGVyXCIpIGJhc2VkIG9uIGEgc3RhdGljYWxseSBrbm93biBoYW5kbGVcbiAqXG4gKiBAcGFyYW0gb3AgVGhlIG9wIGNyZWF0aW9uIGZ1bmN0aW9uXG4gKiBAcGFyYW0gaGFuZGxlIEEgaGFuZGxlXG4gKiBAcGFyYW0gcG9zaXRpb25hbCBBbiBvcHRpb25hbCBsaXN0IG9mIGV4cHJlc3Npb25zIHRvIGNvbXBpbGVcbiAqIEBwYXJhbSBuYW1lZCBBbiBvcHRpb25hbCBsaXN0IG9mIG5hbWVkIGFyZ3VtZW50cyAobmFtZSArIGV4cHJlc3Npb24pIHRvIGNvbXBpbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENhbGwoXG4gIG9wOiBQdXNoRXhwcmVzc2lvbk9wLFxuICBoYW5kbGU6IG51bWJlcixcbiAgcG9zaXRpb25hbDogV2lyZUZvcm1hdC5Db3JlLlBhcmFtcyxcbiAgbmFtZWQ6IFdpcmVGb3JtYXQuQ29yZS5IYXNoXG4pOiB2b2lkIHtcbiAgb3AoTWFjaGluZU9wLlB1c2hGcmFtZSk7XG4gIFNpbXBsZUFyZ3Mob3AsIHBvc2l0aW9uYWwsIG5hbWVkLCBmYWxzZSk7XG4gIG9wKE9wLkhlbHBlciwgaGFuZGxlKTtcbiAgb3AoTWFjaGluZU9wLlBvcEZyYW1lKTtcbiAgb3AoT3AuRmV0Y2gsICR2MCk7XG59XG5cbi8qKlxuICogSW52b2tlIGEgZm9yZWlnbiBmdW5jdGlvbiAoYSBcImhlbHBlclwiKSBiYXNlZCBvbiBhIGR5bmFtaWNhbGx5IGxvYWRlZCBkZWZpbml0aW9uXG4gKlxuICogQHBhcmFtIG9wIFRoZSBvcCBjcmVhdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIHBvc2l0aW9uYWwgQW4gb3B0aW9uYWwgbGlzdCBvZiBleHByZXNzaW9ucyB0byBjb21waWxlXG4gKiBAcGFyYW0gbmFtZWQgQW4gb3B0aW9uYWwgbGlzdCBvZiBuYW1lZCBhcmd1bWVudHMgKG5hbWUgKyBleHByZXNzaW9uKSB0byBjb21waWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDYWxsRHluYW1pYyhcbiAgb3A6IFB1c2hFeHByZXNzaW9uT3AsXG4gIHBvc2l0aW9uYWw6IFdpcmVGb3JtYXQuQ29yZS5QYXJhbXMsXG4gIG5hbWVkOiBXaXJlRm9ybWF0LkNvcmUuSGFzaCxcbiAgYXBwZW5kPzogKCkgPT4gdm9pZFxuKTogdm9pZCB7XG4gIG9wKE1hY2hpbmVPcC5QdXNoRnJhbWUpO1xuICBTaW1wbGVBcmdzKG9wLCBwb3NpdGlvbmFsLCBuYW1lZCwgZmFsc2UpO1xuICBvcChPcC5EdXAsICRmcCwgMSk7XG4gIG9wKE9wLkR5bmFtaWNIZWxwZXIpO1xuICBpZiAoYXBwZW5kKSB7XG4gICAgb3AoT3AuRmV0Y2gsICR2MCk7XG4gICAgYXBwZW5kKCk7XG4gICAgb3AoTWFjaGluZU9wLlBvcEZyYW1lKTtcbiAgICBvcChPcC5Qb3AsIDEpO1xuICB9IGVsc2Uge1xuICAgIG9wKE1hY2hpbmVPcC5Qb3BGcmFtZSk7XG4gICAgb3AoT3AuUG9wLCAxKTtcbiAgICBvcChPcC5GZXRjaCwgJHYwKTtcbiAgfVxufVxuXG4vKipcbiAqIEV2YWx1YXRlIHN0YXRlbWVudHMgaW4gdGhlIGNvbnRleHQgb2YgbmV3IGR5bmFtaWMgc2NvcGUgZW50cmllcy4gTW92ZSBlbnRyaWVzIGZyb20gdGhlXG4gKiBzdGFjayBpbnRvIG5hbWVkIGVudHJpZXMgaW4gdGhlIGR5bmFtaWMgc2NvcGUsIHRoZW4gZXZhbHVhdGUgdGhlIHN0YXRlbWVudHMsIHRoZW4gcG9wXG4gKiB0aGUgZHluYW1pYyBzY29wZVxuICpcbiAqIEBwYXJhbSBuYW1lcyBhIGxpc3Qgb2YgZHluYW1pYyBzY29wZSBuYW1lc1xuICogQHBhcmFtIGJsb2NrIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgbGlzdCBvZiBzdGF0ZW1lbnRzIHRvIGV2YWx1YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBEeW5hbWljU2NvcGUob3A6IFB1c2hTdGF0ZW1lbnRPcCwgbmFtZXM6IHN0cmluZ1tdLCBibG9jazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICBvcChPcC5QdXNoRHluYW1pY1Njb3BlKTtcbiAgb3AoT3AuQmluZER5bmFtaWNTY29wZSwgbmFtZXMpO1xuICBibG9jaygpO1xuICBvcChPcC5Qb3BEeW5hbWljU2NvcGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gQ3VycnkoXG4gIG9wOiBQdXNoRXhwcmVzc2lvbk9wLFxuICB0eXBlOiBDdXJyaWVkVHlwZSxcbiAgZGVmaW5pdGlvbjogV2lyZUZvcm1hdC5FeHByZXNzaW9uLFxuICBwb3NpdGlvbmFsOiBXaXJlRm9ybWF0LkNvcmUuUGFyYW1zLFxuICBuYW1lZDogV2lyZUZvcm1hdC5Db3JlLkhhc2hcbik6IHZvaWQge1xuICBvcChNYWNoaW5lT3AuUHVzaEZyYW1lKTtcbiAgU2ltcGxlQXJncyhvcCwgcG9zaXRpb25hbCwgbmFtZWQsIGZhbHNlKTtcbiAgb3AoT3AuQ2FwdHVyZUFyZ3MpO1xuICBleHByKG9wLCBkZWZpbml0aW9uKTtcbiAgb3AoT3AuQ3VycnksIHR5cGUsIGlzU3RyaWN0TW9kZSgpKTtcbiAgb3AoTWFjaGluZU9wLlBvcEZyYW1lKTtcbiAgb3AoT3AuRmV0Y2gsICR2MCk7XG59XG4iLCJpbXBvcnQgeyBNYWNoaW5lT3AsIE9wLCBPcHRpb24sIFdpcmVGb3JtYXQgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7ICRmcCB9IGZyb20gJ0BnbGltbWVyL3ZtJztcbmltcG9ydCB7IFB1c2hQcmltaXRpdmUgfSBmcm9tICcuL3ZtJztcbmltcG9ydCB7IGJsb2NrT3BlcmFuZCwgc3ltYm9sVGFibGVPcGVyYW5kIH0gZnJvbSAnLi4vb3BlcmFuZHMnO1xuaW1wb3J0IHsgU2ltcGxlQXJncyB9IGZyb20gJy4vc2hhcmVkJztcbmltcG9ydCB7IFB1c2hFeHByZXNzaW9uT3AsIFB1c2hTdGF0ZW1lbnRPcCB9IGZyb20gJy4uLy4uL3N5bnRheC9jb21waWxlcnMnO1xuXG4vKipcbiAqIFlpZWxkIHRvIGEgYmxvY2sgbG9jYXRlZCBhdCBhIHBhcnRpY3VsYXIgc3ltYm9sIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSB0byB0aGUgc3ltYm9sIGNvbnRhaW5pbmcgdGhlIGJsb2NrIHRvIHlpZWxkIHRvXG4gKiBAcGFyYW0gcGFyYW1zIG9wdGlvbmFsIGJsb2NrIHBhcmFtZXRlcnMgdG8geWllbGQgdG8gdGhlIGJsb2NrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBZaWVsZEJsb2NrKFxuICBvcDogUHVzaFN0YXRlbWVudE9wLFxuICB0bzogbnVtYmVyLFxuICBwb3NpdGlvbmFsOiBPcHRpb248V2lyZUZvcm1hdC5Db3JlLlBhcmFtcz5cbik6IHZvaWQge1xuICBTaW1wbGVBcmdzKG9wLCBwb3NpdGlvbmFsLCBudWxsLCB0cnVlKTtcbiAgb3AoT3AuR2V0QmxvY2ssIHRvKTtcbiAgb3AoT3AuU3ByZWFkQmxvY2spO1xuICBvcChPcC5Db21waWxlQmxvY2spO1xuICBvcChPcC5JbnZva2VZaWVsZCk7XG4gIG9wKE9wLlBvcFNjb3BlKTtcbiAgb3AoTWFjaGluZU9wLlBvcEZyYW1lKTtcbn1cblxuLyoqXG4gKiBQdXNoIGFuIChvcHRpb25hbCkgeWllbGRhYmxlIGJsb2NrIG9udG8gdGhlIHN0YWNrLiBUaGUgeWllbGRhYmxlIGJsb2NrIG11c3QgYmUga25vd25cbiAqIHN0YXRpY2FsbHkgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIEBwYXJhbSBibG9jayBBbiBvcHRpb25hbCBDb21waWxhYmxlIGJsb2NrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQdXNoWWllbGRhYmxlQmxvY2soXG4gIG9wOiBQdXNoU3RhdGVtZW50T3AsXG4gIGJsb2NrOiBPcHRpb248V2lyZUZvcm1hdC5TZXJpYWxpemVkSW5saW5lQmxvY2s+XG4pOiB2b2lkIHtcbiAgUHVzaFN5bWJvbFRhYmxlKG9wLCBibG9jayAmJiBibG9ja1sxXSk7XG4gIG9wKE9wLlB1c2hCbG9ja1Njb3BlKTtcbiAgUHVzaENvbXBpbGFibGUob3AsIGJsb2NrKTtcbn1cblxuLyoqXG4gKiBJbnZva2UgYSBibG9jayB0aGF0IGlzIGtub3duIHN0YXRpY2FsbHkgYXQgY29tcGlsZSB0aW1lLlxuICpcbiAqIEBwYXJhbSBibG9jayBhIENvbXBpbGFibGUgYmxvY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEludm9rZVN0YXRpY0Jsb2NrKFxuICBvcDogUHVzaFN0YXRlbWVudE9wLFxuICBibG9jazogV2lyZUZvcm1hdC5TZXJpYWxpemVkSW5saW5lQmxvY2tcbik6IHZvaWQge1xuICBvcChNYWNoaW5lT3AuUHVzaEZyYW1lKTtcbiAgUHVzaENvbXBpbGFibGUob3AsIGJsb2NrKTtcbiAgb3AoT3AuQ29tcGlsZUJsb2NrKTtcbiAgb3AoTWFjaGluZU9wLkludm9rZVZpcnR1YWwpO1xuICBvcChNYWNoaW5lT3AuUG9wRnJhbWUpO1xufVxuXG4vKipcbiAqIEludm9rZSBhIHN0YXRpYyBibG9jaywgcHJlc2VydmluZyBzb21lIG51bWJlciBvZiBzdGFjayBlbnRyaWVzIGZvciB1c2UgaW5cbiAqIHVwZGF0aW5nLlxuICpcbiAqIEBwYXJhbSBibG9jayBBIGNvbXBpbGFibGUgYmxvY2tcbiAqIEBwYXJhbSBjYWxsZXJDb3VudCBBIG51bWJlciBvZiBzdGFjayBlbnRyaWVzIHRvIHByZXNlcnZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBJbnZva2VTdGF0aWNCbG9ja1dpdGhTdGFjayhcbiAgb3A6IFB1c2hTdGF0ZW1lbnRPcCxcbiAgYmxvY2s6IFdpcmVGb3JtYXQuU2VyaWFsaXplZElubGluZUJsb2NrLFxuICBjYWxsZXJDb3VudDogbnVtYmVyXG4pOiB2b2lkIHtcbiAgbGV0IHBhcmFtZXRlcnMgPSBibG9ja1sxXTtcbiAgbGV0IGNhbGxlZUNvdW50ID0gcGFyYW1ldGVycy5sZW5ndGg7XG4gIGxldCBjb3VudCA9IE1hdGgubWluKGNhbGxlckNvdW50LCBjYWxsZWVDb3VudCk7XG5cbiAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgSW52b2tlU3RhdGljQmxvY2sob3AsIGJsb2NrKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBvcChNYWNoaW5lT3AuUHVzaEZyYW1lKTtcblxuICBpZiAoY291bnQpIHtcbiAgICBvcChPcC5DaGlsZFNjb3BlKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgb3AoT3AuRHVwLCAkZnAsIGNhbGxlckNvdW50IC0gaSk7XG4gICAgICBvcChPcC5TZXRWYXJpYWJsZSwgcGFyYW1ldGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgUHVzaENvbXBpbGFibGUob3AsIGJsb2NrKTtcbiAgb3AoT3AuQ29tcGlsZUJsb2NrKTtcbiAgb3AoTWFjaGluZU9wLkludm9rZVZpcnR1YWwpO1xuXG4gIGlmIChjb3VudCkge1xuICAgIG9wKE9wLlBvcFNjb3BlKTtcbiAgfVxuXG4gIG9wKE1hY2hpbmVPcC5Qb3BGcmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBQdXNoU3ltYm9sVGFibGUob3A6IFB1c2hFeHByZXNzaW9uT3AsIHBhcmFtZXRlcnM6IG51bWJlcltdIHwgbnVsbCk6IHZvaWQge1xuICBpZiAocGFyYW1ldGVycyAhPT0gbnVsbCkge1xuICAgIG9wKE9wLlB1c2hTeW1ib2xUYWJsZSwgc3ltYm9sVGFibGVPcGVyYW5kKHsgcGFyYW1ldGVycyB9KSk7XG4gIH0gZWxzZSB7XG4gICAgUHVzaFByaW1pdGl2ZShvcCwgbnVsbCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFB1c2hDb21waWxhYmxlKFxuICBvcDogUHVzaEV4cHJlc3Npb25PcCxcbiAgX2Jsb2NrOiBPcHRpb248V2lyZUZvcm1hdC5TZXJpYWxpemVkSW5saW5lQmxvY2s+XG4pOiB2b2lkIHtcbiAgaWYgKF9ibG9jayA9PT0gbnVsbCkge1xuICAgIFB1c2hQcmltaXRpdmUob3AsIG51bGwpO1xuICB9IGVsc2Uge1xuICAgIG9wKE9wLkNvbnN0YW50LCBibG9ja09wZXJhbmQoX2Jsb2NrKSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IGxhYmVsT3BlcmFuZCB9IGZyb20gJy4uL29wZXJhbmRzJztcbmltcG9ydCB7IE9wLCBNYWNoaW5lT3AsIEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFB1c2hTdGF0ZW1lbnRPcCB9IGZyb20gJy4uLy4uL3N5bnRheC9jb21waWxlcnMnO1xuXG5leHBvcnQgdHlwZSBXaGVuID0gKG1hdGNoOiBudW1iZXIsIGNhbGxiYWNrOiAoKSA9PiB2b2lkKSA9PiB2b2lkO1xuXG5leHBvcnQgZnVuY3Rpb24gU3dpdGNoQ2FzZXMoXG4gIG9wOiBQdXNoU3RhdGVtZW50T3AsXG4gIGJvb3RzdHJhcDogKCkgPT4gdm9pZCxcbiAgY2FsbGJhY2s6ICh3aGVuOiBXaGVuKSA9PiB2b2lkXG4pOiB2b2lkIHtcbiAgLy8gU2V0dXAgdGhlIHN3aXRjaCBEU0xcbiAgbGV0IGNsYXVzZXM6IEFycmF5PHsgbWF0Y2g6IG51bWJlcjsgbGFiZWw6IHN0cmluZzsgY2FsbGJhY2s6ICgpID0+IHZvaWQgfT4gPSBbXTtcblxuICBsZXQgY291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIHdoZW4obWF0Y2g6IG51bWJlciwgY2FsbGJhY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBjbGF1c2VzLnB1c2goeyBtYXRjaCwgY2FsbGJhY2ssIGxhYmVsOiBgQ0xBVVNFJHtjb3VudCsrfWAgfSk7XG4gIH1cblxuICAvLyBDYWxsIHRoZSBjYWxsYmFja1xuICBjYWxsYmFjayh3aGVuKTtcblxuICAvLyBFbWl0IHRoZSBvcGNvZGVzIGZvciB0aGUgc3dpdGNoXG4gIG9wKE9wLkVudGVyLCAxKTtcbiAgYm9vdHN0cmFwKCk7XG4gIG9wKEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUuU3RhcnRMYWJlbHMpO1xuXG4gIC8vIEZpcnN0LCBlbWl0IHRoZSBqdW1wIG9wY29kZXMuIFdlIGRvbid0IG5lZWQgYSBqdW1wIGZvciB0aGUgbGFzdFxuICAvLyBvcGNvZGUsIHNpbmNlIGl0IGJsZWVkcyBkaXJlY3RseSBpbnRvIGl0cyBjbGF1c2UuXG4gIGZvciAobGV0IGNsYXVzZSBvZiBjbGF1c2VzLnNsaWNlKDAsIC0xKSkge1xuICAgIG9wKE9wLkp1bXBFcSwgbGFiZWxPcGVyYW5kKGNsYXVzZS5sYWJlbCksIGNsYXVzZS5tYXRjaCk7XG4gIH1cblxuICAvLyBFbnVtZXJhdGUgdGhlIGNsYXVzZXMgaW4gcmV2ZXJzZSBvcmRlci4gRWFybGllciBtYXRjaGVzIHdpbGxcbiAgLy8gcmVxdWlyZSBmZXdlciBjaGVja3MuXG4gIGZvciAobGV0IGkgPSBjbGF1c2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IGNsYXVzZSA9IGNsYXVzZXNbaV07XG5cbiAgICBvcChIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLkxhYmVsLCBjbGF1c2UubGFiZWwpO1xuICAgIG9wKE9wLlBvcCwgMSk7XG4gICAgY2xhdXNlLmNhbGxiYWNrKCk7XG5cbiAgICAvLyBUaGUgZmlyc3QgbWF0Y2ggaXMgc3BlY2lhbDogaXQgaXMgcGxhY2VkIGRpcmVjdGx5IGJlZm9yZSB0aGUgRU5EXG4gICAgLy8gbGFiZWwsIHNvIG5vIGFkZGl0aW9uYWwganVtcCBpcyBuZWVkZWQgYXQgdGhlIGVuZCBvZiBpdC5cbiAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgb3AoTWFjaGluZU9wLkp1bXAsIGxhYmVsT3BlcmFuZCgnRU5EJykpO1xuICAgIH1cbiAgfVxuXG4gIG9wKEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUuTGFiZWwsICdFTkQnKTtcbiAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5TdG9wTGFiZWxzKTtcbiAgb3AoT3AuRXhpdCk7XG59XG5cbi8qKlxuICogQSBjb252ZW5pZW5jZSBmb3IgcHVzaGluZyBzb21lIGFyZ3VtZW50cyBvbiB0aGUgc3RhY2sgYW5kXG4gKiBydW5uaW5nIHNvbWUgY29kZSBpZiB0aGUgY29kZSBuZWVkcyB0byBiZSByZS1leGVjdXRlZCBkdXJpbmdcbiAqIHVwZGF0aW5nIGV4ZWN1dGlvbiBpZiBzb21lIG9mIHRoZSBhcmd1bWVudHMgaGF2ZSBjaGFuZ2VkLlxuICpcbiAqICMgSW5pdGlhbCBFeGVjdXRpb25cbiAqXG4gKiBUaGUgYGFyZ3NgIGZ1bmN0aW9uIHNob3VsZCBwdXNoIHplcm8gb3IgbW9yZSBhcmd1bWVudHMgb250b1xuICogdGhlIHN0YWNrIGFuZCByZXR1cm4gdGhlIG51bWJlciBvZiBhcmd1bWVudHMgcHVzaGVkLlxuICpcbiAqIFRoZSBgYm9keWAgZnVuY3Rpb24gcHJvdmlkZXMgdGhlIGluc3RydWN0aW9ucyB0byBleGVjdXRlIGJvdGhcbiAqIGR1cmluZyBpbml0aWFsIGV4ZWN1dGlvbiBhbmQgZHVyaW5nIHVwZGF0aW5nIGV4ZWN1dGlvbi5cbiAqXG4gKiBJbnRlcm5hbGx5LCB0aGlzIGZ1bmN0aW9uIHN0YXJ0cyBieSBwdXNoaW5nIGEgbmV3IGZyYW1lLCBzb1xuICogdGhhdCB0aGUgYm9keSBjYW4gcmV0dXJuIGFuZCBzZXRzIHRoZSByZXR1cm4gcG9pbnQgKCRyYSkgdG9cbiAqIHRoZSBFTkRJTklUSUFMIGxhYmVsLlxuICpcbiAqIEl0IHRoZW4gZXhlY3V0ZXMgdGhlIGBhcmdzYCBmdW5jdGlvbiwgd2hpY2ggYWRkcyBpbnN0cnVjdGlvbnNcbiAqIHJlc3BvbnNpYmxlIGZvciBwdXNoaW5nIHRoZSBhcmd1bWVudHMgZm9yIHRoZSBibG9jayB0byB0aGVcbiAqIHN0YWNrLiBUaGVzZSBhcmd1bWVudHMgd2lsbCBiZSByZXN0b3JlZCB0byB0aGUgc3RhY2sgYmVmb3JlXG4gKiB1cGRhdGluZyBleGVjdXRpb24uXG4gKlxuICogTmV4dCwgaXQgYWRkcyB0aGUgRW50ZXIgb3Bjb2RlLCB3aGljaCBtYXJrcyB0aGUgY3VycmVudCBwb3NpdGlvblxuICogaW4gdGhlIERPTSwgYW5kIHJlbWVtYmVycyB0aGUgY3VycmVudCAkcGMgKHRoZSBuZXh0IGluc3RydWN0aW9uKVxuICogYXMgdGhlIGZpcnN0IGluc3RydWN0aW9uIHRvIGV4ZWN1dGUgZHVyaW5nIHVwZGF0aW5nIGV4ZWN1dGlvbi5cbiAqXG4gKiBOZXh0LCBpdCBydW5zIGBib2R5YCwgd2hpY2ggYWRkcyB0aGUgb3Bjb2RlcyB0aGF0IHNob3VsZFxuICogZXhlY3V0ZSBib3RoIGR1cmluZyBpbml0aWFsIGV4ZWN1dGlvbiBhbmQgZHVyaW5nIHVwZGF0aW5nIGV4ZWN1dGlvbi5cbiAqIElmIHRoZSBgYm9keWAgd2lzaGVzIHRvIGZpbmlzaCBlYXJseSwgaXQgc2hvdWxkIEp1bXAgdG8gdGhlXG4gKiBgRklOQUxMWWAgbGFiZWwuXG4gKlxuICogTmV4dCwgaXQgYWRkcyB0aGUgRklOQUxMWSBsYWJlbCwgZm9sbG93ZWQgYnk6XG4gKlxuICogLSB0aGUgRXhpdCBvcGNvZGUsIHdoaWNoIGZpbmFsaXplcyB0aGUgbWFya2VkIERPTSBzdGFydGVkIGJ5IHRoZVxuICogICBFbnRlciBvcGNvZGUuXG4gKiAtIHRoZSBSZXR1cm4gb3Bjb2RlLCB3aGljaCByZXR1cm5zIHRvIHRoZSBjdXJyZW50IHJldHVybiBwb2ludFxuICogICAoJHJhKS5cbiAqXG4gKiBGaW5hbGx5LCBpdCBhZGRzIHRoZSBFTkRJTklUSUFMIGxhYmVsIGZvbGxvd2VkIGJ5IHRoZSBQb3BGcmFtZVxuICogaW5zdHJ1Y3Rpb24sIHdoaWNoIHJlc3RvcmVzICRmcCwgJHNwIGFuZCAkcmEuXG4gKlxuICogIyBVcGRhdGluZyBFeGVjdXRpb25cbiAqXG4gKiBVcGRhdGluZyBleGVjdXRpb24gZm9yIHRoaXMgYHJlcGxheWFibGVgIG9jY3VycyBpZiB0aGUgYGJvZHlgIGFkZGVkIGFuXG4gKiBhc3NlcnRpb24sIHZpYSBvbmUgb2YgdGhlIGBKdW1wSWZgLCBgSnVtcFVubGVzc2Agb3IgYEFzc2VydFNhbWVgIG9wY29kZXMuXG4gKlxuICogSWYsIGR1cmluZyB1cGRhdGluZyBleGVjdXRvbiwgdGhlIGFzc2VydGlvbiBmYWlscywgdGhlIGluaXRpYWwgVk0gaXNcbiAqIHJlc3RvcmVkLCBhbmQgdGhlIHN0b3JlZCBhcmd1bWVudHMgYXJlIHB1c2hlZCBvbnRvIHRoZSBzdGFjay4gVGhlIERPTVxuICogYmV0d2VlbiB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyBtYXJrZXJzIGlzIGNsZWFyZWQsIGFuZCB0aGUgVk0ncyBjdXJzb3JcbiAqIGlzIHNldCB0byB0aGUgYXJlYSBqdXN0IGNsZWFyZWQuXG4gKlxuICogVGhlIHJldHVybiBwb2ludCAoJHJhKSBpcyBzZXQgdG8gLTEsIHRoZSBleGl0IGluc3RydWN0aW9uLlxuICpcbiAqIEZpbmFsbHksIHRoZSAkcGMgaXMgc2V0IHRvIHRvIHRoZSBpbnN0cnVjdGlvbiBzYXZlZCBvZmYgYnkgdGhlXG4gKiBFbnRlciBvcGNvZGUgZHVyaW5nIGluaXRpYWwgZXhlY3V0aW9uLCBhbmQgZXhlY3V0aW9uIHByb2NlZWRzIGFzXG4gKiB1c3VhbC5cbiAqXG4gKiBUaGUgb25seSBkaWZmZXJlbmNlIGlzIHRoYXQgd2hlbiBhIGBSZXR1cm5gIGluc3RydWN0aW9uIGlzXG4gKiBlbmNvdW50ZXJlZCwgdGhlIHByb2dyYW0ganVtcHMgdG8gLTEgcmF0aGVyIHRoYW4gdGhlIEVORCBsYWJlbCxcbiAqIGFuZCB0aGUgUG9wRnJhbWUgb3Bjb2RlIGlzIG5vdCBuZWVkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSZXBsYXlhYmxlKG9wOiBQdXNoU3RhdGVtZW50T3AsIGFyZ3M6ICgpID0+IG51bWJlciwgYm9keTogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAvLyBTdGFydCBhIG5ldyBsYWJlbCBmcmFtZSwgdG8gZ2l2ZSBFTkQgYW5kIFJFVFVSTlxuICAvLyBhIHVuaXF1ZSBtZWFuaW5nLlxuXG4gIG9wKEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUuU3RhcnRMYWJlbHMpO1xuICBvcChNYWNoaW5lT3AuUHVzaEZyYW1lKTtcblxuICAvLyBJZiB0aGUgYm9keSBpbnZva2VzIGEgYmxvY2ssIGl0cyByZXR1cm4gd2lsbCByZXR1cm4gdG9cbiAgLy8gRU5ELiBPdGhlcndpc2UsIHRoZSByZXR1cm4gaW4gUkVUVVJOIHdpbGwgcmV0dXJuIHRvIEVORC5cbiAgb3AoTWFjaGluZU9wLlJldHVyblRvLCBsYWJlbE9wZXJhbmQoJ0VORElOSVRJQUwnKSk7XG5cbiAgLy8gUHVzaCB0aGUgYXJndW1lbnRzIG9udG8gdGhlIHN0YWNrLiBUaGUgYXJncygpIGZ1bmN0aW9uXG4gIC8vIHRlbGxzIHVzIGhvdyBtYW55IHN0YWNrIGVsZW1lbnRzIHRvIHJldGFpbiBmb3IgcmUtZXhlY3V0aW9uXG4gIC8vIHdoZW4gdXBkYXRpbmcuXG4gIGxldCBjb3VudCA9IGFyZ3MoKTtcblxuICAvLyBTdGFydCBhIG5ldyB1cGRhdGluZyBjbG9zdXJlLCByZW1lbWJlcmluZyBgY291bnRgIGVsZW1lbnRzXG4gIC8vIGZyb20gdGhlIHN0YWNrLiBFdmVyeXRoaW5nIGFmdGVyIHRoaXMgcG9pbnQsIGFuZCBiZWZvcmUgRU5ELFxuICAvLyB3aWxsIGV4ZWN1dGUgYm90aCBpbml0aWFsbHkgYW5kIHRvIHVwZGF0ZSB0aGUgYmxvY2suXG4gIC8vXG4gIC8vIFRoZSBlbnRlciBhbmQgZXhpdCBvcGNvZGVzIGFsc28gdHJhY2sgdGhlIGFyZWEgb2YgdGhlIERPTVxuICAvLyBhc3NvY2lhdGVkIHdpdGggdGhpcyBibG9jay4gSWYgYW4gYXNzZXJ0aW9uIGluc2lkZSB0aGUgYmxvY2tcbiAgLy8gZmFpbHMgKGZvciBleGFtcGxlLCB0aGUgdGVzdCB2YWx1ZSBjaGFuZ2VzIGZyb20gdHJ1ZSB0byBmYWxzZVxuICAvLyBpbiBhbiAjaWYpLCB0aGUgRE9NIGlzIGNsZWFyZWQgYW5kIHRoZSBwcm9ncmFtIGlzIHJlLWV4ZWN1dGVkLFxuICAvLyByZXN0b3JpbmcgYGNvdW50YCBlbGVtZW50cyB0byB0aGUgc3RhY2sgYW5kIGV4ZWN1dGluZyB0aGVcbiAgLy8gaW5zdHJ1Y3Rpb25zIGJldHdlZW4gdGhlIGVudGVyIGFuZCBleGl0LlxuICBvcChPcC5FbnRlciwgY291bnQpO1xuXG4gIC8vIEV2YWx1YXRlIHRoZSBib2R5IG9mIHRoZSBibG9jay4gVGhlIGJvZHkgb2YgdGhlIGJsb2NrIG1heVxuICAvLyByZXR1cm4sIHdoaWNoIHdpbGwganVtcCBleGVjdXRpb24gdG8gRU5EIGR1cmluZyBpbml0aWFsXG4gIC8vIGV4ZWN1dGlvbiwgYW5kIGV4aXQgdGhlIHVwZGF0aW5nIHJvdXRpbmUuXG4gIGJvZHkoKTtcblxuICAvLyBBbGwgZXhlY3V0aW9uIHBhdGhzIGluIHRoZSBib2R5IHNob3VsZCBydW4gdGhlIEZJTkFMTFkgb25jZVxuICAvLyB0aGV5IGFyZSBkb25lLiBJdCBpcyBleGVjdXRlZCBib3RoIGR1cmluZyBpbml0aWFsIGV4ZWN1dGlvblxuICAvLyBhbmQgZHVyaW5nIHVwZGF0aW5nIGV4ZWN1dGlvbi5cbiAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5MYWJlbCwgJ0ZJTkFMTFknKTtcblxuICAvLyBGaW5hbGl6ZSB0aGUgRE9NLlxuICBvcChPcC5FeGl0KTtcblxuICAvLyBJbiBpbml0aWFsIGV4ZWN1dGlvbiwgdGhpcyBpcyBhIG5vb3A6IGl0IHJldHVybnMgdG8gdGhlXG4gIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2luZyBvcGNvZGUuIEluIHVwZGF0aW5nIGV4ZWN1dGlvbiwgdGhpc1xuICAvLyBleGl0cyB0aGUgdXBkYXRpbmcgcm91dGluZS5cbiAgb3AoTWFjaGluZU9wLlJldHVybik7XG5cbiAgLy8gQ2xlYW51cCBjb2RlIGZvciB0aGUgYmxvY2suIFJ1bnMgb24gaW5pdGlhbCBleGVjdXRpb25cbiAgLy8gYnV0IG5vdCBvbiB1cGRhdGluZy5cbiAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5MYWJlbCwgJ0VORElOSVRJQUwnKTtcbiAgb3AoTWFjaGluZU9wLlBvcEZyYW1lKTtcbiAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5TdG9wTGFiZWxzKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgdGhlIGByZXBsYXlhYmxlYCBjb252ZW5pZW5jZSB0aGF0IGFsbG93cyB0aGVcbiAqIGNhbGxlciB0byBwcm92aWRlIGRpZmZlcmVudCBjb2RlIGJhc2VkIHVwb24gd2hldGhlciB0aGUgaXRlbSBhdFxuICogdGhlIHRvcCBvZiB0aGUgc3RhY2sgaXMgdHJ1ZSBvciBmYWxzZS5cbiAqXG4gKiBBcyBpbiBgcmVwbGF5YWJsZWAsIHRoZSBgaWZUcnVlYCBhbmQgYGlmRmFsc2VgIGNvZGUgY2FuIGludm9rZSBgcmV0dXJuYC5cbiAqXG4gKiBEdXJpbmcgdGhlIGluaXRpYWwgZXhlY3V0aW9uLCBhIGByZXR1cm5gIHdpbGwgY29udGludWUgZXhlY3V0aW9uXG4gKiBpbiB0aGUgY2xlYW51cCBjb2RlLCB3aGljaCBmaW5hbGl6ZXMgdGhlIGN1cnJlbnQgRE9NIGJsb2NrIGFuZCBwb3BzXG4gKiB0aGUgY3VycmVudCBmcmFtZS5cbiAqXG4gKiBEdXJpbmcgdGhlIHVwZGF0aW5nIGV4ZWN1dGlvbiwgYSBgcmV0dXJuYCB3aWxsIGV4aXQgdGhlIHVwZGF0aW5nXG4gKiByb3V0aW5lLCBhcyBpdCBjYW4gcmV1c2UgdGhlIERPTSBibG9jayBhbmQgaXMgYWx3YXlzIG9ubHkgYSBzaW5nbGVcbiAqIGZyYW1lIGRlZXAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSZXBsYXlhYmxlSWYoXG4gIG9wOiBQdXNoU3RhdGVtZW50T3AsXG4gIGFyZ3M6ICgpID0+IG51bWJlcixcbiAgaWZUcnVlOiAoKSA9PiB2b2lkLFxuICBpZkZhbHNlPzogKCkgPT4gdm9pZFxuKTogdm9pZCB7XG4gIHJldHVybiBSZXBsYXlhYmxlKG9wLCBhcmdzLCAoKSA9PiB7XG4gICAgLy8gSWYgdGhlIGNvbmRpdGlvbmFsIGlzIGZhbHNlLCBqdW1wIHRvIHRoZSBFTFNFIGxhYmVsLlxuICAgIG9wKE9wLkp1bXBVbmxlc3MsIGxhYmVsT3BlcmFuZCgnRUxTRScpKTtcbiAgICAvLyBPdGhlcndpc2UsIGV4ZWN1dGUgdGhlIGNvZGUgYXNzb2NpYXRlZCB3aXRoIHRoZSB0cnVlIGJyYW5jaC5cbiAgICBpZlRydWUoKTtcbiAgICAvLyBXZSdyZSBkb25lLCBzbyByZXR1cm4uIEluIHRoZSBpbml0aWFsIGV4ZWN1dGlvbiwgdGhpcyBydW5zXG4gICAgLy8gdGhlIGNsZWFudXAgY29kZS4gSW4gdGhlIHVwZGF0aW5nIFZNLCBpdCBleGl0cyB0aGUgdXBkYXRpbmdcbiAgICAvLyByb3V0aW5lLlxuICAgIG9wKE1hY2hpbmVPcC5KdW1wLCBsYWJlbE9wZXJhbmQoJ0ZJTkFMTFknKSk7XG4gICAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5MYWJlbCwgJ0VMU0UnKTtcblxuICAgIC8vIElmIHRoZSBjb25kaXRpb25hbCBpcyBmYWxzZSwgYW5kIGNvZGUgYXNzb2NpYXRpZWQgaXRoIHRoZVxuICAgIC8vIGZhbHNlIGJyYW5jaCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQuIElmIHRoZXJlIHdhcyBubyBjb2RlXG4gICAgLy8gYXNzb2NpYXRlZCB3aXRoIHRoZSBmYWxzZSBicmFuY2gsIGp1bXBpbmcgdG8gdGhlIGVsc2Ugc3RhdGVtZW50XG4gICAgLy8gaGFzIG5vIG90aGVyIGJlaGF2aW9yLlxuICAgIGlmIChpZkZhbHNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmRmFsc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtcbiAgQ29tcGlsYWJsZVByb2dyYW0sXG4gIENvbXBpbGVUaW1lQ29tcG9uZW50LFxuICBIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLFxuICBMYXlvdXRXaXRoQ29udGV4dCxcbiAgTWFjaGluZU9wLFxuICBOYW1lZEJsb2NrcyxcbiAgV2lyZUZvcm1hdCxcbiAgT3B0aW9uLFxuICBPcCxcbiAgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGhhc0NhcGFiaWxpdHkgfSBmcm9tICdAZ2xpbW1lci9tYW5hZ2VyJztcbmltcG9ydCB7ICRzMCwgJHMxLCAkc3AsIFNhdmVkUmVnaXN0ZXIgfSBmcm9tICdAZ2xpbW1lci92bSc7XG5pbXBvcnQgeyBFTVBUWV9TVFJJTkdfQVJSQVkgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IFB1c2hFeHByZXNzaW9uT3AsIFB1c2hTdGF0ZW1lbnRPcCB9IGZyb20gJy4uLy4uL3N5bnRheC9jb21waWxlcnMnO1xuaW1wb3J0IHsgbmFtZWRCbG9ja3MgfSBmcm9tICcuLi8uLi91dGlscyc7XG5pbXBvcnQgeyBsYWJlbE9wZXJhbmQsIGxheW91dE9wZXJhbmQsIHN5bWJvbFRhYmxlT3BlcmFuZCwgaXNTdHJpY3RNb2RlIH0gZnJvbSAnLi4vb3BlcmFuZHMnO1xuaW1wb3J0IHsgSW52b2tlU3RhdGljQmxvY2ssIFB1c2hZaWVsZGFibGVCbG9jaywgWWllbGRCbG9jayB9IGZyb20gJy4vYmxvY2tzJztcbmltcG9ydCB7IFJlcGxheWFibGUgfSBmcm9tICcuL2NvbmRpdGlvbmFsJztcbmltcG9ydCB7IGV4cHIgfSBmcm9tICcuL2V4cHInO1xuaW1wb3J0IHsgQ29tcGlsZUFyZ3MsIENvbXBpbGVQb3NpdGlvbmFsIH0gZnJvbSAnLi9zaGFyZWQnO1xuXG5leHBvcnQgY29uc3QgQVRUUlNfQkxPQ0sgPSAnJmF0dHJzJztcblxuaW50ZXJmYWNlIEFueUNvbXBvbmVudCB7XG4gIGVsZW1lbnRCbG9jazogT3B0aW9uPFdpcmVGb3JtYXQuU2VyaWFsaXplZElubGluZUJsb2NrPjtcbiAgcG9zaXRpb25hbDogV2lyZUZvcm1hdC5Db3JlLlBhcmFtcztcbiAgbmFtZWQ6IFdpcmVGb3JtYXQuQ29yZS5IYXNoO1xuICBibG9ja3M6IE5hbWVkQmxvY2tzO1xufVxuXG4vLyB7e2NvbXBvbmVudH19XG5leHBvcnQgaW50ZXJmYWNlIER5bmFtaWNDb21wb25lbnQgZXh0ZW5kcyBBbnlDb21wb25lbnQge1xuICBkZWZpbml0aW9uOiBXaXJlRm9ybWF0LkV4cHJlc3Npb247XG4gIGF0TmFtZXM6IGJvb2xlYW47XG4gIGN1cnJpZWQ6IGJvb2xlYW47XG59XG5cbi8vIDxDb21wb25lbnQ+XG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpY0NvbXBvbmVudCBleHRlbmRzIEFueUNvbXBvbmVudCB7XG4gIGNhcGFiaWxpdGllczogSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5O1xuICBsYXlvdXQ6IENvbXBpbGFibGVQcm9ncmFtO1xufVxuXG4vLyBjaG9rZXBvaW50XG5leHBvcnQgaW50ZXJmYWNlIENvbXBvbmVudCBleHRlbmRzIEFueUNvbXBvbmVudCB7XG4gIC8vIGVpdGhlciB3ZSBrbm93IHRoZSBjYXBhYmlsaXRpZXMgc3RhdGljYWxseSBvciB3ZSBuZWVkIHRvIGJlIGNvbnNlcnZhdGl2ZSBhbmQgYXNzdW1lXG4gIC8vIHRoYXQgdGhlIGNvbXBvbmVudCByZXF1aXJlcyBhbGwgY2FwYWJpbGl0aWVzXG4gIGNhcGFiaWxpdGllczogSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5IHwgdHJ1ZTtcblxuICAvLyBhcmUgdGhlIGFyZ3VtZW50cyBzdXBwbGllZCBhcyBhdE5hbWVzP1xuICBhdE5hbWVzOiBib29sZWFuO1xuXG4gIC8vIGRvIHdlIGhhdmUgdGhlIGxheW91dCBzdGF0aWNhbGx5IG9yIHdpbGwgd2UgbmVlZCB0byBsb29rIGl0IHVwIGF0IHJ1bnRpbWU/XG4gIGxheW91dD86IENvbXBpbGFibGVQcm9ncmFtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSW52b2tlQ29tcG9uZW50KFxuICBvcDogUHVzaFN0YXRlbWVudE9wLFxuICBjb21wb25lbnQ6IENvbXBpbGVUaW1lQ29tcG9uZW50LFxuICBfZWxlbWVudEJsb2NrOiBXaXJlRm9ybWF0LkNvcmUuRWxlbWVudFBhcmFtZXRlcnMsXG4gIHBvc2l0aW9uYWw6IFdpcmVGb3JtYXQuQ29yZS5QYXJhbXMsXG4gIG5hbWVkOiBXaXJlRm9ybWF0LkNvcmUuSGFzaCxcbiAgX2Jsb2NrczogV2lyZUZvcm1hdC5Db3JlLkJsb2Nrc1xuKTogdm9pZCB7XG4gIGxldCB7IGNvbXBpbGFibGUsIGNhcGFiaWxpdGllcywgaGFuZGxlIH0gPSBjb21wb25lbnQ7XG5cbiAgbGV0IGVsZW1lbnRCbG9jayA9IF9lbGVtZW50QmxvY2tcbiAgICA/IChbX2VsZW1lbnRCbG9jaywgW11dIGFzIFdpcmVGb3JtYXQuU2VyaWFsaXplZElubGluZUJsb2NrKVxuICAgIDogbnVsbDtcbiAgbGV0IGJsb2NrcyA9IEFycmF5LmlzQXJyYXkoX2Jsb2NrcykgfHwgX2Jsb2NrcyA9PT0gbnVsbCA/IG5hbWVkQmxvY2tzKF9ibG9ja3MpIDogX2Jsb2NrcztcblxuICBpZiAoY29tcGlsYWJsZSkge1xuICAgIG9wKE9wLlB1c2hDb21wb25lbnREZWZpbml0aW9uLCBoYW5kbGUpO1xuICAgIEludm9rZVN0YXRpY0NvbXBvbmVudChvcCwge1xuICAgICAgY2FwYWJpbGl0aWVzOiBjYXBhYmlsaXRpZXMsXG4gICAgICBsYXlvdXQ6IGNvbXBpbGFibGUsXG4gICAgICBlbGVtZW50QmxvY2ssXG4gICAgICBwb3NpdGlvbmFsLFxuICAgICAgbmFtZWQsXG4gICAgICBibG9ja3MsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb3AoT3AuUHVzaENvbXBvbmVudERlZmluaXRpb24sIGhhbmRsZSk7XG4gICAgSW52b2tlTm9uU3RhdGljQ29tcG9uZW50KG9wLCB7XG4gICAgICBjYXBhYmlsaXRpZXM6IGNhcGFiaWxpdGllcyxcbiAgICAgIGVsZW1lbnRCbG9jayxcbiAgICAgIHBvc2l0aW9uYWwsXG4gICAgICBuYW1lZCxcbiAgICAgIGF0TmFtZXM6IHRydWUsXG4gICAgICBibG9ja3MsXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEludm9rZUR5bmFtaWNDb21wb25lbnQoXG4gIG9wOiBQdXNoU3RhdGVtZW50T3AsXG4gIGRlZmluaXRpb246IFdpcmVGb3JtYXQuQ29yZS5FeHByZXNzaW9uLFxuICBfZWxlbWVudEJsb2NrOiBXaXJlRm9ybWF0LkNvcmUuRWxlbWVudFBhcmFtZXRlcnMsXG4gIHBvc2l0aW9uYWw6IFdpcmVGb3JtYXQuQ29yZS5QYXJhbXMsXG4gIG5hbWVkOiBXaXJlRm9ybWF0LkNvcmUuSGFzaCxcbiAgX2Jsb2NrczogV2lyZUZvcm1hdC5Db3JlLkJsb2NrcyxcbiAgYXROYW1lczogYm9vbGVhbixcbiAgY3VycmllZDogYm9vbGVhblxuKTogdm9pZCB7XG4gIGxldCBlbGVtZW50QmxvY2sgPSBfZWxlbWVudEJsb2NrXG4gICAgPyAoW19lbGVtZW50QmxvY2ssIFtdXSBhcyBXaXJlRm9ybWF0LlNlcmlhbGl6ZWRJbmxpbmVCbG9jaylcbiAgICA6IG51bGw7XG4gIGxldCBibG9ja3MgPSBBcnJheS5pc0FycmF5KF9ibG9ja3MpIHx8IF9ibG9ja3MgPT09IG51bGwgPyBuYW1lZEJsb2NrcyhfYmxvY2tzKSA6IF9ibG9ja3M7XG5cbiAgUmVwbGF5YWJsZShcbiAgICBvcCxcblxuICAgICgpID0+IHtcbiAgICAgIGV4cHIob3AsIGRlZmluaXRpb24pO1xuICAgICAgb3AoT3AuRHVwLCAkc3AsIDApO1xuICAgICAgcmV0dXJuIDI7XG4gICAgfSxcblxuICAgICgpID0+IHtcbiAgICAgIG9wKE9wLkp1bXBVbmxlc3MsIGxhYmVsT3BlcmFuZCgnRUxTRScpKTtcblxuICAgICAgaWYgKGN1cnJpZWQpIHtcbiAgICAgICAgb3AoT3AuUmVzb2x2ZUN1cnJpZWRDb21wb25lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3AoT3AuUmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsIGlzU3RyaWN0TW9kZSgpKTtcbiAgICAgIH1cblxuICAgICAgb3AoT3AuUHVzaER5bmFtaWNDb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICBJbnZva2VOb25TdGF0aWNDb21wb25lbnQob3AsIHtcbiAgICAgICAgY2FwYWJpbGl0aWVzOiB0cnVlLFxuICAgICAgICBlbGVtZW50QmxvY2ssXG4gICAgICAgIHBvc2l0aW9uYWwsXG4gICAgICAgIG5hbWVkLFxuICAgICAgICBhdE5hbWVzLFxuICAgICAgICBibG9ja3MsXG4gICAgICB9KTtcbiAgICAgIG9wKEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUuTGFiZWwsICdFTFNFJyk7XG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBJbnZva2VTdGF0aWNDb21wb25lbnQoXG4gIG9wOiBQdXNoU3RhdGVtZW50T3AsXG4gIHsgY2FwYWJpbGl0aWVzLCBsYXlvdXQsIGVsZW1lbnRCbG9jaywgcG9zaXRpb25hbCwgbmFtZWQsIGJsb2NrcyB9OiBTdGF0aWNDb21wb25lbnRcbik6IHZvaWQge1xuICBsZXQgeyBzeW1ib2xUYWJsZSB9ID0gbGF5b3V0O1xuXG4gIGxldCBiYWlsT3V0ID1cbiAgICBzeW1ib2xUYWJsZS5oYXNFdmFsIHx8IGhhc0NhcGFiaWxpdHkoY2FwYWJpbGl0aWVzLCBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuUHJlcGFyZUFyZ3MpO1xuXG4gIGlmIChiYWlsT3V0KSB7XG4gICAgSW52b2tlTm9uU3RhdGljQ29tcG9uZW50KG9wLCB7XG4gICAgICBjYXBhYmlsaXRpZXMsXG4gICAgICBlbGVtZW50QmxvY2ssXG4gICAgICBwb3NpdGlvbmFsLFxuICAgICAgbmFtZWQsXG4gICAgICBhdE5hbWVzOiB0cnVlLFxuICAgICAgYmxvY2tzLFxuICAgICAgbGF5b3V0LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgb3AoT3AuRmV0Y2gsICRzMCk7XG4gIG9wKE9wLkR1cCwgJHNwLCAxKTtcbiAgb3AoT3AuTG9hZCwgJHMwKTtcbiAgb3AoTWFjaGluZU9wLlB1c2hGcmFtZSk7XG5cbiAgLy8gU2V0dXAgYXJndW1lbnRzXG4gIGxldCB7IHN5bWJvbHMgfSA9IHN5bWJvbFRhYmxlO1xuXG4gIC8vIEFzIHdlIHB1c2ggdmFsdWVzIG9udG8gdGhlIHN0YWNrLCB3ZSBzdG9yZSB0aGUgc3ltYm9scyBhc3NvY2lhdGVkICB3aXRoIHRoZW1cbiAgLy8gc28gdGhhdCB3ZSBjYW4gc2V0IHRoZW0gb24gdGhlIHNjb3BlIGxhdGVyIG9uIHdpdGggU2V0VmFyaWFibGUgYW5kIFNldEJsb2NrXG4gIGxldCBibG9ja1N5bWJvbHM6IG51bWJlcltdID0gW107XG4gIGxldCBhcmdTeW1ib2xzOiBudW1iZXJbXSA9IFtdO1xuICBsZXQgYXJnTmFtZXM6IHN0cmluZ1tdID0gW107XG5cbiAgLy8gRmlyc3Qgd2UgcHVzaCB0aGUgYmxvY2tzIG9udG8gdGhlIHN0YWNrXG4gIGxldCBibG9ja05hbWVzID0gYmxvY2tzLm5hbWVzO1xuXG4gIC8vIFN0YXJ0aW5nIHdpdGggdGhlIGF0dHJzIGJsb2NrLCBpZiBpdCBleGlzdHMgYW5kIGlzIHJlZmVyZW5jZWQgaW4gdGhlIGNvbXBvbmVudFxuICBpZiAoZWxlbWVudEJsb2NrICE9PSBudWxsKSB7XG4gICAgbGV0IHN5bWJvbCA9IHN5bWJvbHMuaW5kZXhPZihBVFRSU19CTE9DSyk7XG5cbiAgICBpZiAoc3ltYm9sICE9PSAtMSkge1xuICAgICAgUHVzaFlpZWxkYWJsZUJsb2NrKG9wLCBlbGVtZW50QmxvY2spO1xuICAgICAgYmxvY2tTeW1ib2xzLnB1c2goc3ltYm9sKTtcbiAgICB9XG4gIH1cblxuICAvLyBGb2xsb3dlZCBieSB0aGUgb3RoZXIgYmxvY2tzLCBpZiB0aGV5IGV4aXN0IGFuZCBhcmUgcmVmZXJlbmNlZCBpbiB0aGUgY29tcG9uZW50LlxuICAvLyBBbHNvIHN0b3JlIHRoZSBpbmRleCBvZiB0aGUgYXNzb2NpYXRlZCBzeW1ib2wuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBuYW1lID0gYmxvY2tOYW1lc1tpXTtcbiAgICBsZXQgc3ltYm9sID0gc3ltYm9scy5pbmRleE9mKGAmJHtuYW1lfWApO1xuXG4gICAgaWYgKHN5bWJvbCAhPT0gLTEpIHtcbiAgICAgIFB1c2hZaWVsZGFibGVCbG9jayhvcCwgYmxvY2tzLmdldChuYW1lKSk7XG4gICAgICBibG9ja1N5bWJvbHMucHVzaChzeW1ib2wpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE5leHQgdXAgd2UgaGF2ZSBhcmd1bWVudHMuIElmIHRoZSBjb21wb25lbnQgaGFzIHRoZSBgY3JlYXRlQXJnc2AgY2FwYWJpbGl0eSxcbiAgLy8gdGhlbiBpdCB3YW50cyBhY2Nlc3MgdG8gdGhlIGFyZ3VtZW50cyBpbiBKYXZhU2NyaXB0LiBXZSBjYW4ndCBrbm93IHdoZXRoZXJcbiAgLy8gb3Igbm90IGFuIGFyZ3VtZW50IGlzIHVzZWQsIHNvIHdlIGhhdmUgdG8gZ2l2ZSBhY2Nlc3MgdG8gYWxsIG9mIHRoZW0uXG4gIGlmIChoYXNDYXBhYmlsaXR5KGNhcGFiaWxpdGllcywgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LkNyZWF0ZUFyZ3MpKSB7XG4gICAgLy8gRmlyc3Qgd2UgcHVzaCBwb3NpdGlvbmFsIGFyZ3VtZW50c1xuICAgIGxldCBjb3VudCA9IENvbXBpbGVQb3NpdGlvbmFsKG9wLCBwb3NpdGlvbmFsKTtcblxuICAgIC8vIHNldHVwIHRoZSBmbGFncyB3aXRoIHRoZSBjb3VudCBvZiBwb3NpdGlvbmFscywgYW5kIHRvIGluZGljYXRlIHRoYXQgYXROYW1lc1xuICAgIC8vIGFyZSB1c2VkXG4gICAgbGV0IGZsYWdzID0gY291bnQgPDwgNDtcbiAgICBmbGFncyB8PSAwYjEwMDA7XG5cbiAgICBsZXQgbmFtZXM6IHN0cmluZ1tdID0gRU1QVFlfU1RSSU5HX0FSUkFZIGFzIHN0cmluZ1tdO1xuXG4gICAgLy8gTmV4dCwgaWYgbmFtZWQgYXJncyBleGlzdCwgcHVzaCB0aGVtIGFsbC4gSWYgdGhleSBoYXZlIGFuIGFzc29jaWF0ZWQgc3ltYm9sXG4gICAgLy8gaW4gdGhlIGludm9rZWQgY29tcG9uZW50IChlLmcuIHRoZXkgYXJlIHVzZWQgd2l0aGluIGl0cyB0ZW1wbGF0ZSksIHdlIHB1c2hcbiAgICAvLyB0aGF0IHN5bWJvbC4gSWYgbm90LCB3ZSBzdGlsbCBwdXNoIHRoZSBleHByZXNzaW9uIGFzIGl0IG1heSBiZSB1c2VkLCBhbmRcbiAgICAvLyB3ZSBzdG9yZSB0aGUgc3ltYm9sIGFzIC0xICh0aGlzIGlzIHVzZWQgbGF0ZXIpLlxuICAgIGlmIChuYW1lZCAhPT0gbnVsbCkge1xuICAgICAgbmFtZXMgPSBuYW1lZFswXTtcbiAgICAgIGxldCB2YWwgPSBuYW1lZFsxXTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHN5bWJvbHMuaW5kZXhPZihuYW1lc1tpXSk7XG5cbiAgICAgICAgZXhwcihvcCwgdmFsW2ldKTtcbiAgICAgICAgYXJnU3ltYm9scy5wdXNoKHN5bWJvbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmluYWxseSwgcHVzaCB0aGUgVk0gYXJndW1lbnRzIHRoZW1zZWx2ZXMuIFRoZXNlIGFyZ3Mgd29uJ3QgbmVlZCBhY2Nlc3NcbiAgICAvLyB0byBibG9ja3MgKHRoZXkgYXJlbid0IGFjY2Vzc2libGUgZnJvbSB1c2VybGFuZCBhbnl3YXlzKSwgc28gd2UgcHVzaCBhblxuICAgIC8vIGVtcHR5IGFycmF5IGluc3RlYWQgb2YgdGhlIGFjdHVhbCBibG9jayBuYW1lcy5cbiAgICBvcChPcC5QdXNoQXJncywgbmFtZXMsIEVNUFRZX1NUUklOR19BUlJBWSwgZmxhZ3MpO1xuXG4gICAgLy8gQW5kIHB1c2ggYW4gZXh0cmEgcG9wIG9wZXJhdGlvbiB0byByZW1vdmUgdGhlIGFyZ3MgYmVmb3JlIHdlIGJlZ2luIHNldHRpbmdcbiAgICAvLyB2YXJpYWJsZXMgb24gdGhlIGxvY2FsIGNvbnRleHRcbiAgICBhcmdTeW1ib2xzLnB1c2goLTEpO1xuICB9IGVsc2UgaWYgKG5hbWVkICE9PSBudWxsKSB7XG4gICAgLy8gSWYgdGhlIGNvbXBvbmVudCBkb2VzIG5vdCBoYXZlIHRoZSBgY3JlYXRlQXJnc2AgY2FwYWJpbGl0eSwgdGhlbiB0aGUgb25seVxuICAgIC8vIGV4cHJlc3Npb25zIHdlIG5lZWQgdG8gcHVzaCBvbnRvIHRoZSBzdGFjayBhcmUgdGhvc2UgdGhhdCBhcmUgYWN0dWFsbHlcbiAgICAvLyByZWZlcmVuY2VkIGluIHRoZSB0ZW1wbGF0ZSBvZiB0aGUgaW52b2tlZCBjb21wb25lbnQgKGUuZy4gaGF2ZSBzeW1ib2xzKS5cbiAgICBsZXQgbmFtZXMgPSBuYW1lZFswXTtcbiAgICBsZXQgdmFsID0gbmFtZWRbMV07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIGxldCBzeW1ib2wgPSBzeW1ib2xzLmluZGV4T2YobmFtZSk7XG5cbiAgICAgIGlmIChzeW1ib2wgIT09IC0xKSB7XG4gICAgICAgIGV4cHIob3AsIHZhbFtpXSk7XG4gICAgICAgIGFyZ1N5bWJvbHMucHVzaChzeW1ib2wpO1xuICAgICAgICBhcmdOYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG9wKE9wLkJlZ2luQ29tcG9uZW50VHJhbnNhY3Rpb24sICRzMCk7XG5cbiAgaWYgKGhhc0NhcGFiaWxpdHkoY2FwYWJpbGl0aWVzLCBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuRHluYW1pY1Njb3BlKSkge1xuICAgIG9wKE9wLlB1c2hEeW5hbWljU2NvcGUpO1xuICB9XG5cbiAgaWYgKGhhc0NhcGFiaWxpdHkoY2FwYWJpbGl0aWVzLCBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuQ3JlYXRlSW5zdGFuY2UpKSB7XG4gICAgb3AoT3AuQ3JlYXRlQ29tcG9uZW50LCAoYmxvY2tzLmhhcygnZGVmYXVsdCcpIGFzIGFueSkgfCAwLCAkczApO1xuICB9XG5cbiAgb3AoT3AuUmVnaXN0ZXJDb21wb25lbnREZXN0cnVjdG9yLCAkczApO1xuXG4gIGlmIChoYXNDYXBhYmlsaXR5KGNhcGFiaWxpdGllcywgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LkNyZWF0ZUFyZ3MpKSB7XG4gICAgb3AoT3AuR2V0Q29tcG9uZW50U2VsZiwgJHMwKTtcbiAgfSBlbHNlIHtcbiAgICBvcChPcC5HZXRDb21wb25lbnRTZWxmLCAkczAsIGFyZ05hbWVzKTtcbiAgfVxuXG4gIC8vIFNldHVwIHRoZSBuZXcgcm9vdCBzY29wZSBmb3IgdGhlIGNvbXBvbmVudFxuICBvcChPcC5Sb290U2NvcGUsIHN5bWJvbHMubGVuZ3RoICsgMSwgT2JqZWN0LmtleXMoYmxvY2tzKS5sZW5ndGggPiAwID8gMSA6IDApO1xuXG4gIC8vIFBvcCB0aGUgc2VsZiByZWZlcmVuY2Ugb2ZmIHRoZSBzdGFjayBhbmQgc2V0IGl0IHRvIHRoZSBzeW1ib2wgZm9yIGB0aGlzYFxuICAvLyBpbiB0aGUgbmV3IHNjb3BlLiBUaGlzIGlzIHdoeSBhbGwgc3Vic2VxdWVudCBzeW1ib2xzIGFyZSBpbmNyZWFzZWQgYnkgb25lLlxuICBvcChPcC5TZXRWYXJpYWJsZSwgMCk7XG5cbiAgLy8gR29pbmcgaW4gcmV2ZXJzZSwgbm93IHdlIHBvcCB0aGUgYXJncy9ibG9ja3Mgb2ZmIHRoZSBzdGFjaywgc3RhcnRpbmcgd2l0aFxuICAvLyBhcmd1bWVudHMsIGFuZCBhc3NpZ24gdGhlbSB0byB0aGVpciBzeW1ib2xzIGluIHRoZSBuZXcgc2NvcGUuXG4gIGZvciAobGV0IGkgPSBhcmdTeW1ib2xzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IHN5bWJvbCA9IGFyZ1N5bWJvbHNbaV07XG5cbiAgICBpZiAoc3ltYm9sID09PSAtMSkge1xuICAgICAgLy8gVGhlIGV4cHJlc3Npb24gd2FzIG5vdCBib3VuZCB0byBhIGxvY2FsIHN5bWJvbCwgaXQgd2FzIG9ubHkgcHVzaGVkIHRvIGJlXG4gICAgICAvLyB1c2VkIHdpdGggVk0gYXJncyBpbiB0aGUgamF2YXNjcmlwdCBzaWRlXG4gICAgICBvcChPcC5Qb3AsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcChPcC5TZXRWYXJpYWJsZSwgc3ltYm9sICsgMSk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgYW55IHBvc2l0aW9uYWwgcGFyYW1zIGV4aXN0LCBwb3AgdGhlbSBvZmYgdGhlIHN0YWNrIGFzIHdlbGxcbiAgaWYgKHBvc2l0aW9uYWwgIT09IG51bGwpIHtcbiAgICBvcChPcC5Qb3AsIHBvc2l0aW9uYWwubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIEZpbmlzaCB1cCBieSBwb3BwaW5nIG9mZiBhbmQgYXNzaWduaW5nIGJsb2Nrc1xuICBmb3IgKGxldCBpID0gYmxvY2tTeW1ib2xzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGV0IHN5bWJvbCA9IGJsb2NrU3ltYm9sc1tpXTtcblxuICAgIG9wKE9wLlNldEJsb2NrLCBzeW1ib2wgKyAxKTtcbiAgfVxuXG4gIG9wKE9wLkNvbnN0YW50LCBsYXlvdXRPcGVyYW5kKGxheW91dCkpO1xuICBvcChPcC5Db21waWxlQmxvY2spO1xuICBvcChNYWNoaW5lT3AuSW52b2tlVmlydHVhbCk7XG4gIG9wKE9wLkRpZFJlbmRlckxheW91dCwgJHMwKTtcblxuICBvcChNYWNoaW5lT3AuUG9wRnJhbWUpO1xuICBvcChPcC5Qb3BTY29wZSk7XG5cbiAgaWYgKGhhc0NhcGFiaWxpdHkoY2FwYWJpbGl0aWVzLCBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuRHluYW1pY1Njb3BlKSkge1xuICAgIG9wKE9wLlBvcER5bmFtaWNTY29wZSk7XG4gIH1cblxuICBvcChPcC5Db21taXRDb21wb25lbnRUcmFuc2FjdGlvbik7XG4gIG9wKE9wLkxvYWQsICRzMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBJbnZva2VOb25TdGF0aWNDb21wb25lbnQoXG4gIG9wOiBQdXNoU3RhdGVtZW50T3AsXG4gIHsgY2FwYWJpbGl0aWVzLCBlbGVtZW50QmxvY2ssIHBvc2l0aW9uYWwsIG5hbWVkLCBhdE5hbWVzLCBibG9ja3M6IG5hbWVkQmxvY2tzLCBsYXlvdXQgfTogQ29tcG9uZW50XG4pOiB2b2lkIHtcbiAgbGV0IGJpbmRhYmxlQmxvY2tzID0gISFuYW1lZEJsb2NrcztcbiAgbGV0IGJpbmRhYmxlQXROYW1lcyA9XG4gICAgY2FwYWJpbGl0aWVzID09PSB0cnVlIHx8XG4gICAgaGFzQ2FwYWJpbGl0eShjYXBhYmlsaXRpZXMsIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5QcmVwYXJlQXJncykgfHxcbiAgICAhIShuYW1lZCAmJiBuYW1lZFswXS5sZW5ndGggIT09IDApO1xuXG4gIGxldCBibG9ja3MgPSBuYW1lZEJsb2Nrcy53aXRoKCdhdHRycycsIGVsZW1lbnRCbG9jayk7XG5cbiAgb3AoT3AuRmV0Y2gsICRzMCk7XG4gIG9wKE9wLkR1cCwgJHNwLCAxKTtcbiAgb3AoT3AuTG9hZCwgJHMwKTtcblxuICBvcChNYWNoaW5lT3AuUHVzaEZyYW1lKTtcbiAgQ29tcGlsZUFyZ3Mob3AsIHBvc2l0aW9uYWwsIG5hbWVkLCBibG9ja3MsIGF0TmFtZXMpO1xuICBvcChPcC5QcmVwYXJlQXJncywgJHMwKTtcblxuICBpbnZva2VQcmVwYXJlZENvbXBvbmVudChvcCwgYmxvY2tzLmhhcygnZGVmYXVsdCcpLCBiaW5kYWJsZUJsb2NrcywgYmluZGFibGVBdE5hbWVzLCAoKSA9PiB7XG4gICAgaWYgKGxheW91dCkge1xuICAgICAgb3AoT3AuUHVzaFN5bWJvbFRhYmxlLCBzeW1ib2xUYWJsZU9wZXJhbmQobGF5b3V0LnN5bWJvbFRhYmxlKSk7XG4gICAgICBvcChPcC5Db25zdGFudCwgbGF5b3V0T3BlcmFuZChsYXlvdXQpKTtcbiAgICAgIG9wKE9wLkNvbXBpbGVCbG9jayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wKE9wLkdldENvbXBvbmVudExheW91dCwgJHMwKTtcbiAgICB9XG5cbiAgICBvcChPcC5Qb3B1bGF0ZUxheW91dCwgJHMwKTtcbiAgfSk7XG5cbiAgb3AoT3AuTG9hZCwgJHMwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFdyYXBwZWRDb21wb25lbnQoXG4gIG9wOiBQdXNoU3RhdGVtZW50T3AsXG4gIGxheW91dDogTGF5b3V0V2l0aENvbnRleHQsXG4gIGF0dHJzQmxvY2tOdW1iZXI6IG51bWJlclxuKTogdm9pZCB7XG4gIG9wKEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUuU3RhcnRMYWJlbHMpO1xuICBXaXRoU2F2ZWRSZWdpc3RlcihvcCwgJHMxLCAoKSA9PiB7XG4gICAgb3AoT3AuR2V0Q29tcG9uZW50VGFnTmFtZSwgJHMwKTtcbiAgICBvcChPcC5QcmltaXRpdmVSZWZlcmVuY2UpO1xuICAgIG9wKE9wLkR1cCwgJHNwLCAwKTtcbiAgfSk7XG4gIG9wKE9wLkp1bXBVbmxlc3MsIGxhYmVsT3BlcmFuZCgnQk9EWScpKTtcbiAgb3AoT3AuRmV0Y2gsICRzMSk7XG4gIG9wKE9wLlB1dENvbXBvbmVudE9wZXJhdGlvbnMpO1xuICBvcChPcC5PcGVuRHluYW1pY0VsZW1lbnQpO1xuICBvcChPcC5EaWRDcmVhdGVFbGVtZW50LCAkczApO1xuICBZaWVsZEJsb2NrKG9wLCBhdHRyc0Jsb2NrTnVtYmVyLCBudWxsKTtcbiAgb3AoT3AuRmx1c2hFbGVtZW50KTtcbiAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5MYWJlbCwgJ0JPRFknKTtcbiAgSW52b2tlU3RhdGljQmxvY2sob3AsIFtsYXlvdXQuYmxvY2tbMF0sIFtdXSk7XG4gIG9wKE9wLkZldGNoLCAkczEpO1xuICBvcChPcC5KdW1wVW5sZXNzLCBsYWJlbE9wZXJhbmQoJ0VORCcpKTtcbiAgb3AoT3AuQ2xvc2VFbGVtZW50KTtcbiAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5MYWJlbCwgJ0VORCcpO1xuICBvcChPcC5Mb2FkLCAkczEpO1xuICBvcChIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLlN0b3BMYWJlbHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlUHJlcGFyZWRDb21wb25lbnQoXG4gIG9wOiBQdXNoU3RhdGVtZW50T3AsXG4gIGhhc0Jsb2NrOiBib29sZWFuLFxuICBiaW5kYWJsZUJsb2NrczogYm9vbGVhbixcbiAgYmluZGFibGVBdE5hbWVzOiBib29sZWFuLFxuICBwb3B1bGF0ZUxheW91dDogT3B0aW9uPCgpID0+IHZvaWQ+ID0gbnVsbFxuKTogdm9pZCB7XG4gIG9wKE9wLkJlZ2luQ29tcG9uZW50VHJhbnNhY3Rpb24sICRzMCk7XG4gIG9wKE9wLlB1c2hEeW5hbWljU2NvcGUpO1xuXG4gIG9wKE9wLkNyZWF0ZUNvbXBvbmVudCwgKGhhc0Jsb2NrIGFzIGFueSkgfCAwLCAkczApO1xuXG4gIC8vIHRoaXMgaGFzIHRvIHJ1biBhZnRlciBjcmVhdGVDb21wb25lbnQgdG8gYWxsb3dcbiAgLy8gZm9yIGxhdGUtYm91bmQgbGF5b3V0cywgYnV0IGEgY2FsbGVyIGlzIGZyZWVcbiAgLy8gdG8gcG9wdWxhdGUgdGhlIGxheW91dCBlYXJsaWVyIGlmIGl0IHdhbnRzIHRvXG4gIC8vIGFuZCBkbyBub3RoaW5nIGhlcmUuXG4gIGlmIChwb3B1bGF0ZUxheW91dCkge1xuICAgIHBvcHVsYXRlTGF5b3V0KCk7XG4gIH1cblxuICBvcChPcC5SZWdpc3RlckNvbXBvbmVudERlc3RydWN0b3IsICRzMCk7XG4gIG9wKE9wLkdldENvbXBvbmVudFNlbGYsICRzMCk7XG5cbiAgb3AoT3AuVmlydHVhbFJvb3RTY29wZSwgJHMwKTtcbiAgb3AoT3AuU2V0VmFyaWFibGUsIDApO1xuICBvcChPcC5TZXR1cEZvckV2YWwsICRzMCk7XG5cbiAgaWYgKGJpbmRhYmxlQXROYW1lcykgb3AoT3AuU2V0TmFtZWRWYXJpYWJsZXMsICRzMCk7XG4gIGlmIChiaW5kYWJsZUJsb2Nrcykgb3AoT3AuU2V0QmxvY2tzLCAkczApO1xuXG4gIG9wKE9wLlBvcCwgMSk7XG4gIG9wKE9wLkludm9rZUNvbXBvbmVudExheW91dCwgJHMwKTtcbiAgb3AoT3AuRGlkUmVuZGVyTGF5b3V0LCAkczApO1xuICBvcChNYWNoaW5lT3AuUG9wRnJhbWUpO1xuXG4gIG9wKE9wLlBvcFNjb3BlKTtcbiAgb3AoT3AuUG9wRHluYW1pY1Njb3BlKTtcbiAgb3AoT3AuQ29tbWl0Q29tcG9uZW50VHJhbnNhY3Rpb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gSW52b2tlQmFyZUNvbXBvbmVudChvcDogUHVzaFN0YXRlbWVudE9wKTogdm9pZCB7XG4gIG9wKE9wLkZldGNoLCAkczApO1xuICBvcChPcC5EdXAsICRzcCwgMSk7XG4gIG9wKE9wLkxvYWQsICRzMCk7XG5cbiAgb3AoTWFjaGluZU9wLlB1c2hGcmFtZSk7XG4gIG9wKE9wLlB1c2hFbXB0eUFyZ3MpO1xuICBvcChPcC5QcmVwYXJlQXJncywgJHMwKTtcbiAgaW52b2tlUHJlcGFyZWRDb21wb25lbnQob3AsIGZhbHNlLCBmYWxzZSwgdHJ1ZSwgKCkgPT4ge1xuICAgIG9wKE9wLkdldENvbXBvbmVudExheW91dCwgJHMwKTtcbiAgICBvcChPcC5Qb3B1bGF0ZUxheW91dCwgJHMwKTtcbiAgfSk7XG4gIG9wKE9wLkxvYWQsICRzMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBXaXRoU2F2ZWRSZWdpc3RlcihcbiAgb3A6IFB1c2hFeHByZXNzaW9uT3AsXG4gIHJlZ2lzdGVyOiBTYXZlZFJlZ2lzdGVyLFxuICBibG9jazogKCkgPT4gdm9pZFxuKTogdm9pZCB7XG4gIG9wKE9wLkZldGNoLCByZWdpc3Rlcik7XG4gIGJsb2NrKCk7XG4gIG9wKE9wLkxvYWQsIHJlZ2lzdGVyKTtcbn1cbiIsImV4cG9ydCBjbGFzcyBTdGRMaWIge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgbWFpbjogbnVtYmVyLFxuICAgIHByaXZhdGUgdHJ1c3RpbmdHdWFyZGVkQXBwZW5kOiBudW1iZXIsXG4gICAgcHJpdmF0ZSBjYXV0aW91c0d1YXJkZWRBcHBlbmQ6IG51bWJlcixcbiAgICBwcml2YXRlIHRydXN0aW5nTm9uRHluYW1pY0FwcGVuZDogbnVtYmVyLFxuICAgIHByaXZhdGUgY2F1dGlvdXNOb25EeW5hbWljQXBwZW5kOiBudW1iZXJcbiAgKSB7fVxuXG4gIGdldCAndHJ1c3RpbmctYXBwZW5kJygpIHtcbiAgICByZXR1cm4gdGhpcy50cnVzdGluZ0d1YXJkZWRBcHBlbmQ7XG4gIH1cblxuICBnZXQgJ2NhdXRpb3VzLWFwcGVuZCcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2F1dGlvdXNHdWFyZGVkQXBwZW5kO1xuICB9XG5cbiAgZ2V0ICd0cnVzdGluZy1ub24tZHluYW1pYy1hcHBlbmQnKCkge1xuICAgIHJldHVybiB0aGlzLnRydXN0aW5nTm9uRHluYW1pY0FwcGVuZDtcbiAgfVxuXG4gIGdldCAnY2F1dGlvdXMtbm9uLWR5bmFtaWMtYXBwZW5kJygpIHtcbiAgICByZXR1cm4gdGhpcy5jYXV0aW91c05vbkR5bmFtaWNBcHBlbmQ7XG4gIH1cblxuICBnZXRBcHBlbmQodHJ1c3Rpbmc6IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdHJ1c3RpbmcgPyB0aGlzLnRydXN0aW5nR3VhcmRlZEFwcGVuZCA6IHRoaXMuY2F1dGlvdXNHdWFyZGVkQXBwZW5kO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBDb21waWxlVGltZVJlc29sdmVyLFxuICBDb250YWluaW5nTWV0YWRhdGEsXG4gIFRlbXBsYXRlQ29tcGlsYXRpb25Db250ZXh0LFxuICBDb21waWxlVGltZUFydGlmYWN0cyxcbiAgQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgRW5jb2RlckltcGwgfSBmcm9tICcuL2VuY29kZXInO1xuaW1wb3J0IHsgQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHRJbXBsIH0gZnJvbSAnLi4vcHJvZ3JhbS1jb250ZXh0JztcblxuZXhwb3J0IGZ1bmN0aW9uIHByb2dyYW1Db21waWxhdGlvbkNvbnRleHQoXG4gIGFydGlmYWN0czogQ29tcGlsZVRpbWVBcnRpZmFjdHMsXG4gIHJlc29sdmVyOiBDb21waWxlVGltZVJlc29sdmVyXG4pOiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCB7XG4gIHJldHVybiBuZXcgQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHRJbXBsKGFydGlmYWN0cywgcmVzb2x2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVDb21waWxhdGlvbkNvbnRleHQoXG4gIHByb2dyYW06IENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0LFxuICBtZXRhOiBDb250YWluaW5nTWV0YWRhdGFcbik6IFRlbXBsYXRlQ29tcGlsYXRpb25Db250ZXh0IHtcbiAgbGV0IGVuY29kZXIgPSBuZXcgRW5jb2RlckltcGwocHJvZ3JhbS5oZWFwLCBtZXRhLCBwcm9ncmFtLnN0ZGxpYik7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm9ncmFtLFxuICAgIGVuY29kZXIsXG4gICAgbWV0YSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IGRlYnVnU2xpY2UgfSBmcm9tICdAZ2xpbW1lci9kZWJ1Zyc7XG5pbXBvcnQgeyBUZW1wbGF0ZUNvbXBpbGF0aW9uQ29udGV4dCwgSGFuZGxlUmVzdWx0IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBMT0NBTF9TSE9VTERfTE9HIH0gZnJvbSAnQGdsaW1tZXIvbG9jYWwtZGVidWctZmxhZ3MnO1xuaW1wb3J0IHsgZXh0cmFjdEhhbmRsZSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5leHBvcnQgbGV0IGRlYnVnQ29tcGlsZXI6IChjb250ZXh0OiBUZW1wbGF0ZUNvbXBpbGF0aW9uQ29udGV4dCwgaGFuZGxlOiBIYW5kbGVSZXN1bHQpID0+IHZvaWQ7XG5cbmlmIChMT0NBTF9TSE9VTERfTE9HKSB7XG4gIGRlYnVnQ29tcGlsZXIgPSAoY29udGV4dDogVGVtcGxhdGVDb21waWxhdGlvbkNvbnRleHQsIHJlc3VsdDogSGFuZGxlUmVzdWx0KSA9PiB7XG4gICAgbGV0IGhhbmRsZSA9IGV4dHJhY3RIYW5kbGUocmVzdWx0KTtcbiAgICBsZXQgeyBoZWFwIH0gPSBjb250ZXh0LnByb2dyYW07XG4gICAgbGV0IHN0YXJ0ID0gaGVhcC5nZXRhZGRyKGhhbmRsZSk7XG4gICAgbGV0IGVuZCA9IHN0YXJ0ICsgaGVhcC5zaXplb2YoaGFuZGxlKTtcblxuICAgIGRlYnVnU2xpY2UoY29udGV4dCwgc3RhcnQsIGVuZCk7XG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBDb21waWxlVGltZUNvbXBvbmVudCxcbiAgQ29udGVudFR5cGUsXG4gIEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUsXG4gIEhpZ2hMZXZlbFJlc29sdXRpb25PcGNvZGUsXG4gIE1hY2hpbmVPcCxcbiAgT3AsXG4gIFNleHBPcGNvZGVzLFxuICBTdGF0ZW1lbnRTZXhwT3Bjb2RlLFxuICBXZWxsS25vd25BdHRyTmFtZSxcbiAgV2VsbEtub3duVGFnTmFtZSxcbiAgV2lyZUZvcm1hdCxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyAkZnAsICRzcCB9IGZyb20gJ0BnbGltbWVyL3ZtJztcbmltcG9ydCB7XG4gIEludm9rZVN0YXRpY0Jsb2NrLFxuICBJbnZva2VTdGF0aWNCbG9ja1dpdGhTdGFjayxcbiAgWWllbGRCbG9jayxcbn0gZnJvbSAnLi4vb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9ibG9ja3MnO1xuaW1wb3J0IHtcbiAgSW52b2tlQ29tcG9uZW50LFxuICBJbnZva2VEeW5hbWljQ29tcG9uZW50LFxuICBJbnZva2VOb25TdGF0aWNDb21wb25lbnQsXG59IGZyb20gJy4uL29wY29kZS1idWlsZGVyL2hlbHBlcnMvY29tcG9uZW50cyc7XG5pbXBvcnQgeyBTd2l0Y2hDYXNlcywgUmVwbGF5YWJsZSwgUmVwbGF5YWJsZUlmIH0gZnJvbSAnLi4vb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9jb25kaXRpb25hbCc7XG5pbXBvcnQgeyBleHByIH0gZnJvbSAnLi4vb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9leHByJztcbmltcG9ydCB7IENvbXBpbGVQb3NpdGlvbmFsLCBTaW1wbGVBcmdzIH0gZnJvbSAnLi4vb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9zaGFyZWQnO1xuaW1wb3J0IHtcbiAgQ2FsbCxcbiAgQ2FsbER5bmFtaWMsXG4gIER5bmFtaWNTY29wZSxcbiAgUHVzaFByaW1pdGl2ZVJlZmVyZW5jZSxcbn0gZnJvbSAnLi4vb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy92bSc7XG5pbXBvcnQgeyBldmFsU3ltYm9sc09wZXJhbmQsIGxhYmVsT3BlcmFuZCwgc3RkbGliT3BlcmFuZCB9IGZyb20gJy4uL29wY29kZS1idWlsZGVyL29wZXJhbmRzJztcbmltcG9ydCB7IENvbXBpbGVycywgUHVzaFN0YXRlbWVudE9wIH0gZnJvbSAnLi9jb21waWxlcnMnO1xuaW1wb3J0IHtcbiAgaXNHZXRGcmVlQ29tcG9uZW50LFxuICBpc0dldEZyZWVDb21wb25lbnRPckhlbHBlcixcbiAgaXNHZXRGcmVlTW9kaWZpZXIsXG4gIGlzR2V0RnJlZU9wdGlvbmFsQ29tcG9uZW50T3JIZWxwZXIsXG59IGZyb20gJy4uL29wY29kZS1idWlsZGVyL2hlbHBlcnMvcmVzb2x1dGlvbic7XG5pbXBvcnQgeyBuYW1lZEJsb2NrcyB9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGNvbnN0IFNUQVRFTUVOVFMgPSBuZXcgQ29tcGlsZXJzPFB1c2hTdGF0ZW1lbnRPcCwgU3RhdGVtZW50U2V4cE9wY29kZT4oKTtcblxuY29uc3QgSU5GTEFURV9BVFRSX1RBQkxFOiB7XG4gIFtJIGluIFdlbGxLbm93bkF0dHJOYW1lXTogc3RyaW5nO1xufSA9IFsnY2xhc3MnLCAnaWQnLCAndmFsdWUnLCAnbmFtZScsICd0eXBlJywgJ3N0eWxlJywgJ2hyZWYnXTtcbmNvbnN0IElORkxBVEVfVEFHX1RBQkxFOiB7XG4gIFtJIGluIFdlbGxLbm93blRhZ05hbWVdOiBzdHJpbmc7XG59ID0gWydkaXYnLCAnc3BhbicsICdwJywgJ2EnXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGluZmxhdGVUYWdOYW1lKHRhZ05hbWU6IHN0cmluZyB8IFdlbGxLbm93blRhZ05hbWUpOiBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIHRhZ05hbWUgPT09ICdzdHJpbmcnID8gdGFnTmFtZSA6IElORkxBVEVfVEFHX1RBQkxFW3RhZ05hbWVdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5mbGF0ZUF0dHJOYW1lKGF0dHJOYW1lOiBzdHJpbmcgfCBXZWxsS25vd25BdHRyTmFtZSk6IHN0cmluZyB7XG4gIHJldHVybiB0eXBlb2YgYXR0ck5hbWUgPT09ICdzdHJpbmcnID8gYXR0ck5hbWUgOiBJTkZMQVRFX0FUVFJfVEFCTEVbYXR0ck5hbWVdO1xufVxuXG5TVEFURU1FTlRTLmFkZChTZXhwT3Bjb2Rlcy5Db21tZW50LCAob3AsIHNleHApID0+IG9wKE9wLkNvbW1lbnQsIHNleHBbMV0pKTtcblNUQVRFTUVOVFMuYWRkKFNleHBPcGNvZGVzLkNsb3NlRWxlbWVudCwgKG9wKSA9PiBvcChPcC5DbG9zZUVsZW1lbnQpKTtcblNUQVRFTUVOVFMuYWRkKFNleHBPcGNvZGVzLkZsdXNoRWxlbWVudCwgKG9wKSA9PiBvcChPcC5GbHVzaEVsZW1lbnQpKTtcblxuU1RBVEVNRU5UUy5hZGQoU2V4cE9wY29kZXMuTW9kaWZpZXIsIChvcCwgWywgZXhwcmVzc2lvbiwgcG9zaXRpb25hbCwgbmFtZWRdKSA9PiB7XG4gIGlmIChpc0dldEZyZWVNb2RpZmllcihleHByZXNzaW9uKSkge1xuICAgIG9wKEhpZ2hMZXZlbFJlc29sdXRpb25PcGNvZGUuUmVzb2x2ZU1vZGlmaWVyLCBleHByZXNzaW9uLCAoaGFuZGxlOiBudW1iZXIpID0+IHtcbiAgICAgIG9wKE1hY2hpbmVPcC5QdXNoRnJhbWUpO1xuICAgICAgU2ltcGxlQXJncyhvcCwgcG9zaXRpb25hbCwgbmFtZWQsIGZhbHNlKTtcbiAgICAgIG9wKE9wLk1vZGlmaWVyLCBoYW5kbGUpO1xuICAgICAgb3AoTWFjaGluZU9wLlBvcEZyYW1lKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBleHByKG9wLCBleHByZXNzaW9uKTtcbiAgICBvcChNYWNoaW5lT3AuUHVzaEZyYW1lKTtcbiAgICBTaW1wbGVBcmdzKG9wLCBwb3NpdGlvbmFsLCBuYW1lZCwgZmFsc2UpO1xuICAgIG9wKE9wLkR1cCwgJGZwLCAxKTtcbiAgICBvcChPcC5EeW5hbWljTW9kaWZpZXIpO1xuICAgIG9wKE1hY2hpbmVPcC5Qb3BGcmFtZSk7XG4gIH1cbn0pO1xuXG5TVEFURU1FTlRTLmFkZChTZXhwT3Bjb2Rlcy5TdGF0aWNBdHRyLCAob3AsIFssIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2VdKSA9PiB7XG4gIG9wKE9wLlN0YXRpY0F0dHIsIGluZmxhdGVBdHRyTmFtZShuYW1lKSwgdmFsdWUgYXMgc3RyaW5nLCBuYW1lc3BhY2UgPz8gbnVsbCk7XG59KTtcblxuU1RBVEVNRU5UUy5hZGQoU2V4cE9wY29kZXMuU3RhdGljQ29tcG9uZW50QXR0ciwgKG9wLCBbLCBuYW1lLCB2YWx1ZSwgbmFtZXNwYWNlXSkgPT4ge1xuICBvcChPcC5TdGF0aWNDb21wb25lbnRBdHRyLCBpbmZsYXRlQXR0ck5hbWUobmFtZSksIHZhbHVlIGFzIHN0cmluZywgbmFtZXNwYWNlID8/IG51bGwpO1xufSk7XG5cblNUQVRFTUVOVFMuYWRkKFNleHBPcGNvZGVzLkR5bmFtaWNBdHRyLCAob3AsIFssIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2VdKSA9PiB7XG4gIGV4cHIob3AsIHZhbHVlKTtcbiAgb3AoT3AuRHluYW1pY0F0dHIsIGluZmxhdGVBdHRyTmFtZShuYW1lKSwgZmFsc2UsIG5hbWVzcGFjZSA/PyBudWxsKTtcbn0pO1xuXG5TVEFURU1FTlRTLmFkZChTZXhwT3Bjb2Rlcy5UcnVzdGluZ0R5bmFtaWNBdHRyLCAob3AsIFssIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2VdKSA9PiB7XG4gIGV4cHIob3AsIHZhbHVlKTtcbiAgb3AoT3AuRHluYW1pY0F0dHIsIGluZmxhdGVBdHRyTmFtZShuYW1lKSwgdHJ1ZSwgbmFtZXNwYWNlID8/IG51bGwpO1xufSk7XG5cblNUQVRFTUVOVFMuYWRkKFNleHBPcGNvZGVzLkNvbXBvbmVudEF0dHIsIChvcCwgWywgbmFtZSwgdmFsdWUsIG5hbWVzcGFjZV0pID0+IHtcbiAgZXhwcihvcCwgdmFsdWUpO1xuICBvcChPcC5Db21wb25lbnRBdHRyLCBpbmZsYXRlQXR0ck5hbWUobmFtZSksIGZhbHNlLCBuYW1lc3BhY2UgPz8gbnVsbCk7XG59KTtcblxuU1RBVEVNRU5UUy5hZGQoU2V4cE9wY29kZXMuVHJ1c3RpbmdDb21wb25lbnRBdHRyLCAob3AsIFssIG5hbWUsIHZhbHVlLCBuYW1lc3BhY2VdKSA9PiB7XG4gIGV4cHIob3AsIHZhbHVlKTtcbiAgb3AoT3AuQ29tcG9uZW50QXR0ciwgaW5mbGF0ZUF0dHJOYW1lKG5hbWUpLCB0cnVlLCBuYW1lc3BhY2UgPz8gbnVsbCk7XG59KTtcblxuU1RBVEVNRU5UUy5hZGQoU2V4cE9wY29kZXMuT3BlbkVsZW1lbnQsIChvcCwgWywgdGFnXSkgPT4ge1xuICBvcChPcC5PcGVuRWxlbWVudCwgaW5mbGF0ZVRhZ05hbWUodGFnKSk7XG59KTtcblxuU1RBVEVNRU5UUy5hZGQoU2V4cE9wY29kZXMuT3BlbkVsZW1lbnRXaXRoU3BsYXQsIChvcCwgWywgdGFnXSkgPT4ge1xuICBvcChPcC5QdXRDb21wb25lbnRPcGVyYXRpb25zKTtcbiAgb3AoT3AuT3BlbkVsZW1lbnQsIGluZmxhdGVUYWdOYW1lKHRhZykpO1xufSk7XG5cblNUQVRFTUVOVFMuYWRkKFNleHBPcGNvZGVzLkNvbXBvbmVudCwgKG9wLCBbLCBleHByLCBlbGVtZW50QmxvY2ssIG5hbWVkLCBibG9ja3NdKSA9PiB7XG4gIGlmIChpc0dldEZyZWVDb21wb25lbnQoZXhwcikpIHtcbiAgICBvcChIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVDb21wb25lbnQsIGV4cHIsIChjb21wb25lbnQ6IENvbXBpbGVUaW1lQ29tcG9uZW50KSA9PiB7XG4gICAgICBJbnZva2VDb21wb25lbnQob3AsIGNvbXBvbmVudCwgZWxlbWVudEJsb2NrLCBudWxsLCBuYW1lZCwgYmxvY2tzKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UsIHRoZSBjb21wb25lbnQgbmFtZSB3YXMgYW4gZXhwcmVzc2lvbiwgc28gcmVzb2x2ZSB0aGUgZXhwcmVzc2lvblxuICAgIC8vIGFuZCBpbnZva2UgaXQgYXMgYSBkeW5hbWljIGNvbXBvbmVudFxuICAgIEludm9rZUR5bmFtaWNDb21wb25lbnQob3AsIGV4cHIsIGVsZW1lbnRCbG9jaywgbnVsbCwgbmFtZWQsIGJsb2NrcywgdHJ1ZSwgdHJ1ZSk7XG4gIH1cbn0pO1xuXG5TVEFURU1FTlRTLmFkZChTZXhwT3Bjb2Rlcy5ZaWVsZCwgKG9wLCBbLCB0bywgcGFyYW1zXSkgPT4gWWllbGRCbG9jayhvcCwgdG8sIHBhcmFtcykpO1xuXG5TVEFURU1FTlRTLmFkZChTZXhwT3Bjb2Rlcy5BdHRyU3BsYXQsIChvcCwgWywgdG9dKSA9PiBZaWVsZEJsb2NrKG9wLCB0bywgbnVsbCkpO1xuXG5TVEFURU1FTlRTLmFkZChTZXhwT3Bjb2Rlcy5EZWJ1Z2dlciwgKG9wLCBbLCBldmFsSW5mb10pID0+XG4gIG9wKE9wLkRlYnVnZ2VyLCBldmFsU3ltYm9sc09wZXJhbmQoKSwgZXZhbEluZm8pXG4pO1xuXG5TVEFURU1FTlRTLmFkZChTZXhwT3Bjb2Rlcy5BcHBlbmQsIChvcCwgWywgdmFsdWVdKSA9PiB7XG4gIC8vIFNwZWNpYWwgY2FzZSBmb3Igc3RhdGljIHZhbHVlc1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgb3AoT3AuVGV4dCwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoaXNHZXRGcmVlT3B0aW9uYWxDb21wb25lbnRPckhlbHBlcih2YWx1ZSkpIHtcbiAgICBvcChIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVPcHRpb25hbENvbXBvbmVudE9ySGVscGVyLCB2YWx1ZSwge1xuICAgICAgaWZDb21wb25lbnQoY29tcG9uZW50OiBDb21waWxlVGltZUNvbXBvbmVudCkge1xuICAgICAgICBJbnZva2VDb21wb25lbnQob3AsIGNvbXBvbmVudCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICB9LFxuXG4gICAgICBpZkhlbHBlcihoYW5kbGU6IG51bWJlcikge1xuICAgICAgICBvcChNYWNoaW5lT3AuUHVzaEZyYW1lKTtcbiAgICAgICAgQ2FsbChvcCwgaGFuZGxlLCBudWxsLCBudWxsKTtcbiAgICAgICAgb3AoTWFjaGluZU9wLkludm9rZVN0YXRpYywgc3RkbGliT3BlcmFuZCgnY2F1dGlvdXMtbm9uLWR5bmFtaWMtYXBwZW5kJykpO1xuICAgICAgICBvcChNYWNoaW5lT3AuUG9wRnJhbWUpO1xuICAgICAgfSxcblxuICAgICAgaWZWYWx1ZShoYW5kbGU6IG51bWJlcikge1xuICAgICAgICBvcChNYWNoaW5lT3AuUHVzaEZyYW1lKTtcbiAgICAgICAgb3AoT3AuQ29uc3RhbnRSZWZlcmVuY2UsIGhhbmRsZSk7XG4gICAgICAgIG9wKE1hY2hpbmVPcC5JbnZva2VTdGF0aWMsIHN0ZGxpYk9wZXJhbmQoJ2NhdXRpb3VzLW5vbi1keW5hbWljLWFwcGVuZCcpKTtcbiAgICAgICAgb3AoTWFjaGluZU9wLlBvcEZyYW1lKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodmFsdWVbMF0gPT09IFNleHBPcGNvZGVzLkNhbGwpIHtcbiAgICBsZXQgWywgZXhwcmVzc2lvbiwgcG9zaXRpb25hbCwgbmFtZWRdID0gdmFsdWU7XG5cbiAgICBpZiAoaXNHZXRGcmVlQ29tcG9uZW50T3JIZWxwZXIoZXhwcmVzc2lvbikpIHtcbiAgICAgIG9wKEhpZ2hMZXZlbFJlc29sdXRpb25PcGNvZGUuUmVzb2x2ZUNvbXBvbmVudE9ySGVscGVyLCBleHByZXNzaW9uLCB7XG4gICAgICAgIGlmQ29tcG9uZW50KGNvbXBvbmVudDogQ29tcGlsZVRpbWVDb21wb25lbnQpIHtcbiAgICAgICAgICBJbnZva2VDb21wb25lbnQob3AsIGNvbXBvbmVudCwgbnVsbCwgcG9zaXRpb25hbCwgaGFzaFRvQXJncyhuYW1lZCksIG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBpZkhlbHBlcihoYW5kbGU6IG51bWJlcikge1xuICAgICAgICAgIG9wKE1hY2hpbmVPcC5QdXNoRnJhbWUpO1xuICAgICAgICAgIENhbGwob3AsIGhhbmRsZSwgcG9zaXRpb25hbCwgbmFtZWQpO1xuICAgICAgICAgIG9wKE1hY2hpbmVPcC5JbnZva2VTdGF0aWMsIHN0ZGxpYk9wZXJhbmQoJ2NhdXRpb3VzLW5vbi1keW5hbWljLWFwcGVuZCcpKTtcbiAgICAgICAgICBvcChNYWNoaW5lT3AuUG9wRnJhbWUpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFN3aXRjaENhc2VzKFxuICAgICAgICBvcCxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGV4cHIob3AsIGV4cHJlc3Npb24pO1xuICAgICAgICAgIG9wKE9wLkR5bmFtaWNDb250ZW50VHlwZSk7XG4gICAgICAgIH0sXG4gICAgICAgICh3aGVuKSA9PiB7XG4gICAgICAgICAgd2hlbihDb250ZW50VHlwZS5Db21wb25lbnQsICgpID0+IHtcbiAgICAgICAgICAgIG9wKE9wLlJlc29sdmVDdXJyaWVkQ29tcG9uZW50KTtcbiAgICAgICAgICAgIG9wKE9wLlB1c2hEeW5hbWljQ29tcG9uZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgSW52b2tlTm9uU3RhdGljQ29tcG9uZW50KG9wLCB7XG4gICAgICAgICAgICAgIGNhcGFiaWxpdGllczogdHJ1ZSxcbiAgICAgICAgICAgICAgZWxlbWVudEJsb2NrOiBudWxsLFxuICAgICAgICAgICAgICBwb3NpdGlvbmFsLFxuICAgICAgICAgICAgICBuYW1lZCxcbiAgICAgICAgICAgICAgYXROYW1lczogZmFsc2UsXG4gICAgICAgICAgICAgIGJsb2NrczogbmFtZWRCbG9ja3MobnVsbCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHdoZW4oQ29udGVudFR5cGUuSGVscGVyLCAoKSA9PiB7XG4gICAgICAgICAgICBDYWxsRHluYW1pYyhvcCwgcG9zaXRpb25hbCwgbmFtZWQsICgpID0+IHtcbiAgICAgICAgICAgICAgb3AoTWFjaGluZU9wLkludm9rZVN0YXRpYywgc3RkbGliT3BlcmFuZCgnY2F1dGlvdXMtbm9uLWR5bmFtaWMtYXBwZW5kJykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG9wKE1hY2hpbmVPcC5QdXNoRnJhbWUpO1xuICAgIGV4cHIob3AsIHZhbHVlKTtcbiAgICBvcChNYWNoaW5lT3AuSW52b2tlU3RhdGljLCBzdGRsaWJPcGVyYW5kKCdjYXV0aW91cy1hcHBlbmQnKSk7XG4gICAgb3AoTWFjaGluZU9wLlBvcEZyYW1lKTtcbiAgfVxufSk7XG5cblNUQVRFTUVOVFMuYWRkKFNleHBPcGNvZGVzLlRydXN0aW5nQXBwZW5kLCAob3AsIFssIHZhbHVlXSkgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgb3AoT3AuVGV4dCwgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKHZhbHVlKSk7XG4gIH0gZWxzZSB7XG4gICAgb3AoTWFjaGluZU9wLlB1c2hGcmFtZSk7XG4gICAgZXhwcihvcCwgdmFsdWUpO1xuICAgIG9wKE1hY2hpbmVPcC5JbnZva2VTdGF0aWMsIHN0ZGxpYk9wZXJhbmQoJ3RydXN0aW5nLWFwcGVuZCcpKTtcbiAgICBvcChNYWNoaW5lT3AuUG9wRnJhbWUpO1xuICB9XG59KTtcblxuU1RBVEVNRU5UUy5hZGQoU2V4cE9wY29kZXMuQmxvY2ssIChvcCwgWywgZXhwciwgcG9zaXRpb25hbCwgbmFtZWQsIGJsb2Nrc10pID0+IHtcbiAgaWYgKGlzR2V0RnJlZUNvbXBvbmVudChleHByKSkge1xuICAgIG9wKEhpZ2hMZXZlbFJlc29sdXRpb25PcGNvZGUuUmVzb2x2ZUNvbXBvbmVudCwgZXhwciwgKGNvbXBvbmVudDogQ29tcGlsZVRpbWVDb21wb25lbnQpID0+IHtcbiAgICAgIEludm9rZUNvbXBvbmVudChvcCwgY29tcG9uZW50LCBudWxsLCBwb3NpdGlvbmFsLCBoYXNoVG9BcmdzKG5hbWVkKSwgYmxvY2tzKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBJbnZva2VEeW5hbWljQ29tcG9uZW50KG9wLCBleHByLCBudWxsLCBwb3NpdGlvbmFsLCBuYW1lZCwgYmxvY2tzLCBmYWxzZSwgZmFsc2UpO1xuICB9XG59KTtcblxuU1RBVEVNRU5UUy5hZGQoU2V4cE9wY29kZXMuSW5FbGVtZW50LCAob3AsIFssIGJsb2NrLCBndWlkLCBkZXN0aW5hdGlvbiwgaW5zZXJ0QmVmb3JlXSkgPT4ge1xuICBSZXBsYXlhYmxlSWYoXG4gICAgb3AsXG5cbiAgICAoKSA9PiB7XG4gICAgICBleHByKG9wLCBndWlkKTtcblxuICAgICAgaWYgKGluc2VydEJlZm9yZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFB1c2hQcmltaXRpdmVSZWZlcmVuY2Uob3AsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHByKG9wLCBpbnNlcnRCZWZvcmUpO1xuICAgICAgfVxuXG4gICAgICBleHByKG9wLCBkZXN0aW5hdGlvbik7XG4gICAgICBvcChPcC5EdXAsICRzcCwgMCk7XG5cbiAgICAgIHJldHVybiA0O1xuICAgIH0sXG5cbiAgICAoKSA9PiB7XG4gICAgICBvcChPcC5QdXNoUmVtb3RlRWxlbWVudCk7XG4gICAgICBJbnZva2VTdGF0aWNCbG9jayhvcCwgYmxvY2spO1xuICAgICAgb3AoT3AuUG9wUmVtb3RlRWxlbWVudCk7XG4gICAgfVxuICApO1xufSk7XG5cblNUQVRFTUVOVFMuYWRkKFNleHBPcGNvZGVzLklmLCAob3AsIFssIGNvbmRpdGlvbiwgYmxvY2ssIGludmVyc2VdKSA9PlxuICBSZXBsYXlhYmxlSWYoXG4gICAgb3AsXG4gICAgKCkgPT4ge1xuICAgICAgZXhwcihvcCwgY29uZGl0aW9uKTtcbiAgICAgIG9wKE9wLlRvQm9vbGVhbik7XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH0sXG5cbiAgICAoKSA9PiB7XG4gICAgICBJbnZva2VTdGF0aWNCbG9jayhvcCwgYmxvY2spO1xuICAgIH0sXG5cbiAgICBpbnZlcnNlXG4gICAgICA/ICgpID0+IHtcbiAgICAgICAgICBJbnZva2VTdGF0aWNCbG9jayhvcCwgaW52ZXJzZSk7XG4gICAgICAgIH1cbiAgICAgIDogdW5kZWZpbmVkXG4gIClcbik7XG5cblNUQVRFTUVOVFMuYWRkKFNleHBPcGNvZGVzLkVhY2gsIChvcCwgWywgdmFsdWUsIGtleSwgYmxvY2ssIGludmVyc2VdKSA9PlxuICBSZXBsYXlhYmxlKFxuICAgIG9wLFxuXG4gICAgKCkgPT4ge1xuICAgICAgaWYgKGtleSkge1xuICAgICAgICBleHByKG9wLCBrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUHVzaFByaW1pdGl2ZVJlZmVyZW5jZShvcCwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGV4cHIob3AsIHZhbHVlKTtcblxuICAgICAgcmV0dXJuIDI7XG4gICAgfSxcblxuICAgICgpID0+IHtcbiAgICAgIG9wKE9wLkVudGVyTGlzdCwgbGFiZWxPcGVyYW5kKCdCT0RZJyksIGxhYmVsT3BlcmFuZCgnRUxTRScpKTtcbiAgICAgIG9wKE1hY2hpbmVPcC5QdXNoRnJhbWUpO1xuICAgICAgb3AoT3AuRHVwLCAkZnAsIDEpO1xuICAgICAgb3AoTWFjaGluZU9wLlJldHVyblRvLCBsYWJlbE9wZXJhbmQoJ0lURVInKSk7XG4gICAgICBvcChIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLkxhYmVsLCAnSVRFUicpO1xuICAgICAgb3AoT3AuSXRlcmF0ZSwgbGFiZWxPcGVyYW5kKCdCUkVBSycpKTtcbiAgICAgIG9wKEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUuTGFiZWwsICdCT0RZJyk7XG4gICAgICBJbnZva2VTdGF0aWNCbG9ja1dpdGhTdGFjayhvcCwgYmxvY2ssIDIpO1xuICAgICAgb3AoT3AuUG9wLCAyKTtcbiAgICAgIG9wKE1hY2hpbmVPcC5KdW1wLCBsYWJlbE9wZXJhbmQoJ0ZJTkFMTFknKSk7XG4gICAgICBvcChIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLkxhYmVsLCAnQlJFQUsnKTtcbiAgICAgIG9wKE1hY2hpbmVPcC5Qb3BGcmFtZSk7XG4gICAgICBvcChPcC5FeGl0TGlzdCk7XG4gICAgICBvcChNYWNoaW5lT3AuSnVtcCwgbGFiZWxPcGVyYW5kKCdGSU5BTExZJykpO1xuICAgICAgb3AoSGlnaExldmVsQnVpbGRlck9wY29kZS5MYWJlbCwgJ0VMU0UnKTtcblxuICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgSW52b2tlU3RhdGljQmxvY2sob3AsIGludmVyc2UpO1xuICAgICAgfVxuICAgIH1cbiAgKVxuKTtcblxuU1RBVEVNRU5UUy5hZGQoU2V4cE9wY29kZXMuV2l0aCwgKG9wLCBbLCB2YWx1ZSwgYmxvY2ssIGludmVyc2VdKSA9PiB7XG4gIFJlcGxheWFibGVJZihcbiAgICBvcCxcblxuICAgICgpID0+IHtcbiAgICAgIGV4cHIob3AsIHZhbHVlKTtcbiAgICAgIG9wKE9wLkR1cCwgJHNwLCAwKTtcbiAgICAgIG9wKE9wLlRvQm9vbGVhbik7XG5cbiAgICAgIHJldHVybiAyO1xuICAgIH0sXG5cbiAgICAoKSA9PiB7XG4gICAgICBJbnZva2VTdGF0aWNCbG9ja1dpdGhTdGFjayhvcCwgYmxvY2ssIDEpO1xuICAgIH0sXG5cbiAgICAoKSA9PiB7XG4gICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICBJbnZva2VTdGF0aWNCbG9jayhvcCwgaW52ZXJzZSk7XG4gICAgICB9XG4gICAgfVxuICApO1xufSk7XG5cblNUQVRFTUVOVFMuYWRkKFNleHBPcGNvZGVzLkxldCwgKG9wLCBbLCBwb3NpdGlvbmFsLCBibG9ja10pID0+IHtcbiAgbGV0IGNvdW50ID0gQ29tcGlsZVBvc2l0aW9uYWwob3AsIHBvc2l0aW9uYWwpO1xuICBJbnZva2VTdGF0aWNCbG9ja1dpdGhTdGFjayhvcCwgYmxvY2ssIGNvdW50KTtcbn0pO1xuXG5TVEFURU1FTlRTLmFkZChTZXhwT3Bjb2Rlcy5XaXRoRHluYW1pY1ZhcnMsIChvcCwgWywgbmFtZWQsIGJsb2NrXSkgPT4ge1xuICBpZiAobmFtZWQpIHtcbiAgICBsZXQgW25hbWVzLCBleHByZXNzaW9uc10gPSBuYW1lZDtcblxuICAgIENvbXBpbGVQb3NpdGlvbmFsKG9wLCBleHByZXNzaW9ucyk7XG4gICAgRHluYW1pY1Njb3BlKG9wLCBuYW1lcywgKCkgPT4ge1xuICAgICAgSW52b2tlU3RhdGljQmxvY2sob3AsIGJsb2NrKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBJbnZva2VTdGF0aWNCbG9jayhvcCwgYmxvY2spO1xuICB9XG59KTtcblxuU1RBVEVNRU5UUy5hZGQoU2V4cE9wY29kZXMuSW52b2tlQ29tcG9uZW50LCAob3AsIFssIGV4cHIsIHBvc2l0aW9uYWwsIG5hbWVkLCBibG9ja3NdKSA9PiB7XG4gIGlmIChpc0dldEZyZWVDb21wb25lbnQoZXhwcikpIHtcbiAgICBvcChIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVDb21wb25lbnQsIGV4cHIsIChjb21wb25lbnQ6IENvbXBpbGVUaW1lQ29tcG9uZW50KSA9PiB7XG4gICAgICBJbnZva2VDb21wb25lbnQob3AsIGNvbXBvbmVudCwgbnVsbCwgcG9zaXRpb25hbCwgaGFzaFRvQXJncyhuYW1lZCksIGJsb2Nrcyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgSW52b2tlRHluYW1pY0NvbXBvbmVudChvcCwgZXhwciwgbnVsbCwgcG9zaXRpb25hbCwgbmFtZWQsIGJsb2NrcywgZmFsc2UsIGZhbHNlKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGhhc2hUb0FyZ3MoaGFzaDogV2lyZUZvcm1hdC5Db3JlLkhhc2ggfCBudWxsKTogV2lyZUZvcm1hdC5Db3JlLkhhc2ggfCBudWxsIHtcbiAgaWYgKGhhc2ggPT09IG51bGwpIHJldHVybiBudWxsO1xuICBsZXQgbmFtZXMgPSBoYXNoWzBdLm1hcCgoa2V5KSA9PiBgQCR7a2V5fWApO1xuICByZXR1cm4gW25hbWVzIGFzIFtzdHJpbmcsIC4uLnN0cmluZ1tdXSwgaGFzaFsxXV07XG59XG4iLCJpbXBvcnQge1xuICBPcHRpb24sXG4gIExheW91dFdpdGhDb250ZXh0LFxuICBDb250YWluaW5nTWV0YWRhdGEsXG4gIFNlcmlhbGl6ZWRJbmxpbmVCbG9jayxcbiAgV2lyZUZvcm1hdCxcbiAgU3ltYm9sVGFibGUsXG4gIENvbXBpbGFibGVUZW1wbGF0ZSxcbiAgU3RhdGVtZW50LFxuICBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCxcbiAgQ29tcGlsYWJsZUJsb2NrLFxuICBDb21waWxhYmxlUHJvZ3JhbSxcbiAgSGFuZGxlUmVzdWx0LFxuICBCbG9ja1N5bWJvbFRhYmxlLFxuICBTZXJpYWxpemVkQmxvY2ssXG4gIEJ1aWxkZXJPcCxcbiAgSGlnaExldmVsT3AsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgbWV0YSB9IGZyb20gJy4vb3Bjb2RlLWJ1aWxkZXIvaGVscGVycy9zaGFyZWQnO1xuaW1wb3J0IHsgRU1QVFlfQVJSQVkgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IHRlbXBsYXRlQ29tcGlsYXRpb25Db250ZXh0IH0gZnJvbSAnLi9vcGNvZGUtYnVpbGRlci9jb250ZXh0JztcbmltcG9ydCB7IExPQ0FMX1NIT1VMRF9MT0cgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBkZWJ1Z0NvbXBpbGVyIH0gZnJvbSAnLi9jb21waWxlcic7XG5pbXBvcnQgeyBTVEFURU1FTlRTIH0gZnJvbSAnLi9zeW50YXgvc3RhdGVtZW50cyc7XG5pbXBvcnQgeyBIaWdoTGV2ZWxTdGF0ZW1lbnRPcCB9IGZyb20gJy4vc3ludGF4L2NvbXBpbGVycyc7XG5pbXBvcnQgeyBlbmNvZGVPcCB9IGZyb20gJy4vb3Bjb2RlLWJ1aWxkZXIvZW5jb2Rlcic7XG5cbmV4cG9ydCBjb25zdCBQTEFDRUhPTERFUl9IQU5ETEUgPSAtMTtcblxuY2xhc3MgQ29tcGlsYWJsZVRlbXBsYXRlSW1wbDxTIGV4dGVuZHMgU3ltYm9sVGFibGU+IGltcGxlbWVudHMgQ29tcGlsYWJsZVRlbXBsYXRlPFM+IHtcbiAgY29tcGlsZWQ6IE9wdGlvbjxIYW5kbGVSZXN1bHQ+ID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBzdGF0ZW1lbnRzOiBXaXJlRm9ybWF0LlN0YXRlbWVudFtdLFxuICAgIHJlYWRvbmx5IG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgICAvLyBQYXJ0IG9mIENvbXBpbGFibGVUZW1wbGF0ZVxuICAgIHJlYWRvbmx5IHN5bWJvbFRhYmxlOiBTLFxuICAgIC8vIFVzZWQgZm9yIGRlYnVnZ2luZ1xuICAgIHJlYWRvbmx5IG1vZHVsZU5hbWUgPSAncGxhaW4gYmxvY2snXG4gICkge31cblxuICAvLyBQYXJ0IG9mIENvbXBpbGFibGVUZW1wbGF0ZVxuICBjb21waWxlKGNvbnRleHQ6IENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0KTogSGFuZGxlUmVzdWx0IHtcbiAgICByZXR1cm4gbWF5YmVDb21waWxlKHRoaXMsIGNvbnRleHQpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxhYmxlKGxheW91dDogTGF5b3V0V2l0aENvbnRleHQsIG1vZHVsZU5hbWU6IHN0cmluZyk6IENvbXBpbGFibGVQcm9ncmFtIHtcbiAgbGV0IFtzdGF0ZW1lbnRzLCBzeW1ib2xzLCBoYXNFdmFsXSA9IGxheW91dC5ibG9jaztcbiAgcmV0dXJuIG5ldyBDb21waWxhYmxlVGVtcGxhdGVJbXBsKFxuICAgIHN0YXRlbWVudHMsXG4gICAgbWV0YShsYXlvdXQpLFxuICAgIHtcbiAgICAgIHN5bWJvbHMsXG4gICAgICBoYXNFdmFsLFxuICAgIH0sXG4gICAgbW9kdWxlTmFtZVxuICApO1xufVxuXG5mdW5jdGlvbiBtYXliZUNvbXBpbGUoXG4gIGNvbXBpbGFibGU6IENvbXBpbGFibGVUZW1wbGF0ZUltcGw8U3ltYm9sVGFibGU+LFxuICBjb250ZXh0OiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dFxuKTogSGFuZGxlUmVzdWx0IHtcbiAgaWYgKGNvbXBpbGFibGUuY29tcGlsZWQgIT09IG51bGwpIHJldHVybiBjb21waWxhYmxlLmNvbXBpbGVkITtcblxuICBjb21waWxhYmxlLmNvbXBpbGVkID0gUExBQ0VIT0xERVJfSEFORExFO1xuXG4gIGxldCB7IHN0YXRlbWVudHMsIG1ldGEgfSA9IGNvbXBpbGFibGU7XG5cbiAgbGV0IHJlc3VsdCA9IGNvbXBpbGVTdGF0ZW1lbnRzKHN0YXRlbWVudHMsIG1ldGEsIGNvbnRleHQpO1xuICBjb21waWxhYmxlLmNvbXBpbGVkID0gcmVzdWx0O1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlU3RhdGVtZW50cyhcbiAgc3RhdGVtZW50czogU3RhdGVtZW50W10sXG4gIG1ldGE6IENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgc3ludGF4Q29udGV4dDogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHRcbik6IEhhbmRsZVJlc3VsdCB7XG4gIGxldCBzQ29tcGlsZXIgPSBTVEFURU1FTlRTO1xuICBsZXQgY29udGV4dCA9IHRlbXBsYXRlQ29tcGlsYXRpb25Db250ZXh0KHN5bnRheENvbnRleHQsIG1ldGEpO1xuXG4gIGxldCB7XG4gICAgZW5jb2RlcixcbiAgICBwcm9ncmFtOiB7IGNvbnN0YW50cywgcmVzb2x2ZXIgfSxcbiAgfSA9IGNvbnRleHQ7XG5cbiAgZnVuY3Rpb24gcHVzaE9wKC4uLm9wOiBCdWlsZGVyT3AgfCBIaWdoTGV2ZWxPcCB8IEhpZ2hMZXZlbFN0YXRlbWVudE9wKSB7XG4gICAgZW5jb2RlT3AoZW5jb2RlciwgY29uc3RhbnRzLCByZXNvbHZlciwgbWV0YSwgb3AgYXMgQnVpbGRlck9wIHwgSGlnaExldmVsT3ApO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgc0NvbXBpbGVyLmNvbXBpbGUocHVzaE9wLCBzdGF0ZW1lbnRzW2ldKTtcbiAgfVxuXG4gIGxldCBoYW5kbGUgPSBjb250ZXh0LmVuY29kZXIuY29tbWl0KG1ldGEuc2l6ZSk7XG5cbiAgaWYgKExPQ0FMX1NIT1VMRF9MT0cpIHtcbiAgICBkZWJ1Z0NvbXBpbGVyKGNvbnRleHQsIGhhbmRsZSk7XG4gIH1cblxuICByZXR1cm4gaGFuZGxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGlsYWJsZUJsb2NrKFxuICBibG9jazogU2VyaWFsaXplZElubGluZUJsb2NrIHwgU2VyaWFsaXplZEJsb2NrLFxuICBjb250YWluaW5nOiBDb250YWluaW5nTWV0YWRhdGFcbik6IENvbXBpbGFibGVCbG9jayB7XG4gIHJldHVybiBuZXcgQ29tcGlsYWJsZVRlbXBsYXRlSW1wbDxCbG9ja1N5bWJvbFRhYmxlPihibG9ja1swXSwgY29udGFpbmluZywge1xuICAgIHBhcmFtZXRlcnM6IGJsb2NrWzFdIHx8IChFTVBUWV9BUlJBWSBhcyBudW1iZXJbXSksXG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgSW5zdHJ1Y3Rpb25FbmNvZGVySW1wbCB9IGZyb20gJ0BnbGltbWVyL2VuY29kZXInO1xuaW1wb3J0IHtcbiAgQ29tcGlsZVRpbWVDb25zdGFudHMsXG4gIE9wZXJhbmQsXG4gIENvbXBpbGVUaW1lSGVhcCxcbiAgT3AsXG4gIEJ1aWxkZXJPcGNvZGUsXG4gIEhpZ2hMZXZlbEJ1aWxkZXJPcGNvZGUsXG4gIE1hY2hpbmVPcCxcbiAgU2luZ2xlQnVpbGRlck9wZXJhbmQsXG4gIEVuY29kZXIsXG4gIEhpZ2hMZXZlbFJlc29sdXRpb25PcGNvZGUsXG4gIEhpZ2hMZXZlbE9wLFxuICBPcGNvZGVTaXplLFxuICBJbnN0cnVjdGlvbkVuY29kZXIsXG4gIERpY3QsXG4gIEVuY29kZXJFcnJvcixcbiAgSGFuZGxlUmVzdWx0LFxuICBCdWlsZGVyT3AsXG4gIENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIENvbnRhaW5pbmdNZXRhZGF0YSxcbiAgSGlnaExldmVsT3BlcmFuZCxcbiAgU1RETGliLFxuICBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBpc01hY2hpbmVPcCB9IGZyb20gJ0BnbGltbWVyL3ZtJztcbmltcG9ydCB7IFN0YWNrLCBkaWN0LCBleHBlY3QsIEVNUFRZX1NUUklOR19BUlJBWSwgZW5jb2RlSGFuZGxlLCBhc3NlcnQgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7XG4gIHJlc29sdmVDb21wb25lbnQsXG4gIHJlc29sdmVDb21wb25lbnRPckhlbHBlcixcbiAgcmVzb2x2ZUhlbHBlcixcbiAgcmVzb2x2ZU1vZGlmaWVyLFxuICByZXNvbHZlT3B0aW9uYWxDb21wb25lbnRPckhlbHBlcixcbiAgcmVzb2x2ZU9wdGlvbmFsSGVscGVyLFxufSBmcm9tICcuL2hlbHBlcnMvcmVzb2x1dGlvbic7XG5pbXBvcnQgeyBjb21waWxhYmxlQmxvY2sgfSBmcm9tICcuLi9jb21waWxhYmxlLXRlbXBsYXRlJztcbmltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcblxuZXhwb3J0IGNsYXNzIExhYmVscyB7XG4gIGxhYmVsczogRGljdDxudW1iZXI+ID0gZGljdCgpO1xuICB0YXJnZXRzOiBBcnJheTx7IGF0OiBudW1iZXI7IHRhcmdldDogc3RyaW5nIH0+ID0gW107XG5cbiAgbGFiZWwobmFtZTogc3RyaW5nLCBpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5sYWJlbHNbbmFtZV0gPSBpbmRleDtcbiAgfVxuXG4gIHRhcmdldChhdDogbnVtYmVyLCB0YXJnZXQ6IHN0cmluZykge1xuICAgIHRoaXMudGFyZ2V0cy5wdXNoKHsgYXQsIHRhcmdldCB9KTtcbiAgfVxuXG4gIHBhdGNoKGhlYXA6IENvbXBpbGVUaW1lSGVhcCk6IHZvaWQge1xuICAgIGxldCB7IHRhcmdldHMsIGxhYmVscyB9ID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCB7IGF0LCB0YXJnZXQgfSA9IHRhcmdldHNbaV07XG4gICAgICBsZXQgYWRkcmVzcyA9IGxhYmVsc1t0YXJnZXRdIC0gYXQ7XG5cbiAgICAgIGFzc2VydChoZWFwLmdldGJ5YWRkcihhdCkgPT09IC0xLCAnRXhwZWN0ZWQgaGVhcCB0byBjb250YWluIGEgcGxhY2Vob2xkZXIsIGJ1dCBpdCBkaWQgbm90Jyk7XG5cbiAgICAgIGhlYXAuc2V0YnlhZGRyKGF0LCBhZGRyZXNzKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZU9wKFxuICBlbmNvZGVyOiBFbmNvZGVyLFxuICBjb25zdGFudHM6IENvbXBpbGVUaW1lQ29uc3RhbnRzICYgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG4gIHJlc29sdmVyOiBDb21waWxlVGltZVJlc29sdmVyLFxuICBtZXRhOiBDb250YWluaW5nTWV0YWRhdGEsXG4gIG9wOiBCdWlsZGVyT3AgfCBIaWdoTGV2ZWxPcFxuKTogdm9pZCB7XG4gIGlmIChpc0J1aWxkZXJPcGNvZGUob3BbMF0pKSB7XG4gICAgbGV0IFt0eXBlLCAuLi5vcGVyYW5kc10gPSBvcDtcbiAgICBlbmNvZGVyLnB1c2goY29uc3RhbnRzLCB0eXBlLCAuLi4ob3BlcmFuZHMgYXMgU2luZ2xlQnVpbGRlck9wZXJhbmRbXSkpO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgIGNhc2UgSGlnaExldmVsQnVpbGRlck9wY29kZS5MYWJlbDpcbiAgICAgICAgcmV0dXJuIGVuY29kZXIubGFiZWwob3BbMV0pO1xuICAgICAgY2FzZSBIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLlN0YXJ0TGFiZWxzOlxuICAgICAgICByZXR1cm4gZW5jb2Rlci5zdGFydExhYmVscygpO1xuICAgICAgY2FzZSBIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLlN0b3BMYWJlbHM6XG4gICAgICAgIHJldHVybiBlbmNvZGVyLnN0b3BMYWJlbHMoKTtcblxuICAgICAgY2FzZSBIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiByZXNvbHZlQ29tcG9uZW50KHJlc29sdmVyLCBjb25zdGFudHMsIG1ldGEsIG9wKTtcbiAgICAgIGNhc2UgSGlnaExldmVsUmVzb2x1dGlvbk9wY29kZS5SZXNvbHZlTW9kaWZpZXI6XG4gICAgICAgIHJldHVybiByZXNvbHZlTW9kaWZpZXIocmVzb2x2ZXIsIGNvbnN0YW50cywgbWV0YSwgb3ApO1xuICAgICAgY2FzZSBIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVIZWxwZXI6XG4gICAgICAgIHJldHVybiByZXNvbHZlSGVscGVyKHJlc29sdmVyLCBjb25zdGFudHMsIG1ldGEsIG9wKTtcbiAgICAgIGNhc2UgSGlnaExldmVsUmVzb2x1dGlvbk9wY29kZS5SZXNvbHZlQ29tcG9uZW50T3JIZWxwZXI6XG4gICAgICAgIHJldHVybiByZXNvbHZlQ29tcG9uZW50T3JIZWxwZXIocmVzb2x2ZXIsIGNvbnN0YW50cywgbWV0YSwgb3ApO1xuICAgICAgY2FzZSBIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVPcHRpb25hbEhlbHBlcjpcbiAgICAgICAgcmV0dXJuIHJlc29sdmVPcHRpb25hbEhlbHBlcihyZXNvbHZlciwgY29uc3RhbnRzLCBtZXRhLCBvcCk7XG4gICAgICBjYXNlIEhpZ2hMZXZlbFJlc29sdXRpb25PcGNvZGUuUmVzb2x2ZU9wdGlvbmFsQ29tcG9uZW50T3JIZWxwZXI6XG4gICAgICAgIHJldHVybiByZXNvbHZlT3B0aW9uYWxDb21wb25lbnRPckhlbHBlcihyZXNvbHZlciwgY29uc3RhbnRzLCBtZXRhLCBvcCk7XG5cbiAgICAgIGNhc2UgSGlnaExldmVsUmVzb2x1dGlvbk9wY29kZS5SZXNvbHZlTG9jYWw6XG4gICAgICAgIGxldCBmcmVlVmFyID0gb3BbMV07XG4gICAgICAgIGxldCBuYW1lID0gZXhwZWN0KG1ldGEudXB2YXJzLCAnQlVHOiBhdHRlbXB0ZWQgdG8gcmVzb2x2ZSB2YWx1ZSBidXQgbm8gdXB2YXJzIGZvdW5kJylbXG4gICAgICAgICAgZnJlZVZhclxuICAgICAgICBdO1xuXG4gICAgICAgIGxldCBhbmRUaGVuID0gb3BbMl07XG5cbiAgICAgICAgYW5kVGhlbihuYW1lLCBtZXRhLm1vZHVsZU5hbWUpO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEhpZ2hMZXZlbFJlc29sdXRpb25PcGNvZGUuUmVzb2x2ZVRlbXBsYXRlTG9jYWw6XG4gICAgICAgIGxldCBbLCB2YWx1ZUluZGV4LCB0aGVuXSA9IG9wO1xuICAgICAgICBsZXQgdmFsdWUgPSBleHBlY3QoXG4gICAgICAgICAgbWV0YS5zY29wZVZhbHVlcyxcbiAgICAgICAgICAnQlVHOiBBdHRlbXB0ZWQgdG8gZ2VjdCBhIHRlbXBsYXRlIGxvY2FsLCBidXQgdGVtcGxhdGUgZG9lcyBub3QgaGF2ZSBhbnknXG4gICAgICAgIClbdmFsdWVJbmRleF07XG5cbiAgICAgICAgdGhlbihjb25zdGFudHMudmFsdWUodmFsdWUpKTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIaWdoTGV2ZWxSZXNvbHV0aW9uT3Bjb2RlLlJlc29sdmVGcmVlOlxuICAgICAgICBpZiAoREVCVUcpIHtcbiAgICAgICAgICBsZXQgWywgdXB2YXJJbmRleF0gPSBvcDtcbiAgICAgICAgICBsZXQgZnJlZU5hbWUgPSBleHBlY3QobWV0YS51cHZhcnMsICdCVUc6IGF0dGVtcHRlZCB0byByZXNvbHZlIHZhbHVlIGJ1dCBubyB1cHZhcnMgZm91bmQnKVtcbiAgICAgICAgICAgIHVwdmFySW5kZXhcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEF0dGVtcHRlZCB0byByZXNvbHZlIGEgdmFsdWUgaW4gYSBzdHJpY3QgbW9kZSB0ZW1wbGF0ZSwgYnV0IHRoYXQgdmFsdWUgd2FzIG5vdCBpbiBzY29wZTogJHtmcmVlTmFtZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGhpZ2ggbGV2ZWwgb3Bjb2RlICR7b3BbMF19YCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFbmNvZGVySW1wbCBpbXBsZW1lbnRzIEVuY29kZXIge1xuICBwcml2YXRlIGxhYmVsc1N0YWNrID0gbmV3IFN0YWNrPExhYmVscz4oKTtcbiAgcHJpdmF0ZSBlbmNvZGVyOiBJbnN0cnVjdGlvbkVuY29kZXIgPSBuZXcgSW5zdHJ1Y3Rpb25FbmNvZGVySW1wbChbXSk7XG4gIHByaXZhdGUgZXJyb3JzOiBFbmNvZGVyRXJyb3JbXSA9IFtdO1xuICBwcml2YXRlIGhhbmRsZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgaGVhcDogQ29tcGlsZVRpbWVIZWFwLFxuICAgIHByaXZhdGUgbWV0YTogQ29udGFpbmluZ01ldGFkYXRhLFxuICAgIHByaXZhdGUgc3RkbGliPzogU1RETGliXG4gICkge1xuICAgIHRoaXMuaGFuZGxlID0gaGVhcC5tYWxsb2MoKTtcbiAgfVxuXG4gIGVycm9yKGVycm9yOiBFbmNvZGVyRXJyb3IpOiB2b2lkIHtcbiAgICB0aGlzLmVuY29kZXIuZW5jb2RlKE9wLlByaW1pdGl2ZSwgMCk7XG4gICAgdGhpcy5lcnJvcnMucHVzaChlcnJvcik7XG4gIH1cblxuICBjb21taXQoc2l6ZTogbnVtYmVyKTogSGFuZGxlUmVzdWx0IHtcbiAgICBsZXQgaGFuZGxlID0gdGhpcy5oYW5kbGU7XG5cbiAgICB0aGlzLmhlYXAucHVzaChNYWNoaW5lT3AuUmV0dXJuIHwgT3Bjb2RlU2l6ZS5NQUNISU5FX01BU0spO1xuICAgIHRoaXMuaGVhcC5maW5pc2hNYWxsb2MoaGFuZGxlLCBzaXplKTtcblxuICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7IGVycm9yczogdGhpcy5lcnJvcnMsIGhhbmRsZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaGFuZGxlO1xuICAgIH1cbiAgfVxuXG4gIHB1c2goXG4gICAgY29uc3RhbnRzOiBDb21waWxlVGltZUNvbnN0YW50cyxcbiAgICB0eXBlOiBCdWlsZGVyT3Bjb2RlLFxuICAgIC4uLmFyZ3M6IFNpbmdsZUJ1aWxkZXJPcGVyYW5kW11cbiAgKTogdm9pZCB7XG4gICAgbGV0IHsgaGVhcCB9ID0gdGhpcztcblxuICAgIGlmIChERUJVRyAmJiAodHlwZSBhcyBudW1iZXIpID4gT3Bjb2RlU2l6ZS5UWVBFX1NJWkUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT3Bjb2RlIHR5cGUgb3ZlciA4LWJpdHMuIEdvdCAke3R5cGV9LmApO1xuICAgIH1cblxuICAgIGxldCBtYWNoaW5lID0gaXNNYWNoaW5lT3AodHlwZSkgPyBPcGNvZGVTaXplLk1BQ0hJTkVfTUFTSyA6IDA7XG4gICAgbGV0IGZpcnN0ID0gdHlwZSB8IG1hY2hpbmUgfCAoYXJncy5sZW5ndGggPDwgT3Bjb2RlU2l6ZS5BUkdfU0hJRlQpO1xuXG4gICAgaGVhcC5wdXNoKGZpcnN0KTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG9wID0gYXJnc1tpXTtcbiAgICAgIGhlYXAucHVzaCh0aGlzLm9wZXJhbmQoY29uc3RhbnRzLCBvcCkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgb3BlcmFuZChjb25zdGFudHM6IENvbXBpbGVUaW1lQ29uc3RhbnRzLCBvcGVyYW5kOiBTaW5nbGVCdWlsZGVyT3BlcmFuZCk6IE9wZXJhbmQge1xuICAgIGlmICh0eXBlb2Ygb3BlcmFuZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBvcGVyYW5kO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3BlcmFuZCA9PT0gJ29iamVjdCcgJiYgb3BlcmFuZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3BlcmFuZCkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUhhbmRsZShjb25zdGFudHMuYXJyYXkob3BlcmFuZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChvcGVyYW5kLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIEhpZ2hMZXZlbE9wZXJhbmQuTGFiZWw6XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRMYWJlbHMudGFyZ2V0KHRoaXMuaGVhcC5vZmZzZXQsIG9wZXJhbmQudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuXG4gICAgICAgICAgY2FzZSBIaWdoTGV2ZWxPcGVyYW5kLklzU3RyaWN0TW9kZTpcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVIYW5kbGUoY29uc3RhbnRzLnZhbHVlKHRoaXMubWV0YS5pc1N0cmljdE1vZGUpKTtcblxuICAgICAgICAgIGNhc2UgSGlnaExldmVsT3BlcmFuZC5FdmFsU3ltYm9sczpcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVIYW5kbGUoY29uc3RhbnRzLmFycmF5KHRoaXMubWV0YS5ldmFsU3ltYm9scyB8fCBFTVBUWV9TVFJJTkdfQVJSQVkpKTtcblxuICAgICAgICAgIGNhc2UgSGlnaExldmVsT3BlcmFuZC5CbG9jazpcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVIYW5kbGUoY29uc3RhbnRzLnZhbHVlKGNvbXBpbGFibGVCbG9jayhvcGVyYW5kLnZhbHVlLCB0aGlzLm1ldGEpKSk7XG5cbiAgICAgICAgICBjYXNlIEhpZ2hMZXZlbE9wZXJhbmQuU3RkTGliOlxuICAgICAgICAgICAgcmV0dXJuIGV4cGVjdChcbiAgICAgICAgICAgICAgdGhpcy5zdGRsaWIsXG4gICAgICAgICAgICAgICdhdHRlbXB0ZWQgdG8gZW5jb2RlIGEgc3RkbGliIG9wZXJhbmQsIGJ1dCB0aGUgZW5jb2RlciBkaWQgbm90IGhhdmUgYSBzdGRsaWIuIEFyZSB5b3UgY3VycmVudGx5IGJ1aWxkaW5nIHRoZSBzdGRsaWI/J1xuICAgICAgICAgICAgKVtvcGVyYW5kLnZhbHVlXTtcblxuICAgICAgICAgIGNhc2UgSGlnaExldmVsT3BlcmFuZC5Ob25TbWFsbEludDpcbiAgICAgICAgICBjYXNlIEhpZ2hMZXZlbE9wZXJhbmQuU3ltYm9sVGFibGU6XG4gICAgICAgICAgY2FzZSBIaWdoTGV2ZWxPcGVyYW5kLkxheW91dDpcbiAgICAgICAgICAgIHJldHVybiBjb25zdGFudHMudmFsdWUob3BlcmFuZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RlSGFuZGxlKGNvbnN0YW50cy52YWx1ZShvcGVyYW5kKSk7XG4gIH1cblxuICBwcml2YXRlIGdldCBjdXJyZW50TGFiZWxzKCk6IExhYmVscyB7XG4gICAgcmV0dXJuIGV4cGVjdCh0aGlzLmxhYmVsc1N0YWNrLmN1cnJlbnQsICdidWc6IG5vdCBpbiBhIGxhYmVsIHN0YWNrJyk7XG4gIH1cblxuICBsYWJlbChuYW1lOiBzdHJpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnRMYWJlbHMubGFiZWwobmFtZSwgdGhpcy5oZWFwLm9mZnNldCArIDEpO1xuICB9XG5cbiAgc3RhcnRMYWJlbHMoKSB7XG4gICAgdGhpcy5sYWJlbHNTdGFjay5wdXNoKG5ldyBMYWJlbHMoKSk7XG4gIH1cblxuICBzdG9wTGFiZWxzKCkge1xuICAgIGxldCBsYWJlbCA9IGV4cGVjdCh0aGlzLmxhYmVsc1N0YWNrLnBvcCgpLCAndW5iYWxhbmNlZCBwdXNoIGFuZCBwb3AgbGFiZWxzJyk7XG4gICAgbGFiZWwucGF0Y2godGhpcy5oZWFwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0J1aWxkZXJPcGNvZGUob3A6IG51bWJlcik6IG9wIGlzIEJ1aWxkZXJPcGNvZGUge1xuICByZXR1cm4gb3AgPCBIaWdoTGV2ZWxCdWlsZGVyT3Bjb2RlLlN0YXJ0O1xufVxuIiwiaW1wb3J0IHsgJHMwIH0gZnJvbSAnQGdsaW1tZXIvdm0nO1xuXG5pbXBvcnQgeyBpbnZva2VQcmVwYXJlZENvbXBvbmVudCwgSW52b2tlQmFyZUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cyc7XG5pbXBvcnQgeyBTdGRMaWIgfSBmcm9tICcuLi9zdGRsaWInO1xuaW1wb3J0IHsgZW5jb2RlT3AsIEVuY29kZXJJbXBsIH0gZnJvbSAnLi4vZW5jb2Rlcic7XG5pbXBvcnQge1xuICBDb250ZW50VHlwZSxcbiAgT3AsXG4gIENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0LFxuICBIaWdoTGV2ZWxPcCxcbiAgQnVpbGRlck9wLFxuICBNYWNoaW5lT3AsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgU3dpdGNoQ2FzZXMgfSBmcm9tICcuL2NvbmRpdGlvbmFsJztcbmltcG9ydCB7IEhpZ2hMZXZlbFN0YXRlbWVudE9wLCBQdXNoU3RhdGVtZW50T3AgfSBmcm9tICcuLi8uLi9zeW50YXgvY29tcGlsZXJzJztcbmltcG9ydCB7IENhbGxEeW5hbWljIH0gZnJvbSAnLi92bSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWluKG9wOiBQdXNoU3RhdGVtZW50T3ApOiB2b2lkIHtcbiAgb3AoT3AuTWFpbiwgJHMwKTtcbiAgaW52b2tlUHJlcGFyZWRDb21wb25lbnQob3AsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG59XG5cbi8qKlxuICogQXBwZW5kIGNvbnRlbnQgdG8gdGhlIERPTS4gVGhpcyBzdGFuZGFyZCBmdW5jdGlvbiB0cmlhZ2VzIGNvbnRlbnQgYW5kIGRvZXMgdGhlXG4gKiByaWdodCB0aGluZyBiYXNlZCB1cG9uIHdoZXRoZXIgaXQncyBhIHN0cmluZywgc2FmZSBzdHJpbmcsIGNvbXBvbmVudCwgZnJhZ21lbnRcbiAqIG9yIG5vZGUuXG4gKlxuICogQHBhcmFtIHRydXN0aW5nIHdoZXRoZXIgdG8gaW50ZXJwb2xhdGUgYSBzdHJpbmcgYXMgcmF3IEhUTUwgKGNvcnJlc3BvbmRzIHRvXG4gKiB0cmlwbGUgY3VybGllcylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFN0ZEFwcGVuZChcbiAgb3A6IFB1c2hTdGF0ZW1lbnRPcCxcbiAgdHJ1c3Rpbmc6IGJvb2xlYW4sXG4gIG5vbkR5bmFtaWNBcHBlbmQ6IG51bWJlciB8IG51bGxcbik6IHZvaWQge1xuICBTd2l0Y2hDYXNlcyhcbiAgICBvcCxcbiAgICAoKSA9PiBvcChPcC5Db250ZW50VHlwZSksXG4gICAgKHdoZW4pID0+IHtcbiAgICAgIHdoZW4oQ29udGVudFR5cGUuU3RyaW5nLCAoKSA9PiB7XG4gICAgICAgIGlmICh0cnVzdGluZykge1xuICAgICAgICAgIG9wKE9wLkFzc2VydFNhbWUpO1xuICAgICAgICAgIG9wKE9wLkFwcGVuZEhUTUwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wKE9wLkFwcGVuZFRleHQpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBub25EeW5hbWljQXBwZW5kID09PSAnbnVtYmVyJykge1xuICAgICAgICB3aGVuKENvbnRlbnRUeXBlLkNvbXBvbmVudCwgKCkgPT4ge1xuICAgICAgICAgIG9wKE9wLlJlc29sdmVDdXJyaWVkQ29tcG9uZW50KTtcbiAgICAgICAgICBvcChPcC5QdXNoRHluYW1pY0NvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgICAgICBJbnZva2VCYXJlQ29tcG9uZW50KG9wKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2hlbihDb250ZW50VHlwZS5IZWxwZXIsICgpID0+IHtcbiAgICAgICAgICBDYWxsRHluYW1pYyhvcCwgbnVsbCwgbnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgb3AoTWFjaGluZU9wLkludm9rZVN0YXRpYywgbm9uRHluYW1pY0FwcGVuZCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2hlbiBub24tZHluYW1pYywgd2UgY2FuIG5vIGxvbmdlciBjYWxsIHRoZSB2YWx1ZSAocG90ZW50aWFsbHkgYmVjYXVzZSB3ZSd2ZSBhbHJlYWR5IGNhbGxlZCBpdClcbiAgICAgICAgLy8gdGhpcyBwcmV2ZW50cyBpbmZpbml0ZSBsb29wcy4gV2UgaW5zdGVhZCBjb2VyY2UgdGhlIHZhbHVlLCB3aGF0ZXZlciBpdCBpcywgaW50byB0aGUgRE9NLlxuICAgICAgICB3aGVuKENvbnRlbnRUeXBlLkNvbXBvbmVudCwgKCkgPT4ge1xuICAgICAgICAgIG9wKE9wLkFwcGVuZFRleHQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB3aGVuKENvbnRlbnRUeXBlLkhlbHBlciwgKCkgPT4ge1xuICAgICAgICAgIG9wKE9wLkFwcGVuZFRleHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgd2hlbihDb250ZW50VHlwZS5TYWZlU3RyaW5nLCAoKSA9PiB7XG4gICAgICAgIG9wKE9wLkFzc2VydFNhbWUpO1xuICAgICAgICBvcChPcC5BcHBlbmRTYWZlSFRNTCk7XG4gICAgICB9KTtcblxuICAgICAgd2hlbihDb250ZW50VHlwZS5GcmFnbWVudCwgKCkgPT4ge1xuICAgICAgICBvcChPcC5Bc3NlcnRTYW1lKTtcbiAgICAgICAgb3AoT3AuQXBwZW5kRG9jdW1lbnRGcmFnbWVudCk7XG4gICAgICB9KTtcblxuICAgICAgd2hlbihDb250ZW50VHlwZS5Ob2RlLCAoKSA9PiB7XG4gICAgICAgIG9wKE9wLkFzc2VydFNhbWUpO1xuICAgICAgICBvcChPcC5BcHBlbmROb2RlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVTdGQoY29udGV4dDogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQpOiBTdGRMaWIge1xuICBsZXQgbWFpbkhhbmRsZSA9IGJ1aWxkKGNvbnRleHQsIChvcCkgPT4gbWFpbihvcCkpO1xuICBsZXQgdHJ1c3RpbmdHdWFyZGVkTm9uRHluYW1pY0FwcGVuZCA9IGJ1aWxkKGNvbnRleHQsIChvcCkgPT4gU3RkQXBwZW5kKG9wLCB0cnVlLCBudWxsKSk7XG4gIGxldCBjYXV0aW91c0d1YXJkZWROb25EeW5hbWljQXBwZW5kID0gYnVpbGQoY29udGV4dCwgKG9wKSA9PiBTdGRBcHBlbmQob3AsIGZhbHNlLCBudWxsKSk7XG5cbiAgbGV0IHRydXN0aW5nR3VhcmRlZER5bmFtaWNBcHBlbmQgPSBidWlsZChjb250ZXh0LCAob3ApID0+XG4gICAgU3RkQXBwZW5kKG9wLCB0cnVlLCB0cnVzdGluZ0d1YXJkZWROb25EeW5hbWljQXBwZW5kKVxuICApO1xuICBsZXQgY2F1dGlvdXNHdWFyZGVkRHluYW1pY0FwcGVuZCA9IGJ1aWxkKGNvbnRleHQsIChvcCkgPT5cbiAgICBTdGRBcHBlbmQob3AsIGZhbHNlLCBjYXV0aW91c0d1YXJkZWROb25EeW5hbWljQXBwZW5kKVxuICApO1xuXG4gIHJldHVybiBuZXcgU3RkTGliKFxuICAgIG1haW5IYW5kbGUsXG4gICAgdHJ1c3RpbmdHdWFyZGVkRHluYW1pY0FwcGVuZCxcbiAgICBjYXV0aW91c0d1YXJkZWREeW5hbWljQXBwZW5kLFxuICAgIHRydXN0aW5nR3VhcmRlZE5vbkR5bmFtaWNBcHBlbmQsXG4gICAgY2F1dGlvdXNHdWFyZGVkTm9uRHluYW1pY0FwcGVuZFxuICApO1xufVxuXG5jb25zdCBTVERMSUJfTUVUQSA9IHtcbiAgZXZhbFN5bWJvbHM6IG51bGwsXG4gIHVwdmFyczogbnVsbCxcbiAgbW9kdWxlTmFtZTogJ3N0ZGxpYicsXG5cbiAgLy8gVE9ETzogPz9cbiAgc2NvcGVWYWx1ZXM6IG51bGwsXG4gIGlzU3RyaWN0TW9kZTogdHJ1ZSxcbiAgb3duZXI6IG51bGwsXG4gIHNpemU6IDAsXG59O1xuXG5mdW5jdGlvbiBidWlsZChcbiAgcHJvZ3JhbTogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIGNhbGxiYWNrOiAob3A6IFB1c2hTdGF0ZW1lbnRPcCkgPT4gdm9pZFxuKTogbnVtYmVyIHtcbiAgbGV0IHsgY29uc3RhbnRzLCBoZWFwLCByZXNvbHZlciB9ID0gcHJvZ3JhbTtcbiAgbGV0IGVuY29kZXIgPSBuZXcgRW5jb2RlckltcGwoaGVhcCwgU1RETElCX01FVEEpO1xuXG4gIGZ1bmN0aW9uIHB1c2hPcCguLi5vcDogQnVpbGRlck9wIHwgSGlnaExldmVsT3AgfCBIaWdoTGV2ZWxTdGF0ZW1lbnRPcCkge1xuICAgIGVuY29kZU9wKGVuY29kZXIsIGNvbnN0YW50cywgcmVzb2x2ZXIsIFNURExJQl9NRVRBLCBvcCBhcyBCdWlsZGVyT3AgfCBIaWdoTGV2ZWxPcCk7XG4gIH1cblxuICBjYWxsYmFjayhwdXNoT3ApO1xuXG4gIGxldCByZXN1bHQgPSBlbmNvZGVyLmNvbW1pdCgwKTtcblxuICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ251bWJlcicpIHtcbiAgICAvLyBUaGlzIHNob3VsZG4ndCBiZSBwb3NzaWJsZVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBlcnJvcnMgY29tcGlsaW5nIHN0ZGApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIFNURExpYixcbiAgQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIENvbXBpbGVUaW1lUmVzb2x2ZXIsXG4gIENvbXBpbGVUaW1lSGVhcCxcbiAgQ29tcGlsZVRpbWVDb25zdGFudHMsXG4gIENvbXBpbGVUaW1lQXJ0aWZhY3RzLFxuICBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjb21waWxlU3RkIH0gZnJvbSAnLi9vcGNvZGUtYnVpbGRlci9oZWxwZXJzL3N0ZGxpYic7XG5cbmV4cG9ydCBjbGFzcyBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dEltcGwgaW1wbGVtZW50cyBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCB7XG4gIHJlYWRvbmx5IGNvbnN0YW50czogQ29tcGlsZVRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cztcbiAgcmVhZG9ubHkgaGVhcDogQ29tcGlsZVRpbWVIZWFwO1xuICByZWFkb25seSBzdGRsaWI6IFNURExpYjtcblxuICBjb25zdHJ1Y3Rvcih7IGNvbnN0YW50cywgaGVhcCB9OiBDb21waWxlVGltZUFydGlmYWN0cywgcmVhZG9ubHkgcmVzb2x2ZXI6IENvbXBpbGVUaW1lUmVzb2x2ZXIpIHtcbiAgICB0aGlzLmNvbnN0YW50cyA9IGNvbnN0YW50cztcbiAgICB0aGlzLmhlYXAgPSBoZWFwO1xuICAgIHRoaXMuc3RkbGliID0gY29tcGlsZVN0ZCh0aGlzKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXRpZXMsIE9wdGlvbiwgQ29tcGlsZVRpbWVDb21wb25lbnQgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ0FQQUJJTElUSUVTOiBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdGllcyA9IHtcbiAgZHluYW1pY0xheW91dDogdHJ1ZSxcbiAgZHluYW1pY1RhZzogdHJ1ZSxcbiAgcHJlcGFyZUFyZ3M6IHRydWUsXG4gIGNyZWF0ZUFyZ3M6IHRydWUsXG4gIGF0dHJpYnV0ZUhvb2s6IGZhbHNlLFxuICBlbGVtZW50SG9vazogZmFsc2UsXG4gIGR5bmFtaWNTY29wZTogdHJ1ZSxcbiAgY3JlYXRlQ2FsbGVyOiBmYWxzZSxcbiAgdXBkYXRlSG9vazogdHJ1ZSxcbiAgY3JlYXRlSW5zdGFuY2U6IHRydWUsXG4gIHdyYXBwZWQ6IGZhbHNlLFxuICB3aWxsRGVzdHJveTogZmFsc2UsXG4gIGhhc1N1Yk93bmVyOiBmYWxzZSxcbn07XG5cbmV4cG9ydCBjb25zdCBNSU5JTUFMX0NBUEFCSUxJVElFUzogSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXRpZXMgPSB7XG4gIGR5bmFtaWNMYXlvdXQ6IGZhbHNlLFxuICBkeW5hbWljVGFnOiBmYWxzZSxcbiAgcHJlcGFyZUFyZ3M6IGZhbHNlLFxuICBjcmVhdGVBcmdzOiBmYWxzZSxcbiAgYXR0cmlidXRlSG9vazogZmFsc2UsXG4gIGVsZW1lbnRIb29rOiBmYWxzZSxcbiAgZHluYW1pY1Njb3BlOiBmYWxzZSxcbiAgY3JlYXRlQ2FsbGVyOiBmYWxzZSxcbiAgdXBkYXRlSG9vazogZmFsc2UsXG4gIGNyZWF0ZUluc3RhbmNlOiBmYWxzZSxcbiAgd3JhcHBlZDogZmFsc2UsXG4gIHdpbGxEZXN0cm95OiBmYWxzZSxcbiAgaGFzU3ViT3duZXI6IGZhbHNlLFxufTtcblxuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlckRlbGVnYXRlPFIgPSB1bmtub3duPiB7XG4gIGxvb2t1cEhlbHBlcj8obmFtZTogc3RyaW5nLCByZWZlcnJlcjogUik6IE9wdGlvbjxudW1iZXI+IHwgdm9pZDtcbiAgbG9va3VwTW9kaWZpZXI/KG5hbWU6IHN0cmluZywgcmVmZXJyZXI6IFIpOiBPcHRpb248bnVtYmVyPiB8IHZvaWQ7XG4gIGxvb2t1cENvbXBvbmVudD8obmFtZTogc3RyaW5nLCByZWZlcnJlcjogUik6IE9wdGlvbjxDb21waWxlVGltZUNvbXBvbmVudD4gfCB2b2lkO1xuXG4gIC8vIEZvciBkZWJ1Z2dpbmdcbiAgcmVzb2x2ZT8oaGFuZGxlOiBudW1iZXIpOiBSO1xufVxuIiwiaW1wb3J0IHtcbiAgUHJvZ3JhbVN5bWJvbFRhYmxlLFxuICBDb21waWxhYmxlUHJvZ3JhbSxcbiAgTGF5b3V0V2l0aENvbnRleHQsXG4gIE9wdGlvbixcbiAgQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIEhhbmRsZVJlc3VsdCxcbiAgQnVpbGRlck9wLFxuICBIaWdoTGV2ZWxPcCxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbmltcG9ydCB7IHRlbXBsYXRlQ29tcGlsYXRpb25Db250ZXh0IH0gZnJvbSAnLi9vcGNvZGUtYnVpbGRlci9jb250ZXh0JztcbmltcG9ydCB7IG1ldGEgfSBmcm9tICcuL29wY29kZS1idWlsZGVyL2hlbHBlcnMvc2hhcmVkJztcbmltcG9ydCB7IEFUVFJTX0JMT0NLLCBXcmFwcGVkQ29tcG9uZW50IH0gZnJvbSAnLi9vcGNvZGUtYnVpbGRlci9oZWxwZXJzL2NvbXBvbmVudHMnO1xuaW1wb3J0IHsgTE9DQUxfU0hPVUxEX0xPRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7IGRlYnVnQ29tcGlsZXIgfSBmcm9tICcuL2NvbXBpbGVyJztcbmltcG9ydCB7IGVuY29kZU9wIH0gZnJvbSAnLi9vcGNvZGUtYnVpbGRlci9lbmNvZGVyJztcbmltcG9ydCB7IEhpZ2hMZXZlbFN0YXRlbWVudE9wIH0gZnJvbSAnLi9zeW50YXgvY29tcGlsZXJzJztcblxuZXhwb3J0IGNsYXNzIFdyYXBwZWRCdWlsZGVyIGltcGxlbWVudHMgQ29tcGlsYWJsZVByb2dyYW0ge1xuICBwdWJsaWMgc3ltYm9sVGFibGU6IFByb2dyYW1TeW1ib2xUYWJsZTtcbiAgcHJpdmF0ZSBjb21waWxlZDogT3B0aW9uPG51bWJlcj4gPSBudWxsO1xuICBwcml2YXRlIGF0dHJzQmxvY2tOdW1iZXI6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGxheW91dDogTGF5b3V0V2l0aENvbnRleHQsIHB1YmxpYyBtb2R1bGVOYW1lOiBzdHJpbmcpIHtcbiAgICBsZXQgeyBibG9jayB9ID0gbGF5b3V0O1xuICAgIGxldCBbLCBzeW1ib2xzLCBoYXNFdmFsXSA9IGJsb2NrO1xuXG4gICAgc3ltYm9scyA9IHN5bWJvbHMuc2xpY2UoKTtcblxuICAgIC8vIGVuc3VyZSBBVFRSU19CTE9DSyBpcyBhbHdheXMgaW5jbHVkZWQgKG9ubHkgb25jZSkgaW4gdGhlIGxpc3Qgb2Ygc3ltYm9sc1xuICAgIGxldCBhdHRyc0Jsb2NrSW5kZXggPSBzeW1ib2xzLmluZGV4T2YoQVRUUlNfQkxPQ0spO1xuICAgIGlmIChhdHRyc0Jsb2NrSW5kZXggPT09IC0xKSB7XG4gICAgICB0aGlzLmF0dHJzQmxvY2tOdW1iZXIgPSBzeW1ib2xzLnB1c2goQVRUUlNfQkxPQ0spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF0dHJzQmxvY2tOdW1iZXIgPSBhdHRyc0Jsb2NrSW5kZXggKyAxO1xuICAgIH1cblxuICAgIHRoaXMuc3ltYm9sVGFibGUgPSB7XG4gICAgICBoYXNFdmFsLFxuICAgICAgc3ltYm9scyxcbiAgICB9O1xuICB9XG5cbiAgY29tcGlsZShzeW50YXg6IENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0KTogSGFuZGxlUmVzdWx0IHtcbiAgICBpZiAodGhpcy5jb21waWxlZCAhPT0gbnVsbCkgcmV0dXJuIHRoaXMuY29tcGlsZWQ7XG5cbiAgICBsZXQgbSA9IG1ldGEodGhpcy5sYXlvdXQpO1xuICAgIGxldCBjb250ZXh0ID0gdGVtcGxhdGVDb21waWxhdGlvbkNvbnRleHQoc3ludGF4LCBtKTtcblxuICAgIGxldCB7XG4gICAgICBlbmNvZGVyLFxuICAgICAgcHJvZ3JhbTogeyBjb25zdGFudHMsIHJlc29sdmVyIH0sXG4gICAgfSA9IGNvbnRleHQ7XG5cbiAgICBmdW5jdGlvbiBwdXNoT3AoLi4ub3A6IEJ1aWxkZXJPcCB8IEhpZ2hMZXZlbE9wIHwgSGlnaExldmVsU3RhdGVtZW50T3ApIHtcbiAgICAgIGVuY29kZU9wKGVuY29kZXIsIGNvbnN0YW50cywgcmVzb2x2ZXIsIG0sIG9wIGFzIEJ1aWxkZXJPcCB8IEhpZ2hMZXZlbE9wKTtcbiAgICB9XG5cbiAgICBXcmFwcGVkQ29tcG9uZW50KHB1c2hPcCwgdGhpcy5sYXlvdXQsIHRoaXMuYXR0cnNCbG9ja051bWJlcik7XG5cbiAgICBsZXQgaGFuZGxlID0gY29udGV4dC5lbmNvZGVyLmNvbW1pdChtLnNpemUpO1xuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGUgIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gaGFuZGxlO1xuICAgIH1cblxuICAgIHRoaXMuY29tcGlsZWQgPSBoYW5kbGU7XG5cbiAgICBpZiAoTE9DQUxfU0hPVUxEX0xPRykge1xuICAgICAgZGVidWdDb21waWxlcihjb250ZXh0LCBoYW5kbGUpO1xuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGU7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIENvbXBpbGFibGVQcm9ncmFtLFxuICBMYXlvdXRXaXRoQ29udGV4dCxcbiAgT3B0aW9uLFxuICBPd25lcixcbiAgU2VyaWFsaXplZFRlbXBsYXRlQmxvY2ssXG4gIFNlcmlhbGl6ZWRUZW1wbGF0ZVdpdGhMYXp5QmxvY2ssXG4gIFRlbXBsYXRlLFxuICBUZW1wbGF0ZUZhY3RvcnksXG4gIFRlbXBsYXRlT2ssXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBjb21waWxhYmxlIH0gZnJvbSAnLi9jb21waWxhYmxlLXRlbXBsYXRlJztcbmltcG9ydCB7IFdyYXBwZWRCdWlsZGVyIH0gZnJvbSAnLi93cmFwcGVkLWNvbXBvbmVudCc7XG5cbmxldCBjbGllbnRJZCA9IDA7XG5cbmV4cG9ydCBsZXQgdGVtcGxhdGVDYWNoZUNvdW50ZXJzID0ge1xuICBjYWNoZUhpdDogMCxcbiAgY2FjaGVNaXNzOiAwLFxufTtcblxuLy8gVGhlc2UgaW50ZXJmYWNlcyBhcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBzb21lIGFkZG9ucyB1c2UgdGhlc2UgaW50aW1hdGUgQVBJc1xuZXhwb3J0IGludGVyZmFjZSBUZW1wbGF0ZUZhY3RvcnlXaXRoSWRBbmRNZXRhIGV4dGVuZHMgVGVtcGxhdGVGYWN0b3J5IHtcbiAgX19pZD86IHN0cmluZztcbiAgX19tZXRhPzogeyBtb2R1bGVOYW1lOiBzdHJpbmcgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUZW1wbGF0ZVdpdGhJZEFuZFJlZmVycmVyIGV4dGVuZHMgVGVtcGxhdGVPayB7XG4gIGlkOiBzdHJpbmc7XG4gIHJlZmVycmVyOiB7XG4gICAgbW9kdWxlTmFtZTogc3RyaW5nO1xuICAgIG93bmVyOiBPd25lciB8IG51bGw7XG4gIH07XG59XG5cbi8qKlxuICogV3JhcHMgYSB0ZW1wbGF0ZSBqcyBpbiBhIHRlbXBsYXRlIG1vZHVsZSB0byBjaGFuZ2UgaXQgaW50byBhIGZhY3RvcnlcbiAqIHRoYXQgaGFuZGxlcyBsYXp5IHBhcnNpbmcgdGhlIHRlbXBsYXRlIGFuZCB0byBjcmVhdGUgcGVyIGVudiBzaW5nbGV0b25zXG4gKiBvZiB0aGUgdGVtcGxhdGUuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRlbXBsYXRlRmFjdG9yeSh7XG4gIGlkOiB0ZW1wbGF0ZUlkLFxuICBtb2R1bGVOYW1lLFxuICBibG9jayxcbiAgc2NvcGUsXG4gIGlzU3RyaWN0TW9kZSxcbn06IFNlcmlhbGl6ZWRUZW1wbGF0ZVdpdGhMYXp5QmxvY2spOiBUZW1wbGF0ZUZhY3Rvcnkge1xuICAvLyBUT0RPKHRlbXBsYXRlLXJlZmFjdG9ycyk6IFRoaXMgc2hvdWxkIGJlIHJlbW92ZWQgaW4gdGhlIG5lYXIgZnV0dXJlLCBhcyBpdFxuICAvLyBhcHBlYXJzIHRoYXQgaWQgaXMgdW51c2VkLiBJdCBpcyBjdXJyZW50bHkga2VwdCBmb3IgYmFja3dhcmRzIGNvbXBhdCByZWFzb25zLlxuICBsZXQgaWQgPSB0ZW1wbGF0ZUlkIHx8IGBjbGllbnQtJHtjbGllbnRJZCsrfWA7XG5cbiAgLy8gVE9ETzogVGhpcyBjYWNoZXMgSlNPTiBzZXJpYWxpemVkIG91dHB1dCBvbmNlIGluIGNhc2UgYSB0ZW1wbGF0ZSBpc1xuICAvLyBjb21waWxlZCBieSBtdWx0aXBsZSBvd25lcnMsIGJ1dCB3ZSBoYXZlbid0IHZlcmlmaWVkIGlmIHRoaXMgaXMgYWN0dWFsbHlcbiAgLy8gaGVscGZ1bC4gV2Ugc2hvdWxkIGJlbmNobWFyayB0aGlzIGluIHRoZSBmdXR1cmUuXG4gIGxldCBwYXJzZWRCbG9jazogU2VyaWFsaXplZFRlbXBsYXRlQmxvY2s7XG5cbiAgbGV0IG93bmVybGVzc1RlbXBsYXRlOiBUZW1wbGF0ZSB8IG51bGwgPSBudWxsO1xuICBsZXQgdGVtcGxhdGVDYWNoZSA9IG5ldyBXZWFrTWFwPG9iamVjdCwgVGVtcGxhdGU+KCk7XG5cbiAgbGV0IGZhY3Rvcnk6IFRlbXBsYXRlRmFjdG9yeVdpdGhJZEFuZE1ldGEgPSAob3duZXI/OiBPd25lcikgPT4ge1xuICAgIGlmIChwYXJzZWRCbG9jayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWRCbG9jayA9IEpTT04ucGFyc2UoYmxvY2spO1xuICAgIH1cblxuICAgIGlmIChvd25lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAob3duZXJsZXNzVGVtcGxhdGUgPT09IG51bGwpIHtcbiAgICAgICAgdGVtcGxhdGVDYWNoZUNvdW50ZXJzLmNhY2hlTWlzcysrO1xuICAgICAgICBvd25lcmxlc3NUZW1wbGF0ZSA9IG5ldyBUZW1wbGF0ZUltcGwoe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGJsb2NrOiBwYXJzZWRCbG9jayxcbiAgICAgICAgICBtb2R1bGVOYW1lLFxuICAgICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgIGlzU3RyaWN0TW9kZSxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZUNhY2hlQ291bnRlcnMuY2FjaGVIaXQrKztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG93bmVybGVzc1RlbXBsYXRlO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSB0ZW1wbGF0ZUNhY2hlLmdldChvd25lcikgYXMgVGVtcGxhdGU7XG5cbiAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRlbXBsYXRlQ2FjaGVDb3VudGVycy5jYWNoZU1pc3MrKztcbiAgICAgIHJlc3VsdCA9IG5ldyBUZW1wbGF0ZUltcGwoeyBpZCwgYmxvY2s6IHBhcnNlZEJsb2NrLCBtb2R1bGVOYW1lLCBvd25lciwgc2NvcGUsIGlzU3RyaWN0TW9kZSB9KTtcbiAgICAgIHRlbXBsYXRlQ2FjaGUuc2V0KG93bmVyLCByZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wbGF0ZUNhY2hlQ291bnRlcnMuY2FjaGVIaXQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIGZhY3RvcnkuX19pZCA9IGlkO1xuICBmYWN0b3J5Ll9fbWV0YSA9IHsgbW9kdWxlTmFtZSB9O1xuXG4gIHJldHVybiBmYWN0b3J5O1xufVxuXG5jbGFzcyBUZW1wbGF0ZUltcGwgaW1wbGVtZW50cyBUZW1wbGF0ZVdpdGhJZEFuZFJlZmVycmVyIHtcbiAgcmVhZG9ubHkgcmVzdWx0ID0gJ29rJztcblxuICBwcml2YXRlIGxheW91dDogT3B0aW9uPENvbXBpbGFibGVQcm9ncmFtPiA9IG51bGw7XG4gIHByaXZhdGUgd3JhcHBlZExheW91dDogT3B0aW9uPENvbXBpbGFibGVQcm9ncmFtPiA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwYXJzZWRMYXlvdXQ6IExheW91dFdpdGhDb250ZXh0KSB7fVxuXG4gIGdldCBtb2R1bGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlZExheW91dC5tb2R1bGVOYW1lO1xuICB9XG5cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlZExheW91dC5pZDtcbiAgfVxuXG4gIC8vIFRPRE8odGVtcGxhdGUtcmVmYWN0b3JzKTogVGhpcyBzaG91bGQgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUsIGl0IGlzXG4gIC8vIG9ubHkgYmVpbmcgZXhwb3NlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgZ2V0IHJlZmVycmVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtb2R1bGVOYW1lOiB0aGlzLnBhcnNlZExheW91dC5tb2R1bGVOYW1lLFxuICAgICAgb3duZXI6IHRoaXMucGFyc2VkTGF5b3V0Lm93bmVyLFxuICAgIH07XG4gIH1cblxuICBhc0xheW91dCgpOiBDb21waWxhYmxlUHJvZ3JhbSB7XG4gICAgaWYgKHRoaXMubGF5b3V0KSByZXR1cm4gdGhpcy5sYXlvdXQ7XG4gICAgcmV0dXJuICh0aGlzLmxheW91dCA9IGNvbXBpbGFibGUoYXNzaWduKHt9LCB0aGlzLnBhcnNlZExheW91dCksIHRoaXMubW9kdWxlTmFtZSkpO1xuICB9XG5cbiAgYXNXcmFwcGVkTGF5b3V0KCk6IENvbXBpbGFibGVQcm9ncmFtIHtcbiAgICBpZiAodGhpcy53cmFwcGVkTGF5b3V0KSByZXR1cm4gdGhpcy53cmFwcGVkTGF5b3V0O1xuICAgIHJldHVybiAodGhpcy53cmFwcGVkTGF5b3V0ID0gbmV3IFdyYXBwZWRCdWlsZGVyKFxuICAgICAgYXNzaWduKHt9LCB0aGlzLnBhcnNlZExheW91dCksXG4gICAgICB0aGlzLm1vZHVsZU5hbWVcbiAgICApKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImFzc2lnbiIsImRpY3QiLCJERUJVRyIsImRlYnVnVG9TdHJpbmciLCJhc3NlcnQiLCJkZXByZWNhdGUiLCIkdjAiLCJFTVBUWV9BUlJBWSIsIkVNUFRZX1NUUklOR19BUlJBWSIsImlzU21hbGxJbnQiLCJlbmNvZGVJbW1lZGlhdGUiLCIkZnAiLCIkc3AiLCJoYXNDYXBhYmlsaXR5IiwiJHMwIiwiJHMxIiwiU3RhY2siLCJJbnN0cnVjdGlvbkVuY29kZXJJbXBsIiwiaXNNYWNoaW5lT3AiLCJlbmNvZGVIYW5kbGUiXSwibWFwcGluZ3MiOiI7Ozs7O01BT00sZUFBTjtFQUdFLDJCQUFBLE1BQUEsRUFBbUQ7RUFBL0IsU0FBQSxNQUFB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LENBQUEsRUFBQSxFQUFBLFVBQUEsRUFBQSxLQUFBLEVBQUEsTUFBQSxFQUllO0VBRW5CLEVBQUEsRUFBRSxDQUFBO0VBQUE7RUFBQSxHQUFGO0VBQ0EsRUFBQSxVQUFVLENBQUEsRUFBQSxFQUFBLFVBQUEsRUFBQSxLQUFBLEVBQVYsS0FBVSxDQUFWO0VBQ0EsRUFBQSxFQUFFLENBQUE7RUFBQTtFQUFBLElBQUFLLE1BQUEsRUFBRixDQUFFLENBQUY7RUFDQSxFQUFBLEVBQUUsQ0FBQTtFQUFBO0VBQUEsR0FBRjs7RUFDQSxNQUFBLE1BQUEsRUFBWTtFQUNWLElBQUEsRUFBRSxDQUFBO0VBQUE7RUFBQSxNQUFGTCxNQUFFLENBQUY7RUFDQSxJQUFBLE1BQU07RUFDTixJQUFBLEVBQUUsQ0FBQTtFQUFBO0VBQUEsS0FBRjtFQUNBLElBQUEsRUFBRSxDQUFBO0VBQUE7RUFBQSxNQUFGLENBQUUsQ0FBRjtFQUpGLEdBQUEsTUFLTztFQUNMLElBQUEsRUFBRSxDQUFBO0VBQUE7RUFBQSxLQUFGO0VBQ0EsSUFBQSxFQUFFLENBQUE7RUFBQTtFQUFBLE1BQUYsQ0FBRSxDQUFGO0VBQ0EsSUFBQSxFQUFFLENBQUE7RUFBQTtFQUFBLE1BQUZBLE1BQUUsQ0FBRjtFQUNEO0VBQ0Y7RUFFRDs7Ozs7Ozs7O0FBUUEsRUFBTSxTQUFBLFlBQUEsQ0FBQSxFQUFBLEVBQUEsS0FBQSxFQUFBLEtBQUEsRUFBOEU7RUFDbEYsRUFBQSxFQUFFLENBQUE7RUFBQTtFQUFBLEdBQUY7RUFDQSxFQUFBLEVBQUUsQ0FBQTtFQUFBO0VBQUEsSUFBRixLQUFFLENBQUY7RUFDQSxFQUFBLEtBQUs7RUFDTCxFQUFBLEVBQUUsQ0FBQTtFQUFBO0VBQUEsR0FBRjtFQUNEO0FBRUQsRUFBTSxTQUFBLEtBQUEsQ0FBQSxFQUFBLEVBQUEsSUFBQSxFQUFBLFVBQUEsRUFBQSxVQUFBLEVBQUEsS0FBQSxFQUt1QjtFQUUzQixFQUFBLEVBQUUsQ0FBQTtFQUFBO0VBQUEsR0FBRjtFQUNBLEVBQUEsVUFBVSxDQUFBLEVBQUEsRUFBQSxVQUFBLEVB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
