import { Option, WireFormat, CurriedType } from '@glimmer/interfaces';
import { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';
export declare type Primitive = undefined | null | boolean | number | string;
export interface CompileHelper {
    handle: number;
    positional: Option<WireFormat.Core.Params>;
    named: WireFormat.Core.Hash;
}
/**
 * Push a reference onto the stack corresponding to a statically known primitive
 * @param value A JavaScript primitive (undefined, null, boolean, number or string)
 */
export declare function PushPrimitiveReference(op: PushExpressionOp, value: Primitive): void;
/**
 * Push an encoded representation of a JavaScript primitive on the stack
 *
 * @param value A JavaScript primitive (undefined, null, boolean, number or string)
 */
export declare function PushPrimitive(op: PushExpressionOp, primitive: Primitive): void;
/**
 * Invoke a foreign function (a "helper") based on a statically known handle
 *
 * @param op The op creation function
 * @param handle A handle
 * @param positional An optional list of expressions to compile
 * @param named An optional list of named arguments (name + expression) to compile
 */
export declare function Call(op: PushExpressionOp, handle: number, positional: WireFormat.Core.Params, named: WireFormat.Core.Hash): void;
/**
 * Invoke a foreign function (a "helper") based on a dynamically loaded definition
 *
 * @param op The op creation function
 * @param positional An optional list of expressions to compile
 * @param named An optional list of named arguments (name + expression) to compile
 */
export declare function CallDynamic(op: PushExpressionOp, positional: WireFormat.Core.Params, named: WireFormat.Core.Hash, append?: () => void): void;
/**
 * Evaluate statements in the context of new dynamic scope entries. Move entries from the
 * stack into named entries in the dynamic scope, then evaluate the statements, then pop
 * the dynamic scope
 *
 * @param names a list of dynamic scope names
 * @param block a function that returns a list of statements to evaluate
 */
export declare function DynamicScope(op: PushStatementOp, names: string[], block: () => void): void;
export declare function Curry(op: PushExpressionOp, type: CurriedType, definition: WireFormat.Expression, positional: WireFormat.Core.Params, named: WireFormat.Core.Hash): void;
//# sourceMappingURL=vm.d.ts.map