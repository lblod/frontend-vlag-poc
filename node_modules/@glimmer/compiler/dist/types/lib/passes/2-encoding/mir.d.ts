import { CurriedType, PresentArray } from '@glimmer/interfaces';
import { ASTv2, BlockSymbolTable, ProgramSymbolTable, SourceSlice, SymbolTable } from '@glimmer/syntax';
import { AnyOptionalList, OptionalList, PresentList } from '../../shared/list';
declare const Template_base: ASTv2.TypedNodeConstructor<"Template", {
    scope: ProgramSymbolTable;
    body: Statement[];
} & ASTv2.BaseNodeFields>;
export declare class Template extends Template_base {
}
declare const InElement_base: ASTv2.TypedNodeConstructor<"InElement", {
    guid: string;
    insertBefore: ExpressionNode | Missing;
    destination: ExpressionNode;
    block: NamedBlock;
} & ASTv2.BaseNodeFields>;
export declare class InElement extends InElement_base {
}
declare const Not_base: ASTv2.TypedNodeConstructor<"Not", {
    value: ExpressionNode;
} & ASTv2.BaseNodeFields>;
export declare class Not extends Not_base {
}
declare const If_base: ASTv2.TypedNodeConstructor<"If", {
    condition: ExpressionNode;
    block: NamedBlock;
    inverse: NamedBlock | null;
} & ASTv2.BaseNodeFields>;
export declare class If extends If_base {
}
declare const IfInline_base: ASTv2.TypedNodeConstructor<"IfInline", {
    condition: ExpressionNode;
    truthy: ExpressionNode;
    falsy: ExpressionNode | null;
} & ASTv2.BaseNodeFields>;
export declare class IfInline extends IfInline_base {
}
declare const Each_base: ASTv2.TypedNodeConstructor<"Each", {
    value: ExpressionNode;
    key: ExpressionNode | null;
    block: NamedBlock;
    inverse: NamedBlock | null;
} & ASTv2.BaseNodeFields>;
export declare class Each extends Each_base {
}
declare const With_base: ASTv2.TypedNodeConstructor<"With", {
    value: ExpressionNode;
    block: NamedBlock;
    inverse: NamedBlock | null;
} & ASTv2.BaseNodeFields>;
export declare class With extends With_base {
}
declare const Let_base: ASTv2.TypedNodeConstructor<"Let", {
    positional: Positional;
    block: NamedBlock;
} & ASTv2.BaseNodeFields>;
export declare class Let extends Let_base {
}
declare const WithDynamicVars_base: ASTv2.TypedNodeConstructor<"WithDynamicVars", {
    named: NamedArguments;
    block: NamedBlock;
} & ASTv2.BaseNodeFields>;
export declare class WithDynamicVars extends WithDynamicVars_base {
}
declare const GetDynamicVar_base: ASTv2.TypedNodeConstructor<"GetDynamicVar", {
    name: ExpressionNode;
} & ASTv2.BaseNodeFields>;
export declare class GetDynamicVar extends GetDynamicVar_base {
}
declare const Log_base: ASTv2.TypedNodeConstructor<"Log", {
    positional: Positional;
} & ASTv2.BaseNodeFields>;
export declare class Log extends Log_base {
}
declare const InvokeComponent_base: ASTv2.TypedNodeConstructor<"InvokeComponent", {
    definition: ExpressionNode;
    args: Args;
    blocks: NamedBlocks | null;
} & ASTv2.BaseNodeFields>;
export declare class InvokeComponent extends InvokeComponent_base {
}
declare const NamedBlocks_base: ASTv2.TypedNodeConstructor<"NamedBlocks", {
    blocks: OptionalList<NamedBlock>;
} & ASTv2.BaseNodeFields>;
export declare class NamedBlocks extends NamedBlocks_base {
}
declare const NamedBlock_base: ASTv2.TypedNodeConstructor<"NamedBlock", {
    scope: BlockSymbolTable;
    name: SourceSlice;
    body: Statement[];
} & ASTv2.BaseNodeFields>;
export declare class NamedBlock extends NamedBlock_base {
}
declare const EndBlock_base: ASTv2.TypedNodeConstructor<"EndBlock", object & ASTv2.BaseNodeFields>;
export declare class EndBlock extends EndBlock_base {
}
declare const AppendTrustedHTML_base: ASTv2.TypedNodeConstructor<"AppendTrustedHTML", {
    html: ExpressionNode;
} & ASTv2.BaseNodeFields>;
export declare class AppendTrustedHTML extends AppendTrustedHTML_base {
}
declare const AppendTextNode_base: ASTv2.TypedNodeConstructor<"AppendTextNode", {
    text: ExpressionNode;
} & ASTv2.BaseNodeFields>;
export declare class AppendTextNode extends AppendTextNode_base {
}
declare const AppendComment_base: ASTv2.TypedNodeConstructor<"AppendComment", {
    value: SourceSlice;
} & ASTv2.BaseNodeFields>;
export declare class AppendComment extends AppendComment_base {
}
declare const Component_base: ASTv2.TypedNodeConstructor<"Component", {
    tag: ExpressionNode;
    params: ElementParameters;
    args: NamedArguments;
    blocks: NamedBlocks;
} & ASTv2.BaseNodeFields>;
export declare class Component extends Component_base {
}
export interface AttrKind {
    trusting: boolean;
    component: boolean;
}
declare const StaticAttr_base: ASTv2.TypedNodeConstructor<"StaticAttr", {
    kind: {
        component: boolean;
    };
    name: SourceSlice;
    value: SourceSlice;
    namespace?: string | undefined;
} & ASTv2.BaseNodeFields>;
export declare class StaticAttr extends StaticAttr_base {
}
declare const DynamicAttr_base: ASTv2.TypedNodeConstructor<"DynamicAttr", {
    kind: AttrKind;
    name: SourceSlice;
    value: ExpressionNode;
    namespace?: string | undefined;
} & ASTv2.BaseNodeFields>;
export declare class DynamicAttr extends DynamicAttr_base {
}
declare const SimpleElement_base: ASTv2.TypedNodeConstructor<"SimpleElement", {
    tag: SourceSlice;
    params: ElementParameters;
    body: Statement[];
    dynamicFeatures: boolean;
} & ASTv2.BaseNodeFields>;
export declare class SimpleElement extends SimpleElement_base {
}
declare const ElementParameters_base: ASTv2.TypedNodeConstructor<"ElementParameters", {
    body: AnyOptionalList<ElementParameter>;
} & ASTv2.BaseNodeFields>;
export declare class ElementParameters extends ElementParameters_base {
}
declare const Yield_base: ASTv2.TypedNodeConstructor<"Yield", {
    target: SourceSlice;
    to: number;
    positional: Positional;
} & ASTv2.BaseNodeFields>;
export declare class Yield extends Yield_base {
}
declare const Debugger_base: ASTv2.TypedNodeConstructor<"Debugger", {
    scope: SymbolTable;
} & ASTv2.BaseNodeFields>;
export declare class Debugger extends Debugger_base {
}
declare const CallExpression_base: ASTv2.TypedNodeConstructor<"CallExpression", {
    callee: ExpressionNode;
    args: Args;
} & ASTv2.BaseNodeFields>;
export declare class CallExpression extends CallExpression_base {
}
declare const DeprecatedCallExpression_base: ASTv2.TypedNodeConstructor<"DeprecatedCallExpression", {
    arg: SourceSlice;
    callee: ASTv2.FreeVarReference;
} & ASTv2.BaseNodeFields>;
export declare class DeprecatedCallExpression extends DeprecatedCallExpression_base {
}
declare const Modifier_base: ASTv2.TypedNodeConstructor<"Modifier", {
    callee: ExpressionNode;
    args: Args;
} & ASTv2.BaseNodeFields>;
export declare class Modifier extends Modifier_base {
}
declare const InvokeBlock_base: ASTv2.TypedNodeConstructor<"InvokeBlock", {
    head: ExpressionNode;
    args: Args;
    blocks: NamedBlocks;
} & ASTv2.BaseNodeFields>;
export declare class InvokeBlock extends InvokeBlock_base {
}
declare const SplatAttr_base: ASTv2.TypedNodeConstructor<"SplatAttr", {
    symbol: number;
} & ASTv2.BaseNodeFields>;
export declare class SplatAttr extends SplatAttr_base {
}
declare const PathExpression_base: ASTv2.TypedNodeConstructor<"PathExpression", {
    head: ExpressionNode;
    tail: Tail;
} & ASTv2.BaseNodeFields>;
export declare class PathExpression extends PathExpression_base {
}
declare const GetWithResolver_base: ASTv2.TypedNodeConstructor<"GetWithResolver", {
    symbol: number;
} & ASTv2.BaseNodeFields>;
export declare class GetWithResolver extends GetWithResolver_base {
}
declare const GetSymbol_base: ASTv2.TypedNodeConstructor<"GetSymbol", {
    symbol: number;
} & ASTv2.BaseNodeFields>;
export declare class GetSymbol extends GetSymbol_base {
}
declare const GetFreeWithContext_base: ASTv2.TypedNodeConstructor<"GetFreeWithContext", {
    symbol: number;
    context: ASTv2.FreeVarResolution;
} & ASTv2.BaseNodeFields>;
export declare class GetFreeWithContext extends GetFreeWithContext_base {
}
declare const GetFree_base: ASTv2.TypedNodeConstructor<"GetFree", {
    symbol: number;
} & ASTv2.BaseNodeFields>;
/** strict mode */
export declare class GetFree extends GetFree_base {
}
declare const Missing_base: ASTv2.TypedNodeConstructor<"Missing", object & ASTv2.BaseNodeFields>;
export declare class Missing extends Missing_base {
}
declare const InterpolateExpression_base: ASTv2.TypedNodeConstructor<"InterpolateExpression", {
    parts: PresentList<ExpressionNode>;
} & ASTv2.BaseNodeFields>;
export declare class InterpolateExpression extends InterpolateExpression_base {
}
declare const HasBlock_base: ASTv2.TypedNodeConstructor<"HasBlock", {
    target: SourceSlice;
    symbol: number;
} & ASTv2.BaseNodeFields>;
export declare class HasBlock extends HasBlock_base {
}
declare const HasBlockParams_base: ASTv2.TypedNodeConstructor<"HasBlockParams", {
    target: SourceSlice;
    symbol: number;
} & ASTv2.BaseNodeFields>;
export declare class HasBlockParams extends HasBlockParams_base {
}
declare const Curry_base: ASTv2.TypedNodeConstructor<"Curry", {
    definition: ExpressionNode;
    curriedType: CurriedType;
    args: Args;
} & ASTv2.BaseNodeFields>;
export declare class Curry extends Curry_base {
}
declare const Positional_base: ASTv2.TypedNodeConstructor<"Positional", {
    list: OptionalList<ExpressionNode>;
} & ASTv2.BaseNodeFields>;
export declare class Positional extends Positional_base {
}
declare const NamedArguments_base: ASTv2.TypedNodeConstructor<"NamedArguments", {
    entries: OptionalList<NamedArgument>;
} & ASTv2.BaseNodeFields>;
export declare class NamedArguments extends NamedArguments_base {
}
declare const NamedArgument_base: ASTv2.TypedNodeConstructor<"NamedArgument", {
    key: SourceSlice;
    value: ExpressionNode;
} & ASTv2.BaseNodeFields>;
export declare class NamedArgument extends NamedArgument_base {
}
declare const Args_base: ASTv2.TypedNodeConstructor<"Args", {
    positional: Positional;
    named: NamedArguments;
} & ASTv2.BaseNodeFields>;
export declare class Args extends Args_base {
}
declare const Tail_base: ASTv2.TypedNodeConstructor<"Tail", {
    members: PresentArray<SourceSlice<string>>;
} & ASTv2.BaseNodeFields>;
export declare class Tail extends Tail_base {
}
export declare type ExpressionNode = ASTv2.LiteralExpression | Missing | PathExpression | ASTv2.VariableReference | InterpolateExpression | CallExpression | DeprecatedCallExpression | Not | IfInline | HasBlock | HasBlockParams | Curry | GetDynamicVar | Log;
export declare type ElementParameter = StaticAttr | DynamicAttr | Modifier | SplatAttr;
export declare type Internal = Args | Positional | NamedArguments | NamedArgument | Tail | NamedBlock | NamedBlocks | ElementParameters;
export declare type ExprLike = ExpressionNode | Internal;
export declare type Statement = InElement | Debugger | Yield | AppendTrustedHTML | AppendTextNode | Component | SimpleElement | InvokeBlock | AppendComment | If | Each | With | Let | WithDynamicVars | InvokeComponent;
export {};
//# sourceMappingURL=mir.d.ts.map