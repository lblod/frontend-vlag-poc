import { WellKnownAttrName, WireFormat } from '@glimmer/interfaces';
import { OptionalList } from '../../shared/list';
import * as mir from './mir';
declare class WireStatements<S extends WireFormat.Statement = WireFormat.Statement> {
    private statements;
    constructor(statements: readonly S[]);
    toArray(): readonly S[];
}
export declare class ContentEncoder {
    list(statements: mir.Statement[]): WireFormat.Statement[];
    content(stmt: mir.Statement): WireFormat.Statement | WireStatements;
    private visitContent;
    Yield({ to, positional }: mir.Yield): WireFormat.Statements.Yield;
    InElement({ guid, insertBefore, destination, block, }: mir.InElement): WireFormat.Statements.InElement;
    InvokeBlock({ head, args, blocks }: mir.InvokeBlock): WireFormat.Statements.Block;
    AppendTrustedHTML({ html }: mir.AppendTrustedHTML): WireFormat.Statements.TrustingAppend;
    AppendTextNode({ text }: mir.AppendTextNode): WireFormat.Statements.Append;
    AppendComment({ value }: mir.AppendComment): WireFormat.Statements.Comment;
    SimpleElement({ tag, params, body, dynamicFeatures }: mir.SimpleElement): WireStatements;
    Component({ tag, params, args, blocks }: mir.Component): WireFormat.Statements.Component;
    ElementParameters({ body }: mir.ElementParameters): OptionalList<WireFormat.ElementParameter>;
    ElementParameter(param: mir.ElementParameter): WireFormat.ElementParameter;
    NamedBlocks({ blocks }: mir.NamedBlocks): WireFormat.Core.Blocks;
    NamedBlock({ name, body, scope }: mir.NamedBlock): WireFormat.Core.NamedBlock;
    If({ condition, block, inverse }: mir.If): WireFormat.Statements.If;
    Each({ value, key, block, inverse }: mir.Each): WireFormat.Statements.Each;
    With({ value, block, inverse }: mir.With): WireFormat.Statements.With;
    Let({ positional, block }: mir.Let): WireFormat.Statements.Let;
    WithDynamicVars({ named, block }: mir.WithDynamicVars): WireFormat.Statements.WithDynamicVars;
    InvokeComponent({ definition, args, blocks, }: mir.InvokeComponent): WireFormat.Statements.InvokeComponent;
}
export declare const CONTENT: ContentEncoder;
export declare type StaticAttrArgs = [name: string | WellKnownAttrName, value: string, namespace?: string];
export declare type DynamicAttrArgs = [
    name: string | WellKnownAttrName,
    value: WireFormat.Expression,
    namespace?: string
];
export {};
//# sourceMappingURL=content.d.ts.map