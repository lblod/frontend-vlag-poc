import { PresentArray, WireFormat } from '@glimmer/interfaces';
import { ASTv2 } from '@glimmer/syntax';
import * as mir from './mir';
export declare type HashPair = [string, WireFormat.Expression];
export declare class ExpressionEncoder {
    expr(expr: mir.ExpressionNode): WireFormat.Expression;
    Literal({ value, }: ASTv2.LiteralExpression): WireFormat.Expressions.Value | WireFormat.Expressions.Undefined;
    Missing(): undefined;
    HasBlock({ symbol }: mir.HasBlock): WireFormat.Expressions.HasBlock;
    HasBlockParams({ symbol }: mir.HasBlockParams): WireFormat.Expressions.HasBlockParams;
    Curry({ definition, curriedType, args }: mir.Curry): WireFormat.Expressions.Curry;
    Local({ isTemplateLocal, symbol, }: ASTv2.LocalVarReference): WireFormat.Expressions.GetSymbol | WireFormat.Expressions.GetTemplateSymbol;
    GetWithResolver({ symbol }: mir.GetWithResolver): WireFormat.Expressions.GetContextualFree;
    PathExpression({ head, tail }: mir.PathExpression): WireFormat.Expressions.GetPath;
    InterpolateExpression({ parts }: mir.InterpolateExpression): WireFormat.Expressions.Concat;
    CallExpression({ callee, args }: mir.CallExpression): WireFormat.Expressions.Helper;
    DeprecatedCallExpression({ arg, callee, }: mir.DeprecatedCallExpression): WireFormat.Expressions.GetPathFreeAsDeprecatedHelperHeadOrThisFallback;
    Tail({ members }: mir.Tail): PresentArray<string>;
    Args({ positional, named }: mir.Args): WireFormat.Core.Args;
    Positional({ list }: mir.Positional): WireFormat.Core.Params;
    NamedArgument({ key, value }: mir.NamedArgument): HashPair;
    NamedArguments({ entries: pairs }: mir.NamedArguments): WireFormat.Core.Hash;
    Not({ value }: mir.Not): WireFormat.Expressions.Not;
    IfInline({ condition, truthy, falsy }: mir.IfInline): WireFormat.Expressions.IfInline;
    GetDynamicVar({ name }: mir.GetDynamicVar): WireFormat.Expressions.GetDynamicVar;
    Log({ positional }: mir.Log): WireFormat.Expressions.Log;
}
export declare const EXPR: ExpressionEncoder;
//# sourceMappingURL=expressions.d.ts.map