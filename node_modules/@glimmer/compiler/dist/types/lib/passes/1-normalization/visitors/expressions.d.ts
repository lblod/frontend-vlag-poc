import { PresentArray } from '@glimmer/interfaces';
import { ASTv2 } from '@glimmer/syntax';
import { AnyOptionalList, PresentList } from '../../../shared/list';
import { Result } from '../../../shared/result';
import * as mir from '../../2-encoding/mir';
import { NormalizationState } from '../context';
export declare class NormalizeExpressions {
    visit(node: ASTv2.ExpressionNode, state: NormalizationState): Result<mir.ExpressionNode>;
    visitList(nodes: PresentArray<ASTv2.ExpressionNode>, state: NormalizationState): Result<PresentList<mir.ExpressionNode>>;
    visitList(nodes: readonly ASTv2.ExpressionNode[], state: NormalizationState): Result<AnyOptionalList<mir.ExpressionNode>>;
    /**
     * Normalize paths into `hir.Path` or a `hir.Expr` that corresponds to the ref.
     *
     * TODO since keywords don't support tails anyway, distinguish PathExpression from
     * VariableReference in ASTv2.
     */
    PathExpression(path: ASTv2.PathExpression): Result<mir.ExpressionNode>;
    VariableReference(ref: ASTv2.VariableReference): ASTv2.VariableReference;
    Literal(literal: ASTv2.LiteralExpression): ASTv2.LiteralExpression;
    Interpolate(expr: ASTv2.InterpolateExpression, state: NormalizationState): Result<mir.InterpolateExpression>;
    CallExpression(expr: ASTv2.CallExpression, state: NormalizationState): Result<mir.ExpressionNode>;
    DeprecaedCallExpression({ arg, callee, loc }: ASTv2.DeprecatedCallExpression, _state: NormalizationState): Result<mir.ExpressionNode>;
    Args({ positional, named, loc }: ASTv2.Args, state: NormalizationState): Result<mir.Args>;
    Positional(positional: ASTv2.PositionalArguments, state: NormalizationState): Result<mir.Positional>;
    NamedArguments(named: ASTv2.NamedArguments, state: NormalizationState): Result<mir.NamedArguments>;
}
export declare function convertPathToCallIfKeyword(path: ASTv2.ExpressionNode): ASTv2.ExpressionNode;
export declare const VISIT_EXPRS: NormalizeExpressions;
//# sourceMappingURL=expressions.d.ts.map