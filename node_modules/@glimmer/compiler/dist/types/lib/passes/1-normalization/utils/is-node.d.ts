import { PresentArray } from '@glimmer/interfaces';
import { ASTv2, SourceSlice } from '@glimmer/syntax';
export declare type HasPath<Node extends ASTv2.CallNode = ASTv2.CallNode> = Node & {
    head: ASTv2.PathExpression;
};
export declare type HasArguments = {
    params: PresentArray<ASTv2.ExpressionNode>;
} | {
    hash: {
        pairs: PresentArray<ASTv2.NamedArgument>;
    };
};
export declare type HelperInvocation<Node extends ASTv2.CallNode = ASTv2.CallNode> = HasPath<Node> & HasArguments;
export declare function hasPath<N extends ASTv2.CallNode>(node: N): node is HasPath<N>;
export declare function isHelperInvocation<N extends ASTv2.CallNode>(node: ASTv2.CallNode): node is HelperInvocation<N>;
export interface SimplePath extends ASTv2.PathExpression {
    tail: [SourceSlice];
    data: false;
    this: false;
}
export declare type SimpleHelper<N extends HasPath> = N & {
    path: SimplePath;
};
export declare function isSimplePath(path: ASTv2.ExpressionNode): path is SimplePath;
export declare function isStrictHelper(expr: HasPath): boolean;
export declare function assertIsValidModifier<N extends HasPath>(helper: N): asserts helper is SimpleHelper<N>;
/**
 * This function is checking whether an AST node is a triple-curly, which means that it's
 * a "trusting" node. In the Handlebars AST, this is indicated by the `escaped` flag, which
 * is a bit of a double-negative, so we change the terminology here for clarity.
 */
export declare function isTrustingNode(value: ASTv2.AppendContent | ASTv2.HtmlText | ASTv2.InterpolateExpression): boolean;
//# sourceMappingURL=is-node.d.ts.map