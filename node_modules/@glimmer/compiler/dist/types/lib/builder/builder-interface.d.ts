import { Dict, Option, PresentArray } from '@glimmer/interfaces';
export declare type BuilderParams = BuilderExpression[];
export declare type BuilderHash = Option<Dict<BuilderExpression>>;
export declare type BuilderBlockHash = BuilderHash | {
    as: string | string[];
};
export declare type BuilderBlocks = Dict<BuilderBlock>;
export declare type BuilderAttrs = Dict<BuilderAttr>;
export declare type NormalizedParams = NormalizedExpression[];
export declare type NormalizedHash = Dict<NormalizedExpression>;
export declare type NormalizedBlock = NormalizedStatement[];
export declare type NormalizedBlocks = Dict<NormalizedBlock>;
export declare type NormalizedAttrs = Dict<NormalizedAttr>;
export declare type NormalizedAttr = HeadKind.Splat | NormalizedExpression;
export interface NormalizedElement {
    name: string;
    attrs: Option<NormalizedAttrs>;
    block: Option<NormalizedBlock>;
}
export interface NormalizedAngleInvocation {
    head: NormalizedExpression;
    attrs: Option<NormalizedAttrs>;
    block: Option<NormalizedBlock>;
}
export declare const enum HeadKind {
    Block = "Block",
    Call = "Call",
    Element = "Element",
    AppendPath = "AppendPath",
    AppendExpr = "AppendExpr",
    Literal = "Literal",
    Modifier = "Modifier",
    DynamicComponent = "DynamicComponent",
    Comment = "Comment",
    Splat = "Splat",
    Keyword = "Keyword"
}
export declare enum VariableKind {
    Local = "Local",
    Free = "Free",
    Arg = "Arg",
    Block = "Block",
    This = "This"
}
export interface Variable {
    kind: VariableKind;
    name: string;
    /**
     * Differences:
     *
     * - strict mode variables always refer to in-scope variables
     * - loose mode variables use this algorithm:
     *   1. otherwise, fall back to `this.<name>`
     */
    mode: 'loose' | 'strict';
}
export interface Path {
    head: Variable;
    tail: PresentArray<string>;
}
export interface AppendExpr {
    kind: HeadKind.AppendExpr;
    expr: NormalizedExpression;
    trusted: boolean;
}
export interface AppendPath {
    kind: HeadKind.AppendPath;
    path: NormalizedPath;
    trusted: boolean;
}
export interface NormalizedKeywordStatement {
    kind: HeadKind.Keyword;
    name: string;
    params: Option<NormalizedParams>;
    hash: Option<NormalizedHash>;
    blockParams: Option<string[]>;
    blocks: NormalizedBlocks;
}
export declare type NormalizedStatement = {
    kind: HeadKind.Call;
    head: NormalizedHead;
    params: Option<NormalizedParams>;
    hash: Option<NormalizedHash>;
    trusted: boolean;
} | {
    kind: HeadKind.Block;
    head: NormalizedHead;
    params: Option<NormalizedParams>;
    hash: Option<NormalizedHash>;
    blockParams: Option<string[]>;
    blocks: NormalizedBlocks;
} | NormalizedKeywordStatement | {
    kind: HeadKind.Element;
    name: string;
    attrs: NormalizedAttrs;
    block: NormalizedBlock;
} | {
    kind: HeadKind.Comment;
    value: string;
} | {
    kind: HeadKind.Literal;
    value: string;
} | AppendPath | AppendExpr | {
    kind: HeadKind.Modifier;
    params: NormalizedParams;
    hash: Option<NormalizedHash>;
} | {
    kind: HeadKind.DynamicComponent;
    expr: NormalizedExpression;
    hash: Option<NormalizedHash>;
    block: NormalizedBlock;
};
export declare function normalizeStatement(statement: BuilderStatement): NormalizedStatement;
export declare function normalizeAppendHead(head: NormalizedHead, trusted: boolean): AppendExpr | AppendPath;
export declare type SugaryArrayStatement = BuilderCallExpression | BuilderElement | BuilderBlockStatement;
export declare function normalizeSugaryArrayStatement(statement: SugaryArrayStatement): NormalizedStatement;
export declare function normalizePathHead(whole: string): Variable;
export declare type BuilderBlockStatement = [string, BuilderBlock | BuilderBlocks] | [string, BuilderParams | BuilderBlockHash, BuilderBlock | BuilderBlocks] | [string, BuilderParams, BuilderBlockHash, BuilderBlock | BuilderBlocks];
export interface NormalizedBuilderBlockStatement {
    head: NormalizedHead;
    params: Option<NormalizedParams>;
    hash: Option<NormalizedHash>;
    blockParams: Option<string[]>;
    blocks: NormalizedBlocks;
}
export declare function normalizeBuilderBlockStatement(statement: BuilderBlockStatement): NormalizedBuilderBlockStatement;
export declare function entries<D extends Dict>(dict: D, callback: <K extends keyof D>(key: K, value: D[K]) => void): void;
export declare type BuilderElement = [string] | [string, BuilderAttrs, BuilderBlock] | [string, BuilderBlock] | [string, BuilderAttrs];
export declare type BuilderComment = [Builder.Comment, string];
export declare type InvocationElement = [string] | [string, BuilderAttrs, BuilderBlock] | [string, BuilderBlock] | [string, BuilderAttrs];
export declare function isElement(input: [string, ...unknown[]]): input is BuilderElement;
export declare function extractElement(input: string): Option<string>;
export declare function extractAngleInvocation(input: string): Option<string>;
export declare function isAngleInvocation(input: [string, ...unknown[]]): input is InvocationElement;
export declare function isBlock(input: [string, ...unknown[]]): input is BuilderBlockStatement;
export declare const enum Builder {
    Literal = 0,
    Comment = 1,
    Append = 2,
    Modifier = 3,
    DynamicComponent = 4,
    Get = 5,
    Concat = 6,
    HasBlock = 7,
    HasBlockParams = 8
}
export declare type VerboseStatement = [Builder.Literal, string] | [Builder.Comment, string] | [Builder.Append, BuilderExpression, true] | [Builder.Append, BuilderExpression] | [Builder.Modifier, Params, Hash] | [Builder.DynamicComponent, BuilderExpression, Hash, BuilderBlock];
export declare type BuilderStatement = VerboseStatement | SugaryArrayStatement | TupleBuilderExpression | string;
export declare type BuilderAttr = 'splat' | BuilderExpression;
export declare type TupleBuilderExpression = [Builder.Literal, string | boolean | null | undefined] | [Builder.Get, string] | [Builder.Get, string, string[]] | [Builder.Concat, ...BuilderExpression[]] | [Builder.HasBlock, string] | [Builder.HasBlockParams, string] | BuilderCallExpression;
declare type Params = BuilderParams;
declare type Hash = Dict<BuilderExpression>;
export declare const enum ExpressionKind {
    Literal = "Literal",
    Call = "Call",
    GetPath = "GetPath",
    GetVar = "GetVar",
    Concat = "Concat",
    HasBlock = "HasBlock",
    HasBlockParams = "HasBlockParams"
}
export interface NormalizedCallExpression {
    type: ExpressionKind.Call;
    head: NormalizedHead;
    params: Option<NormalizedParams>;
    hash: Option<NormalizedHash>;
}
export interface NormalizedPath {
    type: ExpressionKind.GetPath;
    path: Path;
}
export interface NormalizedVar {
    type: ExpressionKind.GetVar;
    variable: Variable;
}
export declare type NormalizedHead = NormalizedPath | NormalizedVar;
export interface NormalizedConcat {
    type: ExpressionKind.Concat;
    params: [NormalizedExpression, ...NormalizedExpression[]];
}
export declare type NormalizedExpression = {
    type: ExpressionKind.Literal;
    value: null | undefined | boolean | string | number;
} | NormalizedCallExpression | NormalizedPath | NormalizedVar | NormalizedConcat | {
    type: ExpressionKind.HasBlock;
    name: string;
} | {
    type: ExpressionKind.HasBlockParams;
    name: string;
};
export declare function normalizeAppendExpression(expression: BuilderExpression, forceTrusted?: boolean): AppendExpr | AppendPath;
export declare function normalizeExpression(expression: BuilderExpression): NormalizedExpression;
export declare type BuilderExpression = TupleBuilderExpression | BuilderCallExpression | null | undefined | boolean | string | number;
export declare function isBuilderExpression(expr: BuilderExpression | BuilderCallExpression): expr is TupleBuilderExpression | BuilderCallExpression;
export declare function isLiteral(expr: BuilderExpression | BuilderCallExpression): expr is [Builder.Literal, string | boolean | undefined];
export declare function statementIsExpression(statement: BuilderStatement): statement is TupleBuilderExpression;
export declare function isBuilderCallExpression(value: TupleBuilderExpression | BuilderCallExpression): value is BuilderCallExpression;
export declare type MiniBuilderBlock = BuilderStatement[];
export declare type BuilderBlock = MiniBuilderBlock;
export declare type BuilderCallExpression = [string] | [string, Params | Hash] | [string, Params, Hash];
export declare function normalizeParams(input: Params): NormalizedParams;
export declare function normalizeHash(input: Option<Hash>): Option<NormalizedHash>;
export declare function normalizeCallExpression(expr: BuilderCallExpression): NormalizedCallExpression;
export {};
//# sourceMappingURL=builder-interface.d.ts.map