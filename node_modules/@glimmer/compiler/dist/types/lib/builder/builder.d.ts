import { Expressions, GetContextualFreeOp, Option, PresentArray, VariableResolutionContext, WireFormat } from '@glimmer/interfaces';
import { AttrNamespace } from '@simple-dom/interface';
import { Builder, BuilderComment, BuilderStatement, NormalizedAngleInvocation, NormalizedAttrs, NormalizedBlocks, NormalizedExpression, NormalizedHash, NormalizedHead, NormalizedParams, NormalizedPath, NormalizedStatement, Variable } from './builder-interface';
interface Symbols {
    top: ProgramSymbols;
    freeVar(name: string): number;
    arg(name: string): number;
    block(name: string): number;
    local(name: string): number;
    this(): number;
    hasLocal(name: string): boolean;
    child(params: string[]): LocalSymbols;
}
export declare class ProgramSymbols implements Symbols {
    _freeVariables: string[];
    _symbols: string[];
    top: this;
    toSymbols(): string[];
    toUpvars(): string[];
    freeVar(name: string): number;
    block(name: string): number;
    arg(name: string): number;
    local(name: string): never;
    this(): number;
    hasLocal(_name: string): false;
    symbol(name: string): number;
    child(locals: string[]): LocalSymbols;
}
declare class LocalSymbols implements Symbols {
    private parent;
    private locals;
    constructor(parent: Symbols, locals: string[]);
    get paramSymbols(): number[];
    get top(): ProgramSymbols;
    freeVar(name: string): number;
    arg(name: string): number;
    block(name: string): number;
    local(name: string): number;
    this(): number;
    hasLocal(name: string): boolean;
    child(locals: string[]): LocalSymbols;
}
export interface BuilderGetFree {
    type: 'GetFree';
    head: string;
    tail: string[];
}
export declare function buildStatements(statements: BuilderStatement[], symbols: Symbols): WireFormat.Statement[];
export declare function buildNormalizedStatements(statements: NormalizedStatement[], symbols: Symbols): WireFormat.Statement[];
export declare function buildStatement(normalized: NormalizedStatement, symbols?: Symbols): WireFormat.Statement[];
export declare function s(arr: TemplateStringsArray, ...interpolated: unknown[]): [Builder.Literal, string];
export declare function c(arr: TemplateStringsArray, ...interpolated: unknown[]): BuilderComment;
export declare function unicode(charCode: string): string;
export declare const NEWLINE = "\n";
export declare function buildAngleInvocation({ attrs, block, head }: NormalizedAngleInvocation, symbols: Symbols): WireFormat.Statements.Component;
export declare function buildElementParams(attrs: NormalizedAttrs, symbols: Symbols): {
    params: WireFormat.ElementParameter[];
    args: WireFormat.Core.Hash;
};
export declare function extractNamespace(name: string): Option<AttrNamespace>;
export declare function buildAttributeValue(name: string, value: NormalizedExpression, namespace: Option<AttrNamespace>, symbols: Symbols): WireFormat.Attribute[];
declare type ExprResolution = VariableResolutionContext | 'Append' | 'TrustedAppend' | 'AttrValue' | 'SubExpression' | 'Strict';
export declare function buildExpression(expr: NormalizedExpression, context: ExprResolution, symbols: Symbols): WireFormat.Expression;
export declare function buildCallHead(callHead: NormalizedHead, context: VarResolution, symbols: Symbols): Expressions.GetVar | Expressions.GetPath;
export declare function buildGetPath(head: NormalizedPath, symbols: Symbols): Expressions.GetPath;
declare type VarResolution = VariableResolutionContext | 'AppendBare' | 'AppendInvoke' | 'TrustedAppendBare' | 'TrustedAppendInvoke' | 'AttrValueBare' | 'AttrValueInvoke' | 'SubExpression' | 'Strict';
export declare function buildVar(head: Variable, context: VarResolution, symbols: Symbols, path: PresentArray<string>): Expressions.GetPath;
export declare function buildVar(head: Variable, context: VarResolution, symbols: Symbols): Expressions.GetVar;
export declare function expressionContextOp(context: VariableResolutionContext): GetContextualFreeOp;
export declare function buildParams(exprs: Option<NormalizedParams>, symbols: Symbols): Option<WireFormat.Core.Params>;
export declare function buildConcat(exprs: [NormalizedExpression, ...NormalizedExpression[]], symbols: Symbols): WireFormat.Core.ConcatParams;
export declare function buildHash(exprs: Option<NormalizedHash>, symbols: Symbols): WireFormat.Core.Hash;
export declare function buildBlocks(blocks: NormalizedBlocks, blockParams: Option<string[]>, parent: Symbols): WireFormat.Core.Blocks;
export {};
//# sourceMappingURL=builder.d.ts.map