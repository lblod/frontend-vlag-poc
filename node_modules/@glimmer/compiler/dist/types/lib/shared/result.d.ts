import { GlimmerSyntaxError } from '@glimmer/syntax';
import { AnyOptionalList } from './list';
declare abstract class ResultImpl<T> {
    static all<T extends Result<unknown>[]>(...results: T): MapAll<T>;
    abstract mapOk<U>(callback: (value: T) => U): Result<U>;
    abstract readonly isOk: boolean;
    abstract readonly isErr: boolean;
}
export declare const Result: typeof ResultImpl;
declare class OkImpl<T> extends ResultImpl<T> {
    readonly value: T;
    readonly isOk = true;
    readonly isErr = false;
    constructor(value: T);
    expect(_message?: string): T;
    ifOk(callback: (value: T) => void): this;
    andThen<U>(callback: (value: T) => Result<U>): Result<U>;
    mapOk<U>(callback: (value: T) => U): Result<U>;
    ifErr(_callback: (value: GlimmerSyntaxError) => void): this;
    mapErr(_callback: (value: GlimmerSyntaxError) => GlimmerSyntaxError): Result<T>;
}
declare class ErrImpl<T> extends ResultImpl<T> {
    readonly reason: GlimmerSyntaxError;
    readonly isOk = false;
    readonly isErr = true;
    constructor(reason: GlimmerSyntaxError);
    expect(message?: string): T;
    andThen<U>(_callback: (value: T) => Result<U>): Result<U>;
    mapOk<U>(_callback: (value: T) => U): Result<U>;
    ifOk(_callback: (value: T) => void): this;
    mapErr(callback: (value: GlimmerSyntaxError) => GlimmerSyntaxError): Result<T>;
    ifErr(callback: (value: GlimmerSyntaxError) => void): this;
    cast<U>(): Result<U>;
}
export declare function isResult<T>(input: MaybeResult<T>): input is Result<T>;
export declare function intoResult<T>(input: MaybeResult<T>): Result<T>;
export declare type Result<T> = OkImpl<T> | ErrImpl<T>;
declare type MapAllOk<T extends Result<unknown>[]> = {
    [P in keyof T]: T[P] extends Result<infer Inner> ? Inner : never;
};
declare type MapAll<T extends Result<unknown>[]> = Result<MapAllOk<T>>;
export declare function Ok<T>(value: T): Result<T>;
export declare type Ok<T> = OkImpl<T>;
export declare function Err<T>(reason: GlimmerSyntaxError): Result<T>;
export declare type Err<T> = ErrImpl<T>;
export declare type MaybeResult<T> = T | Result<T>;
export declare class MapIntoResultArray<T> {
    private items;
    constructor(items: T[]);
    map<U>(callback: (item: T) => Result<U>): Result<U[]>;
}
export declare class ResultArray<T> {
    private items;
    constructor(items?: Result<T>[]);
    add(item: Result<T>): void;
    toArray(): Result<T[]>;
    toOptionalList(): Result<AnyOptionalList<T>>;
}
export {};
//# sourceMappingURL=result.d.ts.map