import { ASTv2, generateSyntaxError, SourceSpan } from '@glimmer/syntax';
import { Err, Ok, Result } from '../../../shared/result';
import * as mir from '../../2-encoding/mir';
import { VISIT_EXPRS } from '../visitors/expressions';
import { keywords } from './impl';
import { toAppend } from './utils/call-to-append';
import { assertCurryKeyword } from './utils/curry';
import { getDynamicVarKeyword } from './utils/dynamic-vars';
import { hasBlockKeyword } from './utils/has-block';
import { ifUnlessInlineKeyword } from './utils/if-unless';
import { logKeyword } from './utils/log';
export const APPEND_KEYWORDS = keywords('Append').kw('has-block', toAppend(hasBlockKeyword('has-block'))).kw('has-block-params', toAppend(hasBlockKeyword('has-block-params'))).kw('-get-dynamic-var', toAppend(getDynamicVarKeyword)).kw('log', toAppend(logKeyword)).kw('if', toAppend(ifUnlessInlineKeyword('if'))).kw('unless', toAppend(ifUnlessInlineKeyword('unless'))).kw('yield', {
  assert(node) {
    let {
      args
    } = node;

    if (args.named.isEmpty()) {
      return Ok({
        target: SourceSpan.synthetic('default').toSlice(),
        positional: args.positional
      });
    } else {
      let target = args.named.get('to');

      if (args.named.size > 1 || target === null) {
        return Err(generateSyntaxError(`yield only takes a single named argument: 'to'`, args.named.loc));
      }

      if (ASTv2.isLiteral(target, 'string')) {
        return Ok({
          target: target.toSlice(),
          positional: args.positional
        });
      } else {
        return Err(generateSyntaxError(`you can only yield to a literal string value`, target.loc));
      }
    }
  },

  translate({
    node,
    state
  }, {
    target,
    positional
  }) {
    return VISIT_EXPRS.Positional(positional, state).mapOk(positional => new mir.Yield({
      loc: node.loc,
      target,
      to: state.scope.allocateBlock(target.chars),
      positional
    }));
  }

}).kw('debugger', {
  assert(node) {
    let {
      args
    } = node;
    let {
      positional
    } = args;

    if (args.isEmpty()) {
      return Ok(undefined);
    } else {
      if (positional.isEmpty()) {
        return Err(generateSyntaxError(`debugger does not take any named arguments`, node.loc));
      } else {
        return Err(generateSyntaxError(`debugger does not take any positional arguments`, node.loc));
      }
    }
  },

  translate({
    node,
    state: {
      scope
    }
  }) {
    scope.setHasEval();
    return Ok(new mir.Debugger({
      loc: node.loc,
      scope
    }));
  }

}).kw('component', {
  assert: assertCurryKeyword(0
  /* Component */
  ),

  translate({
    node,
    state
  }, {
    definition,
    args
  }) {
    let definitionResult = VISIT_EXPRS.visit(definition, state);
    let argsResult = VISIT_EXPRS.Args(args, state);
    return Result.all(definitionResult, argsResult).mapOk(([definition, args]) => new mir.InvokeComponent({
      loc: node.loc,
      definition,
      args,
      blocks: null
    }));
  }

}).kw('helper', {
  assert: assertCurryKeyword(1
  /* Helper */
  ),

  translate({
    node,
    state
  }, {
    definition,
    args
  }) {
    let definitionResult = VISIT_EXPRS.visit(definition, state);
    let argsResult = VISIT_EXPRS.Args(args, state);
    return Result.all(definitionResult, argsResult).mapOk(([definition, args]) => {
      let text = new mir.CallExpression({
        callee: definition,
        args,
        loc: node.loc
      });
      return new mir.AppendTextNode({
        loc: node.loc,
        text
      });
    });
  }

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL2tleXdvcmRzL2FwcGVuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxTQUFTLEtBQVQsRUFBZ0IsbUJBQWhCLEVBQWtELFVBQWxELFFBQW9FLGlCQUFwRTtBQUVBLFNBQVMsR0FBVCxFQUFjLEVBQWQsRUFBa0IsTUFBbEIsUUFBZ0Msd0JBQWhDO0FBQ0EsT0FBTyxLQUFLLEdBQVosTUFBcUIsc0JBQXJCO0FBRUEsU0FBUyxXQUFULFFBQTRCLHlCQUE1QjtBQUNBLFNBQVMsUUFBVCxRQUF5QixRQUF6QjtBQUNBLFNBQVMsUUFBVCxRQUF5Qix3QkFBekI7QUFDQSxTQUFTLGtCQUFULFFBQW1DLGVBQW5DO0FBQ0EsU0FBUyxvQkFBVCxRQUFxQyxzQkFBckM7QUFDQSxTQUFTLGVBQVQsUUFBZ0MsbUJBQWhDO0FBQ0EsU0FBUyxxQkFBVCxRQUFzQyxtQkFBdEM7QUFDQSxTQUFTLFVBQVQsUUFBMkIsYUFBM0I7QUFFQSxPQUFPLE1BQU0sZUFBZSxHQUFHLFFBQVEsQ0FBQyxRQUFELENBQVIsQ0FDNUIsRUFENEIsQ0FDekIsV0FEeUIsRUFDWixRQUFRLENBQUMsZUFBZSxDQUFDLFdBQUQsQ0FBaEIsQ0FESSxFQUU1QixFQUY0QixDQUV6QixrQkFGeUIsRUFFTCxRQUFRLENBQUMsZUFBZSxDQUFDLGtCQUFELENBQWhCLENBRkgsRUFHNUIsRUFINEIsQ0FHekIsa0JBSHlCLEVBR0wsUUFBUSxDQUFDLG9CQUFELENBSEgsRUFJNUIsRUFKNEIsQ0FJekIsS0FKeUIsRUFJbEIsUUFBUSxDQUFDLFVBQUQsQ0FKVSxFQUs1QixFQUw0QixDQUt6QixJQUx5QixFQUtuQixRQUFRLENBQUMscUJBQXFCLENBQUMsSUFBRCxDQUF0QixDQUxXLEVBTTVCLEVBTjRCLENBTXpCLFFBTnlCLEVBTWYsUUFBUSxDQUFDLHFCQUFxQixDQUFD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QVcsQ0FBQyxJQUFaLENBQWlCLElBQWpCLEVBQXVCLEtBQXZCLENBQWpCO0FBRUEsV0FBTyxNQUFNLENBQUMsR0FBUCxDQUFXLGdCQUFYLEVBQTZCLFVBQTdCLEVBQXlDLEtBQXpDLENBQStDLENBQUMsQ0FBQyxVQUFELEVBQWEsSUFBYixDQUFELEtBQXVCO0FBQzNFLFVBQUksSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLGNBQVIsQ0FBdUI7QUFBRSxRQUFBLE1BQU0sRUFBRSxVQUFWO0FBQXNCLFFBQUEsSUFBdEI7QUFBNEIsUUFBQSxHQUFHLEVBQUUsSUFBSSxDQUFDO0FBQXRDLE9BQXZCLENBQVg7QUFFQSxhQUFPLElBQUksR0FBRyxDQUFDLGNBQVIsQ0FBdUI7QUFDNUIsUUFBQSxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBRGtCO0FBRTVCLFFBQUE7QUFGNEIsT0FBdkIsQ0FBUDtBQUlELEtBUE0sQ0FBUDtBQVFEOztBQWxCVyxDQS9HZSxDQUF4QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEN1cnJpZWRUeXBlIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBBU1R2MiwgZ2VuZXJhdGVTeW50YXhFcnJvciwgU291cmNlU2xpY2UsIFNvdXJjZVNwYW4gfSBmcm9tICdAZ2xpbW1lci9zeW50YXgnO1xuXG5pbXBvcnQgeyBFcnIsIE9rLCBSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvcmVzdWx0JztcbmltcG9ydCAqIGFzIG1pciBmcm9tICcuLi8uLi8yLWVuY29kaW5nL21pcic7XG5pbXBvcnQgeyBOb3JtYWxpemF0aW9uU3RhdGUgfSBmcm9tICcuLi9jb250ZXh0JztcbmltcG9ydCB7IFZJU0lUX0VYUFJTIH0gZnJvbSAnLi4vdmlzaXRvcnMvZXhwcmVzc2lvbnMnO1xuaW1wb3J0IHsga2V5d29yZHMgfSBmcm9tICcuL2ltcGwnO1xuaW1wb3J0IHsgdG9BcHBlbmQgfSBmcm9tICcuL3V0aWxzL2NhbGwtdG8tYXBwZW5kJztcbmltcG9ydCB7IGFzc2VydEN1cnJ5S2V5d29yZCB9IGZyb20gJy4vdXRpbHMvY3VycnknO1xuaW1wb3J0IHsgZ2V0RHluYW1pY1ZhcktleXdvcmQgfSBmcm9tICcuL3V0aWxzL2R5bmFtaWMtdmFycyc7XG5pbXBvcnQgeyBoYXNCbG9ja0tleXdvcmQgfSBmcm9tICcuL3V0aWxzL2hhcy1ibG9jayc7XG5pbXBvcnQgeyBpZlVubGVzc0lubGluZUtleXdvcmQgfSBmcm9tICcuL3V0aWxzL2lmLXVubGVzcyc7XG5pbXBvcnQgeyBsb2dLZXl3b3JkIH0gZnJvbSAnLi91dGlscy9sb2cnO1xuXG5leHBvcnQgY29uc3QgQVBQRU5EX0tFWVdPUkRTID0ga2V5d29yZHMoJ0FwcGVuZCcpXG4gIC5rdygnaGFzLWJsb2NrJywgdG9BcHBlbmQoaGFzQmxvY2tLZXl3b3JkKCdoYXMtYmxvY2snKSkpXG4gIC5rdygnaGFzLWJsb2NrLXBhcmFtcycsIHRvQXBwZW5kKGhhc0Jsb2NrS2V5d29yZCgnaGFzLWJsb2NrLXBhcmFtcycpKSlcbiAgLmt3KCctZ2V0LWR5bmFtaWMtdmFyJywgdG9BcHBlbmQoZ2V0RHluYW1pY1ZhcktleXdvcmQpKVxuICAua3coJ2xvZycsIHRvQXBwZW5kKGxvZ0tleXdvcmQpKVxuICAua3coJ2lmJywgdG9BcHBlbmQoaWZVbmxlc3NJbmxpbmVLZXl3b3JkKCdpZicpKSlcbiAgLmt3KCd1bmxlc3MnLCB0b0FwcGVuZChpZlVubGVzc0lubGluZUtleXdvcmQoJ3VubGVzcycpKSlcbiAgLmt3KCd5aWVsZCcsIHtcbiAgICBhc3NlcnQoXG4gICAgICBub2RlOiBBU1R2Mi5BcHBlbmRDb250ZW50XG4gICAgKTogUmVzdWx0PHtcbiAgICAgIHRhcmdldDogU291cmNlU2xpY2U7XG4gICAgICBwb3NpdGlvbmFsOiBBU1R2Mi5Qb3NpdGlvbmFsQXJndW1lbnRzO1xuICAgIH0+IHtcbiAgICAgIGxldCB7IGFyZ3MgfSA9IG5vZGU7XG5cbiAgICAgIGlmIChhcmdzLm5hbWVkLmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gT2soe1xuICAgICAgICAgIHRhcmdldDogU291cmNlU3Bhbi5zeW50aGV0aWMoJ2RlZmF1bHQnKS50b1NsaWNlKCksXG4gICAgICAgICAgcG9zaXRpb25hbDogYXJncy5wb3NpdGlvbmFsLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSBhcmdzLm5hbWVkLmdldCgndG8nKTtcblxuICAgICAgICBpZiAoYXJncy5uYW1lZC5zaXplID4gMSB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gRXJyKFxuICAgICAgICAgICAgZ2VuZXJhdGVTeW50YXhFcnJvcihgeWllbGQgb25seSB0YWtlcyBhIHNpbmdsZSBuYW1lZCBhcmd1bWVudDogJ3RvJ2AsIGFyZ3MubmFtZWQubG9jKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQVNUdjIuaXNMaXRlcmFsKHRhcmdldCwgJ3N0cmluZycpKSB7XG4gICAgICAgICAgcmV0dXJuIE9rKHsgdGFyZ2V0OiB0YXJnZXQudG9TbGljZSgpLCBwb3NpdGlvbmFsOiBhcmdzLnBvc2l0aW9uYWwgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIEVycihcbiAgICAgICAgICAgIGdlbmVyYXRlU3ludGF4RXJyb3IoYHlvdSBjYW4gb25seSB5aWVsZCB0byBhIGxpdGVyYWwgc3RyaW5nIHZhbHVlYCwgdGFyZ2V0LmxvYylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZShcbiAgICAgIHsgbm9kZSwgc3RhdGUgfTogeyBub2RlOiBBU1R2Mi5BcHBlbmRDb250ZW50OyBzdGF0ZTogTm9ybWFsaXphdGlvblN0YXRlIH0sXG4gICAgICB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgcG9zaXRpb25hbCxcbiAgICAgIH06IHtcbiAgICAgICAgdGFyZ2V0OiBTb3VyY2VTbGljZTtcbiAgICAgICAgcG9zaXRpb25hbDogQVNUdjIuUG9zaXRpb25hbEFyZ3VtZW50cztcbiAgICAgIH1cbiAgICApOiBSZXN1bHQ8bWlyLlN0YXRlbWVudD4ge1xuICAgICAgcmV0dXJuIFZJU0lUX0VYUFJTLlBvc2l0aW9uYWwocG9zaXRpb25hbCwgc3RhdGUpLm1hcE9rKFxuICAgICAgICAocG9zaXRpb25hbCkgPT5cbiAgICAgICAgICBuZXcgbWlyLllpZWxkKHtcbiAgICAgICAgICAgIGxvYzogbm9kZS5sb2MsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICB0bzogc3RhdGUuc2NvcGUuYWxsb2NhdGVCbG9jayh0YXJnZXQuY2hhcnMpLFxuICAgICAgICAgICAgcG9zaXRpb25hbCxcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9LFxuICB9KVxuICAua3coJ2RlYnVnZ2VyJywge1xuICAgIGFzc2VydChub2RlOiBBU1R2Mi5BcHBlbmRDb250ZW50KTogUmVzdWx0PHZvaWQ+IHtcbiAgICAgIGxldCB7IGFyZ3MgfSA9IG5vZGU7XG4gICAgICBsZXQgeyBwb3NpdGlvbmFsIH0gPSBhcmdzO1xuXG4gICAgICBpZiAoYXJncy5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIE9rKHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocG9zaXRpb25hbC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICByZXR1cm4gRXJyKGdlbmVyYXRlU3ludGF4RXJyb3IoYGRlYnVnZ2VyIGRvZXMgbm90IHRha2UgYW55IG5hbWVkIGFyZ3VtZW50c2AsIG5vZGUubG9jKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIEVycihcbiAgICAgICAgICAgIGdlbmVyYXRlU3ludGF4RXJyb3IoYGRlYnVnZ2VyIGRvZXMgbm90IHRha2UgYW55IHBvc2l0aW9uYWwgYXJndW1lbnRzYCwgbm9kZS5sb2MpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmFuc2xhdGUoe1xuICAgICAgbm9kZSxcbiAgICAgIHN0YXRlOiB7IHNjb3BlIH0sXG4gICAgfToge1xuICAgICAgbm9kZTogQVNUdjIuQXBwZW5kQ29udGVudDtcbiAgICAgIHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGU7XG4gICAgfSk6IFJlc3VsdDxtaXIuU3RhdGVtZW50PiB7XG4gICAgICBzY29wZS5zZXRIYXNFdmFsKCk7XG4gICAgICByZXR1cm4gT2sobmV3IG1pci5EZWJ1Z2dlcih7IGxvYzogbm9kZS5sb2MsIHNjb3BlIH0pKTtcbiAgICB9LFxuICB9KVxuICAua3coJ2NvbXBvbmVudCcsIHtcbiAgICBhc3NlcnQ6IGFzc2VydEN1cnJ5S2V5d29yZChDdXJyaWVkVHlwZS5Db21wb25lbnQpLFxuXG4gICAgdHJhbnNsYXRlKFxuICAgICAgeyBub2RlLCBzdGF0ZSB9OiB7IG5vZGU6IEFTVHYyLkFwcGVuZENvbnRlbnQ7IHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGUgfSxcbiAgICAgIHsgZGVmaW5pdGlvbiwgYXJncyB9OiB7IGRlZmluaXRpb246IEFTVHYyLkV4cHJlc3Npb25Ob2RlOyBhcmdzOiBBU1R2Mi5BcmdzIH1cbiAgICApOiBSZXN1bHQ8bWlyLkludm9rZUNvbXBvbmVudD4ge1xuICAgICAgbGV0IGRlZmluaXRpb25SZXN1bHQgPSBWSVNJVF9FWFBSUy52aXNpdChkZWZpbml0aW9uLCBzdGF0ZSk7XG4gICAgICBsZXQgYXJnc1Jlc3VsdCA9IFZJU0lUX0VYUFJTLkFyZ3MoYXJncywgc3RhdGUpO1xuXG4gICAgICByZXR1cm4gUmVzdWx0LmFsbChkZWZpbml0aW9uUmVzdWx0LCBhcmdzUmVzdWx0KS5tYXBPayhcbiAgICAgICAgKFtkZWZpbml0aW9uLCBhcmdzXSkgPT5cbiAgICAgICAgICBuZXcgbWlyLkludm9rZUNvbXBvbmVudCh7XG4gICAgICAgICAgICBsb2M6IG5vZGUubG9jLFxuICAgICAgICAgICAgZGVmaW5pdGlvbixcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICBibG9ja3M6IG51bGwsXG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSxcbiAgfSlcbiAgLmt3KCdoZWxwZXInLCB7XG4gICAgYXNzZXJ0OiBhc3NlcnRDdXJyeUtleXdvcmQoQ3VycmllZFR5cGUuSGVscGVyKSxcblxuICAgIHRyYW5zbGF0ZShcbiAgICAgIHsgbm9kZSwgc3RhdGUgfTogeyBub2RlOiBBU1R2Mi5BcHBlbmRDb250ZW50OyBzdGF0ZTogTm9ybWFsaXphdGlvblN0YXRlIH0sXG4gICAgICB7IGRlZmluaXRpb24sIGFyZ3MgfTogeyBkZWZpbml0aW9uOiBBU1R2Mi5FeHByZXNzaW9uTm9kZTsgYXJnczogQVNUdjIuQXJncyB9XG4gICAgKTogUmVzdWx0PG1pci5BcHBlbmRUZXh0Tm9kZT4ge1xuICAgICAgbGV0IGRlZmluaXRpb25SZXN1bHQgPSBWSVNJVF9FWFBSUy52aXNpdChkZWZpbml0aW9uLCBzdGF0ZSk7XG4gICAgICBsZXQgYXJnc1Jlc3VsdCA9IFZJU0lUX0VYUFJTLkFyZ3MoYXJncywgc3RhdGUpO1xuXG4gICAgICByZXR1cm4gUmVzdWx0LmFsbChkZWZpbml0aW9uUmVzdWx0LCBhcmdzUmVzdWx0KS5tYXBPaygoW2RlZmluaXRpb24sIGFyZ3NdKSA9PiB7XG4gICAgICAgIGxldCB0ZXh0ID0gbmV3IG1pci5DYWxsRXhwcmVzc2lvbih7IGNhbGxlZTogZGVmaW5pdGlvbiwgYXJncywgbG9jOiBub2RlLmxvYyB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IG1pci5BcHBlbmRUZXh0Tm9kZSh7XG4gICAgICAgICAgbG9jOiBub2RlLmxvYyxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIH0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==