import { ASTv2, maybeLoc, SourceSpan } from '@glimmer/syntax';
import { OptionalList } from '../../../../shared/list';
import { Ok, Result, ResultArray } from '../../../../shared/result';
import { getAttrNamespace } from '../../../../utils';
import * as mir from '../../../2-encoding/mir';
import { MODIFIER_KEYWORDS } from '../../keywords';
import { assertIsValidModifier, isHelperInvocation } from '../../utils/is-node';
import { convertPathToCallIfKeyword, VISIT_EXPRS } from '../expressions';
export class ClassifiedElement {
  constructor(element, delegate, state) {
    this.element = element;
    this.state = state;
    this.delegate = delegate;
  }

  toStatement() {
    return this.prepare().andThen(prepared => this.delegate.toStatement(this, prepared));
  }

  attr(attr) {
    let name = attr.name;
    let rawValue = attr.value;
    let namespace = getAttrNamespace(name.chars) || undefined;

    if (ASTv2.isLiteral(rawValue, 'string')) {
      return Ok(new mir.StaticAttr({
        loc: attr.loc,
        name,
        value: rawValue.toSlice(),
        namespace,
        kind: {
          component: this.delegate.dynamicFeatures
        }
      }));
    }

    return VISIT_EXPRS.visit(convertPathToCallIfKeyword(rawValue), this.state).mapOk(value => {
      let isTrusting = attr.trusting;
      return new mir.DynamicAttr({
        loc: attr.loc,
        name,
        value: value,
        namespace,
        kind: {
          trusting: isTrusting,
          component: this.delegate.dynamicFeatures
        }
      });
    });
  }

  modifier(modifier) {
    if (isHelperInvocation(modifier)) {
      assertIsValidModifier(modifier);
    }

    let translated = MODIFIER_KEYWORDS.translate(modifier, this.state);

    if (translated !== null) {
      return translated;
    }

    let head = VISIT_EXPRS.visit(modifier.callee, this.state);
    let args = VISIT_EXPRS.Args(modifier.args, this.state);
    return Result.all(head, args).mapOk(([head, args]) => new mir.Modifier({
      loc: modifier.loc,
      callee: head,
      args
    }));
  }

  attrs() {
    let attrs = new ResultArray();
    let args = new ResultArray(); // Unlike most attributes, the `type` attribute can change how
    // subsequent attributes are interpreted by the browser. To address
    // this, in simple cases, we special case the `type` attribute to be set
    // last. For elements with splattributes, where attribute order affects
    // precedence, this re-ordering happens at runtime instead.
    // See https://github.com/glimmerjs/glimmer-vm/pull/726

    let typeAttr = null;
    let simple = this.element.attrs.filter(attr => attr.type === 'SplatAttr').length === 0;

    for (let attr of this.element.attrs) {
      if (attr.type === 'SplatAttr') {
        attrs.add(Ok(new mir.SplatAttr({
          loc: attr.loc,
          symbol: this.state.scope.allocateBlock('attrs')
        })));
      } else if (attr.name.chars === 'type' && simple) {
        typeAttr = attr;
      } else {
        attrs.add(this.attr(attr));
      }
    }

    for (let arg of this.element.componentArgs) {
      args.add(this.delegate.arg(arg, this));
    }

    if (typeAttr) {
      attrs.add(this.attr(typeAttr));
    }

    return Result.all(args.toArray(), attrs.toArray()).mapOk(([args, attrs]) => ({
      attrs,
      args: new mir.NamedArguments({
        loc: maybeLoc(args, SourceSpan.NON_EXISTENT),
        entries: OptionalList(args)
      })
    }));
  }

  prepare() {
    let attrs = this.attrs();
    let modifiers = new ResultArray(this.element.modifiers.map(m => this.modifier(m))).toArray();
    return Result.all(attrs, modifiers).mapOk(([result, modifiers]) => {
      let {
        attrs,
        args
      } = result;
      let elementParams = [...attrs, ...modifiers];
      let params = new mir.ElementParameters({
        loc: maybeLoc(elementParams, SourceSpan.NON_EXISTENT),
        body: OptionalList(elementParams)
      });
      return {
        args,
        params
      };
    });
  }

}
export function hasDynamicFeatures({
  attrs,
  modifiers
}) {
  // ElementModifier needs the special ComponentOperations
  if (modifiers.length > 0) {
    return true;
  } // Splattributes need the special ComponentOperations to merge into


  return !!attrs.filter(attr => attr.type === 'SplatAttr')[0];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL3Zpc2l0b3JzL2VsZW1lbnQvY2xhc3NpZmllZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLEtBQVQsRUFBZ0IsUUFBaEIsRUFBMEIsVUFBMUIsUUFBNEMsaUJBQTVDO0FBRUEsU0FBUyxZQUFULFFBQTZCLHlCQUE3QjtBQUNBLFNBQVMsRUFBVCxFQUFhLE1BQWIsRUFBcUIsV0FBckIsUUFBd0MsMkJBQXhDO0FBQ0EsU0FBUyxnQkFBVCxRQUFpQyxtQkFBakM7QUFDQSxPQUFPLEtBQUssR0FBWixNQUFxQix5QkFBckI7QUFFQSxTQUFTLGlCQUFULFFBQWtDLGdCQUFsQztBQUNBLFNBQVMscUJBQVQsRUFBZ0Msa0JBQWhDLFFBQTBELHFCQUExRDtBQUNBLFNBQVMsMEJBQVQsRUFBcUMsV0FBckMsUUFBd0QsZ0JBQXhEO0FBZ0JBLE9BQU0sTUFBTyxpQkFBUCxDQUF3QjtBQUc1QixFQUFBLFdBQUEsQ0FDVyxPQURYLEVBRUUsUUFGRixFQUdXLEtBSFgsRUFHb0M7QUFGekIsU0FBQSxPQUFBLEdBQUEsT0FBQTtBQUVBLFNBQUEsS0FBQSxHQUFBLEtBQUE7QUFFVCxTQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDRDs7QUFFRCxFQUFBLFdBQVcsR0FBQTtBQUNULFdBQU8sS0FBSyxPQUFMLEdBQWUsT0FBZixDQUF3QixRQUFELElBQWMsS0FBSyxRQUFMLENBQWMsV0FBZCxDQUEwQixJQUExQixFQUFnQyxRQUFoQyxDQUFyQyxDQUFQO0FBQ0Q7O0FBRU8sRUFBQSxJQUFJLENBQUMsSUFBRCxFQUFxQjtBQUMvQixRQUFJLElBQUksR0FBRyxJQUFJLENBQUMsSUFBaEI7QUFDQSxRQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBcEI7QUFDQSxRQUFJLFNBQVMsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMs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ZXIvc3ludGF4JztcblxuaW1wb3J0IHsgT3B0aW9uYWxMaXN0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpc3QnO1xuaW1wb3J0IHsgT2ssIFJlc3VsdCwgUmVzdWx0QXJyYXkgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvcmVzdWx0JztcbmltcG9ydCB7IGdldEF0dHJOYW1lc3BhY2UgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyBtaXIgZnJvbSAnLi4vLi4vLi4vMi1lbmNvZGluZy9taXInO1xuaW1wb3J0IHsgTm9ybWFsaXphdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vY29udGV4dCc7XG5pbXBvcnQgeyBNT0RJRklFUl9LRVlXT1JEUyB9IGZyb20gJy4uLy4uL2tleXdvcmRzJztcbmltcG9ydCB7IGFzc2VydElzVmFsaWRNb2RpZmllciwgaXNIZWxwZXJJbnZvY2F0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMvaXMtbm9kZSc7XG5pbXBvcnQgeyBjb252ZXJ0UGF0aFRvQ2FsbElmS2V5d29yZCwgVklTSVRfRVhQUlMgfSBmcm9tICcuLi9leHByZXNzaW9ucyc7XG5cbmV4cG9ydCB0eXBlIFZhbGlkQXR0ciA9IG1pci5TdGF0aWNBdHRyIHwgbWlyLkR5bmFtaWNBdHRyIHwgbWlyLlNwbGF0QXR0cjtcblxudHlwZSBQcm9jZXNzZWRBdHRyaWJ1dGVzID0ge1xuICBhdHRyczogVmFsaWRBdHRyW107XG4gIGFyZ3M6IG1pci5OYW1lZEFyZ3VtZW50cztcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xhc3NpZmllZCB7XG4gIHJlYWRvbmx5IGR5bmFtaWNGZWF0dXJlczogYm9vbGVhbjtcblxuICBhcmcoYXR0cjogQVNUdjIuQXR0ck5vZGUsIGNsYXNzaWZpZWQ6IENsYXNzaWZpZWRFbGVtZW50KTogUmVzdWx0PG1pci5OYW1lZEFyZ3VtZW50PjtcbiAgdG9TdGF0ZW1lbnQoY2xhc3NpZmllZDogQ2xhc3NpZmllZEVsZW1lbnQsIHByZXBhcmVkOiBQcmVwYXJlZEFyZ3MpOiBSZXN1bHQ8bWlyLlN0YXRlbWVudD47XG59XG5cbmV4cG9ydCBjbGFzcyBDbGFzc2lmaWVkRWxlbWVudCB7XG4gIHJlYWRvbmx5IGRlbGVnYXRlOiBDbGFzc2lmaWVkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGVsZW1lbnQ6IEFTVHYyLkVsZW1lbnROb2RlLFxuICAgIGRlbGVnYXRlOiBDbGFzc2lmaWVkLFxuICAgIHJlYWRvbmx5IHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGVcbiAgKSB7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICB9XG5cbiAgdG9TdGF0ZW1lbnQoKTogUmVzdWx0PG1pci5TdGF0ZW1lbnQ+IHtcbiAgICByZXR1cm4gdGhpcy5wcmVwYXJlKCkuYW5kVGhlbigocHJlcGFyZWQpID0+IHRoaXMuZGVsZWdhdGUudG9TdGF0ZW1lbnQodGhpcywgcHJlcGFyZWQpKTtcbiAgfVxuXG4gIHByaXZhdGUgYXR0cihhdHRyOiBBU1R2Mi5IdG1sQXR0cik6IFJlc3VsdDxWYWxpZEF0dHI+IHtcbiAgICBsZXQgbmFtZSA9IGF0dHIubmFtZTtcbiAgICBsZXQgcmF3VmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgIGxldCBuYW1lc3BhY2UgPSBnZXRBdHRyTmFtZXNwYWNlKG5hbWUuY2hhcnMpIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmIChBU1R2Mi5pc0xpdGVyYWwocmF3VmFsdWUsICdzdHJpbmcnKSkge1xuICAgICAgcmV0dXJuIE9rKFxuICAgICAgICBuZXcgbWlyLlN0YXRpY0F0dHIoe1xuICAgICAgICAgIGxvYzogYXR0ci5sb2MsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB2YWx1ZTogcmF3VmFsdWUudG9TbGljZSgpLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBraW5kOiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMuZGVsZWdhdGUuZHluYW1pY0ZlYXR1cmVzLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBWSVNJVF9FWFBSUy52aXNpdChjb252ZXJ0UGF0aFRvQ2FsbElmS2V5d29yZChyYXdWYWx1ZSksIHRoaXMuc3RhdGUpLm1hcE9rKCh2YWx1ZSkgPT4ge1xuICAgICAgbGV0IGlzVHJ1c3RpbmcgPSBhdHRyLnRydXN0aW5nO1xuXG4gICAgICByZXR1cm4gbmV3IG1pci5EeW5hbWljQXR0cih7XG4gICAgICAgIGxvYzogYXR0ci5sb2MsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBraW5kOiB7XG4gICAgICAgICAgdHJ1c3Rpbmc6IGlzVHJ1c3RpbmcsXG4gICAgICAgICAgY29tcG9uZW50OiB0aGlzLmRlbGVnYXRlLmR5bmFtaWNGZWF0dXJlcyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBtb2RpZmllcihtb2RpZmllcjogQVNUdjIuRWxlbWVudE1vZGlmaWVyKTogUmVzdWx0PG1pci5Nb2RpZmllcj4ge1xuICAgIGlmIChpc0hlbHBlckludm9jYXRpb24obW9kaWZpZXIpKSB7XG4gICAgICBhc3NlcnRJc1ZhbGlkTW9kaWZpZXIobW9kaWZpZXIpO1xuICAgIH1cblxuICAgIGxldCB0cmFuc2xhdGVkID0gTU9ESUZJRVJfS0VZV09SRFMudHJhbnNsYXRlKG1vZGlmaWVyLCB0aGlzLnN0YXRlKTtcblxuICAgIGlmICh0cmFuc2xhdGVkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJhbnNsYXRlZDtcbiAgICB9XG5cbiAgICBsZXQgaGVhZCA9IFZJU0lUX0VYUFJTLnZpc2l0KG1vZGlmaWVyLmNhbGxlZSwgdGhpcy5zdGF0ZSk7XG4gICAgbGV0IGFyZ3MgPSBWSVNJVF9FWFBSUy5BcmdzKG1vZGlmaWVyLmFyZ3MsIHRoaXMuc3RhdGUpO1xuXG4gICAgcmV0dXJuIFJlc3VsdC5hbGwoaGVhZCwgYXJncykubWFwT2soXG4gICAgICAoW2hlYWQsIGFyZ3NdKSA9PlxuICAgICAgICBuZXcgbWlyLk1vZGlmaWVyKHtcbiAgICAgICAgICBsb2M6IG1vZGlmaWVyLmxvYyxcbiAgICAgICAgICBjYWxsZWU6IGhlYWQsXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBhdHRycygpOiBSZXN1bHQ8UHJvY2Vzc2VkQXR0cmlidXRlcz4ge1xuICAgIGxldCBhdHRycyA9IG5ldyBSZXN1bHRBcnJheTxWYWxpZEF0dHI+KCk7XG4gICAgbGV0IGFyZ3MgPSBuZXcgUmVzdWx0QXJyYXk8bWlyLk5hbWVkQXJndW1lbnQ+KCk7XG5cbiAgICAvLyBVbmxpa2UgbW9zdCBhdHRyaWJ1dGVzLCB0aGUgYHR5cGVgIGF0dHJpYnV0ZSBjYW4gY2hhbmdlIGhvd1xuICAgIC8vIHN1YnNlcXVlbnQgYXR0cmlidXRlcyBhcmUgaW50ZXJwcmV0ZWQgYnkgdGhlIGJyb3dzZXIuIFRvIGFkZHJlc3NcbiAgICAvLyB0aGlzLCBpbiBzaW1wbGUgY2FzZXMsIHdlIHNwZWNpYWwgY2FzZSB0aGUgYHR5cGVgIGF0dHJpYnV0ZSB0byBiZSBzZXRcbiAgICAvLyBsYXN0LiBGb3IgZWxlbWVudHMgd2l0aCBzcGxhdHRyaWJ1dGVzLCB3aGVyZSBhdHRyaWJ1dGUgb3JkZXIgYWZmZWN0c1xuICAgIC8vIHByZWNlZGVuY2UsIHRoaXMgcmUtb3JkZXJpbmcgaGFwcGVucyBhdCBydW50aW1lIGluc3RlYWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGltbWVyanMvZ2xpbW1lci12bS9wdWxsLzcyNlxuICAgIGxldCB0eXBlQXR0cjogQVNUdjIuQXR0ck5vZGUgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgc2ltcGxlID0gdGhpcy5lbGVtZW50LmF0dHJzLmZpbHRlcigoYXR0cikgPT4gYXR0ci50eXBlID09PSAnU3BsYXRBdHRyJykubGVuZ3RoID09PSAwO1xuXG4gICAgZm9yIChsZXQgYXR0ciBvZiB0aGlzLmVsZW1lbnQuYXR0cnMpIHtcbiAgICAgIGlmIChhdHRyLnR5cGUgPT09ICdTcGxhdEF0dHInKSB7XG4gICAgICAgIGF0dHJzLmFkZChcbiAgICAgICAgICBPayhuZXcgbWlyLlNwbGF0QXR0cih7IGxvYzogYXR0ci5sb2MsIHN5bWJvbDogdGhpcy5zdGF0ZS5zY29wZS5hbGxvY2F0ZUJsb2NrKCdhdHRycycpIH0pKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChhdHRyLm5hbWUuY2hhcnMgPT09ICd0eXBlJyAmJiBzaW1wbGUpIHtcbiAgICAgICAgdHlwZUF0dHIgPSBhdHRyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMuYWRkKHRoaXMuYXR0cihhdHRyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgYXJnIG9mIHRoaXMuZWxlbWVudC5jb21wb25lbnRBcmdzKSB7XG4gICAgICBhcmdzLmFkZCh0aGlzLmRlbGVnYXRlLmFyZyhhcmcsIHRoaXMpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZUF0dHIpIHtcbiAgICAgIGF0dHJzLmFkZCh0aGlzLmF0dHIodHlwZUF0dHIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVzdWx0LmFsbChhcmdzLnRvQXJyYXkoKSwgYXR0cnMudG9BcnJheSgpKS5tYXBPaygoW2FyZ3MsIGF0dHJzXSkgPT4gKHtcbiAgICAgIGF0dHJzLFxuICAgICAgYXJnczogbmV3IG1pci5OYW1lZEFyZ3VtZW50cyh7XG4gICAgICAgIGxvYzogbWF5YmVMb2MoYXJncywgU291cmNlU3Bhbi5OT05fRVhJU1RFTlQpLFxuICAgICAgICBlbnRyaWVzOiBPcHRpb25hbExpc3QoYXJncyksXG4gICAgICB9KSxcbiAgICB9KSk7XG4gIH1cblxuICBwcml2YXRlIHByZXBhcmUoKTogUmVzdWx0PFByZXBhcmVkQXJncz4ge1xuICAgIGxldCBhdHRycyA9IHRoaXMuYXR0cnMoKTtcbiAgICBsZXQgbW9kaWZpZXJzID0gbmV3IFJlc3VsdEFycmF5KHRoaXMuZWxlbWVudC5tb2RpZmllcnMubWFwKChtKSA9PiB0aGlzLm1vZGlmaWVyKG0pKSkudG9BcnJheSgpO1xuXG4gICAgcmV0dXJuIFJlc3VsdC5hbGwoYXR0cnMsIG1vZGlmaWVycykubWFwT2soKFtyZXN1bHQsIG1vZGlmaWVyc10pID0+IHtcbiAgICAgIGxldCB7IGF0dHJzLCBhcmdzIH0gPSByZXN1bHQ7XG5cbiAgICAgIGxldCBlbGVtZW50UGFyYW1zID0gWy4uLmF0dHJzLCAuLi5tb2RpZmllcnNdO1xuXG4gICAgICBsZXQgcGFyYW1zID0gbmV3IG1pci5FbGVtZW50UGFyYW1ldGVycyh7XG4gICAgICAgIGxvYzogbWF5YmVMb2MoZWxlbWVudFBhcmFtcywgU291cmNlU3Bhbi5OT05fRVhJU1RFTlQpLFxuICAgICAgICBib2R5OiBPcHRpb25hbExpc3QoZWxlbWVudFBhcmFtcyksXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHsgYXJncywgcGFyYW1zIH07XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmVwYXJlZEFyZ3Mge1xuICBhcmdzOiBtaXIuTmFtZWRBcmd1bWVudHM7XG4gIHBhcmFtczogbWlyLkVsZW1lbnRQYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzRHluYW1pY0ZlYXR1cmVzKHtcbiAgYXR0cnMsXG4gIG1vZGlmaWVycyxcbn06IFBpY2s8QVNUdjIuRWxlbWVudE5vZGUsICdhdHRycycgfCAnbW9kaWZpZXJzJz4pOiBib29sZWFuIHtcbiAgLy8gRWxlbWVudE1vZGlmaWVyIG5lZWRzIHRoZSBzcGVjaWFsIENvbXBvbmVudE9wZXJhdGlvbnNcbiAgaWYgKG1vZGlmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBTcGxhdHRyaWJ1dGVzIG5lZWQgdGhlIHNwZWNpYWwgQ29tcG9uZW50T3BlcmF0aW9ucyB0byBtZXJnZSBpbnRvXG4gIHJldHVybiAhIWF0dHJzLmZpbHRlcigoYXR0cikgPT4gYXR0ci50eXBlID09PSAnU3BsYXRBdHRyJylbMF07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9