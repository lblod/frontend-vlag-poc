import { LOCAL_LOGGER } from '@glimmer/util';
import * as mir from '../2-encoding/mir';
import { NormalizationState } from './context';
import { VISIT_STMTS } from './visitors/statements';
/**
 * Normalize the AST from @glimmer/syntax into the HIR. The HIR has special
 * instructions for keywords like `{{yield}}`, `(has-block)` and
 * `{{#in-element}}`.
 *
 * Most importantly, it also classifies HTML element syntax into:
 *
 * 1. simple HTML element (with optional splattributes)
 * 2. component invocation
 *
 * Because the @glimmer/syntax AST gives us a string for an element's tag,
 * this pass also normalizes that string into an expression.
 *
 * ```
 * // normalized into a path expression whose head is `this` and tail is
 * // `["x"]`
 * <this.x />
 *
 * {{#let expr as |t|}}
 *   // `"t"` is normalized into a variable lookup.
 *   <t />
 *
 *   // normalized into a path expression whose head is the variable lookup
 *   // `t` and tail is `["input"]`.
 *   <t.input />
 * {{/let}}
 *
 * // normalized into a free variable lookup for `SomeComponent` (with the
 * // context `ComponentHead`).
 * <SomeComponent />
 *
 * // normalized into a path expression whose head is the free variable
 * // `notInScope` (with the context `Expression`), and whose tail is
 * // `["SomeComponent"]`. In resolver mode, this path will be rejected later,
 * // since it cannot serve as an input to the resolver.
 * <notInScope.SomeComponent />
 * ```
 */

export default function normalize(source, root, isStrict) {
  // create a new context for the normalization pass
  let state = new NormalizationState(root.table, isStrict);

  if (false
  /* LOCAL_SHOULD_LOG */
  ) {
    LOCAL_LOGGER.groupCollapsed(`pass0: visiting`);
    LOCAL_LOGGER.log('symbols', root.table);
    LOCAL_LOGGER.log('source', source);
    LOCAL_LOGGER.groupEnd();
  }

  let body = VISIT_STMTS.visitList(root.body, state);

  if (false
  /* LOCAL_SHOULD_LOG */
  ) {
    if (body.isOk) {
      LOCAL_LOGGER.log('-> pass0: out', body.value);
    } else {
      LOCAL_LOGGER.log('-> pass0: error', body.reason);
    }
  }

  return body.mapOk(body => new mir.Template({
    loc: root.loc,
    scope: root.table,
    body: body.toArray()
  }));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLFNBQVMsWUFBVCxRQUE2QixlQUE3QjtBQUdBLE9BQU8sS0FBSyxHQUFaLE1BQXFCLG1CQUFyQjtBQUNBLFNBQVMsa0JBQVQsUUFBbUMsV0FBbkM7QUFDQSxTQUFTLFdBQVQsUUFBNEIsdUJBQTVCO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDQSxlQUFjLFNBQVUsU0FBVixDQUNaLE1BRFksRUFFWixJQUZZLEVBR1osUUFIWSxFQUdLO0FBRWpCO0FBQ0EsTUFBSSxLQUFLLEdBQUcsSUFBSSxrQkFBSixDQUF1QixJQUFJLENBQUMsS0FBNUIsRUFBbUMsUUFBbkMsQ0FBWjs7QUFFQTtBQUFBO0FBQUEsSUFBc0I7QUFDcEIsSUFBQSxZQUFZLENBQUMsY0FBYixDQUE0QixpQkFBNUI7QUFDQSxJQUFBLFlBQVksQ0FBQyxHQUFiLENBQWlCLFNBQWpCLEVBQTRCLElBQUksQ0FBQyxLQUFqQztBQUNBLElBQUEsWUFBWSxDQUFDLEdBQWIsQ0FBaUIsUUFBakIsRUFBMkIsTUFBM0I7QUFDQSxJQUFBLFlBQVksQ0FBQyxRQUFiO0FBQ0Q7O0FBRUQsTUFBSSxJQUFJLEdBQUcsV0FBVyxDQUFDLFNBQVosQ0FBc0IsSUFBSSxDQUFDLElBQTNCLEVBQWlDLEtBQWpDLENBQVg7O0FBRUE7QUFBQTtBQUFBLElBQXNCO0FBQ3BCLFFBQUksSUFBSSxDQUFDLElBQVQsRUFBZTtBQUNiLE1BQUEsWUFBWSxDQUFDLEdBQWIsQ0FBaUIsZUFBakIsRUFBa0MsSUFBSSxDQUFDLEtBQXZDO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsTUFBQSxZQUFZLENBQUMsR0FBYixDQUFpQixpQkFBakIsRUFBb0MsSUFBSSxDQUFDLE1BQXpDO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLElBQUksQ0FBQyxLQUFMLENBQ0osSUFBRCxJQUFVLElBQUksR0FBRyxDQUFDLFFBQVIsQ0FBaUI7QUFBRSxJQUFBLEdBQUcsRUFBRSxJQUFJLENBQUMsR0FBWjtBQUFpQixJQUFBLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBN0I7QUFBb0MsSUFBQSxJQUFJLEVBQUUsSUFBSSxDQUFDLE9BQUw7QUFBMUMsR0FBakIsQ0FETCxDQUFQO0FBR0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMT0NBTF9TSE9VTERfTE9HIH0gZnJvbSAnQGdsaW1tZXIvbG9jYWwtZGVidWctZmxhZ3MnO1xuaW1wb3J0IHsgQVNUdjIsIFNvdXJjZSB9IGZyb20gJ0BnbGltbWVyL3N5bnRheCc7XG5pbXBvcnQgeyBMT0NBTF9MT0dHRVIgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcblxuaW1wb3J0IHsgUmVzdWx0IH0gZnJvbSAnLi4vLi4vc2hhcmVkL3Jlc3VsdCc7XG5pbXBvcnQgKiBhcyBtaXIgZnJvbSAnLi4vMi1lbmNvZGluZy9taXInO1xuaW1wb3J0IHsgTm9ybWFsaXphdGlvblN0YXRlIH0gZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCB7IFZJU0lUX1NUTVRTIH0gZnJvbSAnLi92aXNpdG9ycy9zdGF0ZW1lbnRzJztcblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIEFTVCBmcm9tIEBnbGltbWVyL3N5bnRheCBpbnRvIHRoZSBISVIuIFRoZSBISVIgaGFzIHNwZWNpYWxcbiAqIGluc3RydWN0aW9ucyBmb3Iga2V5d29yZHMgbGlrZSBge3t5aWVsZH19YCwgYChoYXMtYmxvY2spYCBhbmRcbiAqIGB7eyNpbi1lbGVtZW50fX1gLlxuICpcbiAqIE1vc3QgaW1wb3J0YW50bHksIGl0IGFsc28gY2xhc3NpZmllcyBIVE1MIGVsZW1lbnQgc3ludGF4IGludG86XG4gKlxuICogMS4gc2ltcGxlIEhUTUwgZWxlbWVudCAod2l0aCBvcHRpb25hbCBzcGxhdHRyaWJ1dGVzKVxuICogMi4gY29tcG9uZW50IGludm9jYXRpb25cbiAqXG4gKiBCZWNhdXNlIHRoZSBAZ2xpbW1lci9zeW50YXggQVNUIGdpdmVzIHVzIGEgc3RyaW5nIGZvciBhbiBlbGVtZW50J3MgdGFnLFxuICogdGhpcyBwYXNzIGFsc28gbm9ybWFsaXplcyB0aGF0IHN0cmluZyBpbnRvIGFuIGV4cHJlc3Npb24uXG4gKlxuICogYGBgXG4gKiAvLyBub3JtYWxpemVkIGludG8gYSBwYXRoIGV4cHJlc3Npb24gd2hvc2UgaGVhZCBpcyBgdGhpc2AgYW5kIHRhaWwgaXNcbiAqIC8vIGBbXCJ4XCJdYFxuICogPHRoaXMueCAvPlxuICpcbiAqIHt7I2xldCBleHByIGFzIHx0fH19XG4gKiAgIC8vIGBcInRcImAgaXMgbm9ybWFsaXplZCBpbnRvIGEgdmFyaWFibGUgbG9va3VwLlxuICogICA8dCAvPlxuICpcbiAqICAgLy8gbm9ybWFsaXplZCBpbnRvIGEgcGF0aCBleHByZXNzaW9uIHdob3NlIGhlYWQgaXMgdGhlIHZhcmlhYmxlIGxvb2t1cFxuICogICAvLyBgdGAgYW5kIHRhaWwgaXMgYFtcImlucHV0XCJdYC5cbiAqICAgPHQuaW5wdXQgLz5cbiAqIHt7L2xldH19XG4gKlxuICogLy8gbm9ybWFsaXplZCBpbnRvIGEgZnJlZSB2YXJpYWJsZSBsb29rdXAgZm9yIGBTb21lQ29tcG9uZW50YCAod2l0aCB0aGVcbiAqIC8vIGNvbnRleHQgYENvbXBvbmVudEhlYWRgKS5cbiAqIDxTb21lQ29tcG9uZW50IC8+XG4gKlxuICogLy8gbm9ybWFsaXplZCBpbnRvIGEgcGF0aCBleHByZXNzaW9uIHdob3NlIGhlYWQgaXMgdGhlIGZyZWUgdmFyaWFibGVcbiAqIC8vIGBub3RJblNjb3BlYCAod2l0aCB0aGUgY29udGV4dCBgRXhwcmVzc2lvbmApLCBhbmQgd2hvc2UgdGFpbCBpc1xuICogLy8gYFtcIlNvbWVDb21wb25lbnRcIl1gLiBJbiByZXNvbHZlciBtb2RlLCB0aGlzIHBhdGggd2lsbCBiZSByZWplY3RlZCBsYXRlcixcbiAqIC8vIHNpbmNlIGl0IGNhbm5vdCBzZXJ2ZSBhcyBhbiBpbnB1dCB0byB0aGUgcmVzb2x2ZXIuXG4gKiA8bm90SW5TY29wZS5Tb21lQ29tcG9uZW50IC8+XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplKFxuICBzb3VyY2U6IFNvdXJjZSxcbiAgcm9vdDogQVNUdjIuVGVtcGxhdGUsXG4gIGlzU3RyaWN0OiBib29sZWFuXG4pOiBSZXN1bHQ8bWlyLlRlbXBsYXRlPiB7XG4gIC8vIGNyZWF0ZSBhIG5ldyBjb250ZXh0IGZvciB0aGUgbm9ybWFsaXphdGlvbiBwYXNzXG4gIGxldCBzdGF0ZSA9IG5ldyBOb3JtYWxpemF0aW9uU3RhdGUocm9vdC50YWJsZSwgaXNTdHJpY3QpO1xuXG4gIGlmIChMT0NBTF9TSE9VTERfTE9HKSB7XG4gICAgTE9DQUxfTE9HR0VSLmdyb3VwQ29sbGFwc2VkKGBwYXNzMDogdmlzaXRpbmdgKTtcbiAgICBMT0NBTF9MT0dHRVIubG9nKCdzeW1ib2xzJywgcm9vdC50YWJsZSk7XG4gICAgTE9DQUxfTE9HR0VSLmxvZygnc291cmNlJywgc291cmNlKTtcbiAgICBMT0NBTF9MT0dHRVIuZ3JvdXBFbmQoKTtcbiAgfVxuXG4gIGxldCBib2R5ID0gVklTSVRfU1RNVFMudmlzaXRMaXN0KHJvb3QuYm9keSwgc3RhdGUpO1xuXG4gIGlmIChMT0NBTF9TSE9VTERfTE9HKSB7XG4gICAgaWYgKGJvZHkuaXNPaykge1xuICAgICAgTE9DQUxfTE9HR0VSLmxvZygnLT4gcGFzczA6IG91dCcsIGJvZHkudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBMT0NBTF9MT0dHRVIubG9nKCctPiBwYXNzMDogZXJyb3InLCBib2R5LnJlYXNvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJvZHkubWFwT2soXG4gICAgKGJvZHkpID0+IG5ldyBtaXIuVGVtcGxhdGUoeyBsb2M6IHJvb3QubG9jLCBzY29wZTogcm9vdC50YWJsZSwgYm9keTogYm9keS50b0FycmF5KCkgfSlcbiAgKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=