import { ASTv2, generateSyntaxError, SourceSlice } from '@glimmer/syntax';
import { Err, Ok } from '../../../../shared/result';
import * as mir from '../../../2-encoding/mir';

function assertHasBlockKeyword(type) {
  return node => {
    let call = node.type === 'AppendContent' ? node.value : node;
    let named = call.type === 'Call' ? call.args.named : null;
    let positionals = call.type === 'Call' ? call.args.positional : null;

    if (named && !named.isEmpty()) {
      return Err(generateSyntaxError(`(${type}) does not take any named arguments`, call.loc));
    }

    if (!positionals || positionals.isEmpty()) {
      return Ok(SourceSlice.synthetic('default'));
    } else if (positionals.exprs.length === 1) {
      let positional = positionals.exprs[0];

      if (ASTv2.isLiteral(positional, 'string')) {
        return Ok(positional.toSlice());
      } else {
        return Err(generateSyntaxError(`(${type}) can only receive a string literal as its first argument`, call.loc));
      }
    } else {
      return Err(generateSyntaxError(`(${type}) only takes a single positional argument`, call.loc));
    }
  };
}

function translateHasBlockKeyword(type) {
  return ({
    node,
    state: {
      scope
    }
  }, target) => {
    let block = type === 'has-block' ? new mir.HasBlock({
      loc: node.loc,
      target,
      symbol: scope.allocateBlock(target.chars)
    }) : new mir.HasBlockParams({
      loc: node.loc,
      target,
      symbol: scope.allocateBlock(target.chars)
    });
    return Ok(block);
  };
}

export function hasBlockKeyword(type) {
  return {
    assert: assertHasBlockKeyword(type),
    translate: translateHasBlockKeyword(type)
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL2tleXdvcmRzL3V0aWxzL2hhcy1ibG9jay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLEtBQVQsRUFBZ0IsbUJBQWhCLEVBQXFDLFdBQXJDLFFBQXdELGlCQUF4RDtBQUVBLFNBQVMsR0FBVCxFQUFjLEVBQWQsUUFBZ0MsMkJBQWhDO0FBQ0EsT0FBTyxLQUFLLEdBQVosTUFBcUIseUJBQXJCOztBQUlBLFNBQVMscUJBQVQsQ0FBK0IsSUFBL0IsRUFBMkM7QUFDekMsU0FBUSxJQUFELElBQWtEO0FBQ3ZELFFBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFMLEtBQWMsZUFBZCxHQUFnQyxJQUFJLENBQUMsS0FBckMsR0FBNkMsSUFBeEQ7QUFFQSxRQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBTCxLQUFjLE1BQWQsR0FBdUIsSUFBSSxDQUFDLElBQUwsQ0FBVSxLQUFqQyxHQUF5QyxJQUFyRDtBQUNBLFFBQUksV0FBVyxHQUFHLElBQUksQ0FBQyxJQUFMLEtBQWMsTUFBZCxHQUF1QixJQUFJLENBQUMsSUFBTCxDQUFVLFVBQWpDLEdBQThDLElBQWhFOztBQUVBLFFBQUksS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU4sRUFBZCxFQUErQjtBQUM3QixhQUFPLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLElBQUkscUNBQVQsRUFBZ0QsSUFBSSxDQUFDLEdBQXJELENBQXBCLENBQVY7QUFDRDs7QUFFRCxRQUFJLENBQUMsV0FBRCxJQUFnQixXQUFXLENBQUMsT0FBWixFQUFwQixFQUEyQztBQUN6QyxhQUFPLEVBQUUsQ0FBQyxXQUFXLENBQUMsU0FBWixDQUFzQixTQUF0QixDQUFELENBQVQ7QUFDRCxLQUZELE1BRU8sSUFBSSxXQUFXLENBQUMsS0FBWixDQUFrQixNQUFsQixLQUE2QixDQUFqQyxFQUFvQztBQUN6QyxVQUFJLFVBQVUsR0FBRyxXQUFXLENBQUMsS0FBWixDQUFrQixDQUFsQixDQUFqQjs7QUFDQSxVQUFJLEtBQUssQ0FBQyxTQUFOLENBQWdCLFVBQWhCLEVBQTRCLFFBQTVCLENBQUosRUFBMkM7QUFDekMsZUFBTyxFQUFFLENBQUMsVUFBVSxDQUFDLE9BQVgsRUFBRCxDQUFUO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsZUFBTyxHQUFHLENBQ1IsbUJBQW1CLENBQ2pCLElBQUksSUFBSSwyREFEUyxFQUVqQixJQUFJLENBQUMsR0FGWSxDQURYLENBQVY7QUFNRDtBQUNGLEtBWk0sTUFZQTtBQUNMLGFBQU8sR0FBRyxDQUNSLG1CQUFtQixDQUFDLElBQUksSUFBSSwyQ0FBVCxFQUFzRCxJQUFJLENBQUMsR0FBM0QsQ0FEWCxDQUFWO0FBR0Q7QUFDRixHQTdCRDtBQThCRDs7QUFFRCxTQUFTLHdCQUFULENBQWtDLElBQWxDLEVBQThDO0FBQzVDLFNBQU8sQ0FDTDtBQUFFLElBQUEsSUFBRjtBQUFRLElBQUEsS0FBSyxFQUFFO0FBQUUsTUFBQTtBQUFGO0FBQWYsR0FESyxFQUVMLE1BRkssS0FHd0M7QUFDN0MsUUFBSSxLQUFLLEdBQ1AsSUFBSSxLQUFLLFdBQVQsR0FDSSxJQUFJLEdBQUcsQ0FBQyxRQUFSLENBQWlCO0FBQUUsTUFBQSxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBQVo7QUFBaUIsTUFBQSxNQUFqQjtBQUF5QixNQUFBLE1BQU0sRUFBRSxLQUFLLENBQUMsYUFBTixDQUFvQixNQUFNLENBQUMsS0FBM0I7QUFBakMsS0FBakIsQ0FESixHQUVJLElBQUksR0FBRyxDQUFDLGNBQVIsQ0FBdUI7QUFDckIsTUFBQSxHQUFHLEVBQUUsSUFBSSxDQUFDLEdBRFc7QUFFckIsTUFBQSxNQUZxQjtBQUdyQixNQUFBLE1BQU0sRUFBRSxLQUFLLENBQUMsYUFBTixDQUFvQixNQUFNLENBQUMsS0FBM0I7QUFIYSxLQUF2QixDQUhOO0FBU0EsV0FBTyxFQUFFLENBQUMsS0FBRCxDQUFUO0FBQ0QsR0FkRDtBQWVEOztBQUVELE9BQU0sU0FBVSxlQUFWLENBQ0osSUFESSxFQUNRO0FBTVosU0FBTztBQUNMLElBQUEsTUFBTSxFQUFFLHFCQUFxQixDQUFDLElBQUQsQ0FEeEI7QUFFTCxJQUFBLFNBQVMsRUFBRSx3QkFBd0IsQ0FBQyxJQUFEO0FBRjlCLEdBQVA7QUFJRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFTVHYyLCBnZW5lcmF0ZVN5bnRheEVycm9yLCBTb3VyY2VTbGljZSB9IGZyb20gJ0BnbGltbWVyL3N5bnRheCc7XG5cbmltcG9ydCB7IEVyciwgT2ssIFJlc3VsdCB9IGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9yZXN1bHQnO1xuaW1wb3J0ICogYXMgbWlyIGZyb20gJy4uLy4uLy4uLzItZW5jb2RpbmcvbWlyJztcbmltcG9ydCB7IE5vcm1hbGl6YXRpb25TdGF0ZSB9IGZyb20gJy4uLy4uL2NvbnRleHQnO1xuaW1wb3J0IHsgR2VuZXJpY0tleXdvcmROb2RlLCBLZXl3b3JkRGVsZWdhdGUgfSBmcm9tICcuLi9pbXBsJztcblxuZnVuY3Rpb24gYXNzZXJ0SGFzQmxvY2tLZXl3b3JkKHR5cGU6IHN0cmluZykge1xuICByZXR1cm4gKG5vZGU6IEdlbmVyaWNLZXl3b3JkTm9kZSk6IFJlc3VsdDxTb3VyY2VTbGljZT4gPT4ge1xuICAgIGxldCBjYWxsID0gbm9kZS50eXBlID09PSAnQXBwZW5kQ29udGVudCcgPyBub2RlLnZhbHVlIDogbm9kZTtcblxuICAgIGxldCBuYW1lZCA9IGNhbGwudHlwZSA9PT0gJ0NhbGwnID8gY2FsbC5hcmdzLm5hbWVkIDogbnVsbDtcbiAgICBsZXQgcG9zaXRpb25hbHMgPSBjYWxsLnR5cGUgPT09ICdDYWxsJyA/IGNhbGwuYXJncy5wb3NpdGlvbmFsIDogbnVsbDtcblxuICAgIGlmIChuYW1lZCAmJiAhbmFtZWQuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gRXJyKGdlbmVyYXRlU3ludGF4RXJyb3IoYCgke3R5cGV9KSBkb2VzIG5vdCB0YWtlIGFueSBuYW1lZCBhcmd1bWVudHNgLCBjYWxsLmxvYykpO1xuICAgIH1cblxuICAgIGlmICghcG9zaXRpb25hbHMgfHwgcG9zaXRpb25hbHMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gT2soU291cmNlU2xpY2Uuc3ludGhldGljKCdkZWZhdWx0JykpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb25hbHMuZXhwcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICBsZXQgcG9zaXRpb25hbCA9IHBvc2l0aW9uYWxzLmV4cHJzWzBdO1xuICAgICAgaWYgKEFTVHYyLmlzTGl0ZXJhbChwb3NpdGlvbmFsLCAnc3RyaW5nJykpIHtcbiAgICAgICAgcmV0dXJuIE9rKHBvc2l0aW9uYWwudG9TbGljZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBFcnIoXG4gICAgICAgICAgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICAgIGAoJHt0eXBlfSkgY2FuIG9ubHkgcmVjZWl2ZSBhIHN0cmluZyBsaXRlcmFsIGFzIGl0cyBmaXJzdCBhcmd1bWVudGAsXG4gICAgICAgICAgICBjYWxsLmxvY1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEVycihcbiAgICAgICAgZ2VuZXJhdGVTeW50YXhFcnJvcihgKCR7dHlwZX0pIG9ubHkgdGFrZXMgYSBzaW5nbGUgcG9zaXRpb25hbCBhcmd1bWVudGAsIGNhbGwubG9jKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZUhhc0Jsb2NrS2V5d29yZCh0eXBlOiBzdHJpbmcpIHtcbiAgcmV0dXJuIChcbiAgICB7IG5vZGUsIHN0YXRlOiB7IHNjb3BlIH0gfTogeyBub2RlOiBBU1R2Mi5DYWxsRXhwcmVzc2lvbjsgc3RhdGU6IE5vcm1hbGl6YXRpb25TdGF0ZSB9LFxuICAgIHRhcmdldDogU291cmNlU2xpY2VcbiAgKTogUmVzdWx0PG1pci5IYXNCbG9jayB8IG1pci5IYXNCbG9ja1BhcmFtcz4gPT4ge1xuICAgIGxldCBibG9jayA9XG4gICAgICB0eXBlID09PSAnaGFzLWJsb2NrJ1xuICAgICAgICA/IG5ldyBtaXIuSGFzQmxvY2soeyBsb2M6IG5vZGUubG9jLCB0YXJnZXQsIHN5bWJvbDogc2NvcGUuYWxsb2NhdGVCbG9jayh0YXJnZXQuY2hhcnMpIH0pXG4gICAgICAgIDogbmV3IG1pci5IYXNCbG9ja1BhcmFtcyh7XG4gICAgICAgICAgICBsb2M6IG5vZGUubG9jLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgc3ltYm9sOiBzY29wZS5hbGxvY2F0ZUJsb2NrKHRhcmdldC5jaGFycyksXG4gICAgICAgICAgfSk7XG5cbiAgICByZXR1cm4gT2soYmxvY2spO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzQmxvY2tLZXl3b3JkKFxuICB0eXBlOiBzdHJpbmdcbik6IEtleXdvcmREZWxlZ2F0ZTxcbiAgQVNUdjIuQ2FsbEV4cHJlc3Npb24gfCBBU1R2Mi5BcHBlbmRDb250ZW50LFxuICBTb3VyY2VTbGljZSxcbiAgbWlyLkhhc0Jsb2NrIHwgbWlyLkhhc0Jsb2NrUGFyYW1zXG4+IHtcbiAgcmV0dXJuIHtcbiAgICBhc3NlcnQ6IGFzc2VydEhhc0Jsb2NrS2V5d29yZCh0eXBlKSxcbiAgICB0cmFuc2xhdGU6IHRyYW5zbGF0ZUhhc0Jsb2NrS2V5d29yZCh0eXBlKSxcbiAgfTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=