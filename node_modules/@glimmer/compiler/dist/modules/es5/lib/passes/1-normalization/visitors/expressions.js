import { ASTv2, KEYWORDS_TYPES } from '@glimmer/syntax';
import { isPresent } from '@glimmer/util';
import { Ok, Result, ResultArray } from '../../../shared/result';
import * as mir from '../../2-encoding/mir';
import { CALL_KEYWORDS } from '../keywords';
import { hasPath } from '../utils/is-node';
export var NormalizeExpressions = /*#__PURE__*/function () {
  function NormalizeExpressions() {}

  var _proto = NormalizeExpressions.prototype;

  _proto.visit = function visit(node, state) {
    switch (node.type) {
      case 'Literal':
        return Ok(this.Literal(node));

      case 'Interpolate':
        return this.Interpolate(node, state);

      case 'Path':
        return this.PathExpression(node);

      case 'Call':
        var translated = CALL_KEYWORDS.translate(node, state);

        if (translated !== null) {
          return translated;
        }

        return this.CallExpression(node, state);

      case 'DeprecatedCall':
        return this.DeprecaedCallExpression(node, state);
    }
  };

  _proto.visitList = function visitList(nodes, state) {
    return new ResultArray(nodes.map(function (e) {
      return VISIT_EXPRS.visit(e, state);
    })).toOptionalList();
  }
  /**
   * Normalize paths into `hir.Path` or a `hir.Expr` that corresponds to the ref.
   *
   * TODO since keywords don't support tails anyway, distinguish PathExpression from
   * VariableReference in ASTv2.
   */
  ;

  _proto.PathExpression = function PathExpression(path) {
    var ref = this.VariableReference(path.ref);
    var tail = path.tail;

    if (isPresent(tail)) {
      var tailLoc = tail[0].loc.extend(tail[tail.length - 1].loc);
      return Ok(new mir.PathExpression({
        loc: path.loc,
        head: ref,
        tail: new mir.Tail({
          loc: tailLoc,
          members: tail
        })
      }));
    } else {
      return Ok(ref);
    }
  };

  _proto.VariableReference = function VariableReference(ref) {
    return ref;
  };

  _proto.Literal = function Literal(literal) {
    return literal;
  };

  _proto.Interpolate = function Interpolate(expr, state) {
    var parts = expr.parts.map(convertPathToCallIfKeyword);
    return VISIT_EXPRS.visitList(parts, state).mapOk(function (parts) {
      return new mir.InterpolateExpression({
        loc: expr.loc,
        parts: parts
      });
    });
  };

  _proto.CallExpression = function CallExpression(expr, state) {
    if (!hasPath(expr)) {
      throw new Error("unimplemented subexpression at the head of a subexpression");
    } else {
      return Result.all(VISIT_EXPRS.visit(expr.callee, state), VISIT_EXPRS.Args(expr.args, state)).mapOk(function (_ref) {
        var callee = _ref[0],
            args = _ref[1];
        return new mir.CallExpression({
          loc: expr.loc,
          callee: callee,
          args: args
        });
      });
    }
  };

  _proto.DeprecaedCallExpression = function DeprecaedCallExpression(_ref2, _state) {
    var arg = _ref2.arg,
        callee = _ref2.callee,
        loc = _ref2.loc;
    return Ok(new mir.DeprecatedCallExpression({
      loc: loc,
      arg: arg,
      callee: callee
    }));
  };

  _proto.Args = function Args(_ref3, state) {
    var positional = _ref3.positional,
        named = _ref3.named,
        loc = _ref3.loc;
    return Result.all(this.Positional(positional, state), this.NamedArguments(named, state)).mapOk(function (_ref4) {
      var positional = _ref4[0],
          named = _ref4[1];
      return new mir.Args({
        loc: loc,
        positional: positional,
        named: named
      });
    });
  };

  _proto.Positional = function Positional(positional, state) {
    return VISIT_EXPRS.visitList(positional.exprs, state).mapOk(function (list) {
      return new mir.Positional({
        loc: positional.loc,
        list: list
      });
    });
  };

  _proto.NamedArguments = function NamedArguments(named, state) {
    var pairs = named.entries.map(function (arg) {
      var value = convertPathToCallIfKeyword(arg.value);
      return VISIT_EXPRS.visit(value, state).mapOk(function (value) {
        return new mir.NamedArgument({
          loc: arg.loc,
          key: arg.name,
          value: value
        });
      });
    });
    return new ResultArray(pairs).toOptionalList().mapOk(function (pairs) {
      return new mir.NamedArguments({
        loc: named.loc,
        entries: pairs
      });
    });
  };

  return NormalizeExpressions;
}();
export function convertPathToCallIfKeyword(path) {
  if (path.type === 'Path' && path.ref.type === 'Free' && path.ref.name in KEYWORDS_TYPES) {
    return new ASTv2.CallExpression({
      callee: path,
      args: ASTv2.Args.empty(path.loc),
      loc: path.loc
    });
  }

  return path;
}
export var VISIT_EXPRS = new NormalizeExpressions();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL3Zpc2l0b3JzL2V4cHJlc3Npb25zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLFNBQUEsS0FBQSxFQUFBLGNBQUEsUUFBQSxpQkFBQTtBQUNBLFNBQUEsU0FBQSxRQUFBLGVBQUE7QUFHQSxTQUFBLEVBQUEsRUFBQSxNQUFBLEVBQUEsV0FBQSxRQUFBLHdCQUFBO0FBQ0EsT0FBTyxLQUFQLEdBQUEsTUFBQSxzQkFBQTtBQUVBLFNBQUEsYUFBQSxRQUFBLGFBQUE7QUFDQSxTQUFBLE9BQUEsUUFBQSxrQkFBQTtBQUVBLFdBQU0sb0JBQU47QUFBQTs7QUFBQTs7QUFBQSxTQUNFLEtBREYsR0FDRSxlQUFLLElBQUwsRUFBSyxLQUFMLEVBQTJEO0FBQ3pELFlBQVEsSUFBSSxDQUFaLElBQUE7QUFDRSxXQUFBLFNBQUE7QUFDRSxlQUFPLEVBQUUsQ0FBQyxLQUFBLE9BQUEsQ0FBVixJQUFVLENBQUQsQ0FBVDs7QUFDRixXQUFBLGFBQUE7QUFDRSxlQUFPLEtBQUEsV0FBQSxDQUFBLElBQUEsRUFBUCxLQUFPLENBQVA7O0FBQ0YsV0FBQSxNQUFBO0FBQ0UsZUFBTyxLQUFBLGNBQUEsQ0FBUCxJQUFPLENBQVA7O0FBQ0YsV0FBQSxNQUFBO0FBQ0UsWUFBSSxVQUFVLEdBQUcsYUFBYSxDQUFiLFNBQUEsQ0FBQSxJQUFBLEVBQWpCLEtBQWlCLENBQWpCOztBQUVBLFlBQUksVUFBVSxLQUFkLElBQUEsRUFBeUI7QUFDdkIsaUJBQUEsVUFBQTtBQUNEOztBQUVELGVBQU8sS0FBQSxjQUFBLENBQUEsSUFBQSxFQUFQLEtBQU8sQ0FBUDs7QUFDRixXQUFBLGdCQUFBO0FBQ0UsZUFBTyxLQUFBLHVCQUFBLENBQUEsSUFBQSxFQUFQLEtBQU8sQ0FBUDtBQWhCSjtBQWtCRCxHQXBCSDs7QUFBQSxTQThCRSxTQTlCRixHQThCRSxt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QSxDQUFBLEtBQUEsQ0FBaUIsSUFBSSxDQUZHLEdBRXhCLENBRndCO0FBRzlCLE1BQUEsR0FBRyxFQUFFLElBQUksQ0FBQztBQUhvQixLQUF6QixDQUFQO0FBS0Q7O0FBRUQsU0FBQSxJQUFBO0FBQ0Q7QUFFRCxPQUFPLElBQU0sV0FBVyxHQUFHLElBQXBCLG9CQUFvQixFQUFwQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByZXNlbnRBcnJheSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgQVNUdjIsIEtFWVdPUkRTX1RZUEVTIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcbmltcG9ydCB7IGlzUHJlc2VudCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5pbXBvcnQgeyBBbnlPcHRpb25hbExpc3QsIFByZXNlbnRMaXN0IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpc3QnO1xuaW1wb3J0IHsgT2ssIFJlc3VsdCwgUmVzdWx0QXJyYXkgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvcmVzdWx0JztcbmltcG9ydCAqIGFzIG1pciBmcm9tICcuLi8uLi8yLWVuY29kaW5nL21pcic7XG5pbXBvcnQgeyBOb3JtYWxpemF0aW9uU3RhdGUgfSBmcm9tICcuLi9jb250ZXh0JztcbmltcG9ydCB7IENBTExfS0VZV09SRFMgfSBmcm9tICcuLi9rZXl3b3Jkcyc7XG5pbXBvcnQgeyBoYXNQYXRoIH0gZnJvbSAnLi4vdXRpbHMvaXMtbm9kZSc7XG5cbmV4cG9ydCBjbGFzcyBOb3JtYWxpemVFeHByZXNzaW9ucyB7XG4gIHZpc2l0KG5vZGU6IEFTVHYyLkV4cHJlc3Npb25Ob2RlLCBzdGF0ZTogTm9ybWFsaXphdGlvblN0YXRlKTogUmVzdWx0PG1pci5FeHByZXNzaW9uTm9kZT4ge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgICAgcmV0dXJuIE9rKHRoaXMuTGl0ZXJhbChub2RlKSk7XG4gICAgICBjYXNlICdJbnRlcnBvbGF0ZSc6XG4gICAgICAgIHJldHVybiB0aGlzLkludGVycG9sYXRlKG5vZGUsIHN0YXRlKTtcbiAgICAgIGNhc2UgJ1BhdGgnOlxuICAgICAgICByZXR1cm4gdGhpcy5QYXRoRXhwcmVzc2lvbihub2RlKTtcbiAgICAgIGNhc2UgJ0NhbGwnOlxuICAgICAgICBsZXQgdHJhbnNsYXRlZCA9IENBTExfS0VZV09SRFMudHJhbnNsYXRlKG5vZGUsIHN0YXRlKTtcblxuICAgICAgICBpZiAodHJhbnNsYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0cmFuc2xhdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbEV4cHJlc3Npb24obm9kZSwgc3RhdGUpO1xuICAgICAgY2FzZSAnRGVwcmVjYXRlZENhbGwnOlxuICAgICAgICByZXR1cm4gdGhpcy5EZXByZWNhZWRDYWxsRXhwcmVzc2lvbihub2RlLCBzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgdmlzaXRMaXN0KFxuICAgIG5vZGVzOiBQcmVzZW50QXJyYXk8QVNUdjIuRXhwcmVzc2lvbk5vZGU+LFxuICAgIHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGVcbiAgKTogUmVzdWx0PFByZXNlbnRMaXN0PG1pci5FeHByZXNzaW9uTm9kZT4+O1xuICB2aXNpdExpc3QoXG4gICAgbm9kZXM6IHJlYWRvbmx5IEFTVHYyLkV4cHJlc3Npb25Ob2RlW10sXG4gICAgc3RhdGU6IE5vcm1hbGl6YXRpb25TdGF0ZVxuICApOiBSZXN1bHQ8QW55T3B0aW9uYWxMaXN0PG1pci5FeHByZXNzaW9uTm9kZT4+O1xuICB2aXNpdExpc3QoXG4gICAgbm9kZXM6IHJlYWRvbmx5IEFTVHYyLkV4cHJlc3Npb25Ob2RlW10sXG4gICAgc3RhdGU6IE5vcm1hbGl6YXRpb25TdGF0ZVxuICApOiBSZXN1bHQ8QW55T3B0aW9uYWxMaXN0PG1pci5FeHByZXNzaW9uTm9kZT4+IHtcbiAgICByZXR1cm4gbmV3IFJlc3VsdEFycmF5KG5vZGVzLm1hcCgoZSkgPT4gVklTSVRfRVhQUlMudmlzaXQoZSwgc3RhdGUpKSkudG9PcHRpb25hbExpc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgcGF0aHMgaW50byBgaGlyLlBhdGhgIG9yIGEgYGhpci5FeHByYCB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSByZWYuXG4gICAqXG4gICAqIFRPRE8gc2luY2Uga2V5d29yZHMgZG9uJ3Qgc3VwcG9ydCB0YWlscyBhbnl3YXksIGRpc3Rpbmd1aXNoIFBhdGhFeHByZXNzaW9uIGZyb21cbiAgICogVmFyaWFibGVSZWZlcmVuY2UgaW4gQVNUdjIuXG4gICAqL1xuICBQYXRoRXhwcmVzc2lvbihwYXRoOiBBU1R2Mi5QYXRoRXhwcmVzc2lvbik6IFJlc3VsdDxtaXIuRXhwcmVzc2lvbk5vZGU+IHtcbiAgICBsZXQgcmVmID0gdGhpcy5WYXJpYWJsZVJlZmVyZW5jZShwYXRoLnJlZik7XG4gICAgbGV0IHsgdGFpbCB9ID0gcGF0aDtcblxuICAgIGlmIChpc1ByZXNlbnQodGFpbCkpIHtcbiAgICAgIGxldCB0YWlsTG9jID0gdGFpbFswXS5sb2MuZXh0ZW5kKHRhaWxbdGFpbC5sZW5ndGggLSAxXS5sb2MpO1xuICAgICAgcmV0dXJuIE9rKFxuICAgICAgICBuZXcgbWlyLlBhdGhFeHByZXNzaW9uKHtcbiAgICAgICAgICBsb2M6IHBhdGgubG9jLFxuICAgICAgICAgIGhlYWQ6IHJlZixcbiAgICAgICAgICB0YWlsOiBuZXcgbWlyLlRhaWwoeyBsb2M6IHRhaWxMb2MsIG1lbWJlcnM6IHRhaWwgfSksXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gT2socmVmKTtcbiAgICB9XG4gIH1cblxuICBWYXJpYWJsZVJlZmVyZW5jZShyZWY6IEFTVHYyLlZhcmlhYmxlUmVmZXJlbmNlKTogQVNUdjIuVmFyaWFibGVSZWZlcmVuY2Uge1xuICAgIHJldHVybiByZWY7XG4gIH1cblxuICBMaXRlcmFsKGxpdGVyYWw6IEFTVHYyLkxpdGVyYWxFeHByZXNzaW9uKTogQVNUdjIuTGl0ZXJhbEV4cHJlc3Npb24ge1xuICAgIHJldHVybiBsaXRlcmFsO1xuICB9XG5cbiAgSW50ZXJwb2xhdGUoXG4gICAgZXhwcjogQVNUdjIuSW50ZXJwb2xhdGVFeHByZXNzaW9uLFxuICAgIHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGVcbiAgKTogUmVzdWx0PG1pci5JbnRlcnBvbGF0ZUV4cHJlc3Npb24+IHtcbiAgICBsZXQgcGFydHMgPSBleHByLnBhcnRzLm1hcChjb252ZXJ0UGF0aFRvQ2FsbElmS2V5d29yZCkgYXMgUHJlc2VudEFycmF5PEFTVHYyLkV4cHJlc3Npb25Ob2RlPjtcblxuICAgIHJldHVybiBWSVNJVF9FWFBSUy52aXNpdExpc3QocGFydHMsIHN0YXRlKS5tYXBPayhcbiAgICAgIChwYXJ0cykgPT4gbmV3IG1pci5JbnRlcnBvbGF0ZUV4cHJlc3Npb24oeyBsb2M6IGV4cHIubG9jLCBwYXJ0czogcGFydHMgfSlcbiAgICApO1xuICB9XG5cbiAgQ2FsbEV4cHJlc3Npb24oXG4gICAgZXhwcjogQVNUdjIuQ2FsbEV4cHJlc3Npb24sXG4gICAgc3RhdGU6IE5vcm1hbGl6YXRpb25TdGF0ZVxuICApOiBSZXN1bHQ8bWlyLkV4cHJlc3Npb25Ob2RlPiB7XG4gICAgaWYgKCFoYXNQYXRoKGV4cHIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVuaW1wbGVtZW50ZWQgc3ViZXhwcmVzc2lvbiBhdCB0aGUgaGVhZCBvZiBhIHN1YmV4cHJlc3Npb25gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFJlc3VsdC5hbGwoXG4gICAgICAgIFZJU0lUX0VYUFJTLnZpc2l0KGV4cHIuY2FsbGVlLCBzdGF0ZSksXG4gICAgICAgIFZJU0lUX0VYUFJTLkFyZ3MoZXhwci5hcmdzLCBzdGF0ZSlcbiAgICAgICkubWFwT2soXG4gICAgICAgIChbY2FsbGVlLCBhcmdzXSkgPT5cbiAgICAgICAgICBuZXcgbWlyLkNhbGxFeHByZXNzaW9uKHtcbiAgICAgICAgICAgIGxvYzogZXhwci5sb2MsXG4gICAgICAgICAgICBjYWxsZWUsXG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIERlcHJlY2FlZENhbGxFeHByZXNzaW9uKFxuICAgIHsgYXJnLCBjYWxsZWUsIGxvYyB9OiBBU1R2Mi5EZXByZWNhdGVkQ2FsbEV4cHJlc3Npb24sXG4gICAgX3N0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGVcbiAgKTogUmVzdWx0PG1pci5FeHByZXNzaW9uTm9kZT4ge1xuICAgIHJldHVybiBPayhuZXcgbWlyLkRlcHJlY2F0ZWRDYWxsRXhwcmVzc2lvbih7IGxvYywgYXJnLCBjYWxsZWUgfSkpO1xuICB9XG5cbiAgQXJncyh7IHBvc2l0aW9uYWwsIG5hbWVkLCBsb2MgfTogQVNUdjIuQXJncywgc3RhdGU6IE5vcm1hbGl6YXRpb25TdGF0ZSk6IFJlc3VsdDxtaXIuQXJncz4ge1xuICAgIHJldHVybiBSZXN1bHQuYWxsKHRoaXMuUG9zaXRpb25hbChwb3NpdGlvbmFsLCBzdGF0ZSksIHRoaXMuTmFtZWRBcmd1bWVudHMobmFtZWQsIHN0YXRlKSkubWFwT2soXG4gICAgICAoW3Bvc2l0aW9uYWwsIG5hbWVkXSkgPT5cbiAgICAgICAgbmV3IG1pci5BcmdzKHtcbiAgICAgICAgICBsb2MsXG4gICAgICAgICAgcG9zaXRpb25hbCxcbiAgICAgICAgICBuYW1lZCxcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgUG9zaXRpb25hbChcbiAgICBwb3NpdGlvbmFsOiBBU1R2Mi5Qb3NpdGlvbmFsQXJndW1lbnRzLFxuICAgIHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGVcbiAgKTogUmVzdWx0PG1pci5Qb3NpdGlvbmFsPiB7XG4gICAgcmV0dXJuIFZJU0lUX0VYUFJTLnZpc2l0TGlzdChwb3NpdGlvbmFsLmV4cHJzLCBzdGF0ZSkubWFwT2soXG4gICAgICAobGlzdCkgPT5cbiAgICAgICAgbmV3IG1pci5Qb3NpdGlvbmFsKHtcbiAgICAgICAgICBsb2M6IHBvc2l0aW9uYWwubG9jLFxuICAgICAgICAgIGxpc3QsXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIE5hbWVkQXJndW1lbnRzKFxuICAgIG5hbWVkOiBBU1R2Mi5OYW1lZEFyZ3VtZW50cyxcbiAgICBzdGF0ZTogTm9ybWFsaXphdGlvblN0YXRlXG4gICk6IFJlc3VsdDxtaXIuTmFtZWRBcmd1bWVudHM+IHtcbiAgICBsZXQgcGFpcnMgPSBuYW1lZC5lbnRyaWVzLm1hcCgoYXJnKSA9PiB7XG4gICAgICBsZXQgdmFsdWUgPSBjb252ZXJ0UGF0aFRvQ2FsbElmS2V5d29yZChhcmcudmFsdWUpO1xuXG4gICAgICByZXR1cm4gVklTSVRfRVhQUlMudmlzaXQodmFsdWUsIHN0YXRlKS5tYXBPayhcbiAgICAgICAgKHZhbHVlKSA9PlxuICAgICAgICAgIG5ldyBtaXIuTmFtZWRBcmd1bWVudCh7XG4gICAgICAgICAgICBsb2M6IGFyZy5sb2MsXG4gICAgICAgICAgICBrZXk6IGFyZy5uYW1lLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IFJlc3VsdEFycmF5KHBhaXJzKVxuICAgICAgLnRvT3B0aW9uYWxMaXN0KClcbiAgICAgIC5tYXBPaygocGFpcnMpID0+IG5ldyBtaXIuTmFtZWRBcmd1bWVudHMoeyBsb2M6IG5hbWVkLmxvYywgZW50cmllczogcGFpcnMgfSkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0UGF0aFRvQ2FsbElmS2V5d29yZChwYXRoOiBBU1R2Mi5FeHByZXNzaW9uTm9kZSk6IEFTVHYyLkV4cHJlc3Npb25Ob2RlIHtcbiAgaWYgKHBhdGgudHlwZSA9PT0gJ1BhdGgnICYmIHBhdGgucmVmLnR5cGUgPT09ICdGcmVlJyAmJiBwYXRoLnJlZi5uYW1lIGluIEtFWVdPUkRTX1RZUEVTKSB7XG4gICAgcmV0dXJuIG5ldyBBU1R2Mi5DYWxsRXhwcmVzc2lvbih7XG4gICAgICBjYWxsZWU6IHBhdGgsXG4gICAgICBhcmdzOiBBU1R2Mi5BcmdzLmVtcHR5KHBhdGgubG9jKSxcbiAgICAgIGxvYzogcGF0aC5sb2MsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn1cblxuZXhwb3J0IGNvbnN0IFZJU0lUX0VYUFJTID0gbmV3IE5vcm1hbGl6ZUV4cHJlc3Npb25zKCk7XG4iXSwic291cmNlUm9vdCI6IiJ9