import { LOCAL_LOGGER } from '@glimmer/util';
import * as mir from '../2-encoding/mir';
import { NormalizationState } from './context';
import { VISIT_STMTS } from './visitors/statements';
/**
 * Normalize the AST from @glimmer/syntax into the HIR. The HIR has special
 * instructions for keywords like `{{yield}}`, `(has-block)` and
 * `{{#in-element}}`.
 *
 * Most importantly, it also classifies HTML element syntax into:
 *
 * 1. simple HTML element (with optional splattributes)
 * 2. component invocation
 *
 * Because the @glimmer/syntax AST gives us a string for an element's tag,
 * this pass also normalizes that string into an expression.
 *
 * ```
 * // normalized into a path expression whose head is `this` and tail is
 * // `["x"]`
 * <this.x />
 *
 * {{#let expr as |t|}}
 *   // `"t"` is normalized into a variable lookup.
 *   <t />
 *
 *   // normalized into a path expression whose head is the variable lookup
 *   // `t` and tail is `["input"]`.
 *   <t.input />
 * {{/let}}
 *
 * // normalized into a free variable lookup for `SomeComponent` (with the
 * // context `ComponentHead`).
 * <SomeComponent />
 *
 * // normalized into a path expression whose head is the free variable
 * // `notInScope` (with the context `Expression`), and whose tail is
 * // `["SomeComponent"]`. In resolver mode, this path will be rejected later,
 * // since it cannot serve as an input to the resolver.
 * <notInScope.SomeComponent />
 * ```
 */

export default function normalize(source, root, isStrict) {
  // create a new context for the normalization pass
  var state = new NormalizationState(root.table, isStrict);

  if (false
  /* LOCAL_SHOULD_LOG */
  ) {
      LOCAL_LOGGER.groupCollapsed("pass0: visiting");
      LOCAL_LOGGER.log('symbols', root.table);
      LOCAL_LOGGER.log('source', source);
      LOCAL_LOGGER.groupEnd();
    }

  var body = VISIT_STMTS.visitList(root.body, state);

  if (false
  /* LOCAL_SHOULD_LOG */
  ) {
      if (body.isOk) {
        LOCAL_LOGGER.log('-> pass0: out', body.value);
      } else {
        LOCAL_LOGGER.log('-> pass0: error', body.reason);
      }
    }

  return body.mapOk(function (body) {
    return new mir.Template({
      loc: root.loc,
      scope: root.table,
      body: body.toArray()
    });
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLFNBQUEsWUFBQSxRQUFBLGVBQUE7QUFHQSxPQUFPLEtBQVAsR0FBQSxNQUFBLG1CQUFBO0FBQ0EsU0FBQSxrQkFBQSxRQUFBLFdBQUE7QUFDQSxTQUFBLFdBQUEsUUFBQSx1QkFBQTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQ0EsZUFBYyxTQUFBLFNBQUEsQ0FBQSxNQUFBLEVBQUEsSUFBQSxFQUFBLFFBQUEsRUFHSztBQUVqQjtBQUNBLE1BQUksS0FBSyxHQUFHLElBQUEsa0JBQUEsQ0FBdUIsSUFBSSxDQUEzQixLQUFBLEVBQVosUUFBWSxDQUFaOztBQUVBLE1BQUE7QUFBQTtBQUFBLElBQXNCO0FBQ3BCLE1BQUEsWUFBWSxDQUFaLGNBQUE7QUFDQSxNQUFBLFlBQVksQ0FBWixHQUFBLENBQUEsU0FBQSxFQUE0QixJQUFJLENBQWhDLEtBQUE7QUFDQSxNQUFBLFlBQVksQ0FBWixHQUFBLENBQUEsUUFBQSxFQUFBLE1BQUE7QUFDQSxNQUFBLFlBQVksQ0FBWixRQUFBO0FBQ0Q7O0FBRUQsTUFBSSxJQUFJLEdBQUcsV0FBVyxDQUFYLFNBQUEsQ0FBc0IsSUFBSSxDQUExQixJQUFBLEVBQVgsS0FBVyxDQUFYOztBQUVBLE1BQUE7QUFBQTtBQUFBLElBQXNCO0FBQ3BCLFVBQUksSUFBSSxDQUFSLElBQUEsRUFBZTtBQUNiLFFBQUEsWUFBWSxDQUFaLEdBQUEsQ0FBQSxlQUFBLEVBQWtDLElBQUksQ0FBdEMsS0FBQTtBQURGLE9BQUEsTUFFTztBQUNMLFFBQUEsWUFBWSxDQUFaLEdBQUEsQ0FBQSxpQkFBQSxFQUFvQyxJQUFJLENBQXhDLE1BQUE7QUFDRDtBQUNGOztBQUVELFNBQU8sSUFBSSxDQUFKLEtBQUEsQ0FDSixVQUFBLElBQUQ7QUFBQSxXQUFVLElBQUksR0FBRyxDQUFQLFFBQUEsQ0FBaUI7QUFBRSxNQUFBLEdBQUcsRUFBRSxJQUFJLENBQVgsR0FBQTtBQUFpQixNQUFBLEtBQUssRUFBRSxJQUFJLENBQTVCLEtBQUE7QUFBb0MsTUFBQSxJQUFJLEVBQUUsSUFBSSxDQUFKLE9BQUE7QUFBMUMsS0FBakIsQ0FBVjtBQUFBLEdBREssQ0FBUDtBQUdEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTE9DQUxfU0hPVUxEX0xPRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7IEFTVHYyLCBTb3VyY2UgfSBmcm9tICdAZ2xpbW1lci9zeW50YXgnO1xuaW1wb3J0IHsgTE9DQUxfTE9HR0VSIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmltcG9ydCB7IFJlc3VsdCB9IGZyb20gJy4uLy4uL3NoYXJlZC9yZXN1bHQnO1xuaW1wb3J0ICogYXMgbWlyIGZyb20gJy4uLzItZW5jb2RpbmcvbWlyJztcbmltcG9ydCB7IE5vcm1hbGl6YXRpb25TdGF0ZSB9IGZyb20gJy4vY29udGV4dCc7XG5pbXBvcnQgeyBWSVNJVF9TVE1UUyB9IGZyb20gJy4vdmlzaXRvcnMvc3RhdGVtZW50cyc7XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBBU1QgZnJvbSBAZ2xpbW1lci9zeW50YXggaW50byB0aGUgSElSLiBUaGUgSElSIGhhcyBzcGVjaWFsXG4gKiBpbnN0cnVjdGlvbnMgZm9yIGtleXdvcmRzIGxpa2UgYHt7eWllbGR9fWAsIGAoaGFzLWJsb2NrKWAgYW5kXG4gKiBge3sjaW4tZWxlbWVudH19YC5cbiAqXG4gKiBNb3N0IGltcG9ydGFudGx5LCBpdCBhbHNvIGNsYXNzaWZpZXMgSFRNTCBlbGVtZW50IHN5bnRheCBpbnRvOlxuICpcbiAqIDEuIHNpbXBsZSBIVE1MIGVsZW1lbnQgKHdpdGggb3B0aW9uYWwgc3BsYXR0cmlidXRlcylcbiAqIDIuIGNvbXBvbmVudCBpbnZvY2F0aW9uXG4gKlxuICogQmVjYXVzZSB0aGUgQGdsaW1tZXIvc3ludGF4IEFTVCBnaXZlcyB1cyBhIHN0cmluZyBmb3IgYW4gZWxlbWVudCdzIHRhZyxcbiAqIHRoaXMgcGFzcyBhbHNvIG5vcm1hbGl6ZXMgdGhhdCBzdHJpbmcgaW50byBhbiBleHByZXNzaW9uLlxuICpcbiAqIGBgYFxuICogLy8gbm9ybWFsaXplZCBpbnRvIGEgcGF0aCBleHByZXNzaW9uIHdob3NlIGhlYWQgaXMgYHRoaXNgIGFuZCB0YWlsIGlzXG4gKiAvLyBgW1wieFwiXWBcbiAqIDx0aGlzLnggLz5cbiAqXG4gKiB7eyNsZXQgZXhwciBhcyB8dHx9fVxuICogICAvLyBgXCJ0XCJgIGlzIG5vcm1hbGl6ZWQgaW50byBhIHZhcmlhYmxlIGxvb2t1cC5cbiAqICAgPHQgLz5cbiAqXG4gKiAgIC8vIG5vcm1hbGl6ZWQgaW50byBhIHBhdGggZXhwcmVzc2lvbiB3aG9zZSBoZWFkIGlzIHRoZSB2YXJpYWJsZSBsb29rdXBcbiAqICAgLy8gYHRgIGFuZCB0YWlsIGlzIGBbXCJpbnB1dFwiXWAuXG4gKiAgIDx0LmlucHV0IC8+XG4gKiB7ey9sZXR9fVxuICpcbiAqIC8vIG5vcm1hbGl6ZWQgaW50byBhIGZyZWUgdmFyaWFibGUgbG9va3VwIGZvciBgU29tZUNvbXBvbmVudGAgKHdpdGggdGhlXG4gKiAvLyBjb250ZXh0IGBDb21wb25lbnRIZWFkYCkuXG4gKiA8U29tZUNvbXBvbmVudCAvPlxuICpcbiAqIC8vIG5vcm1hbGl6ZWQgaW50byBhIHBhdGggZXhwcmVzc2lvbiB3aG9zZSBoZWFkIGlzIHRoZSBmcmVlIHZhcmlhYmxlXG4gKiAvLyBgbm90SW5TY29wZWAgKHdpdGggdGhlIGNvbnRleHQgYEV4cHJlc3Npb25gKSwgYW5kIHdob3NlIHRhaWwgaXNcbiAqIC8vIGBbXCJTb21lQ29tcG9uZW50XCJdYC4gSW4gcmVzb2x2ZXIgbW9kZSwgdGhpcyBwYXRoIHdpbGwgYmUgcmVqZWN0ZWQgbGF0ZXIsXG4gKiAvLyBzaW5jZSBpdCBjYW5ub3Qgc2VydmUgYXMgYW4gaW5wdXQgdG8gdGhlIHJlc29sdmVyLlxuICogPG5vdEluU2NvcGUuU29tZUNvbXBvbmVudCAvPlxuICogYGBgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG5vcm1hbGl6ZShcbiAgc291cmNlOiBTb3VyY2UsXG4gIHJvb3Q6IEFTVHYyLlRlbXBsYXRlLFxuICBpc1N0cmljdDogYm9vbGVhblxuKTogUmVzdWx0PG1pci5UZW1wbGF0ZT4ge1xuICAvLyBjcmVhdGUgYSBuZXcgY29udGV4dCBmb3IgdGhlIG5vcm1hbGl6YXRpb24gcGFzc1xuICBsZXQgc3RhdGUgPSBuZXcgTm9ybWFsaXphdGlvblN0YXRlKHJvb3QudGFibGUsIGlzU3RyaWN0KTtcblxuICBpZiAoTE9DQUxfU0hPVUxEX0xPRykge1xuICAgIExPQ0FMX0xPR0dFUi5ncm91cENvbGxhcHNlZChgcGFzczA6IHZpc2l0aW5nYCk7XG4gICAgTE9DQUxfTE9HR0VSLmxvZygnc3ltYm9scycsIHJvb3QudGFibGUpO1xuICAgIExPQ0FMX0xPR0dFUi5sb2coJ3NvdXJjZScsIHNvdXJjZSk7XG4gICAgTE9DQUxfTE9HR0VSLmdyb3VwRW5kKCk7XG4gIH1cblxuICBsZXQgYm9keSA9IFZJU0lUX1NUTVRTLnZpc2l0TGlzdChyb290LmJvZHksIHN0YXRlKTtcblxuICBpZiAoTE9DQUxfU0hPVUxEX0xPRykge1xuICAgIGlmIChib2R5LmlzT2spIHtcbiAgICAgIExPQ0FMX0xPR0dFUi5sb2coJy0+IHBhc3MwOiBvdXQnLCBib2R5LnZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgTE9DQUxfTE9HR0VSLmxvZygnLT4gcGFzczA6IGVycm9yJywgYm9keS5yZWFzb24pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib2R5Lm1hcE9rKFxuICAgIChib2R5KSA9PiBuZXcgbWlyLlRlbXBsYXRlKHsgbG9jOiByb290LmxvYywgc2NvcGU6IHJvb3QudGFibGUsIGJvZHk6IGJvZHkudG9BcnJheSgpIH0pXG4gICk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9