import { ASTv2, generateSyntaxError } from '@glimmer/syntax';
import { unreachable } from '@glimmer/util';
export function hasPath(node) {
  return node.callee.type === 'Path';
}
export function isHelperInvocation(node) {
  if (!hasPath(node)) {
    return false;
  }

  return !node.args.isEmpty();
}
export function isSimplePath(path) {
  if (path.type === 'Path') {
    var head = path.ref,
        parts = path.tail;
    return head.type === 'Free' && head.resolution !== ASTv2.STRICT_RESOLUTION && parts.length === 0;
  } else {
    return false;
  }
}
export function isStrictHelper(expr) {
  if (expr.callee.type !== 'Path') {
    return true;
  }

  if (expr.callee.ref.type !== 'Free') {
    return true;
  }

  return expr.callee.ref.resolution === ASTv2.STRICT_RESOLUTION;
}
export function assertIsValidModifier(helper) {
  if (isStrictHelper(helper) || isSimplePath(helper.callee)) {
    return;
  }

  throw generateSyntaxError("`" + printPath(helper.callee) + "` is not a valid name for a modifier", helper.loc);
}

function printPath(path) {
  switch (path.type) {
    case 'Literal':
      return JSON.stringify(path.value);

    case 'Path':
      {
        var printedPath = [printPathHead(path.ref)];
        printedPath.push.apply(printedPath, path.tail.map(function (t) {
          return t.chars;
        }));
        return printedPath.join('.');
      }

    case 'Call':
      return "(" + printPath(path.callee) + " ...)";

    case 'DeprecatedCall':
      return "" + path.callee.name;

    case 'Interpolate':
      throw unreachable('a concat statement cannot appear as the head of an expression');
  }
}

function printPathHead(head) {
  switch (head.type) {
    case 'Arg':
      return head.name.chars;

    case 'Free':
    case 'Local':
      return head.name;

    case 'This':
      return 'this';
  }
}
/**
 * This function is checking whether an AST node is a triple-curly, which means that it's
 * a "trusting" node. In the Handlebars AST, this is indicated by the `escaped` flag, which
 * is a bit of a double-negative, so we change the terminology here for clarity.
 */


export function isTrustingNode(value) {
  if (value.type === 'AppendContent') {
    return value.trusting;
  } else {
    return false;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL3V0aWxzL2lzLW5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsU0FBQSxLQUFBLEVBQUEsbUJBQUEsUUFBQSxpQkFBQTtBQUNBLFNBQUEsV0FBQSxRQUFBLGVBQUE7QUFtQkEsT0FBTSxTQUFBLE9BQUEsQ0FBQSxJQUFBLEVBQW1EO0FBQ3ZELFNBQU8sSUFBSSxDQUFKLE1BQUEsQ0FBQSxJQUFBLEtBQVAsTUFBQTtBQUNEO0FBRUQsT0FBTSxTQUFBLGtCQUFBLENBQUEsSUFBQSxFQUNnQjtBQUVwQixNQUFJLENBQUMsT0FBTyxDQUFaLElBQVksQ0FBWixFQUFvQjtBQUNsQixXQUFBLEtBQUE7QUFDRDs7QUFFRCxTQUFPLENBQUMsSUFBSSxDQUFKLElBQUEsQ0FBUixPQUFRLEVBQVI7QUFDRDtBQVlELE9BQU0sU0FBQSxZQUFBLENBQUEsSUFBQSxFQUFpRDtBQUNyRCxNQUFJLElBQUksQ0FBSixJQUFBLEtBQUosTUFBQSxFQUEwQjtBQUFBLFFBQ3BCLElBRG9CLEdBQ3hCLElBRHdCLENBQ2xCLEdBRGtCO0FBQUEsUUFDRCxLQURDLEdBQ3hCLElBRHdCLENBQ1AsSUFETztBQUd4QixXQUNFLElBQUksQ0FBSixJQUFBLEtBQUEsTUFBQSxJQUF3QixJQUFJLENBQUosVUFBQSxLQUFvQixLQUFLLENBQWpELGlCQUFBLElBQXVFLEtBQUssQ0FBTCxNQUFBLEtBRHpFLENBQUE7QUFIRixHQUFBLE1BTU87QUFDTCxXQUFBLEtBQUE7QUFDRDtBQUNGO0FBRUQsT0FBTSxTQUFBLGNBQUEsQ0FBQSxJQUFBLEVBQXNDO0FBQzFDLE1BQUksSUFBSSxDQUFKLE1BQUEsQ0FBQSxJQUFBLEtBQUosTUFBQSxFQUFpQztBQUMvQixXQUFBLElBQUE7QUFDRDs7QUFFRCxNQUFJLElBQUksQ0FBSixNQUFBLENBQUEsR0FBQSxDQUFBLElBQUEsS0FBSixNQUFBLEVBQXFDO0FBQ25DLFdBQUEsSUFBQTtBQUNEOztBQUVELFNBQU8sSUFBSSxDQUFKLE1BQUEsQ0FBQSxHQUFBLENBQUEsVUFBQSxLQUErQixLQUFLLENBQTNDLGlCQUFBO0FBQ0Q7QUFFRCxPQUFNLFNBQUEscUJBQUEsQ0FBQSxNQUFBLEVBQ0s7QUFFVCxNQUFJLGNBQWMsQ0FBZCxNQUFjLENBQWQsSUFBMEIsWUFBWSxDQUFDLE1BQU0sQ0FBakQsTUFBMEMsQ0FBMUMsRUFBMkQ7QUFDekQ7QUFDRDs7QUFFRCxRQUFNLG1CQUFtQixPQUNsQixTQUFTLENBQUMsTUFBTSxDQURFLE1BQ1QsQ0FEUywyQ0FFdkIsTUFBTSxDQUZSLEdBQXlCLENBQXpCO0FBSUQ7O0FBRUQsU0FBQSxTQUFBLENBQUEsSUFBQSxFQUE2QztBQUMzQyxVQUFRLElBQUksQ0FBWixJQUFBO0FBQ0UsU0FBQSxTQUFBO0FBQ0UsYUFBTyxJQUFJLENBQUosU0FBQSxDQUFlLElBQUksQ0FBMUIsS0FBTyxDQUFQOztBQUNGLFNBQUEsTUFBQTtBQUFhO0FBQ1gsWUFBSSxXQUFXLEdBQUcsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFyQyxHQUFnQyxDQUFkLENBQWxCO0FBQ0EsUUFBQSxXQUFXLENBQVgsSUFBQSxPQUFBLFdBQVcsRUFBUyxJQUFJLENBQUosSUFBQSxDQUFBLEdBQUEsQ0FBZSxVQUFBLENBQUQ7QUFBQSxpQkFBTyxDQUFDLENBQTFDLEtBQWtDO0FBQUEsU0FBZCxDQUFULENBQVg7QUFDQSxlQUFPLFdBQVcsQ0FBWCxJQUFBLENBQVAsR0FBTyxDQUFQO0FBQ0Q7O0FBQ0QsU0FBQSxNQUFBO0FBQ0UsbUJBQVcsU0FBUyxDQUFDLElBQUksQ0FBekIsTUFBb0IsQ0FBcEI7O0FBQ0YsU0FBQSxnQkFBQTtBQUNFLGtCQUFVLElBQUksQ0FBSixNQUFBLENBQVYsSUFBQTs7QUFDRixTQUFBLGFBQUE7QUFDRSxZQUFNLFdBQVcsQ0FBakIsK0RBQWlCLENBQWpCO0FBYko7QUFlRDs7QUFFRCxTQUFBLGFBQUEsQ0FBQSxJQUFBLEVBQW9EO0FBQ2xELFVBQVEsSUFBSSxDQUFaLElBQUE7QUFDRSxTQUFBLEtBQUE7QUFDRSxhQUFPLElBQUksQ0FBSixJQUFBLENBQVAsS0FBQTs7QUFDRixTQUFBLE1BQUE7QUFDQSxTQUFBLE9BQUE7QUFDRSxhQUFPLElBQUksQ0FBWCxJQUFBOztBQUNGLFNBQUEsTUFBQTtBQUNFLGFBQUEsTUFBQTtBQVBKO0FBU0Q7QUFFRDs7Ozs7OztBQUtBLE9BQU0sU0FBQSxjQUFBLENBQUEsS0FBQSxFQUNxRTtBQUV6RSxNQUFJLEtBQUssQ0FBTCxJQUFBLEtBQUosZUFBQSxFQUFvQztBQUNsQyxXQUFPLEtBQUssQ0FBWixRQUFBO0FBREYsR0FBQSxNQUVPO0FBQ0wsV0FBQSxLQUFBO0FBQ0Q7QUFDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByZXNlbnRBcnJheSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgQVNUdjIsIGdlbmVyYXRlU3ludGF4RXJyb3IsIFNvdXJjZVNsaWNlIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcbmltcG9ydCB7IHVucmVhY2hhYmxlIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmV4cG9ydCB0eXBlIEhhc1BhdGg8Tm9kZSBleHRlbmRzIEFTVHYyLkNhbGxOb2RlID0gQVNUdjIuQ2FsbE5vZGU+ID0gTm9kZSAmIHtcbiAgaGVhZDogQVNUdjIuUGF0aEV4cHJlc3Npb247XG59O1xuXG5leHBvcnQgdHlwZSBIYXNBcmd1bWVudHMgPVxuICB8IHtcbiAgICAgIHBhcmFtczogUHJlc2VudEFycmF5PEFTVHYyLkV4cHJlc3Npb25Ob2RlPjtcbiAgICB9XG4gIHwge1xuICAgICAgaGFzaDoge1xuICAgICAgICBwYWlyczogUHJlc2VudEFycmF5PEFTVHYyLk5hbWVkQXJndW1lbnQ+O1xuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgdHlwZSBIZWxwZXJJbnZvY2F0aW9uPE5vZGUgZXh0ZW5kcyBBU1R2Mi5DYWxsTm9kZSA9IEFTVHYyLkNhbGxOb2RlPiA9IEhhc1BhdGg8Tm9kZT4gJlxuICBIYXNBcmd1bWVudHM7XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNQYXRoPE4gZXh0ZW5kcyBBU1R2Mi5DYWxsTm9kZT4obm9kZTogTik6IG5vZGUgaXMgSGFzUGF0aDxOPiB7XG4gIHJldHVybiBub2RlLmNhbGxlZS50eXBlID09PSAnUGF0aCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hlbHBlckludm9jYXRpb248TiBleHRlbmRzIEFTVHYyLkNhbGxOb2RlPihcbiAgbm9kZTogQVNUdjIuQ2FsbE5vZGVcbik6IG5vZGUgaXMgSGVscGVySW52b2NhdGlvbjxOPiB7XG4gIGlmICghaGFzUGF0aChub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhbm9kZS5hcmdzLmlzRW1wdHkoKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVQYXRoIGV4dGVuZHMgQVNUdjIuUGF0aEV4cHJlc3Npb24ge1xuICB0YWlsOiBbU291cmNlU2xpY2VdO1xuICBkYXRhOiBmYWxzZTtcbiAgdGhpczogZmFsc2U7XG59XG5cbmV4cG9ydCB0eXBlIFNpbXBsZUhlbHBlcjxOIGV4dGVuZHMgSGFzUGF0aD4gPSBOICYge1xuICBwYXRoOiBTaW1wbGVQYXRoO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2ltcGxlUGF0aChwYXRoOiBBU1R2Mi5FeHByZXNzaW9uTm9kZSk6IHBhdGggaXMgU2ltcGxlUGF0aCB7XG4gIGlmIChwYXRoLnR5cGUgPT09ICdQYXRoJykge1xuICAgIGxldCB7IHJlZjogaGVhZCwgdGFpbDogcGFydHMgfSA9IHBhdGg7XG5cbiAgICByZXR1cm4gKFxuICAgICAgaGVhZC50eXBlID09PSAnRnJlZScgJiYgaGVhZC5yZXNvbHV0aW9uICE9PSBBU1R2Mi5TVFJJQ1RfUkVTT0xVVElPTiAmJiBwYXJ0cy5sZW5ndGggPT09IDBcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpY3RIZWxwZXIoZXhwcjogSGFzUGF0aCk6IGJvb2xlYW4ge1xuICBpZiAoZXhwci5jYWxsZWUudHlwZSAhPT0gJ1BhdGgnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoZXhwci5jYWxsZWUucmVmLnR5cGUgIT09ICdGcmVlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGV4cHIuY2FsbGVlLnJlZi5yZXNvbHV0aW9uID09PSBBU1R2Mi5TVFJJQ1RfUkVTT0xVVElPTjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydElzVmFsaWRNb2RpZmllcjxOIGV4dGVuZHMgSGFzUGF0aD4oXG4gIGhlbHBlcjogTlxuKTogYXNzZXJ0cyBoZWxwZXIgaXMgU2ltcGxlSGVscGVyPE4+IHtcbiAgaWYgKGlzU3RyaWN0SGVscGVyKGhlbHBlcikgfHwgaXNTaW1wbGVQYXRoKGhlbHBlci5jYWxsZWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICBgXFxgJHtwcmludFBhdGgoaGVscGVyLmNhbGxlZSl9XFxgIGlzIG5vdCBhIHZhbGlkIG5hbWUgZm9yIGEgbW9kaWZpZXJgLFxuICAgIGhlbHBlci5sb2NcbiAgKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRQYXRoKHBhdGg6IEFTVHYyLkV4cHJlc3Npb25Ob2RlKTogc3RyaW5nIHtcbiAgc3dpdGNoIChwYXRoLnR5cGUpIHtcbiAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXRoLnZhbHVlKTtcbiAgICBjYXNlICdQYXRoJzoge1xuICAgICAgbGV0IHByaW50ZWRQYXRoID0gW3ByaW50UGF0aEhlYWQocGF0aC5yZWYpXTtcbiAgICAgIHByaW50ZWRQYXRoLnB1c2goLi4ucGF0aC50YWlsLm1hcCgodCkgPT4gdC5jaGFycykpO1xuICAgICAgcmV0dXJuIHByaW50ZWRQYXRoLmpvaW4oJy4nKTtcbiAgICB9XG4gICAgY2FzZSAnQ2FsbCc6XG4gICAgICByZXR1cm4gYCgke3ByaW50UGF0aChwYXRoLmNhbGxlZSl9IC4uLilgO1xuICAgIGNhc2UgJ0RlcHJlY2F0ZWRDYWxsJzpcbiAgICAgIHJldHVybiBgJHtwYXRoLmNhbGxlZS5uYW1lfWA7XG4gICAgY2FzZSAnSW50ZXJwb2xhdGUnOlxuICAgICAgdGhyb3cgdW5yZWFjaGFibGUoJ2EgY29uY2F0IHN0YXRlbWVudCBjYW5ub3QgYXBwZWFyIGFzIHRoZSBoZWFkIG9mIGFuIGV4cHJlc3Npb24nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFBhdGhIZWFkKGhlYWQ6IEFTVHYyLlZhcmlhYmxlUmVmZXJlbmNlKTogc3RyaW5nIHtcbiAgc3dpdGNoIChoZWFkLnR5cGUpIHtcbiAgICBjYXNlICdBcmcnOlxuICAgICAgcmV0dXJuIGhlYWQubmFtZS5jaGFycztcbiAgICBjYXNlICdGcmVlJzpcbiAgICBjYXNlICdMb2NhbCc6XG4gICAgICByZXR1cm4gaGVhZC5uYW1lO1xuICAgIGNhc2UgJ1RoaXMnOlxuICAgICAgcmV0dXJuICd0aGlzJztcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgY2hlY2tpbmcgd2hldGhlciBhbiBBU1Qgbm9kZSBpcyBhIHRyaXBsZS1jdXJseSwgd2hpY2ggbWVhbnMgdGhhdCBpdCdzXG4gKiBhIFwidHJ1c3RpbmdcIiBub2RlLiBJbiB0aGUgSGFuZGxlYmFycyBBU1QsIHRoaXMgaXMgaW5kaWNhdGVkIGJ5IHRoZSBgZXNjYXBlZGAgZmxhZywgd2hpY2hcbiAqIGlzIGEgYml0IG9mIGEgZG91YmxlLW5lZ2F0aXZlLCBzbyB3ZSBjaGFuZ2UgdGhlIHRlcm1pbm9sb2d5IGhlcmUgZm9yIGNsYXJpdHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1RydXN0aW5nTm9kZShcbiAgdmFsdWU6IEFTVHYyLkFwcGVuZENvbnRlbnQgfCBBU1R2Mi5IdG1sVGV4dCB8IEFTVHYyLkludGVycG9sYXRlRXhwcmVzc2lvblxuKTogYm9vbGVhbiB7XG4gIGlmICh2YWx1ZS50eXBlID09PSAnQXBwZW5kQ29udGVudCcpIHtcbiAgICByZXR1cm4gdmFsdWUudHJ1c3Rpbmc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9