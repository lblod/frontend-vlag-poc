function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import { ASTv2, maybeLoc, SourceSpan } from '@glimmer/syntax';
import { OptionalList } from '../../../../shared/list';
import { Ok, Result, ResultArray } from '../../../../shared/result';
import { getAttrNamespace } from '../../../../utils';
import * as mir from '../../../2-encoding/mir';
import { MODIFIER_KEYWORDS } from '../../keywords';
import { assertIsValidModifier, isHelperInvocation } from '../../utils/is-node';
import { convertPathToCallIfKeyword, VISIT_EXPRS } from '../expressions';
export var ClassifiedElement = /*#__PURE__*/function () {
  function ClassifiedElement(element, delegate, state) {
    this.element = element;
    this.state = state;
    this.delegate = delegate;
  }

  var _proto = ClassifiedElement.prototype;

  _proto.toStatement = function toStatement() {
    var _this = this;

    return this.prepare().andThen(function (prepared) {
      return _this.delegate.toStatement(_this, prepared);
    });
  };

  _proto.attr = function attr(_attr) {
    var _this2 = this;

    var name = _attr.name;
    var rawValue = _attr.value;
    var namespace = getAttrNamespace(name.chars) || undefined;

    if (ASTv2.isLiteral(rawValue, 'string')) {
      return Ok(new mir.StaticAttr({
        loc: _attr.loc,
        name: name,
        value: rawValue.toSlice(),
        namespace: namespace,
        kind: {
          component: this.delegate.dynamicFeatures
        }
      }));
    }

    return VISIT_EXPRS.visit(convertPathToCallIfKeyword(rawValue), this.state).mapOk(function (value) {
      var isTrusting = _attr.trusting;
      return new mir.DynamicAttr({
        loc: _attr.loc,
        name: name,
        value: value,
        namespace: namespace,
        kind: {
          trusting: isTrusting,
          component: _this2.delegate.dynamicFeatures
        }
      });
    });
  };

  _proto.modifier = function modifier(_modifier) {
    if (isHelperInvocation(_modifier)) {
      assertIsValidModifier(_modifier);
    }

    var translated = MODIFIER_KEYWORDS.translate(_modifier, this.state);

    if (translated !== null) {
      return translated;
    }

    var head = VISIT_EXPRS.visit(_modifier.callee, this.state);
    var args = VISIT_EXPRS.Args(_modifier.args, this.state);
    return Result.all(head, args).mapOk(function (_ref) {
      var head = _ref[0],
          args = _ref[1];
      return new mir.Modifier({
        loc: _modifier.loc,
        callee: head,
        args: args
      });
    });
  };

  _proto.attrs = function attrs() {
    var attrs = new ResultArray();
    var args = new ResultArray(); // Unlike most attributes, the `type` attribute can change how
    // subsequent attributes are interpreted by the browser. To address
    // this, in simple cases, we special case the `type` attribute to be set
    // last. For elements with splattributes, where attribute order affects
    // precedence, this re-ordering happens at runtime instead.
    // See https://github.com/glimmerjs/glimmer-vm/pull/726

    var typeAttr = null;
    var simple = this.element.attrs.filter(function (attr) {
      return attr.type === 'SplatAttr';
    }).length === 0;

    for (var _iterator = _createForOfIteratorHelperLoose(this.element.attrs), _step; !(_step = _iterator()).done;) {
      var attr = _step.value;

      if (attr.type === 'SplatAttr') {
        attrs.add(Ok(new mir.SplatAttr({
          loc: attr.loc,
          symbol: this.state.scope.allocateBlock('attrs')
        })));
      } else if (attr.name.chars === 'type' && simple) {
        typeAttr = attr;
      } else {
        attrs.add(this.attr(attr));
      }
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(this.element.componentArgs), _step2; !(_step2 = _iterator2()).done;) {
      var arg = _step2.value;
      args.add(this.delegate.arg(arg, this));
    }

    if (typeAttr) {
      attrs.add(this.attr(typeAttr));
    }

    return Result.all(args.toArray(), attrs.toArray()).mapOk(function (_ref2) {
      var args = _ref2[0],
          attrs = _ref2[1];
      return {
        attrs: attrs,
        args: new mir.NamedArguments({
          loc: maybeLoc(args, SourceSpan.NON_EXISTENT),
          entries: OptionalList(args)
        })
      };
    });
  };

  _proto.prepare = function prepare() {
    var _this3 = this;

    var attrs = this.attrs();
    var modifiers = new ResultArray(this.element.modifiers.map(function (m) {
      return _this3.modifier(m);
    })).toArray();
    return Result.all(attrs, modifiers).mapOk(function (_ref3) {
      var result = _ref3[0],
          modifiers = _ref3[1];
      var attrs = result.attrs,
          args = result.args;
      var elementParams = [].concat(attrs, modifiers);
      var params = new mir.ElementParameters({
        loc: maybeLoc(elementParams, SourceSpan.NON_EXISTENT),
        body: OptionalList(elementParams)
      });
      return {
        args: args,
        params: params
      };
    });
  };

  return ClassifiedElement;
}();
export function hasDynamicFeatures(_ref4) {
  var attrs = _ref4.attrs,
      modifiers = _ref4.modifiers;

  // ElementModifier needs the special ComponentOperations
  if (modifiers.length > 0) {
    return true;
  } // Splattributes need the special ComponentOperations to merge into


  return !!attrs.filter(function (attr) {
    return attr.type === 'SplatAttr';
  })[0];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL3Zpc2l0b3JzL2VsZW1lbnQvY2xhc3NpZmllZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxTQUFBLEtBQUEsRUFBQSxRQUFBLEVBQUEsVUFBQSxRQUFBLGlCQUFBO0FBRUEsU0FBQSxZQUFBLFFBQUEseUJBQUE7QUFDQSxTQUFBLEVBQUEsRUFBQSxNQUFBLEVBQUEsV0FBQSxRQUFBLDJCQUFBO0FBQ0EsU0FBQSxnQkFBQSxRQUFBLG1CQUFBO0FBQ0EsT0FBTyxLQUFQLEdBQUEsTUFBQSx5QkFBQTtBQUVBLFNBQUEsaUJBQUEsUUFBQSxnQkFBQTtBQUNBLFNBQUEscUJBQUEsRUFBQSxrQkFBQSxRQUFBLHFCQUFBO0FBQ0EsU0FBQSwwQkFBQSxFQUFBLFdBQUEsUUFBQSxnQkFBQTtBQWdCQSxXQUFNLGlCQUFOO0FBR0UsNkJBQUEsT0FBQSxFQUFBLFFBQUEsRUFBQSxLQUFBLEVBR29DO0FBRnpCLFNBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxTQUFBLEtBQUEsR0FBQSxLQUFBO0FBRVQsU0FBQSxRQUFBLEdBQUEsUUFBQTtBQUNEOztBQVRIOztBQUFBLFNBV0UsV0FYRixHQVdFLHVCQUFXO0FBQUE7O0FBQ1QsV0FBTyxLQUFBLE9BQUEsR0FBQSxPQUFBLENBQXdCLFVBQUEsUUFBRDtBQUFBLGFBQWMsS0FBQSxDQUFBLFFBQUEsQ0FBQSxXQUFBLENBQUEsS0FBQSxFQUE1QyxRQUE0QyxDQUFkO0FBQUEsS0FBdkIsQ0FBUDtBQUNELEdBYkg7O0FBQUEsU0FlVSxJQWZWLEdBZVUsY0FBSSxLQUFKLEVBQXlCO0FBQUE7O0FBQy9CLFFBQUksSUFBSSxHQUFHLEtBQUksQ0FBZixJQUFBO0FBQ0EsUUFBSSxRQUFRLEdBQUcsS0FBSSxDQUFuQixLQUFBO0FBQ0EsUUFBSSxTQUFTLEdBQUcsZ0JBQWdCLENB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O0FBQy9DO0FBQ0EsTUFBSSxTQUFTLENBQVQsTUFBQSxHQUFKLENBQUEsRUFBMEI7QUFDeEIsV0FBQSxJQUFBO0FBSDZDLEdBQUEsQ0FNL0M7OztBQUNBLFNBQU8sQ0FBQyxDQUFDLEtBQUssQ0FBTCxNQUFBLENBQWMsVUFBQSxJQUFEO0FBQUEsV0FBVSxJQUFJLENBQUosSUFBQSxLQUF2QixXQUFhO0FBQUEsR0FBYixFQUFULENBQVMsQ0FBVDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQVNUdjIsIG1heWJlTG9jLCBTb3VyY2VTcGFuIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcblxuaW1wb3J0IHsgT3B0aW9uYWxMaXN0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpc3QnO1xuaW1wb3J0IHsgT2ssIFJlc3VsdCwgUmVzdWx0QXJyYXkgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvcmVzdWx0JztcbmltcG9ydCB7IGdldEF0dHJOYW1lc3BhY2UgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyBtaXIgZnJvbSAnLi4vLi4vLi4vMi1lbmNvZGluZy9taXInO1xuaW1wb3J0IHsgTm9ybWFsaXphdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vY29udGV4dCc7XG5pbXBvcnQgeyBNT0RJRklFUl9LRVlXT1JEUyB9IGZyb20gJy4uLy4uL2tleXdvcmRzJztcbmltcG9ydCB7IGFzc2VydElzVmFsaWRNb2RpZmllciwgaXNIZWxwZXJJbnZvY2F0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMvaXMtbm9kZSc7XG5pbXBvcnQgeyBjb252ZXJ0UGF0aFRvQ2FsbElmS2V5d29yZCwgVklTSVRfRVhQUlMgfSBmcm9tICcuLi9leHByZXNzaW9ucyc7XG5cbmV4cG9ydCB0eXBlIFZhbGlkQXR0ciA9IG1pci5TdGF0aWNBdHRyIHwgbWlyLkR5bmFtaWNBdHRyIHwgbWlyLlNwbGF0QXR0cjtcblxudHlwZSBQcm9jZXNzZWRBdHRyaWJ1dGVzID0ge1xuICBhdHRyczogVmFsaWRBdHRyW107XG4gIGFyZ3M6IG1pci5OYW1lZEFyZ3VtZW50cztcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xhc3NpZmllZCB7XG4gIHJlYWRvbmx5IGR5bmFtaWNGZWF0dXJlczogYm9vbGVhbjtcblxuICBhcmcoYXR0cjogQVNUdjIuQXR0ck5vZGUsIGNsYXNzaWZpZWQ6IENsYXNzaWZpZWRFbGVtZW50KTogUmVzdWx0PG1pci5OYW1lZEFyZ3VtZW50PjtcbiAgdG9TdGF0ZW1lbnQoY2xhc3NpZmllZDogQ2xhc3NpZmllZEVsZW1lbnQsIHByZXBhcmVkOiBQcmVwYXJlZEFyZ3MpOiBSZXN1bHQ8bWlyLlN0YXRlbWVudD47XG59XG5cbmV4cG9ydCBjbGFzcyBDbGFzc2lmaWVkRWxlbWVudCB7XG4gIHJlYWRvbmx5IGRlbGVnYXRlOiBDbGFzc2lmaWVkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGVsZW1lbnQ6IEFTVHYyLkVsZW1lbnROb2RlLFxuICAgIGRlbGVnYXRlOiBDbGFzc2lmaWVkLFxuICAgIHJlYWRvbmx5IHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGVcbiAgKSB7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICB9XG5cbiAgdG9TdGF0ZW1lbnQoKTogUmVzdWx0PG1pci5TdGF0ZW1lbnQ+IHtcbiAgICByZXR1cm4gdGhpcy5wcmVwYXJlKCkuYW5kVGhlbigocHJlcGFyZWQpID0+IHRoaXMuZGVsZWdhdGUudG9TdGF0ZW1lbnQodGhpcywgcHJlcGFyZWQpKTtcbiAgfVxuXG4gIHByaXZhdGUgYXR0cihhdHRyOiBBU1R2Mi5IdG1sQXR0cik6IFJlc3VsdDxWYWxpZEF0dHI+IHtcbiAgICBsZXQgbmFtZSA9IGF0dHIubmFtZTtcbiAgICBsZXQgcmF3VmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgIGxldCBuYW1lc3BhY2UgPSBnZXRBdHRyTmFtZXNwYWNlKG5hbWUuY2hhcnMpIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmIChBU1R2Mi5pc0xpdGVyYWwocmF3VmFsdWUsICdzdHJpbmcnKSkge1xuICAgICAgcmV0dXJuIE9rKFxuICAgICAgICBuZXcgbWlyLlN0YXRpY0F0dHIoe1xuICAgICAgICAgIGxvYzogYXR0ci5sb2MsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB2YWx1ZTogcmF3VmFsdWUudG9TbGljZSgpLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBraW5kOiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMuZGVsZWdhdGUuZHluYW1pY0ZlYXR1cmVzLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBWSVNJVF9FWFBSUy52aXNpdChjb252ZXJ0UGF0aFRvQ2FsbElmS2V5d29yZChyYXdWYWx1ZSksIHRoaXMuc3RhdGUpLm1hcE9rKCh2YWx1ZSkgPT4ge1xuICAgICAgbGV0IGlzVHJ1c3RpbmcgPSBhdHRyLnRydXN0aW5nO1xuXG4gICAgICByZXR1cm4gbmV3IG1pci5EeW5hbWljQXR0cih7XG4gICAgICAgIGxvYzogYXR0ci5sb2MsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBraW5kOiB7XG4gICAgICAgICAgdHJ1c3Rpbmc6IGlzVHJ1c3RpbmcsXG4gICAgICAgICAgY29tcG9uZW50OiB0aGlzLmRlbGVnYXRlLmR5bmFtaWNGZWF0dXJlcyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBtb2RpZmllcihtb2RpZmllcjogQVNUdjIuRWxlbWVudE1vZGlmaWVyKTogUmVzdWx0PG1pci5Nb2RpZmllcj4ge1xuICAgIGlmIChpc0hlbHBlckludm9jYXRpb24obW9kaWZpZXIpKSB7XG4gICAgICBhc3NlcnRJc1ZhbGlkTW9kaWZpZXIobW9kaWZpZXIpO1xuICAgIH1cblxuICAgIGxldCB0cmFuc2xhdGVkID0gTU9ESUZJRVJfS0VZV09SRFMudHJhbnNsYXRlKG1vZGlmaWVyLCB0aGlzLnN0YXRlKTtcblxuICAgIGlmICh0cmFuc2xhdGVkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJhbnNsYXRlZDtcbiAgICB9XG5cbiAgICBsZXQgaGVhZCA9IFZJU0lUX0VYUFJTLnZpc2l0KG1vZGlmaWVyLmNhbGxlZSwgdGhpcy5zdGF0ZSk7XG4gICAgbGV0IGFyZ3MgPSBWSVNJVF9FWFBSUy5BcmdzKG1vZGlmaWVyLmFyZ3MsIHRoaXMuc3RhdGUpO1xuXG4gICAgcmV0dXJuIFJlc3VsdC5hbGwoaGVhZCwgYXJncykubWFwT2soXG4gICAgICAoW2hlYWQsIGFyZ3NdKSA9PlxuICAgICAgICBuZXcgbWlyLk1vZGlmaWVyKHtcbiAgICAgICAgICBsb2M6IG1vZGlmaWVyLmxvYyxcbiAgICAgICAgICBjYWxsZWU6IGhlYWQsXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBhdHRycygpOiBSZXN1bHQ8UHJvY2Vzc2VkQXR0cmlidXRlcz4ge1xuICAgIGxldCBhdHRycyA9IG5ldyBSZXN1bHRBcnJheTxWYWxpZEF0dHI+KCk7XG4gICAgbGV0IGFyZ3MgPSBuZXcgUmVzdWx0QXJyYXk8bWlyLk5hbWVkQXJndW1lbnQ+KCk7XG5cbiAgICAvLyBVbmxpa2UgbW9zdCBhdHRyaWJ1dGVzLCB0aGUgYHR5cGVgIGF0dHJpYnV0ZSBjYW4gY2hhbmdlIGhvd1xuICAgIC8vIHN1YnNlcXVlbnQgYXR0cmlidXRlcyBhcmUgaW50ZXJwcmV0ZWQgYnkgdGhlIGJyb3dzZXIuIFRvIGFkZHJlc3NcbiAgICAvLyB0aGlzLCBpbiBzaW1wbGUgY2FzZXMsIHdlIHNwZWNpYWwgY2FzZSB0aGUgYHR5cGVgIGF0dHJpYnV0ZSB0byBiZSBzZXRcbiAgICAvLyBsYXN0LiBGb3IgZWxlbWVudHMgd2l0aCBzcGxhdHRyaWJ1dGVzLCB3aGVyZSBhdHRyaWJ1dGUgb3JkZXIgYWZmZWN0c1xuICAgIC8vIHByZWNlZGVuY2UsIHRoaXMgcmUtb3JkZXJpbmcgaGFwcGVucyBhdCBydW50aW1lIGluc3RlYWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGltbWVyanMvZ2xpbW1lci12bS9wdWxsLzcyNlxuICAgIGxldCB0eXBlQXR0cjogQVNUdjIuQXR0ck5vZGUgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgc2ltcGxlID0gdGhpcy5lbGVtZW50LmF0dHJzLmZpbHRlcigoYXR0cikgPT4gYXR0ci50eXBlID09PSAnU3BsYXRBdHRyJykubGVuZ3RoID09PSAwO1xuXG4gICAgZm9yIChsZXQgYXR0ciBvZiB0aGlzLmVsZW1lbnQuYXR0cnMpIHtcbiAgICAgIGlmIChhdHRyLnR5cGUgPT09ICdTcGxhdEF0dHInKSB7XG4gICAgICAgIGF0dHJzLmFkZChcbiAgICAgICAgICBPayhuZXcgbWlyLlNwbGF0QXR0cih7IGxvYzogYXR0ci5sb2MsIHN5bWJvbDogdGhpcy5zdGF0ZS5zY29wZS5hbGxvY2F0ZUJsb2NrKCdhdHRycycpIH0pKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChhdHRyLm5hbWUuY2hhcnMgPT09ICd0eXBlJyAmJiBzaW1wbGUpIHtcbiAgICAgICAgdHlwZUF0dHIgPSBhdHRyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMuYWRkKHRoaXMuYXR0cihhdHRyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgYXJnIG9mIHRoaXMuZWxlbWVudC5jb21wb25lbnRBcmdzKSB7XG4gICAgICBhcmdzLmFkZCh0aGlzLmRlbGVnYXRlLmFyZyhhcmcsIHRoaXMpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZUF0dHIpIHtcbiAgICAgIGF0dHJzLmFkZCh0aGlzLmF0dHIodHlwZUF0dHIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVzdWx0LmFsbChhcmdzLnRvQXJyYXkoKSwgYXR0cnMudG9BcnJheSgpKS5tYXBPaygoW2FyZ3MsIGF0dHJzXSkgPT4gKHtcbiAgICAgIGF0dHJzLFxuICAgICAgYXJnczogbmV3IG1pci5OYW1lZEFyZ3VtZW50cyh7XG4gICAgICAgIGxvYzogbWF5YmVMb2MoYXJncywgU291cmNlU3Bhbi5OT05fRVhJU1RFTlQpLFxuICAgICAgICBlbnRyaWVzOiBPcHRpb25hbExpc3QoYXJncyksXG4gICAgICB9KSxcbiAgICB9KSk7XG4gIH1cblxuICBwcml2YXRlIHByZXBhcmUoKTogUmVzdWx0PFByZXBhcmVkQXJncz4ge1xuICAgIGxldCBhdHRycyA9IHRoaXMuYXR0cnMoKTtcbiAgICBsZXQgbW9kaWZpZXJzID0gbmV3IFJlc3VsdEFycmF5KHRoaXMuZWxlbWVudC5tb2RpZmllcnMubWFwKChtKSA9PiB0aGlzLm1vZGlmaWVyKG0pKSkudG9BcnJheSgpO1xuXG4gICAgcmV0dXJuIFJlc3VsdC5hbGwoYXR0cnMsIG1vZGlmaWVycykubWFwT2soKFtyZXN1bHQsIG1vZGlmaWVyc10pID0+IHtcbiAgICAgIGxldCB7IGF0dHJzLCBhcmdzIH0gPSByZXN1bHQ7XG5cbiAgICAgIGxldCBlbGVtZW50UGFyYW1zID0gWy4uLmF0dHJzLCAuLi5tb2RpZmllcnNdO1xuXG4gICAgICBsZXQgcGFyYW1zID0gbmV3IG1pci5FbGVtZW50UGFyYW1ldGVycyh7XG4gICAgICAgIGxvYzogbWF5YmVMb2MoZWxlbWVudFBhcmFtcywgU291cmNlU3Bhbi5OT05fRVhJU1RFTlQpLFxuICAgICAgICBib2R5OiBPcHRpb25hbExpc3QoZWxlbWVudFBhcmFtcyksXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHsgYXJncywgcGFyYW1zIH07XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmVwYXJlZEFyZ3Mge1xuICBhcmdzOiBtaXIuTmFtZWRBcmd1bWVudHM7XG4gIHBhcmFtczogbWlyLkVsZW1lbnRQYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzRHluYW1pY0ZlYXR1cmVzKHtcbiAgYXR0cnMsXG4gIG1vZGlmaWVycyxcbn06IFBpY2s8QVNUdjIuRWxlbWVudE5vZGUsICdhdHRycycgfCAnbW9kaWZpZXJzJz4pOiBib29sZWFuIHtcbiAgLy8gRWxlbWVudE1vZGlmaWVyIG5lZWRzIHRoZSBzcGVjaWFsIENvbXBvbmVudE9wZXJhdGlvbnNcbiAgaWYgKG1vZGlmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBTcGxhdHRyaWJ1dGVzIG5lZWQgdGhlIHNwZWNpYWwgQ29tcG9uZW50T3BlcmF0aW9ucyB0byBtZXJnZSBpbnRvXG4gIHJldHVybiAhIWF0dHJzLmZpbHRlcigoYXR0cikgPT4gYXR0ci50eXBlID09PSAnU3BsYXRBdHRyJylbMF07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9