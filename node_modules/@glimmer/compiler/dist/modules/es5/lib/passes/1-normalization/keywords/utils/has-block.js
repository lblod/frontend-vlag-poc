import { ASTv2, generateSyntaxError, SourceSlice } from '@glimmer/syntax';
import { Err, Ok } from '../../../../shared/result';
import * as mir from '../../../2-encoding/mir';

function assertHasBlockKeyword(type) {
  return function (node) {
    var call = node.type === 'AppendContent' ? node.value : node;
    var named = call.type === 'Call' ? call.args.named : null;
    var positionals = call.type === 'Call' ? call.args.positional : null;

    if (named && !named.isEmpty()) {
      return Err(generateSyntaxError("(" + type + ") does not take any named arguments", call.loc));
    }

    if (!positionals || positionals.isEmpty()) {
      return Ok(SourceSlice.synthetic('default'));
    } else if (positionals.exprs.length === 1) {
      var positional = positionals.exprs[0];

      if (ASTv2.isLiteral(positional, 'string')) {
        return Ok(positional.toSlice());
      } else {
        return Err(generateSyntaxError("(" + type + ") can only receive a string literal as its first argument", call.loc));
      }
    } else {
      return Err(generateSyntaxError("(" + type + ") only takes a single positional argument", call.loc));
    }
  };
}

function translateHasBlockKeyword(type) {
  return function (_ref, target) {
    var node = _ref.node,
        scope = _ref.state.scope;
    var block = type === 'has-block' ? new mir.HasBlock({
      loc: node.loc,
      target: target,
      symbol: scope.allocateBlock(target.chars)
    }) : new mir.HasBlockParams({
      loc: node.loc,
      target: target,
      symbol: scope.allocateBlock(target.chars)
    });
    return Ok(block);
  };
}

export function hasBlockKeyword(type) {
  return {
    assert: assertHasBlockKeyword(type),
    translate: translateHasBlockKeyword(type)
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL2tleXdvcmRzL3V0aWxzL2hhcy1ibG9jay50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFBLEtBQUEsRUFBQSxtQkFBQSxFQUFBLFdBQUEsUUFBQSxpQkFBQTtBQUVBLFNBQUEsR0FBQSxFQUFBLEVBQUEsUUFBQSwyQkFBQTtBQUNBLE9BQU8sS0FBUCxHQUFBLE1BQUEseUJBQUE7O0FBSUEsU0FBQSxxQkFBQSxDQUFBLElBQUEsRUFBMkM7QUFDekMsU0FBUSxVQUFBLElBQUQsRUFBa0Q7QUFDdkQsUUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFKLElBQUEsS0FBQSxlQUFBLEdBQWdDLElBQUksQ0FBcEMsS0FBQSxHQUFYLElBQUE7QUFFQSxRQUFJLEtBQUssR0FBRyxJQUFJLENBQUosSUFBQSxLQUFBLE1BQUEsR0FBdUIsSUFBSSxDQUFKLElBQUEsQ0FBdkIsS0FBQSxHQUFaLElBQUE7QUFDQSxRQUFJLFdBQVcsR0FBRyxJQUFJLENBQUosSUFBQSxLQUFBLE1BQUEsR0FBdUIsSUFBSSxDQUFKLElBQUEsQ0FBdkIsVUFBQSxHQUFsQixJQUFBOztBQUVBLFFBQUksS0FBSyxJQUFJLENBQUMsS0FBSyxDQUFuQixPQUFjLEVBQWQsRUFBK0I7QUFDN0IsYUFBTyxHQUFHLENBQUMsbUJBQW1CLE9BQUEsSUFBQSwwQ0FBZ0QsSUFBSSxDQUFsRixHQUE4QixDQUFwQixDQUFWO0FBQ0Q7O0FBRUQsUUFBSSxDQUFBLFdBQUEsSUFBZ0IsV0FBVyxDQUEvQixPQUFvQixFQUFwQixFQUEyQztBQUN6QyxhQUFPLEVBQUUsQ0FBQyxXQUFXLENBQVgsU0FBQSxDQUFWLFNBQVUsQ0FBRCxDQUFUO0FBREYsS0FBQSxNQUVPLElBQUksV0FBVyxDQUFYLEtBQUEsQ0FBQSxNQUFBLEtBQUosQ0FBQSxFQUFvQztBQUN6QyxVQUFJLFVBQVUsR0FBRyxXQUFXLENBQVgsS0FBQSxDQUFqQixDQUFpQixDQUFqQjs7QUFDQSxVQUFJLEtBQUssQ0FBTCxTQUFBLENBQUEsVUFBQSxFQUFKLFFBQUksQ0FBSixFQUEyQztBQUN6QyxlQUFPLEVBQUUsQ0FBQyxVQUFVLENBQXBCLE9BQVUsRUFBRCxDQUFUO0FBREYsT0FBQSxNQUVPO0FBQ0wsZUFBTyxHQUFHLENBQ1IsbUJBQW1CLE9BQUEsSUFBQSxnRUFFakIsSUFBSSxDQUhSLEdBQ3FCLENBRFgsQ0FBVjtBQU1EO0FBWEksS0FBQSxNQVlBO0FBQ0wsYUFBTyxHQUFHLENBQ1IsbUJBQW1CLE9BQUEsSUFBQSxnREFBc0QsSUFBSSxDQUQvRSxHQUNxQixDQURYLENBQVY7QUFHRDtBQTVCSCxHQUFBO0FBOEJEOztBQUVELFNBQUEsd0JBQUEsQ0FBQSxJQUFBLEVBQThDO0FBQzVDLFNBQU8sZ0JBQUEsTUFBQSxFQUd3QztBQUFBLFFBRjdDLElBRTZDLFFBRjdDLElBRTZDO0FBQUEsUUFGNUIsS0FFNEIsUUFGckMsS0FFcUMsQ0FGNUIsS0FFNEI7QUFDN0MsUUFBSSxLQUFLLEdBQ1AsSUFBSSxLQUFKLFdBQUEsR0FDSSxJQUFJLEdBQUcsQ0FBUCxRQUFBLENBQWlCO0FBQUUsTUFBQSxHQUFHLEVBQUUsSUFBSSxDQUFYLEdBQUE7QUFBaUIsTUFBQSxNQUFqQixFQUFpQixNQUFqQjtBQUF5QixNQUFBLE1BQU0sRUFBRSxLQUFLLENBQUwsYUFBQSxDQUFvQixNQUFNLENBQTFCLEtBQUE7QUFBakMsS0FBakIsQ0FESixHQUVJLElBQUksR0FBRyxDQUFQLGNBQUEsQ0FBdUI7QUFDckIsTUFBQSxHQUFHLEVBQUUsSUFBSSxDQURZLEdBQUE7QUFFckIsTUFBQSxNQUZxQixFQUVyQixNQUZxQjtBQUdyQixNQUFBLE1BQU0sRUFBRSxLQUFLLENBQUwsYUFBQSxDQUFvQixNQUFNLENBQTFCLEtBQUE7QUFIYSxLQUF2QixDQUhOO0FBU0EsV0FBTyxFQUFFLENBQVQsS0FBUyxDQUFUO0FBYkYsR0FBQTtBQWVEOztBQUVELE9BQU0sU0FBQSxlQUFBLENBQUEsSUFBQSxFQUNRO0FBTVosU0FBTztBQUNMLElBQUEsTUFBTSxFQUFFLHFCQUFxQixDQUR4QixJQUN3QixDQUR4QjtBQUVMLElBQUEsU0FBUyxFQUFFLHdCQUF3QixDQUFBLElBQUE7QUFGOUIsR0FBUDtBQUlEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQVNUdjIsIGdlbmVyYXRlU3ludGF4RXJyb3IsIFNvdXJjZVNsaWNlIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcblxuaW1wb3J0IHsgRXJyLCBPaywgUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL3Jlc3VsdCc7XG5pbXBvcnQgKiBhcyBtaXIgZnJvbSAnLi4vLi4vLi4vMi1lbmNvZGluZy9taXInO1xuaW1wb3J0IHsgTm9ybWFsaXphdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vY29udGV4dCc7XG5pbXBvcnQgeyBHZW5lcmljS2V5d29yZE5vZGUsIEtleXdvcmREZWxlZ2F0ZSB9IGZyb20gJy4uL2ltcGwnO1xuXG5mdW5jdGlvbiBhc3NlcnRIYXNCbG9ja0tleXdvcmQodHlwZTogc3RyaW5nKSB7XG4gIHJldHVybiAobm9kZTogR2VuZXJpY0tleXdvcmROb2RlKTogUmVzdWx0PFNvdXJjZVNsaWNlPiA9PiB7XG4gICAgbGV0IGNhbGwgPSBub2RlLnR5cGUgPT09ICdBcHBlbmRDb250ZW50JyA/IG5vZGUudmFsdWUgOiBub2RlO1xuXG4gICAgbGV0IG5hbWVkID0gY2FsbC50eXBlID09PSAnQ2FsbCcgPyBjYWxsLmFyZ3MubmFtZWQgOiBudWxsO1xuICAgIGxldCBwb3NpdGlvbmFscyA9IGNhbGwudHlwZSA9PT0gJ0NhbGwnID8gY2FsbC5hcmdzLnBvc2l0aW9uYWwgOiBudWxsO1xuXG4gICAgaWYgKG5hbWVkICYmICFuYW1lZC5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBFcnIoZ2VuZXJhdGVTeW50YXhFcnJvcihgKCR7dHlwZX0pIGRvZXMgbm90IHRha2UgYW55IG5hbWVkIGFyZ3VtZW50c2AsIGNhbGwubG9jKSk7XG4gICAgfVxuXG4gICAgaWYgKCFwb3NpdGlvbmFscyB8fCBwb3NpdGlvbmFscy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBPayhTb3VyY2VTbGljZS5zeW50aGV0aWMoJ2RlZmF1bHQnKSk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbmFscy5leHBycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxldCBwb3NpdGlvbmFsID0gcG9zaXRpb25hbHMuZXhwcnNbMF07XG4gICAgICBpZiAoQVNUdjIuaXNMaXRlcmFsKHBvc2l0aW9uYWwsICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm4gT2socG9zaXRpb25hbC50b1NsaWNlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEVycihcbiAgICAgICAgICBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgICAgYCgke3R5cGV9KSBjYW4gb25seSByZWNlaXZlIGEgc3RyaW5nIGxpdGVyYWwgYXMgaXRzIGZpcnN0IGFyZ3VtZW50YCxcbiAgICAgICAgICAgIGNhbGwubG9jXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gRXJyKFxuICAgICAgICBnZW5lcmF0ZVN5bnRheEVycm9yKGAoJHt0eXBlfSkgb25seSB0YWtlcyBhIHNpbmdsZSBwb3NpdGlvbmFsIGFyZ3VtZW50YCwgY2FsbC5sb2MpXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlSGFzQmxvY2tLZXl3b3JkKHR5cGU6IHN0cmluZykge1xuICByZXR1cm4gKFxuICAgIHsgbm9kZSwgc3RhdGU6IHsgc2NvcGUgfSB9OiB7IG5vZGU6IEFTVHYyLkNhbGxFeHByZXNzaW9uOyBzdGF0ZTogTm9ybWFsaXphdGlvblN0YXRlIH0sXG4gICAgdGFyZ2V0OiBTb3VyY2VTbGljZVxuICApOiBSZXN1bHQ8bWlyLkhhc0Jsb2NrIHwgbWlyLkhhc0Jsb2NrUGFyYW1zPiA9PiB7XG4gICAgbGV0IGJsb2NrID1cbiAgICAgIHR5cGUgPT09ICdoYXMtYmxvY2snXG4gICAgICAgID8gbmV3IG1pci5IYXNCbG9jayh7IGxvYzogbm9kZS5sb2MsIHRhcmdldCwgc3ltYm9sOiBzY29wZS5hbGxvY2F0ZUJsb2NrKHRhcmdldC5jaGFycykgfSlcbiAgICAgICAgOiBuZXcgbWlyLkhhc0Jsb2NrUGFyYW1zKHtcbiAgICAgICAgICAgIGxvYzogbm9kZS5sb2MsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICBzeW1ib2w6IHNjb3BlLmFsbG9jYXRlQmxvY2sodGFyZ2V0LmNoYXJzKSxcbiAgICAgICAgICB9KTtcblxuICAgIHJldHVybiBPayhibG9jayk7XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNCbG9ja0tleXdvcmQoXG4gIHR5cGU6IHN0cmluZ1xuKTogS2V5d29yZERlbGVnYXRlPFxuICBBU1R2Mi5DYWxsRXhwcmVzc2lvbiB8IEFTVHYyLkFwcGVuZENvbnRlbnQsXG4gIFNvdXJjZVNsaWNlLFxuICBtaXIuSGFzQmxvY2sgfCBtaXIuSGFzQmxvY2tQYXJhbXNcbj4ge1xuICByZXR1cm4ge1xuICAgIGFzc2VydDogYXNzZXJ0SGFzQmxvY2tLZXl3b3JkKHR5cGUpLFxuICAgIHRyYW5zbGF0ZTogdHJhbnNsYXRlSGFzQmxvY2tLZXl3b3JkKHR5cGUpLFxuICB9O1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==