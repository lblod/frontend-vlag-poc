import { ASTv2, generateSyntaxError, SourceSpan } from '@glimmer/syntax';
import { Err, Ok, Result } from '../../../shared/result';
import * as mir from '../../2-encoding/mir';
import { VISIT_EXPRS } from '../visitors/expressions';
import { keywords } from './impl';
import { toAppend } from './utils/call-to-append';
import { assertCurryKeyword } from './utils/curry';
import { getDynamicVarKeyword } from './utils/dynamic-vars';
import { hasBlockKeyword } from './utils/has-block';
import { ifUnlessInlineKeyword } from './utils/if-unless';
import { logKeyword } from './utils/log';
export var APPEND_KEYWORDS = keywords('Append').kw('has-block', toAppend(hasBlockKeyword('has-block'))).kw('has-block-params', toAppend(hasBlockKeyword('has-block-params'))).kw('-get-dynamic-var', toAppend(getDynamicVarKeyword)).kw('log', toAppend(logKeyword)).kw('if', toAppend(ifUnlessInlineKeyword('if'))).kw('unless', toAppend(ifUnlessInlineKeyword('unless'))).kw('yield', {
  assert: function assert(node) {
    var args = node.args;

    if (args.named.isEmpty()) {
      return Ok({
        target: SourceSpan.synthetic('default').toSlice(),
        positional: args.positional
      });
    } else {
      var target = args.named.get('to');

      if (args.named.size > 1 || target === null) {
        return Err(generateSyntaxError("yield only takes a single named argument: 'to'", args.named.loc));
      }

      if (ASTv2.isLiteral(target, 'string')) {
        return Ok({
          target: target.toSlice(),
          positional: args.positional
        });
      } else {
        return Err(generateSyntaxError("you can only yield to a literal string value", target.loc));
      }
    }
  },
  translate: function translate(_ref, _ref2) {
    var node = _ref.node,
        state = _ref.state;
    var target = _ref2.target,
        positional = _ref2.positional;
    return VISIT_EXPRS.Positional(positional, state).mapOk(function (positional) {
      return new mir.Yield({
        loc: node.loc,
        target: target,
        to: state.scope.allocateBlock(target.chars),
        positional: positional
      });
    });
  }
}).kw('debugger', {
  assert: function assert(node) {
    var args = node.args;
    var positional = args.positional;

    if (args.isEmpty()) {
      return Ok(undefined);
    } else {
      if (positional.isEmpty()) {
        return Err(generateSyntaxError("debugger does not take any named arguments", node.loc));
      } else {
        return Err(generateSyntaxError("debugger does not take any positional arguments", node.loc));
      }
    }
  },
  translate: function translate(_ref3) {
    var node = _ref3.node,
        scope = _ref3.state.scope;
    scope.setHasEval();
    return Ok(new mir.Debugger({
      loc: node.loc,
      scope: scope
    }));
  }
}).kw('component', {
  assert: assertCurryKeyword(0
  /* Component */
  ),
  translate: function translate(_ref4, _ref5) {
    var node = _ref4.node,
        state = _ref4.state;
    var definition = _ref5.definition,
        args = _ref5.args;
    var definitionResult = VISIT_EXPRS.visit(definition, state);
    var argsResult = VISIT_EXPRS.Args(args, state);
    return Result.all(definitionResult, argsResult).mapOk(function (_ref6) {
      var definition = _ref6[0],
          args = _ref6[1];
      return new mir.InvokeComponent({
        loc: node.loc,
        definition: definition,
        args: args,
        blocks: null
      });
    });
  }
}).kw('helper', {
  assert: assertCurryKeyword(1
  /* Helper */
  ),
  translate: function translate(_ref7, _ref8) {
    var node = _ref7.node,
        state = _ref7.state;
    var definition = _ref8.definition,
        args = _ref8.args;
    var definitionResult = VISIT_EXPRS.visit(definition, state);
    var argsResult = VISIT_EXPRS.Args(args, state);
    return Result.all(definitionResult, argsResult).mapOk(function (_ref9) {
      var definition = _ref9[0],
          args = _ref9[1];
      var text = new mir.CallExpression({
        callee: definition,
        args: args,
        loc: node.loc
      });
      return new mir.AppendTextNode({
        loc: node.loc,
        text: text
      });
    });
  }
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL2tleXdvcmRzL2FwcGVuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxTQUFBLEtBQUEsRUFBQSxtQkFBQSxFQUFBLFVBQUEsUUFBQSxpQkFBQTtBQUVBLFNBQUEsR0FBQSxFQUFBLEVBQUEsRUFBQSxNQUFBLFFBQUEsd0JBQUE7QUFDQSxPQUFPLEtBQVAsR0FBQSxNQUFBLHNCQUFBO0FBRUEsU0FBQSxXQUFBLFFBQUEseUJBQUE7QUFDQSxTQUFBLFFBQUEsUUFBQSxRQUFBO0FBQ0EsU0FBQSxRQUFBLFFBQUEsd0JBQUE7QUFDQSxTQUFBLGtCQUFBLFFBQUEsZUFBQTtBQUNBLFNBQUEsb0JBQUEsUUFBQSxzQkFBQTtBQUNBLFNBQUEsZUFBQSxRQUFBLG1CQUFBO0FBQ0EsU0FBQSxxQkFBQSxRQUFBLG1CQUFBO0FBQ0EsU0FBQSxVQUFBLFFBQUEsYUFBQTtBQUVBLE9BQU8sSUFBTSxlQUFlLEdBQUcsUUFBUSxDQUFSLFFBQVEsQ0FBUixDQUFBLEVBQUEsQ0FBQSxXQUFBLEVBQ1osUUFBUSxDQUFDLGVBQWUsQ0FEWixXQUNZLENBQWhCLENBREksRUFBQSxFQUFBLENBQUEsa0JBQUEsRUFFTCxRQUFRLENBQUMsZUFBZSxDQUZuQixrQkFFbUIsQ0FBaEIsQ0FGSCxFQUFBLEVBQUEsQ0FBQSxrQkFBQSxFQUdMLFFBQVEsQ0FISCxvQkFHRyxDQUhILEVBQUEsRUFBQSxDQUFBLEtBQUEsRUFJbEIsUUFBUSxDQUpVLFVBSVYsQ0FKVSxFQUFBLEVBQUEsQ0FBQSxJQUFBLEVBS25CLFFBQVEsQ0FBQyxxQkFBcUIsQ0FMWCxJQUtXLENBQXRCLENBTFcsRUFBQSxFQUFBLENBQUEsUUFBQSxFQU1mLFFBQVEsQ0FBQyxxQkFBcUIsQ0FOZixRQU1lLENBQXRCLENBTk8sRUFBQSxFQUFBLENBQUEsT0FBQSxFQU9oQjtBQUNYLEVB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S0FBQSxDQUFBLFVBQUEsRUFBdkIsS0FBdUIsQ0FBdkI7QUFDQSxRQUFJLFVBQVUsR0FBRyxXQUFXLENBQVgsSUFBQSxDQUFBLElBQUEsRUFBakIsS0FBaUIsQ0FBakI7QUFFQSxXQUFPLE1BQU0sQ0FBTixHQUFBLENBQUEsZ0JBQUEsRUFBQSxVQUFBLEVBQUEsS0FBQSxDQUErQyxpQkFBdUI7QUFBQSxVQUF0QixVQUFzQjtBQUFBLFVBQXZCLElBQXVCO0FBQzNFLFVBQUksSUFBSSxHQUFHLElBQUksR0FBRyxDQUFQLGNBQUEsQ0FBdUI7QUFBRSxRQUFBLE1BQU0sRUFBUixVQUFBO0FBQXNCLFFBQUEsSUFBdEIsRUFBc0IsSUFBdEI7QUFBNEIsUUFBQSxHQUFHLEVBQUUsSUFBSSxDQUFDO0FBQXRDLE9BQXZCLENBQVg7QUFFQSxhQUFPLElBQUksR0FBRyxDQUFQLGNBQUEsQ0FBdUI7QUFDNUIsUUFBQSxHQUFHLEVBQUUsSUFBSSxDQURtQixHQUFBO0FBRTVCLFFBQUEsSUFBQSxFQUFBO0FBRjRCLE9BQXZCLENBQVA7QUFIRixLQUFPLENBQVA7QUFRRDtBQWxCVyxDQS9HZSxDQUF4QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEN1cnJpZWRUeXBlIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBBU1R2MiwgZ2VuZXJhdGVTeW50YXhFcnJvciwgU291cmNlU2xpY2UsIFNvdXJjZVNwYW4gfSBmcm9tICdAZ2xpbW1lci9zeW50YXgnO1xuXG5pbXBvcnQgeyBFcnIsIE9rLCBSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvcmVzdWx0JztcbmltcG9ydCAqIGFzIG1pciBmcm9tICcuLi8uLi8yLWVuY29kaW5nL21pcic7XG5pbXBvcnQgeyBOb3JtYWxpemF0aW9uU3RhdGUgfSBmcm9tICcuLi9jb250ZXh0JztcbmltcG9ydCB7IFZJU0lUX0VYUFJTIH0gZnJvbSAnLi4vdmlzaXRvcnMvZXhwcmVzc2lvbnMnO1xuaW1wb3J0IHsga2V5d29yZHMgfSBmcm9tICcuL2ltcGwnO1xuaW1wb3J0IHsgdG9BcHBlbmQgfSBmcm9tICcuL3V0aWxzL2NhbGwtdG8tYXBwZW5kJztcbmltcG9ydCB7IGFzc2VydEN1cnJ5S2V5d29yZCB9IGZyb20gJy4vdXRpbHMvY3VycnknO1xuaW1wb3J0IHsgZ2V0RHluYW1pY1ZhcktleXdvcmQgfSBmcm9tICcuL3V0aWxzL2R5bmFtaWMtdmFycyc7XG5pbXBvcnQgeyBoYXNCbG9ja0tleXdvcmQgfSBmcm9tICcuL3V0aWxzL2hhcy1ibG9jayc7XG5pbXBvcnQgeyBpZlVubGVzc0lubGluZUtleXdvcmQgfSBmcm9tICcuL3V0aWxzL2lmLXVubGVzcyc7XG5pbXBvcnQgeyBsb2dLZXl3b3JkIH0gZnJvbSAnLi91dGlscy9sb2cnO1xuXG5leHBvcnQgY29uc3QgQVBQRU5EX0tFWVdPUkRTID0ga2V5d29yZHMoJ0FwcGVuZCcpXG4gIC5rdygnaGFzLWJsb2NrJywgdG9BcHBlbmQoaGFzQmxvY2tLZXl3b3JkKCdoYXMtYmxvY2snKSkpXG4gIC5rdygnaGFzLWJsb2NrLXBhcmFtcycsIHRvQXBwZW5kKGhhc0Jsb2NrS2V5d29yZCgnaGFzLWJsb2NrLXBhcmFtcycpKSlcbiAgLmt3KCctZ2V0LWR5bmFtaWMtdmFyJywgdG9BcHBlbmQoZ2V0RHluYW1pY1ZhcktleXdvcmQpKVxuICAua3coJ2xvZycsIHRvQXBwZW5kKGxvZ0tleXdvcmQpKVxuICAua3coJ2lmJywgdG9BcHBlbmQoaWZVbmxlc3NJbmxpbmVLZXl3b3JkKCdpZicpKSlcbiAgLmt3KCd1bmxlc3MnLCB0b0FwcGVuZChpZlVubGVzc0lubGluZUtleXdvcmQoJ3VubGVzcycpKSlcbiAgLmt3KCd5aWVsZCcsIHtcbiAgICBhc3NlcnQoXG4gICAgICBub2RlOiBBU1R2Mi5BcHBlbmRDb250ZW50XG4gICAgKTogUmVzdWx0PHtcbiAgICAgIHRhcmdldDogU291cmNlU2xpY2U7XG4gICAgICBwb3NpdGlvbmFsOiBBU1R2Mi5Qb3NpdGlvbmFsQXJndW1lbnRzO1xuICAgIH0+IHtcbiAgICAgIGxldCB7IGFyZ3MgfSA9IG5vZGU7XG5cbiAgICAgIGlmIChhcmdzLm5hbWVkLmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gT2soe1xuICAgICAgICAgIHRhcmdldDogU291cmNlU3Bhbi5zeW50aGV0aWMoJ2RlZmF1bHQnKS50b1NsaWNlKCksXG4gICAgICAgICAgcG9zaXRpb25hbDogYXJncy5wb3NpdGlvbmFsLFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSBhcmdzLm5hbWVkLmdldCgndG8nKTtcblxuICAgICAgICBpZiAoYXJncy5uYW1lZC5zaXplID4gMSB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gRXJyKFxuICAgICAgICAgICAgZ2VuZXJhdGVTeW50YXhFcnJvcihgeWllbGQgb25seSB0YWtlcyBhIHNpbmdsZSBuYW1lZCBhcmd1bWVudDogJ3RvJ2AsIGFyZ3MubmFtZWQubG9jKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQVNUdjIuaXNMaXRlcmFsKHRhcmdldCwgJ3N0cmluZycpKSB7XG4gICAgICAgICAgcmV0dXJuIE9rKHsgdGFyZ2V0OiB0YXJnZXQudG9TbGljZSgpLCBwb3NpdGlvbmFsOiBhcmdzLnBvc2l0aW9uYWwgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIEVycihcbiAgICAgICAgICAgIGdlbmVyYXRlU3ludGF4RXJyb3IoYHlvdSBjYW4gb25seSB5aWVsZCB0byBhIGxpdGVyYWwgc3RyaW5nIHZhbHVlYCwgdGFyZ2V0LmxvYylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZShcbiAgICAgIHsgbm9kZSwgc3RhdGUgfTogeyBub2RlOiBBU1R2Mi5BcHBlbmRDb250ZW50OyBzdGF0ZTogTm9ybWFsaXphdGlvblN0YXRlIH0sXG4gICAgICB7XG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgcG9zaXRpb25hbCxcbiAgICAgIH06IHtcbiAgICAgICAgdGFyZ2V0OiBTb3VyY2VTbGljZTtcbiAgICAgICAgcG9zaXRpb25hbDogQVNUdjIuUG9zaXRpb25hbEFyZ3VtZW50cztcbiAgICAgIH1cbiAgICApOiBSZXN1bHQ8bWlyLlN0YXRlbWVudD4ge1xuICAgICAgcmV0dXJuIFZJU0lUX0VYUFJTLlBvc2l0aW9uYWwocG9zaXRpb25hbCwgc3RhdGUpLm1hcE9rKFxuICAgICAgICAocG9zaXRpb25hbCkgPT5cbiAgICAgICAgICBuZXcgbWlyLllpZWxkKHtcbiAgICAgICAgICAgIGxvYzogbm9kZS5sb2MsXG4gICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICB0bzogc3RhdGUuc2NvcGUuYWxsb2NhdGVCbG9jayh0YXJnZXQuY2hhcnMpLFxuICAgICAgICAgICAgcG9zaXRpb25hbCxcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9LFxuICB9KVxuICAua3coJ2RlYnVnZ2VyJywge1xuICAgIGFzc2VydChub2RlOiBBU1R2Mi5BcHBlbmRDb250ZW50KTogUmVzdWx0PHZvaWQ+IHtcbiAgICAgIGxldCB7IGFyZ3MgfSA9IG5vZGU7XG4gICAgICBsZXQgeyBwb3NpdGlvbmFsIH0gPSBhcmdzO1xuXG4gICAgICBpZiAoYXJncy5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIE9rKHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocG9zaXRpb25hbC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICByZXR1cm4gRXJyKGdlbmVyYXRlU3ludGF4RXJyb3IoYGRlYnVnZ2VyIGRvZXMgbm90IHRha2UgYW55IG5hbWVkIGFyZ3VtZW50c2AsIG5vZGUubG9jKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIEVycihcbiAgICAgICAgICAgIGdlbmVyYXRlU3ludGF4RXJyb3IoYGRlYnVnZ2VyIGRvZXMgbm90IHRha2UgYW55IHBvc2l0aW9uYWwgYXJndW1lbnRzYCwgbm9kZS5sb2MpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmFuc2xhdGUoe1xuICAgICAgbm9kZSxcbiAgICAgIHN0YXRlOiB7IHNjb3BlIH0sXG4gICAgfToge1xuICAgICAgbm9kZTogQVNUdjIuQXBwZW5kQ29udGVudDtcbiAgICAgIHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGU7XG4gICAgfSk6IFJlc3VsdDxtaXIuU3RhdGVtZW50PiB7XG4gICAgICBzY29wZS5zZXRIYXNFdmFsKCk7XG4gICAgICByZXR1cm4gT2sobmV3IG1pci5EZWJ1Z2dlcih7IGxvYzogbm9kZS5sb2MsIHNjb3BlIH0pKTtcbiAgICB9LFxuICB9KVxuICAua3coJ2NvbXBvbmVudCcsIHtcbiAgICBhc3NlcnQ6IGFzc2VydEN1cnJ5S2V5d29yZChDdXJyaWVkVHlwZS5Db21wb25lbnQpLFxuXG4gICAgdHJhbnNsYXRlKFxuICAgICAgeyBub2RlLCBzdGF0ZSB9OiB7IG5vZGU6IEFTVHYyLkFwcGVuZENvbnRlbnQ7IHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGUgfSxcbiAgICAgIHsgZGVmaW5pdGlvbiwgYXJncyB9OiB7IGRlZmluaXRpb246IEFTVHYyLkV4cHJlc3Npb25Ob2RlOyBhcmdzOiBBU1R2Mi5BcmdzIH1cbiAgICApOiBSZXN1bHQ8bWlyLkludm9rZUNvbXBvbmVudD4ge1xuICAgICAgbGV0IGRlZmluaXRpb25SZXN1bHQgPSBWSVNJVF9FWFBSUy52aXNpdChkZWZpbml0aW9uLCBzdGF0ZSk7XG4gICAgICBsZXQgYXJnc1Jlc3VsdCA9IFZJU0lUX0VYUFJTLkFyZ3MoYXJncywgc3RhdGUpO1xuXG4gICAgICByZXR1cm4gUmVzdWx0LmFsbChkZWZpbml0aW9uUmVzdWx0LCBhcmdzUmVzdWx0KS5tYXBPayhcbiAgICAgICAgKFtkZWZpbml0aW9uLCBhcmdzXSkgPT5cbiAgICAgICAgICBuZXcgbWlyLkludm9rZUNvbXBvbmVudCh7XG4gICAgICAgICAgICBsb2M6IG5vZGUubG9jLFxuICAgICAgICAgICAgZGVmaW5pdGlvbixcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICBibG9ja3M6IG51bGwsXG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSxcbiAgfSlcbiAgLmt3KCdoZWxwZXInLCB7XG4gICAgYXNzZXJ0OiBhc3NlcnRDdXJyeUtleXdvcmQoQ3VycmllZFR5cGUuSGVscGVyKSxcblxuICAgIHRyYW5zbGF0ZShcbiAgICAgIHsgbm9kZSwgc3RhdGUgfTogeyBub2RlOiBBU1R2Mi5BcHBlbmRDb250ZW50OyBzdGF0ZTogTm9ybWFsaXphdGlvblN0YXRlIH0sXG4gICAgICB7IGRlZmluaXRpb24sIGFyZ3MgfTogeyBkZWZpbml0aW9uOiBBU1R2Mi5FeHByZXNzaW9uTm9kZTsgYXJnczogQVNUdjIuQXJncyB9XG4gICAgKTogUmVzdWx0PG1pci5BcHBlbmRUZXh0Tm9kZT4ge1xuICAgICAgbGV0IGRlZmluaXRpb25SZXN1bHQgPSBWSVNJVF9FWFBSUy52aXNpdChkZWZpbml0aW9uLCBzdGF0ZSk7XG4gICAgICBsZXQgYXJnc1Jlc3VsdCA9IFZJU0lUX0VYUFJTLkFyZ3MoYXJncywgc3RhdGUpO1xuXG4gICAgICByZXR1cm4gUmVzdWx0LmFsbChkZWZpbml0aW9uUmVzdWx0LCBhcmdzUmVzdWx0KS5tYXBPaygoW2RlZmluaXRpb24sIGFyZ3NdKSA9PiB7XG4gICAgICAgIGxldCB0ZXh0ID0gbmV3IG1pci5DYWxsRXhwcmVzc2lvbih7IGNhbGxlZTogZGVmaW5pdGlvbiwgYXJncywgbG9jOiBub2RlLmxvYyB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IG1pci5BcHBlbmRUZXh0Tm9kZSh7XG4gICAgICAgICAgbG9jOiBub2RlLmxvYyxcbiAgICAgICAgICB0ZXh0LFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIH0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==