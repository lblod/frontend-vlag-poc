"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasDynamicFeatures = hasDynamicFeatures;
exports.ClassifiedElement = void 0;

var _syntax = require("@glimmer/syntax");

var _list = require("../../../../shared/list");

var _result = require("../../../../shared/result");

var _utils = require("../../../../utils");

var mir = _interopRequireWildcard(require("../../../2-encoding/mir"));

var _keywords = require("../../keywords");

var _isNode = require("../../utils/is-node");

var _expressions = require("../expressions");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var ClassifiedElement = /*#__PURE__*/function () {
  function ClassifiedElement(element, delegate, state) {
    this.element = element;
    this.state = state;
    this.delegate = delegate;
  }

  var _proto = ClassifiedElement.prototype;

  _proto.toStatement = function toStatement() {
    var _this = this;

    return this.prepare().andThen(function (prepared) {
      return _this.delegate.toStatement(_this, prepared);
    });
  };

  _proto.attr = function attr(_attr) {
    var _this2 = this;

    var name = _attr.name;
    var rawValue = _attr.value;
    var namespace = (0, _utils.getAttrNamespace)(name.chars) || undefined;

    if (_syntax.ASTv2.isLiteral(rawValue, 'string')) {
      return (0, _result.Ok)(new mir.StaticAttr({
        loc: _attr.loc,
        name: name,
        value: rawValue.toSlice(),
        namespace: namespace,
        kind: {
          component: this.delegate.dynamicFeatures
        }
      }));
    }

    return _expressions.VISIT_EXPRS.visit((0, _expressions.convertPathToCallIfKeyword)(rawValue), this.state).mapOk(function (value) {
      var isTrusting = _attr.trusting;
      return new mir.DynamicAttr({
        loc: _attr.loc,
        name: name,
        value: value,
        namespace: namespace,
        kind: {
          trusting: isTrusting,
          component: _this2.delegate.dynamicFeatures
        }
      });
    });
  };

  _proto.modifier = function modifier(_modifier) {
    if ((0, _isNode.isHelperInvocation)(_modifier)) {
      (0, _isNode.assertIsValidModifier)(_modifier);
    }

    var translated = _keywords.MODIFIER_KEYWORDS.translate(_modifier, this.state);

    if (translated !== null) {
      return translated;
    }

    var head = _expressions.VISIT_EXPRS.visit(_modifier.callee, this.state);

    var args = _expressions.VISIT_EXPRS.Args(_modifier.args, this.state);

    return _result.Result.all(head, args).mapOk(function (_ref) {
      var head = _ref[0],
          args = _ref[1];
      return new mir.Modifier({
        loc: _modifier.loc,
        callee: head,
        args: args
      });
    });
  };

  _proto.attrs = function attrs() {
    var attrs = new _result.ResultArray();
    var args = new _result.ResultArray(); // Unlike most attributes, the `type` attribute can change how
    // subsequent attributes are interpreted by the browser. To address
    // this, in simple cases, we special case the `type` attribute to be set
    // last. For elements with splattributes, where attribute order affects
    // precedence, this re-ordering happens at runtime instead.
    // See https://github.com/glimmerjs/glimmer-vm/pull/726

    var typeAttr = null;
    var simple = this.element.attrs.filter(function (attr) {
      return attr.type === 'SplatAttr';
    }).length === 0;

    for (var _iterator = _createForOfIteratorHelperLoose(this.element.attrs), _step; !(_step = _iterator()).done;) {
      var attr = _step.value;

      if (attr.type === 'SplatAttr') {
        attrs.add((0, _result.Ok)(new mir.SplatAttr({
          loc: attr.loc,
          symbol: this.state.scope.allocateBlock('attrs')
        })));
      } else if (attr.name.chars === 'type' && simple) {
        typeAttr = attr;
      } else {
        attrs.add(this.attr(attr));
      }
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(this.element.componentArgs), _step2; !(_step2 = _iterator2()).done;) {
      var arg = _step2.value;
      args.add(this.delegate.arg(arg, this));
    }

    if (typeAttr) {
      attrs.add(this.attr(typeAttr));
    }

    return _result.Result.all(args.toArray(), attrs.toArray()).mapOk(function (_ref2) {
      var args = _ref2[0],
          attrs = _ref2[1];
      return {
        attrs: attrs,
        args: new mir.NamedArguments({
          loc: (0, _syntax.maybeLoc)(args, _syntax.SourceSpan.NON_EXISTENT),
          entries: (0, _list.OptionalList)(args)
        })
      };
    });
  };

  _proto.prepare = function prepare() {
    var _this3 = this;

    var attrs = this.attrs();
    var modifiers = new _result.ResultArray(this.element.modifiers.map(function (m) {
      return _this3.modifier(m);
    })).toArray();
    return _result.Result.all(attrs, modifiers).mapOk(function (_ref3) {
      var result = _ref3[0],
          modifiers = _ref3[1];
      var attrs = result.attrs,
          args = result.args;
      var elementParams = [].concat(attrs, modifiers);
      var params = new mir.ElementParameters({
        loc: (0, _syntax.maybeLoc)(elementParams, _syntax.SourceSpan.NON_EXISTENT),
        body: (0, _list.OptionalList)(elementParams)
      });
      return {
        args: args,
        params: params
      };
    });
  };

  return ClassifiedElement;
}();

exports.ClassifiedElement = ClassifiedElement;

function hasDynamicFeatures(_ref4) {
  var attrs = _ref4.attrs,
      modifiers = _ref4.modifiers; // ElementModifier needs the special ComponentOperations

  if (modifiers.length > 0) {
    return true;
  } // Splattributes need the special ComponentOperations to merge into


  return !!attrs.filter(function (attr) {
    return attr.type === 'SplatAttr';
  })[0];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL3Zpc2l0b3JzL2VsZW1lbnQvY2xhc3NpZmllZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxJQUFNLGlCQUFOLEdBQUEsYUFBQSxZQUFBO0FBR0UsV0FBQSxpQkFBQSxDQUFBLE9BQUEsRUFBQSxRQUFBLEVBQUEsS0FBQSxFQUdvQztBQUZ6QixTQUFBLE9BQUEsR0FBQSxPQUFBO0FBRUEsU0FBQSxLQUFBLEdBQUEsS0FBQTtBQUVULFNBQUEsUUFBQSxHQUFBLFFBQUE7QUFDRDs7QUFUSCxNQUFBLE1BQUEsR0FBQSxpQkFBQSxDQUFBLFNBQUE7O0FBQUEsRUFBQSxNQUFBLENBQUEsV0FBQSxHQVdFLFNBQUEsV0FBQSxHQUFXO0FBQUEsUUFBQSxLQUFBLEdBQUEsSUFBQTs7QUFDVCxXQUFPLEtBQUEsT0FBQSxHQUFBLE9BQUEsQ0FBd0IsVUFBRCxRQUFDLEVBQUQ7QUFBQSxhQUFjLEtBQUEsQ0FBQSxRQUFBLENBQUEsV0FBQSxDQUFBLEtBQUEsRUFBNUMsUUFBNEMsQ0FBZDtBQUE5QixLQUFPLENBQVA7QUFaSixHQUFBOztBQUFBLEVBQUEsTUFBQSxDQUFBLElBQUEsR0FlVSxTQUFBLElBQUEsQ0FBQSxLQUFBLEVBQXlCO0FBQUEsUUFBQSxNQUFBLEdBQUEsSUFBQTs7QUFDL0IsUUFBSSxJQUFJLEdBQUcsS0FBSSxDQUFmLElBQUE7QUFDQSxRQUFJLFFBQVEsR0FBRyxLQUFJLENBQW5CLEtBQUE7QUFDQSxRQUFJLFNBQVMsR0FBRyw2QkFBaUIsSUFBSSxDQUFyQixLQUFBLEtBQWhCLFNBQUE7O0FBRUEsUUFBSSxjQUFB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VUFBSSxNQUFNLEdBQUcsSUFBSSxHQUFHLENBQVAsaUJBQUEsQ0FBMEI7QUFDckMsUUFBQSxHQUFHLEVBQUUsc0JBQVEsYUFBUixFQUF3QixtQkFEUSxZQUNoQyxDQURnQztBQUVyQyxRQUFBLElBQUksRUFBRSx3QkFBWSxhQUFaO0FBRitCLE9BQTFCLENBQWI7QUFLQSxhQUFPO0FBQUUsUUFBQSxJQUFGLEVBQUEsSUFBQTtBQUFRLFFBQUEsTUFBQSxFQUFBO0FBQVIsT0FBUDtBQVZGLEtBQU8sQ0FBUDtBQXhISixHQUFBOztBQUFBLFNBQUEsaUJBQUE7QUFBQSxDQUFBLEVBQUE7Ozs7QUE0SU0sU0FBQSxrQkFBQSxDQUFBLEtBQUEsRUFHMkM7QUFBQSxNQUhkLEtBR2MsR0FBQSxLQUFBLENBSGQsS0FHYztBQUFBLE1BRC9DLFNBQytDLEdBQUEsS0FBQSxDQUQvQyxTQUMrQyxDQUFBLENBQy9DOztBQUNBLE1BQUksU0FBUyxDQUFULE1BQUEsR0FBSixDQUFBLEVBQTBCO0FBQ3hCLFdBQUEsSUFBQTtBQUg2QyxHQUFBLENBTS9DOzs7QUFDQSxTQUFPLENBQUMsQ0FBQyxLQUFLLENBQUwsTUFBQSxDQUFjLFVBQUQsSUFBQyxFQUFEO0FBQUEsV0FBVSxJQUFJLENBQUosSUFBQSxLQUF2QixXQUFhO0FBQWIsR0FBQSxFQUFULENBQVMsQ0FBVDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQVNUdjIsIG1heWJlTG9jLCBTb3VyY2VTcGFuIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcblxuaW1wb3J0IHsgT3B0aW9uYWxMaXN0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpc3QnO1xuaW1wb3J0IHsgT2ssIFJlc3VsdCwgUmVzdWx0QXJyYXkgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvcmVzdWx0JztcbmltcG9ydCB7IGdldEF0dHJOYW1lc3BhY2UgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyBtaXIgZnJvbSAnLi4vLi4vLi4vMi1lbmNvZGluZy9taXInO1xuaW1wb3J0IHsgTm9ybWFsaXphdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vY29udGV4dCc7XG5pbXBvcnQgeyBNT0RJRklFUl9LRVlXT1JEUyB9IGZyb20gJy4uLy4uL2tleXdvcmRzJztcbmltcG9ydCB7IGFzc2VydElzVmFsaWRNb2RpZmllciwgaXNIZWxwZXJJbnZvY2F0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMvaXMtbm9kZSc7XG5pbXBvcnQgeyBjb252ZXJ0UGF0aFRvQ2FsbElmS2V5d29yZCwgVklTSVRfRVhQUlMgfSBmcm9tICcuLi9leHByZXNzaW9ucyc7XG5cbmV4cG9ydCB0eXBlIFZhbGlkQXR0ciA9IG1pci5TdGF0aWNBdHRyIHwgbWlyLkR5bmFtaWNBdHRyIHwgbWlyLlNwbGF0QXR0cjtcblxudHlwZSBQcm9jZXNzZWRBdHRyaWJ1dGVzID0ge1xuICBhdHRyczogVmFsaWRBdHRyW107XG4gIGFyZ3M6IG1pci5OYW1lZEFyZ3VtZW50cztcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xhc3NpZmllZCB7XG4gIHJlYWRvbmx5IGR5bmFtaWNGZWF0dXJlczogYm9vbGVhbjtcblxuICBhcmcoYXR0cjogQVNUdjIuQXR0ck5vZGUsIGNsYXNzaWZpZWQ6IENsYXNzaWZpZWRFbGVtZW50KTogUmVzdWx0PG1pci5OYW1lZEFyZ3VtZW50PjtcbiAgdG9TdGF0ZW1lbnQoY2xhc3NpZmllZDogQ2xhc3NpZmllZEVsZW1lbnQsIHByZXBhcmVkOiBQcmVwYXJlZEFyZ3MpOiBSZXN1bHQ8bWlyLlN0YXRlbWVudD47XG59XG5cbmV4cG9ydCBjbGFzcyBDbGFzc2lmaWVkRWxlbWVudCB7XG4gIHJlYWRvbmx5IGRlbGVnYXRlOiBDbGFzc2lmaWVkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGVsZW1lbnQ6IEFTVHYyLkVsZW1lbnROb2RlLFxuICAgIGRlbGVnYXRlOiBDbGFzc2lmaWVkLFxuICAgIHJlYWRvbmx5IHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGVcbiAgKSB7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICB9XG5cbiAgdG9TdGF0ZW1lbnQoKTogUmVzdWx0PG1pci5TdGF0ZW1lbnQ+IHtcbiAgICByZXR1cm4gdGhpcy5wcmVwYXJlKCkuYW5kVGhlbigocHJlcGFyZWQpID0+IHRoaXMuZGVsZWdhdGUudG9TdGF0ZW1lbnQodGhpcywgcHJlcGFyZWQpKTtcbiAgfVxuXG4gIHByaXZhdGUgYXR0cihhdHRyOiBBU1R2Mi5IdG1sQXR0cik6IFJlc3VsdDxWYWxpZEF0dHI+IHtcbiAgICBsZXQgbmFtZSA9IGF0dHIubmFtZTtcbiAgICBsZXQgcmF3VmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgIGxldCBuYW1lc3BhY2UgPSBnZXRBdHRyTmFtZXNwYWNlKG5hbWUuY2hhcnMpIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmIChBU1R2Mi5pc0xpdGVyYWwocmF3VmFsdWUsICdzdHJpbmcnKSkge1xuICAgICAgcmV0dXJuIE9rKFxuICAgICAgICBuZXcgbWlyLlN0YXRpY0F0dHIoe1xuICAgICAgICAgIGxvYzogYXR0ci5sb2MsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB2YWx1ZTogcmF3VmFsdWUudG9TbGljZSgpLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBraW5kOiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMuZGVsZWdhdGUuZHluYW1pY0ZlYXR1cmVzLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBWSVNJVF9FWFBSUy52aXNpdChjb252ZXJ0UGF0aFRvQ2FsbElmS2V5d29yZChyYXdWYWx1ZSksIHRoaXMuc3RhdGUpLm1hcE9rKCh2YWx1ZSkgPT4ge1xuICAgICAgbGV0IGlzVHJ1c3RpbmcgPSBhdHRyLnRydXN0aW5nO1xuXG4gICAgICByZXR1cm4gbmV3IG1pci5EeW5hbWljQXR0cih7XG4gICAgICAgIGxvYzogYXR0ci5sb2MsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBraW5kOiB7XG4gICAgICAgICAgdHJ1c3Rpbmc6IGlzVHJ1c3RpbmcsXG4gICAgICAgICAgY29tcG9uZW50OiB0aGlzLmRlbGVnYXRlLmR5bmFtaWNGZWF0dXJlcyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBtb2RpZmllcihtb2RpZmllcjogQVNUdjIuRWxlbWVudE1vZGlmaWVyKTogUmVzdWx0PG1pci5Nb2RpZmllcj4ge1xuICAgIGlmIChpc0hlbHBlckludm9jYXRpb24obW9kaWZpZXIpKSB7XG4gICAgICBhc3NlcnRJc1ZhbGlkTW9kaWZpZXIobW9kaWZpZXIpO1xuICAgIH1cblxuICAgIGxldCB0cmFuc2xhdGVkID0gTU9ESUZJRVJfS0VZV09SRFMudHJhbnNsYXRlKG1vZGlmaWVyLCB0aGlzLnN0YXRlKTtcblxuICAgIGlmICh0cmFuc2xhdGVkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJhbnNsYXRlZDtcbiAgICB9XG5cbiAgICBsZXQgaGVhZCA9IFZJU0lUX0VYUFJTLnZpc2l0KG1vZGlmaWVyLmNhbGxlZSwgdGhpcy5zdGF0ZSk7XG4gICAgbGV0IGFyZ3MgPSBWSVNJVF9FWFBSUy5BcmdzKG1vZGlmaWVyLmFyZ3MsIHRoaXMuc3RhdGUpO1xuXG4gICAgcmV0dXJuIFJlc3VsdC5hbGwoaGVhZCwgYXJncykubWFwT2soXG4gICAgICAoW2hlYWQsIGFyZ3NdKSA9PlxuICAgICAgICBuZXcgbWlyLk1vZGlmaWVyKHtcbiAgICAgICAgICBsb2M6IG1vZGlmaWVyLmxvYyxcbiAgICAgICAgICBjYWxsZWU6IGhlYWQsXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBhdHRycygpOiBSZXN1bHQ8UHJvY2Vzc2VkQXR0cmlidXRlcz4ge1xuICAgIGxldCBhdHRycyA9IG5ldyBSZXN1bHRBcnJheTxWYWxpZEF0dHI+KCk7XG4gICAgbGV0IGFyZ3MgPSBuZXcgUmVzdWx0QXJyYXk8bWlyLk5hbWVkQXJndW1lbnQ+KCk7XG5cbiAgICAvLyBVbmxpa2UgbW9zdCBhdHRyaWJ1dGVzLCB0aGUgYHR5cGVgIGF0dHJpYnV0ZSBjYW4gY2hhbmdlIGhvd1xuICAgIC8vIHN1YnNlcXVlbnQgYXR0cmlidXRlcyBhcmUgaW50ZXJwcmV0ZWQgYnkgdGhlIGJyb3dzZXIuIFRvIGFkZHJlc3NcbiAgICAvLyB0aGlzLCBpbiBzaW1wbGUgY2FzZXMsIHdlIHNwZWNpYWwgY2FzZSB0aGUgYHR5cGVgIGF0dHJpYnV0ZSB0byBiZSBzZXRcbiAgICAvLyBsYXN0LiBGb3IgZWxlbWVudHMgd2l0aCBzcGxhdHRyaWJ1dGVzLCB3aGVyZSBhdHRyaWJ1dGUgb3JkZXIgYWZmZWN0c1xuICAgIC8vIHByZWNlZGVuY2UsIHRoaXMgcmUtb3JkZXJpbmcgaGFwcGVucyBhdCBydW50aW1lIGluc3RlYWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGltbWVyanMvZ2xpbW1lci12bS9wdWxsLzcyNlxuICAgIGxldCB0eXBlQXR0cjogQVNUdjIuQXR0ck5vZGUgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgc2ltcGxlID0gdGhpcy5lbGVtZW50LmF0dHJzLmZpbHRlcigoYXR0cikgPT4gYXR0ci50eXBlID09PSAnU3BsYXRBdHRyJykubGVuZ3RoID09PSAwO1xuXG4gICAgZm9yIChsZXQgYXR0ciBvZiB0aGlzLmVsZW1lbnQuYXR0cnMpIHtcbiAgICAgIGlmIChhdHRyLnR5cGUgPT09ICdTcGxhdEF0dHInKSB7XG4gICAgICAgIGF0dHJzLmFkZChcbiAgICAgICAgICBPayhuZXcgbWlyLlNwbGF0QXR0cih7IGxvYzogYXR0ci5sb2MsIHN5bWJvbDogdGhpcy5zdGF0ZS5zY29wZS5hbGxvY2F0ZUJsb2NrKCdhdHRycycpIH0pKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChhdHRyLm5hbWUuY2hhcnMgPT09ICd0eXBlJyAmJiBzaW1wbGUpIHtcbiAgICAgICAgdHlwZUF0dHIgPSBhdHRyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMuYWRkKHRoaXMuYXR0cihhdHRyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgYXJnIG9mIHRoaXMuZWxlbWVudC5jb21wb25lbnRBcmdzKSB7XG4gICAgICBhcmdzLmFkZCh0aGlzLmRlbGVnYXRlLmFyZyhhcmcsIHRoaXMpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZUF0dHIpIHtcbiAgICAgIGF0dHJzLmFkZCh0aGlzLmF0dHIodHlwZUF0dHIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVzdWx0LmFsbChhcmdzLnRvQXJyYXkoKSwgYXR0cnMudG9BcnJheSgpKS5tYXBPaygoW2FyZ3MsIGF0dHJzXSkgPT4gKHtcbiAgICAgIGF0dHJzLFxuICAgICAgYXJnczogbmV3IG1pci5OYW1lZEFyZ3VtZW50cyh7XG4gICAgICAgIGxvYzogbWF5YmVMb2MoYXJncywgU291cmNlU3Bhbi5OT05fRVhJU1RFTlQpLFxuICAgICAgICBlbnRyaWVzOiBPcHRpb25hbExpc3QoYXJncyksXG4gICAgICB9KSxcbiAgICB9KSk7XG4gIH1cblxuICBwcml2YXRlIHByZXBhcmUoKTogUmVzdWx0PFByZXBhcmVkQXJncz4ge1xuICAgIGxldCBhdHRycyA9IHRoaXMuYXR0cnMoKTtcbiAgICBsZXQgbW9kaWZpZXJzID0gbmV3IFJlc3VsdEFycmF5KHRoaXMuZWxlbWVudC5tb2RpZmllcnMubWFwKChtKSA9PiB0aGlzLm1vZGlmaWVyKG0pKSkudG9BcnJheSgpO1xuXG4gICAgcmV0dXJuIFJlc3VsdC5hbGwoYXR0cnMsIG1vZGlmaWVycykubWFwT2soKFtyZXN1bHQsIG1vZGlmaWVyc10pID0+IHtcbiAgICAgIGxldCB7IGF0dHJzLCBhcmdzIH0gPSByZXN1bHQ7XG5cbiAgICAgIGxldCBlbGVtZW50UGFyYW1zID0gWy4uLmF0dHJzLCAuLi5tb2RpZmllcnNdO1xuXG4gICAgICBsZXQgcGFyYW1zID0gbmV3IG1pci5FbGVtZW50UGFyYW1ldGVycyh7XG4gICAgICAgIGxvYzogbWF5YmVMb2MoZWxlbWVudFBhcmFtcywgU291cmNlU3Bhbi5OT05fRVhJU1RFTlQpLFxuICAgICAgICBib2R5OiBPcHRpb25hbExpc3QoZWxlbWVudFBhcmFtcyksXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHsgYXJncywgcGFyYW1zIH07XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmVwYXJlZEFyZ3Mge1xuICBhcmdzOiBtaXIuTmFtZWRBcmd1bWVudHM7XG4gIHBhcmFtczogbWlyLkVsZW1lbnRQYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzRHluYW1pY0ZlYXR1cmVzKHtcbiAgYXR0cnMsXG4gIG1vZGlmaWVycyxcbn06IFBpY2s8QVNUdjIuRWxlbWVudE5vZGUsICdhdHRycycgfCAnbW9kaWZpZXJzJz4pOiBib29sZWFuIHtcbiAgLy8gRWxlbWVudE1vZGlmaWVyIG5lZWRzIHRoZSBzcGVjaWFsIENvbXBvbmVudE9wZXJhdGlvbnNcbiAgaWYgKG1vZGlmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBTcGxhdHRyaWJ1dGVzIG5lZWQgdGhlIHNwZWNpYWwgQ29tcG9uZW50T3BlcmF0aW9ucyB0byBtZXJnZSBpbnRvXG4gIHJldHVybiAhIWF0dHJzLmZpbHRlcigoYXR0cikgPT4gYXR0ci50eXBlID09PSAnU3BsYXRBdHRyJylbMF07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9