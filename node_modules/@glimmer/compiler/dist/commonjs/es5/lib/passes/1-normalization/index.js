"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalize;

var _util = require("@glimmer/util");

var mir = _interopRequireWildcard(require("../2-encoding/mir"));

var _context = require("./context");

var _statements = require("./visitors/statements");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Normalize the AST from @glimmer/syntax into the HIR. The HIR has special
 * instructions for keywords like `{{yield}}`, `(has-block)` and
 * `{{#in-element}}`.
 *
 * Most importantly, it also classifies HTML element syntax into:
 *
 * 1. simple HTML element (with optional splattributes)
 * 2. component invocation
 *
 * Because the @glimmer/syntax AST gives us a string for an element's tag,
 * this pass also normalizes that string into an expression.
 *
 * ```
 * // normalized into a path expression whose head is `this` and tail is
 * // `["x"]`
 * <this.x />
 *
 * {{#let expr as |t|}}
 *   // `"t"` is normalized into a variable lookup.
 *   <t />
 *
 *   // normalized into a path expression whose head is the variable lookup
 *   // `t` and tail is `["input"]`.
 *   <t.input />
 * {{/let}}
 *
 * // normalized into a free variable lookup for `SomeComponent` (with the
 * // context `ComponentHead`).
 * <SomeComponent />
 *
 * // normalized into a path expression whose head is the free variable
 * // `notInScope` (with the context `Expression`), and whose tail is
 * // `["SomeComponent"]`. In resolver mode, this path will be rejected later,
 * // since it cannot serve as an input to the resolver.
 * <notInScope.SomeComponent />
 * ```
 */
function normalize(source, root, isStrict) {
  // create a new context for the normalization pass
  var state = new _context.NormalizationState(root.table, isStrict);

  if (false
  /* LOCAL_SHOULD_LOG */
  ) {
      _util.LOCAL_LOGGER.groupCollapsed("pass0: visiting");

      _util.LOCAL_LOGGER.log('symbols', root.table);

      _util.LOCAL_LOGGER.log('source', source);

      _util.LOCAL_LOGGER.groupEnd();
    }

  var body = _statements.VISIT_STMTS.visitList(root.body, state);

  if (false
  /* LOCAL_SHOULD_LOG */
  ) {
      if (body.isOk) {
        _util.LOCAL_LOGGER.log('-> pass0: out', body.value);
      } else {
        _util.LOCAL_LOGGER.log('-> pass0: error', body.reason);
      }
    }

  return body.mapOk(function (body) {
    return new mir.Template({
      loc: root.loc,
      scope: root.table,
      body: body.toArray()
    });
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFQTs7QUFHQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NjLFNBQUEsU0FBQSxDQUFBLE1BQUEsRUFBQSxJQUFBLEVBQUEsUUFBQSxFQUdLO0FBRWpCO0FBQ0EsTUFBSSxLQUFLLEdBQUcsSUFBQSwyQkFBQSxDQUF1QixJQUFJLENBQTNCLEtBQUEsRUFBWixRQUFZLENBQVo7O0FBRUEsTUFBQTtBQUFBO0FBQUEsSUFBc0I7QUFDcEIseUJBQUEsY0FBQSxDQUFBLGlCQUFBOztBQUNBLHlCQUFBLEdBQUEsQ0FBQSxTQUFBLEVBQTRCLElBQUksQ0FBaEMsS0FBQTs7QUFDQSx5QkFBQSxHQUFBLENBQUEsUUFBQSxFQUFBLE1BQUE7O0FBQ0EseUJBQUEsUUFBQTtBQUNEOztBQUVELE1BQUksSUFBSSxHQUFHLHdCQUFBLFNBQUEsQ0FBc0IsSUFBSSxDQUExQixJQUFBLEVBQVgsS0FBVyxDQUFYOztBQUVBLE1BQUE7QUFBQTtBQUFBLElBQXNCO0FBQ3BCLFVBQUksSUFBSSxDQUFSLElBQUEsRUFBZTtBQUNiLDJCQUFBLEdBQUEsQ0FBQSxlQUFBLEVBQWtDLElBQUksQ0FBdEMsS0FBQTtBQURGLE9BQUEsTUFFTztBQUNMLDJCQUFBLEdBQUEsQ0FBQSxpQkFBQSxFQUFvQyxJQUFJLENBQXhDLE1BQUE7QUFDRDtBQUNGOztBQUVELFNBQU8sSUFBSSxDQUFKLEtBQUEsQ0FDSixVQUFELElBQUMsRUFBRDtBQUFBLFdBQVUsSUFBSSxHQUFHLENBQVAsUUFBQSxDQUFpQjtBQUFFLE1BQUEsR0FBRyxFQUFFLElBQUksQ0FBWCxHQUFBO0FBQWlCLE1BQUEsS0FBSyxFQUFFLElBQUksQ0FBNUIsS0FBQTtBQUFvQyxNQUFBLElBQUksRUFBRSxJQUFJLENBQUosT0FBQTtBQUExQyxLQUFqQixDQUFWO0FBREYsR0FBTyxDQUFQO0FBR0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMT0NBTF9TSE9VTERfTE9HIH0gZnJvbSAnQGdsaW1tZXIvbG9jYWwtZGVidWctZmxhZ3MnO1xuaW1wb3J0IHsgQVNUdjIsIFNvdXJjZSB9IGZyb20gJ0BnbGltbWVyL3N5bnRheCc7XG5pbXBvcnQgeyBMT0NBTF9MT0dHRVIgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcblxuaW1wb3J0IHsgUmVzdWx0IH0gZnJvbSAnLi4vLi4vc2hhcmVkL3Jlc3VsdCc7XG5pbXBvcnQgKiBhcyBtaXIgZnJvbSAnLi4vMi1lbmNvZGluZy9taXInO1xuaW1wb3J0IHsgTm9ybWFsaXphdGlvblN0YXRlIH0gZnJvbSAnLi9jb250ZXh0JztcbmltcG9ydCB7IFZJU0lUX1NUTVRTIH0gZnJvbSAnLi92aXNpdG9ycy9zdGF0ZW1lbnRzJztcblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIEFTVCBmcm9tIEBnbGltbWVyL3N5bnRheCBpbnRvIHRoZSBISVIuIFRoZSBISVIgaGFzIHNwZWNpYWxcbiAqIGluc3RydWN0aW9ucyBmb3Iga2V5d29yZHMgbGlrZSBge3t5aWVsZH19YCwgYChoYXMtYmxvY2spYCBhbmRcbiAqIGB7eyNpbi1lbGVtZW50fX1gLlxuICpcbiAqIE1vc3QgaW1wb3J0YW50bHksIGl0IGFsc28gY2xhc3NpZmllcyBIVE1MIGVsZW1lbnQgc3ludGF4IGludG86XG4gKlxuICogMS4gc2ltcGxlIEhUTUwgZWxlbWVudCAod2l0aCBvcHRpb25hbCBzcGxhdHRyaWJ1dGVzKVxuICogMi4gY29tcG9uZW50IGludm9jYXRpb25cbiAqXG4gKiBCZWNhdXNlIHRoZSBAZ2xpbW1lci9zeW50YXggQVNUIGdpdmVzIHVzIGEgc3RyaW5nIGZvciBhbiBlbGVtZW50J3MgdGFnLFxuICogdGhpcyBwYXNzIGFsc28gbm9ybWFsaXplcyB0aGF0IHN0cmluZyBpbnRvIGFuIGV4cHJlc3Npb24uXG4gKlxuICogYGBgXG4gKiAvLyBub3JtYWxpemVkIGludG8gYSBwYXRoIGV4cHJlc3Npb24gd2hvc2UgaGVhZCBpcyBgdGhpc2AgYW5kIHRhaWwgaXNcbiAqIC8vIGBbXCJ4XCJdYFxuICogPHRoaXMueCAvPlxuICpcbiAqIHt7I2xldCBleHByIGFzIHx0fH19XG4gKiAgIC8vIGBcInRcImAgaXMgbm9ybWFsaXplZCBpbnRvIGEgdmFyaWFibGUgbG9va3VwLlxuICogICA8dCAvPlxuICpcbiAqICAgLy8gbm9ybWFsaXplZCBpbnRvIGEgcGF0aCBleHByZXNzaW9uIHdob3NlIGhlYWQgaXMgdGhlIHZhcmlhYmxlIGxvb2t1cFxuICogICAvLyBgdGAgYW5kIHRhaWwgaXMgYFtcImlucHV0XCJdYC5cbiAqICAgPHQuaW5wdXQgLz5cbiAqIHt7L2xldH19XG4gKlxuICogLy8gbm9ybWFsaXplZCBpbnRvIGEgZnJlZSB2YXJpYWJsZSBsb29rdXAgZm9yIGBTb21lQ29tcG9uZW50YCAod2l0aCB0aGVcbiAqIC8vIGNvbnRleHQgYENvbXBvbmVudEhlYWRgKS5cbiAqIDxTb21lQ29tcG9uZW50IC8+XG4gKlxuICogLy8gbm9ybWFsaXplZCBpbnRvIGEgcGF0aCBleHByZXNzaW9uIHdob3NlIGhlYWQgaXMgdGhlIGZyZWUgdmFyaWFibGVcbiAqIC8vIGBub3RJblNjb3BlYCAod2l0aCB0aGUgY29udGV4dCBgRXhwcmVzc2lvbmApLCBhbmQgd2hvc2UgdGFpbCBpc1xuICogLy8gYFtcIlNvbWVDb21wb25lbnRcIl1gLiBJbiByZXNvbHZlciBtb2RlLCB0aGlzIHBhdGggd2lsbCBiZSByZWplY3RlZCBsYXRlcixcbiAqIC8vIHNpbmNlIGl0IGNhbm5vdCBzZXJ2ZSBhcyBhbiBpbnB1dCB0byB0aGUgcmVzb2x2ZXIuXG4gKiA8bm90SW5TY29wZS5Tb21lQ29tcG9uZW50IC8+XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplKFxuICBzb3VyY2U6IFNvdXJjZSxcbiAgcm9vdDogQVNUdjIuVGVtcGxhdGUsXG4gIGlzU3RyaWN0OiBib29sZWFuXG4pOiBSZXN1bHQ8bWlyLlRlbXBsYXRlPiB7XG4gIC8vIGNyZWF0ZSBhIG5ldyBjb250ZXh0IGZvciB0aGUgbm9ybWFsaXphdGlvbiBwYXNzXG4gIGxldCBzdGF0ZSA9IG5ldyBOb3JtYWxpemF0aW9uU3RhdGUocm9vdC50YWJsZSwgaXNTdHJpY3QpO1xuXG4gIGlmIChMT0NBTF9TSE9VTERfTE9HKSB7XG4gICAgTE9DQUxfTE9HR0VSLmdyb3VwQ29sbGFwc2VkKGBwYXNzMDogdmlzaXRpbmdgKTtcbiAgICBMT0NBTF9MT0dHRVIubG9nKCdzeW1ib2xzJywgcm9vdC50YWJsZSk7XG4gICAgTE9DQUxfTE9HR0VSLmxvZygnc291cmNlJywgc291cmNlKTtcbiAgICBMT0NBTF9MT0dHRVIuZ3JvdXBFbmQoKTtcbiAgfVxuXG4gIGxldCBib2R5ID0gVklTSVRfU1RNVFMudmlzaXRMaXN0KHJvb3QuYm9keSwgc3RhdGUpO1xuXG4gIGlmIChMT0NBTF9TSE9VTERfTE9HKSB7XG4gICAgaWYgKGJvZHkuaXNPaykge1xuICAgICAgTE9DQUxfTE9HR0VSLmxvZygnLT4gcGFzczA6IG91dCcsIGJvZHkudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBMT0NBTF9MT0dHRVIubG9nKCctPiBwYXNzMDogZXJyb3InLCBib2R5LnJlYXNvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJvZHkubWFwT2soXG4gICAgKGJvZHkpID0+IG5ldyBtaXIuVGVtcGxhdGUoeyBsb2M6IHJvb3QubG9jLCBzY29wZTogcm9vdC50YWJsZSwgYm9keTogYm9keS50b0FycmF5KCkgfSlcbiAgKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=