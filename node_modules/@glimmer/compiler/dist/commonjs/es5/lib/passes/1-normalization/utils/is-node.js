"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasPath = hasPath;
exports.isHelperInvocation = isHelperInvocation;
exports.isSimplePath = isSimplePath;
exports.isStrictHelper = isStrictHelper;
exports.assertIsValidModifier = assertIsValidModifier;
exports.isTrustingNode = isTrustingNode;

var _syntax = require("@glimmer/syntax");

var _util = require("@glimmer/util");

function hasPath(node) {
  return node.callee.type === 'Path';
}

function isHelperInvocation(node) {
  if (!hasPath(node)) {
    return false;
  }

  return !node.args.isEmpty();
}

function isSimplePath(path) {
  if (path.type === 'Path') {
    var head = path.ref,
        parts = path.tail;
    return head.type === 'Free' && head.resolution !== _syntax.ASTv2.STRICT_RESOLUTION && parts.length === 0;
  } else {
    return false;
  }
}

function isStrictHelper(expr) {
  if (expr.callee.type !== 'Path') {
    return true;
  }

  if (expr.callee.ref.type !== 'Free') {
    return true;
  }

  return expr.callee.ref.resolution === _syntax.ASTv2.STRICT_RESOLUTION;
}

function assertIsValidModifier(helper) {
  if (isStrictHelper(helper) || isSimplePath(helper.callee)) {
    return;
  }

  throw (0, _syntax.generateSyntaxError)("`" + printPath(helper.callee) + "` is not a valid name for a modifier", helper.loc);
}

function printPath(path) {
  switch (path.type) {
    case 'Literal':
      return JSON.stringify(path.value);

    case 'Path':
      {
        var printedPath = [printPathHead(path.ref)];
        printedPath.push.apply(printedPath, path.tail.map(function (t) {
          return t.chars;
        }));
        return printedPath.join('.');
      }

    case 'Call':
      return "(" + printPath(path.callee) + " ...)";

    case 'DeprecatedCall':
      return "" + path.callee.name;

    case 'Interpolate':
      throw (0, _util.unreachable)('a concat statement cannot appear as the head of an expression');
  }
}

function printPathHead(head) {
  switch (head.type) {
    case 'Arg':
      return head.name.chars;

    case 'Free':
    case 'Local':
      return head.name;

    case 'This':
      return 'this';
  }
}
/**
 * This function is checking whether an AST node is a triple-curly, which means that it's
 * a "trusting" node. In the Handlebars AST, this is indicated by the `escaped` flag, which
 * is a bit of a double-negative, so we change the terminology here for clarity.
 */


function isTrustingNode(value) {
  if (value.type === 'AppendContent') {
    return value.trusting;
  } else {
    return false;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL3V0aWxzL2lzLW5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQ0E7O0FBQ0E7O0FBbUJNLFNBQUEsT0FBQSxDQUFBLElBQUEsRUFBbUQ7QUFDdkQsU0FBTyxJQUFJLENBQUosTUFBQSxDQUFBLElBQUEsS0FBUCxNQUFBO0FBQ0Q7O0FBRUssU0FBQSxrQkFBQSxDQUFBLElBQUEsRUFDZ0I7QUFFcEIsTUFBSSxDQUFDLE9BQU8sQ0FBWixJQUFZLENBQVosRUFBb0I7QUFDbEIsV0FBQSxLQUFBO0FBQ0Q7O0FBRUQsU0FBTyxDQUFDLElBQUksQ0FBSixJQUFBLENBQVIsT0FBUSxFQUFSO0FBQ0Q7O0FBWUssU0FBQSxZQUFBLENBQUEsSUFBQSxFQUFpRDtBQUNyRCxNQUFJLElBQUksQ0FBSixJQUFBLEtBQUosTUFBQSxFQUEwQjtBQUFBLFFBQ3BCLElBRG9CLEdBQ3hCLElBRHdCLENBQUEsR0FBQTtBQUFBLFFBQ0QsS0FEQyxHQUN4QixJQUR3QixDQUFBLElBQUE7QUFHeEIsV0FDRSxJQUFJLENBQUosSUFBQSxLQUFBLE1BQUEsSUFBd0IsSUFBSSxDQUFKLFVBQUEsS0FBb0IsY0FBNUMsaUJBQUEsSUFBdUUsS0FBSyxDQUFMLE1BQUEsS0FEekUsQ0FBQTtBQUhGLEdBQUEsTUFNTztBQUNMLFdBQUEsS0FBQTtBQUNEO0FBQ0Y7O0FBRUssU0FBQSxjQUFBLENBQUEsSUFBQSxFQUFzQztBQUMxQyxNQUFJLElBQUksQ0FBSixNQUFBLENBQUEsSUFBQSxLQUFKLE1BQUEsRUFBaUM7QUFDL0IsV0FBQSxJQUFBO0FBQ0Q7O0FBRUQsTUFBSSxJQUFJLENBQUosTUFBQSxDQUFBLEdBQUEsQ0FBQSxJQUFBLEtBQUosTUFBQSxFQUFxQztBQUNuQyxXQUFBLElBQUE7QUFDRDs7QUFFRCxTQUFPLElBQUksQ0FBSixNQUFBLENBQUEsR0FBQSxDQUFBLFVBQUEsS0FBK0IsY0FBdEMsaUJBQUE7QUFDRDs7QUFFSyxTQUFBLHFCQUFBLENBQUEsTUFBQSxFQUNLO0FBRVQsTUFBSSxjQUFjLENBQWQsTUFBYyxDQUFkLElBQTBCLFlBQVksQ0FBQyxNQUFNLENBQWpELE1BQTBDLENBQTFDLEVBQTJEO0FBQ3pEO0FBQ0Q7O0FBRUQsUUFBTSxpQ0FBbUIsTUFDbEIsU0FBUyxDQUFDLE1BQU0sQ0FERSxNQUNULENBRFMsR0FBQSxzQ0FBbkIsRUFFSixNQUFNLENBRlIsR0FBTSxDQUFOO0FBSUQ7O0FBRUQsU0FBQSxTQUFBLENBQUEsSUFBQSxFQUE2QztBQUMzQyxVQUFRLElBQUksQ0FBWixJQUFBO0FBQ0UsU0FBQSxTQUFBO0FBQ0UsYUFBTyxJQUFJLENBQUosU0FBQSxDQUFlLElBQUksQ0FBMUIsS0FBTyxDQUFQOztBQUNGLFNBQUEsTUFBQTtBQUFhO0FBQ1gsWUFBSSxXQUFXLEdBQUcsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFyQyxHQUFnQyxDQUFkLENBQWxCO0FBQ0EsUUFBQSxXQUFXLENBQVgsSUFBQSxDQUFBLEtBQUEsQ0FBQSxXQUFBLEVBQW9CLElBQUksQ0FBSixJQUFBLENBQUEsR0FBQSxDQUFlLFVBQUQsQ0FBQyxFQUFEO0FBQUEsaUJBQU8sQ0FBQyxDQUExQyxLQUFrQztBQUFsQyxTQUFvQixDQUFwQjtBQUNBLGVBQU8sV0FBVyxDQUFYLElBQUEsQ0FBUCxHQUFPLENBQVA7QUFDRDs7QUFDRCxTQUFBLE1BQUE7QUFDRSxhQUFBLE1BQVcsU0FBUyxDQUFDLElBQUksQ0FBekIsTUFBb0IsQ0FBcEIsR0FBQSxPQUFBOztBQUNGLFNBQUEsZ0JBQUE7QUFDRSxhQUFBLEtBQVUsSUFBSSxDQUFKLE1BQUEsQ0FBVixJQUFBOztBQUNGLFNBQUEsYUFBQTtBQUNFLFlBQU0sdUJBQU4sK0RBQU0sQ0FBTjtBQWJKO0FBZUQ7O0FBRUQsU0FBQSxhQUFBLENBQUEsSUFBQSxFQUFvRDtBQUNsRCxVQUFRLElBQUksQ0FBWixJQUFBO0FBQ0UsU0FBQSxLQUFBO0FBQ0UsYUFBTyxJQUFJLENBQUosSUFBQSxDQUFQLEtBQUE7O0FBQ0YsU0FBQSxNQUFBO0FBQ0EsU0FBQSxPQUFBO0FBQ0UsYUFBTyxJQUFJLENBQVgsSUFBQTs7QUFDRixTQUFBLE1BQUE7QUFDRSxhQUFBLE1BQUE7QUFQSjtBQVNEO0FBRUQ7Ozs7Ozs7QUFLTSxTQUFBLGNBQUEsQ0FBQSxLQUFBLEVBQ3FFO0FBRXpFLE1BQUksS0FBSyxDQUFMLElBQUEsS0FBSixlQUFBLEVBQW9DO0FBQ2xDLFdBQU8sS0FBSyxDQUFaLFFBQUE7QUFERixHQUFBLE1BRU87QUFDTCxXQUFBLEtBQUE7QUFDRDtBQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJlc2VudEFycmF5IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBBU1R2MiwgZ2VuZXJhdGVTeW50YXhFcnJvciwgU291cmNlU2xpY2UgfSBmcm9tICdAZ2xpbW1lci9zeW50YXgnO1xuaW1wb3J0IHsgdW5yZWFjaGFibGUgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcblxuZXhwb3J0IHR5cGUgSGFzUGF0aDxOb2RlIGV4dGVuZHMgQVNUdjIuQ2FsbE5vZGUgPSBBU1R2Mi5DYWxsTm9kZT4gPSBOb2RlICYge1xuICBoZWFkOiBBU1R2Mi5QYXRoRXhwcmVzc2lvbjtcbn07XG5cbmV4cG9ydCB0eXBlIEhhc0FyZ3VtZW50cyA9XG4gIHwge1xuICAgICAgcGFyYW1zOiBQcmVzZW50QXJyYXk8QVNUdjIuRXhwcmVzc2lvbk5vZGU+O1xuICAgIH1cbiAgfCB7XG4gICAgICBoYXNoOiB7XG4gICAgICAgIHBhaXJzOiBQcmVzZW50QXJyYXk8QVNUdjIuTmFtZWRBcmd1bWVudD47XG4gICAgICB9O1xuICAgIH07XG5cbmV4cG9ydCB0eXBlIEhlbHBlckludm9jYXRpb248Tm9kZSBleHRlbmRzIEFTVHYyLkNhbGxOb2RlID0gQVNUdjIuQ2FsbE5vZGU+ID0gSGFzUGF0aDxOb2RlPiAmXG4gIEhhc0FyZ3VtZW50cztcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1BhdGg8TiBleHRlbmRzIEFTVHYyLkNhbGxOb2RlPihub2RlOiBOKTogbm9kZSBpcyBIYXNQYXRoPE4+IHtcbiAgcmV0dXJuIG5vZGUuY2FsbGVlLnR5cGUgPT09ICdQYXRoJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSGVscGVySW52b2NhdGlvbjxOIGV4dGVuZHMgQVNUdjIuQ2FsbE5vZGU+KFxuICBub2RlOiBBU1R2Mi5DYWxsTm9kZVxuKTogbm9kZSBpcyBIZWxwZXJJbnZvY2F0aW9uPE4+IHtcbiAgaWYgKCFoYXNQYXRoKG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICFub2RlLmFyZ3MuaXNFbXB0eSgpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNpbXBsZVBhdGggZXh0ZW5kcyBBU1R2Mi5QYXRoRXhwcmVzc2lvbiB7XG4gIHRhaWw6IFtTb3VyY2VTbGljZV07XG4gIGRhdGE6IGZhbHNlO1xuICB0aGlzOiBmYWxzZTtcbn1cblxuZXhwb3J0IHR5cGUgU2ltcGxlSGVscGVyPE4gZXh0ZW5kcyBIYXNQYXRoPiA9IE4gJiB7XG4gIHBhdGg6IFNpbXBsZVBhdGg7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTaW1wbGVQYXRoKHBhdGg6IEFTVHYyLkV4cHJlc3Npb25Ob2RlKTogcGF0aCBpcyBTaW1wbGVQYXRoIHtcbiAgaWYgKHBhdGgudHlwZSA9PT0gJ1BhdGgnKSB7XG4gICAgbGV0IHsgcmVmOiBoZWFkLCB0YWlsOiBwYXJ0cyB9ID0gcGF0aDtcblxuICAgIHJldHVybiAoXG4gICAgICBoZWFkLnR5cGUgPT09ICdGcmVlJyAmJiBoZWFkLnJlc29sdXRpb24gIT09IEFTVHYyLlNUUklDVF9SRVNPTFVUSU9OICYmIHBhcnRzLmxlbmd0aCA9PT0gMFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmljdEhlbHBlcihleHByOiBIYXNQYXRoKTogYm9vbGVhbiB7XG4gIGlmIChleHByLmNhbGxlZS50eXBlICE9PSAnUGF0aCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChleHByLmNhbGxlZS5yZWYudHlwZSAhPT0gJ0ZyZWUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZXhwci5jYWxsZWUucmVmLnJlc29sdXRpb24gPT09IEFTVHYyLlNUUklDVF9SRVNPTFVUSU9OO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNWYWxpZE1vZGlmaWVyPE4gZXh0ZW5kcyBIYXNQYXRoPihcbiAgaGVscGVyOiBOXG4pOiBhc3NlcnRzIGhlbHBlciBpcyBTaW1wbGVIZWxwZXI8Tj4ge1xuICBpZiAoaXNTdHJpY3RIZWxwZXIoaGVscGVyKSB8fCBpc1NpbXBsZVBhdGgoaGVscGVyLmNhbGxlZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgIGBcXGAke3ByaW50UGF0aChoZWxwZXIuY2FsbGVlKX1cXGAgaXMgbm90IGEgdmFsaWQgbmFtZSBmb3IgYSBtb2RpZmllcmAsXG4gICAgaGVscGVyLmxvY1xuICApO1xufVxuXG5mdW5jdGlvbiBwcmludFBhdGgocGF0aDogQVNUdjIuRXhwcmVzc2lvbk5vZGUpOiBzdHJpbmcge1xuICBzd2l0Y2ggKHBhdGgudHlwZSkge1xuICAgIGNhc2UgJ0xpdGVyYWwnOlxuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhdGgudmFsdWUpO1xuICAgIGNhc2UgJ1BhdGgnOiB7XG4gICAgICBsZXQgcHJpbnRlZFBhdGggPSBbcHJpbnRQYXRoSGVhZChwYXRoLnJlZildO1xuICAgICAgcHJpbnRlZFBhdGgucHVzaCguLi5wYXRoLnRhaWwubWFwKCh0KSA9PiB0LmNoYXJzKSk7XG4gICAgICByZXR1cm4gcHJpbnRlZFBhdGguam9pbignLicpO1xuICAgIH1cbiAgICBjYXNlICdDYWxsJzpcbiAgICAgIHJldHVybiBgKCR7cHJpbnRQYXRoKHBhdGguY2FsbGVlKX0gLi4uKWA7XG4gICAgY2FzZSAnRGVwcmVjYXRlZENhbGwnOlxuICAgICAgcmV0dXJuIGAke3BhdGguY2FsbGVlLm5hbWV9YDtcbiAgICBjYXNlICdJbnRlcnBvbGF0ZSc6XG4gICAgICB0aHJvdyB1bnJlYWNoYWJsZSgnYSBjb25jYXQgc3RhdGVtZW50IGNhbm5vdCBhcHBlYXIgYXMgdGhlIGhlYWQgb2YgYW4gZXhwcmVzc2lvbicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50UGF0aEhlYWQoaGVhZDogQVNUdjIuVmFyaWFibGVSZWZlcmVuY2UpOiBzdHJpbmcge1xuICBzd2l0Y2ggKGhlYWQudHlwZSkge1xuICAgIGNhc2UgJ0FyZyc6XG4gICAgICByZXR1cm4gaGVhZC5uYW1lLmNoYXJzO1xuICAgIGNhc2UgJ0ZyZWUnOlxuICAgIGNhc2UgJ0xvY2FsJzpcbiAgICAgIHJldHVybiBoZWFkLm5hbWU7XG4gICAgY2FzZSAnVGhpcyc6XG4gICAgICByZXR1cm4gJ3RoaXMnO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBjaGVja2luZyB3aGV0aGVyIGFuIEFTVCBub2RlIGlzIGEgdHJpcGxlLWN1cmx5LCB3aGljaCBtZWFucyB0aGF0IGl0J3NcbiAqIGEgXCJ0cnVzdGluZ1wiIG5vZGUuIEluIHRoZSBIYW5kbGViYXJzIEFTVCwgdGhpcyBpcyBpbmRpY2F0ZWQgYnkgdGhlIGBlc2NhcGVkYCBmbGFnLCB3aGljaFxuICogaXMgYSBiaXQgb2YgYSBkb3VibGUtbmVnYXRpdmUsIHNvIHdlIGNoYW5nZSB0aGUgdGVybWlub2xvZ3kgaGVyZSBmb3IgY2xhcml0eS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVHJ1c3RpbmdOb2RlKFxuICB2YWx1ZTogQVNUdjIuQXBwZW5kQ29udGVudCB8IEFTVHYyLkh0bWxUZXh0IHwgQVNUdjIuSW50ZXJwb2xhdGVFeHByZXNzaW9uXG4pOiBib29sZWFuIHtcbiAgaWYgKHZhbHVlLnR5cGUgPT09ICdBcHBlbmRDb250ZW50Jykge1xuICAgIHJldHVybiB2YWx1ZS50cnVzdGluZztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=