"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = normalize;

var _util = require("@glimmer/util");

var mir = _interopRequireWildcard(require("../2-encoding/mir"));

var _context = require("./context");

var _statements = require("./visitors/statements");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Normalize the AST from @glimmer/syntax into the HIR. The HIR has special
 * instructions for keywords like `{{yield}}`, `(has-block)` and
 * `{{#in-element}}`.
 *
 * Most importantly, it also classifies HTML element syntax into:
 *
 * 1. simple HTML element (with optional splattributes)
 * 2. component invocation
 *
 * Because the @glimmer/syntax AST gives us a string for an element's tag,
 * this pass also normalizes that string into an expression.
 *
 * ```
 * // normalized into a path expression whose head is `this` and tail is
 * // `["x"]`
 * <this.x />
 *
 * {{#let expr as |t|}}
 *   // `"t"` is normalized into a variable lookup.
 *   <t />
 *
 *   // normalized into a path expression whose head is the variable lookup
 *   // `t` and tail is `["input"]`.
 *   <t.input />
 * {{/let}}
 *
 * // normalized into a free variable lookup for `SomeComponent` (with the
 * // context `ComponentHead`).
 * <SomeComponent />
 *
 * // normalized into a path expression whose head is the free variable
 * // `notInScope` (with the context `Expression`), and whose tail is
 * // `["SomeComponent"]`. In resolver mode, this path will be rejected later,
 * // since it cannot serve as an input to the resolver.
 * <notInScope.SomeComponent />
 * ```
 */
function normalize(source, root, isStrict) {
  // create a new context for the normalization pass
  let state = new _context.NormalizationState(root.table, isStrict);

  if (false
  /* LOCAL_SHOULD_LOG */
  ) {
      _util.LOCAL_LOGGER.groupCollapsed(`pass0: visiting`);

      _util.LOCAL_LOGGER.log('symbols', root.table);

      _util.LOCAL_LOGGER.log('source', source);

      _util.LOCAL_LOGGER.groupEnd();
    }

  let body = _statements.VISIT_STMTS.visitList(root.body, state);

  if (false
  /* LOCAL_SHOULD_LOG */
  ) {
      if (body.isOk) {
        _util.LOCAL_LOGGER.log('-> pass0: out', body.value);
      } else {
        _util.LOCAL_LOGGER.log('-> pass0: error', body.reason);
      }
    }

  return body.mapOk(body => new mir.Template({
    loc: root.loc,
    scope: root.table,
    body: body.toArray()
  }));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFQTs7QUFHQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0NjLFNBQUEsU0FBQSxDQUFBLE1BQUEsRUFBQSxJQUFBLEVBQUEsUUFBQSxFQUdLO0FBRWpCO0FBQ0EsTUFBSSxLQUFLLEdBQUcsSUFBQSwyQkFBQSxDQUF1QixJQUFJLENBQTNCLEtBQUEsRUFBWixRQUFZLENBQVo7O0FBRUEsTUFBQTtBQUFBO0FBQUEsSUFBc0I7QUFDcEIseUJBQUEsY0FBQSxDQUFBLGlCQUFBOztBQUNBLHlCQUFBLEdBQUEsQ0FBQSxTQUFBLEVBQTRCLElBQUksQ0FBaEMsS0FBQTs7QUFDQSx5QkFBQSxHQUFBLENBQUEsUUFBQSxFQUFBLE1BQUE7O0FBQ0EseUJBQUEsUUFBQTtBQUNEOztBQUVELE1BQUksSUFBSSxHQUFHLHdCQUFBLFNBQUEsQ0FBc0IsSUFBSSxDQUExQixJQUFBLEVBQVgsS0FBVyxDQUFYOztBQUVBLE1BQUE7QUFBQTtBQUFBLElBQXNCO0FBQ3BCLFVBQUksSUFBSSxDQUFSLElBQUEsRUFBZTtBQUNiLDJCQUFBLEdBQUEsQ0FBQSxlQUFBLEVBQWtDLElBQUksQ0FBdEMsS0FBQTtBQURGLE9BQUEsTUFFTztBQUNMLDJCQUFBLEdBQUEsQ0FBQSxpQkFBQSxFQUFvQyxJQUFJLENBQXhDLE1BQUE7QUFDRDtBQUNGOztBQUVELFNBQU8sSUFBSSxDQUFKLEtBQUEsQ0FDSixJQUFELElBQVUsSUFBSSxHQUFHLENBQVAsUUFBQSxDQUFpQjtBQUFFLElBQUEsR0FBRyxFQUFFLElBQUksQ0FBWCxHQUFBO0FBQWlCLElBQUEsS0FBSyxFQUFFLElBQUksQ0FBNUIsS0FBQTtBQUFvQyxJQUFBLElBQUksRUFBRSxJQUFJLENBQUosT0FBQTtBQUExQyxHQUFqQixDQURMLENBQVA7QUFHRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExPQ0FMX1NIT1VMRF9MT0cgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBBU1R2MiwgU291cmNlIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcbmltcG9ydCB7IExPQ0FMX0xPR0dFUiB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5pbXBvcnQgeyBSZXN1bHQgfSBmcm9tICcuLi8uLi9zaGFyZWQvcmVzdWx0JztcbmltcG9ydCAqIGFzIG1pciBmcm9tICcuLi8yLWVuY29kaW5nL21pcic7XG5pbXBvcnQgeyBOb3JtYWxpemF0aW9uU3RhdGUgfSBmcm9tICcuL2NvbnRleHQnO1xuaW1wb3J0IHsgVklTSVRfU1RNVFMgfSBmcm9tICcuL3Zpc2l0b3JzL3N0YXRlbWVudHMnO1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgQVNUIGZyb20gQGdsaW1tZXIvc3ludGF4IGludG8gdGhlIEhJUi4gVGhlIEhJUiBoYXMgc3BlY2lhbFxuICogaW5zdHJ1Y3Rpb25zIGZvciBrZXl3b3JkcyBsaWtlIGB7e3lpZWxkfX1gLCBgKGhhcy1ibG9jaylgIGFuZFxuICogYHt7I2luLWVsZW1lbnR9fWAuXG4gKlxuICogTW9zdCBpbXBvcnRhbnRseSwgaXQgYWxzbyBjbGFzc2lmaWVzIEhUTUwgZWxlbWVudCBzeW50YXggaW50bzpcbiAqXG4gKiAxLiBzaW1wbGUgSFRNTCBlbGVtZW50ICh3aXRoIG9wdGlvbmFsIHNwbGF0dHJpYnV0ZXMpXG4gKiAyLiBjb21wb25lbnQgaW52b2NhdGlvblxuICpcbiAqIEJlY2F1c2UgdGhlIEBnbGltbWVyL3N5bnRheCBBU1QgZ2l2ZXMgdXMgYSBzdHJpbmcgZm9yIGFuIGVsZW1lbnQncyB0YWcsXG4gKiB0aGlzIHBhc3MgYWxzbyBub3JtYWxpemVzIHRoYXQgc3RyaW5nIGludG8gYW4gZXhwcmVzc2lvbi5cbiAqXG4gKiBgYGBcbiAqIC8vIG5vcm1hbGl6ZWQgaW50byBhIHBhdGggZXhwcmVzc2lvbiB3aG9zZSBoZWFkIGlzIGB0aGlzYCBhbmQgdGFpbCBpc1xuICogLy8gYFtcInhcIl1gXG4gKiA8dGhpcy54IC8+XG4gKlxuICoge3sjbGV0IGV4cHIgYXMgfHR8fX1cbiAqICAgLy8gYFwidFwiYCBpcyBub3JtYWxpemVkIGludG8gYSB2YXJpYWJsZSBsb29rdXAuXG4gKiAgIDx0IC8+XG4gKlxuICogICAvLyBub3JtYWxpemVkIGludG8gYSBwYXRoIGV4cHJlc3Npb24gd2hvc2UgaGVhZCBpcyB0aGUgdmFyaWFibGUgbG9va3VwXG4gKiAgIC8vIGB0YCBhbmQgdGFpbCBpcyBgW1wiaW5wdXRcIl1gLlxuICogICA8dC5pbnB1dCAvPlxuICoge3svbGV0fX1cbiAqXG4gKiAvLyBub3JtYWxpemVkIGludG8gYSBmcmVlIHZhcmlhYmxlIGxvb2t1cCBmb3IgYFNvbWVDb21wb25lbnRgICh3aXRoIHRoZVxuICogLy8gY29udGV4dCBgQ29tcG9uZW50SGVhZGApLlxuICogPFNvbWVDb21wb25lbnQgLz5cbiAqXG4gKiAvLyBub3JtYWxpemVkIGludG8gYSBwYXRoIGV4cHJlc3Npb24gd2hvc2UgaGVhZCBpcyB0aGUgZnJlZSB2YXJpYWJsZVxuICogLy8gYG5vdEluU2NvcGVgICh3aXRoIHRoZSBjb250ZXh0IGBFeHByZXNzaW9uYCksIGFuZCB3aG9zZSB0YWlsIGlzXG4gKiAvLyBgW1wiU29tZUNvbXBvbmVudFwiXWAuIEluIHJlc29sdmVyIG1vZGUsIHRoaXMgcGF0aCB3aWxsIGJlIHJlamVjdGVkIGxhdGVyLFxuICogLy8gc2luY2UgaXQgY2Fubm90IHNlcnZlIGFzIGFuIGlucHV0IHRvIHRoZSByZXNvbHZlci5cbiAqIDxub3RJblNjb3BlLlNvbWVDb21wb25lbnQgLz5cbiAqIGBgYFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub3JtYWxpemUoXG4gIHNvdXJjZTogU291cmNlLFxuICByb290OiBBU1R2Mi5UZW1wbGF0ZSxcbiAgaXNTdHJpY3Q6IGJvb2xlYW5cbik6IFJlc3VsdDxtaXIuVGVtcGxhdGU+IHtcbiAgLy8gY3JlYXRlIGEgbmV3IGNvbnRleHQgZm9yIHRoZSBub3JtYWxpemF0aW9uIHBhc3NcbiAgbGV0IHN0YXRlID0gbmV3IE5vcm1hbGl6YXRpb25TdGF0ZShyb290LnRhYmxlLCBpc1N0cmljdCk7XG5cbiAgaWYgKExPQ0FMX1NIT1VMRF9MT0cpIHtcbiAgICBMT0NBTF9MT0dHRVIuZ3JvdXBDb2xsYXBzZWQoYHBhc3MwOiB2aXNpdGluZ2ApO1xuICAgIExPQ0FMX0xPR0dFUi5sb2coJ3N5bWJvbHMnLCByb290LnRhYmxlKTtcbiAgICBMT0NBTF9MT0dHRVIubG9nKCdzb3VyY2UnLCBzb3VyY2UpO1xuICAgIExPQ0FMX0xPR0dFUi5ncm91cEVuZCgpO1xuICB9XG5cbiAgbGV0IGJvZHkgPSBWSVNJVF9TVE1UUy52aXNpdExpc3Qocm9vdC5ib2R5LCBzdGF0ZSk7XG5cbiAgaWYgKExPQ0FMX1NIT1VMRF9MT0cpIHtcbiAgICBpZiAoYm9keS5pc09rKSB7XG4gICAgICBMT0NBTF9MT0dHRVIubG9nKCctPiBwYXNzMDogb3V0JywgYm9keS52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIExPQ0FMX0xPR0dFUi5sb2coJy0+IHBhc3MwOiBlcnJvcicsIGJvZHkucmVhc29uKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYm9keS5tYXBPayhcbiAgICAoYm9keSkgPT4gbmV3IG1pci5UZW1wbGF0ZSh7IGxvYzogcm9vdC5sb2MsIHNjb3BlOiByb290LnRhYmxlLCBib2R5OiBib2R5LnRvQXJyYXkoKSB9KVxuICApO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==