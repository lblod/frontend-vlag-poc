"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ClassifiedComponent = void 0;

var mir = _interopRequireWildcard(require("../../../2-encoding/mir"));

var _expressions = require("../expressions");

var _statements = require("../statements");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class ClassifiedComponent {
  constructor(tag, element) {
    this.tag = tag;
    this.element = element;
    this.dynamicFeatures = true;
  }

  arg(attr, {
    state
  }) {
    let name = attr.name;
    return _expressions.VISIT_EXPRS.visit((0, _expressions.convertPathToCallIfKeyword)(attr.value), state).mapOk(value => new mir.NamedArgument({
      loc: attr.loc,
      key: name,
      value
    }));
  }

  toStatement(component, {
    args,
    params
  }) {
    let {
      element,
      state
    } = component;
    return this.blocks(state).mapOk(blocks => new mir.Component({
      loc: element.loc,
      tag: this.tag,
      params,
      args,
      blocks
    }));
  }

  blocks(state) {
    return _statements.VISIT_STMTS.NamedBlocks(this.element.blocks, state);
  }

}

exports.ClassifiedComponent = ClassifiedComponent;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL3Zpc2l0b3JzL2VsZW1lbnQvY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFHQTs7QUFFQTs7QUFDQTs7Ozs7O0FBR00sTUFBQSxtQkFBQSxDQUEwQjtBQUc5QixFQUFBLFdBQUEsQ0FBQSxHQUFBLEVBQUEsT0FBQSxFQUFtRjtBQUEvRCxTQUFBLEdBQUEsR0FBQSxHQUFBO0FBQWlDLFNBQUEsT0FBQSxHQUFBLE9BQUE7QUFGNUMsU0FBQSxlQUFBLEdBQUEsSUFBQTtBQUU4RTs7QUFFdkYsRUFBQSxHQUFHLENBQUEsSUFBQSxFQUEyQjtBQUFFLElBQUE7QUFBRixHQUEzQixFQUF1RDtBQUN4RCxRQUFJLElBQUksR0FBRyxJQUFJLENBQWYsSUFBQTtBQUVBLFdBQU8seUJBQUEsS0FBQSxDQUFrQiw2Q0FBMkIsSUFBSSxDQUFqRCxLQUFrQixDQUFsQixFQUFBLEtBQUEsRUFBQSxLQUFBLENBQ0osS0FBRCxJQUNFLElBQUksR0FBRyxDQUFQLGFBQUEsQ0FBc0I7QUFDcEIsTUFBQSxHQUFHLEVBQUUsSUFBSSxDQURXLEdBQUE7QUFFcEIsTUFBQSxHQUFHLEVBRmlCLElBQUE7QUFHcEIsTUFBQTtBQUhvQixLQUF0QixDQUZHLENBQVA7QUFRRDs7QUFFRCxFQUFBLFdBQVcsQ0FBQSxTQUFBLEVBQStCO0FBQUEsSUFBQSxJQUFBO0FBQVEsSUFBQTtBQUFSLEdBQS9CLEVBQTZEO0FBQ3RFLFFBQUk7QUFBQSxNQUFBLE9BQUE7QUFBVyxNQUFBO0FBQVgsUUFBSixTQUFBO0FBRUEsV0FBTyxLQUFBLE1BQUEsQ0FBQSxLQUFBLEVBQUEsS0FBQSxDQUNKLE1BQUQsSUFDRSxJQUFJLEdBQUcsQ0FBUCxTQUFBLENBQWtCO0FBQ2hCLE1BQUEsR0FBRyxFQUFFLE9BQU8sQ0FESSxHQUFBO0FBRWhCLE1BQUEsR0FBRyxFQUFFLEtBRlcsR0FBQTtBQUFBLE1BQUEsTUFBQTtBQUFBLE1BQUEsSUFBQTtBQUtoQixNQUFBO0FBTGdCLEtBQWxCLENBRkcsQ0FBUDtBQVVEOztBQUVPLEVBQUEsTUFBTSxDQUFBLEtBQUEsRUFBMEI7QUFDdEMsV0FBTyx3QkFBQSxXQUFBLENBQXdCLEtBQUEsT0FBQSxDQUF4QixNQUFBLEVBQVAsS0FBTyxDQUFQO0FBQ0Q7O0FBbkM2QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFTVHYyIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcblxuaW1wb3J0IHsgUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL3Jlc3VsdCc7XG5pbXBvcnQgKiBhcyBtaXIgZnJvbSAnLi4vLi4vLi4vMi1lbmNvZGluZy9taXInO1xuaW1wb3J0IHsgTm9ybWFsaXphdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vY29udGV4dCc7XG5pbXBvcnQgeyBjb252ZXJ0UGF0aFRvQ2FsbElmS2V5d29yZCwgVklTSVRfRVhQUlMgfSBmcm9tICcuLi9leHByZXNzaW9ucyc7XG5pbXBvcnQgeyBWSVNJVF9TVE1UUyB9IGZyb20gJy4uL3N0YXRlbWVudHMnO1xuaW1wb3J0IHsgQ2xhc3NpZmllZCwgQ2xhc3NpZmllZEVsZW1lbnQsIFByZXBhcmVkQXJncyB9IGZyb20gJy4vY2xhc3NpZmllZCc7XG5cbmV4cG9ydCBjbGFzcyBDbGFzc2lmaWVkQ29tcG9uZW50IGltcGxlbWVudHMgQ2xhc3NpZmllZCB7XG4gIHJlYWRvbmx5IGR5bmFtaWNGZWF0dXJlcyA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB0YWc6IG1pci5FeHByZXNzaW9uTm9kZSwgcHJpdmF0ZSBlbGVtZW50OiBBU1R2Mi5JbnZva2VDb21wb25lbnQpIHt9XG5cbiAgYXJnKGF0dHI6IEFTVHYyLkNvbXBvbmVudEFyZywgeyBzdGF0ZSB9OiBDbGFzc2lmaWVkRWxlbWVudCk6IFJlc3VsdDxtaXIuTmFtZWRBcmd1bWVudD4ge1xuICAgIGxldCBuYW1lID0gYXR0ci5uYW1lO1xuXG4gICAgcmV0dXJuIFZJU0lUX0VYUFJTLnZpc2l0KGNvbnZlcnRQYXRoVG9DYWxsSWZLZXl3b3JkKGF0dHIudmFsdWUpLCBzdGF0ZSkubWFwT2soXG4gICAgICAodmFsdWUpID0+XG4gICAgICAgIG5ldyBtaXIuTmFtZWRBcmd1bWVudCh7XG4gICAgICAgICAgbG9jOiBhdHRyLmxvYyxcbiAgICAgICAgICBrZXk6IG5hbWUsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHRvU3RhdGVtZW50KGNvbXBvbmVudDogQ2xhc3NpZmllZEVsZW1lbnQsIHsgYXJncywgcGFyYW1zIH06IFByZXBhcmVkQXJncyk6IFJlc3VsdDxtaXIuU3RhdGVtZW50PiB7XG4gICAgbGV0IHsgZWxlbWVudCwgc3RhdGUgfSA9IGNvbXBvbmVudDtcblxuICAgIHJldHVybiB0aGlzLmJsb2NrcyhzdGF0ZSkubWFwT2soXG4gICAgICAoYmxvY2tzKSA9PlxuICAgICAgICBuZXcgbWlyLkNvbXBvbmVudCh7XG4gICAgICAgICAgbG9jOiBlbGVtZW50LmxvYyxcbiAgICAgICAgICB0YWc6IHRoaXMudGFnLFxuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICBhcmdzLFxuICAgICAgICAgIGJsb2NrcyxcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBibG9ja3Moc3RhdGU6IE5vcm1hbGl6YXRpb25TdGF0ZSk6IFJlc3VsdDxtaXIuTmFtZWRCbG9ja3M+IHtcbiAgICByZXR1cm4gVklTSVRfU1RNVFMuTmFtZWRCbG9ja3ModGhpcy5lbGVtZW50LmJsb2Nrcywgc3RhdGUpO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9