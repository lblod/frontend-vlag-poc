"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BLOCK_KEYWORDS = void 0;

var _syntax = require("@glimmer/syntax");

var _result = require("../../../shared/result");

var mir = _interopRequireWildcard(require("../../2-encoding/mir"));

var _expressions = require("../visitors/expressions");

var _statements = require("../visitors/statements");

var _impl = require("./impl");

var _curry = require("./utils/curry");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const BLOCK_KEYWORDS = (0, _impl.keywords)('Block').kw('in-element', {
  assert(node) {
    let {
      args
    } = node;
    let guid = args.get('guid');

    if (guid) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`Cannot pass \`guid\` to \`{{#in-element}}\``, guid.loc));
    }

    let insertBefore = args.get('insertBefore');
    let destination = args.nth(0);

    if (destination === null) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#in-element}} requires a target element as its first positional parameter`, args.loc));
    } // TODO Better syntax checks


    return (0, _result.Ok)({
      insertBefore,
      destination
    });
  },

  translate({
    node,
    state
  }, {
    insertBefore,
    destination
  }) {
    let named = node.blocks.get('default');

    let body = _statements.VISIT_STMTS.NamedBlock(named, state);

    let destinationResult = _expressions.VISIT_EXPRS.visit(destination, state);

    return _result.Result.all(body, destinationResult).andThen(([body, destination]) => {
      if (insertBefore) {
        return _expressions.VISIT_EXPRS.visit(insertBefore, state).mapOk(insertBefore => ({
          body,
          destination,
          insertBefore
        }));
      } else {
        return (0, _result.Ok)({
          body,
          destination,
          insertBefore: new mir.Missing({
            loc: node.callee.loc.collapse('end')
          })
        });
      }
    }).mapOk(({
      body,
      destination,
      insertBefore
    }) => new mir.InElement({
      loc: node.loc,
      block: body,
      insertBefore,
      guid: state.generateUniqueCursor(),
      destination
    }));
  }

}).kw('if', {
  assert(node) {
    let {
      args
    } = node;

    if (!args.named.isEmpty()) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#if}} cannot receive named parameters, received ${args.named.entries.map(e => e.name.chars).join(', ')}`, node.loc));
    }

    if (args.positional.size > 1) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#if}} can only receive one positional parameter in block form, the conditional value. Received ${args.positional.size} parameters`, node.loc));
    }

    let condition = args.nth(0);

    if (condition === null) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#if}} requires a condition as its first positional parameter, did not receive any parameters`, node.loc));
    }

    return (0, _result.Ok)({
      condition
    });
  },

  translate({
    node,
    state
  }, {
    condition
  }) {
    let block = node.blocks.get('default');
    let inverse = node.blocks.get('else');

    let conditionResult = _expressions.VISIT_EXPRS.visit(condition, state);

    let blockResult = _statements.VISIT_STMTS.NamedBlock(block, state);

    let inverseResult = inverse ? _statements.VISIT_STMTS.NamedBlock(inverse, state) : (0, _result.Ok)(null);
    return _result.Result.all(conditionResult, blockResult, inverseResult).mapOk(([condition, block, inverse]) => new mir.If({
      loc: node.loc,
      condition,
      block,
      inverse
    }));
  }

}).kw('unless', {
  assert(node) {
    let {
      args
    } = node;

    if (!args.named.isEmpty()) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#unless}} cannot receive named parameters, received ${args.named.entries.map(e => e.name.chars).join(', ')}`, node.loc));
    }

    if (args.positional.size > 1) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#unless}} can only receive one positional parameter in block form, the conditional value. Received ${args.positional.size} parameters`, node.loc));
    }

    let condition = args.nth(0);

    if (condition === null) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#unless}} requires a condition as its first positional parameter, did not receive any parameters`, node.loc));
    }

    return (0, _result.Ok)({
      condition
    });
  },

  translate({
    node,
    state
  }, {
    condition
  }) {
    let block = node.blocks.get('default');
    let inverse = node.blocks.get('else');

    let conditionResult = _expressions.VISIT_EXPRS.visit(condition, state);

    let blockResult = _statements.VISIT_STMTS.NamedBlock(block, state);

    let inverseResult = inverse ? _statements.VISIT_STMTS.NamedBlock(inverse, state) : (0, _result.Ok)(null);
    return _result.Result.all(conditionResult, blockResult, inverseResult).mapOk(([condition, block, inverse]) => new mir.If({
      loc: node.loc,
      condition: new mir.Not({
        value: condition,
        loc: node.loc
      }),
      block,
      inverse
    }));
  }

}).kw('each', {
  assert(node) {
    let {
      args
    } = node;

    if (!args.named.entries.every(e => e.name.chars === 'key')) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#each}} can only receive the 'key' named parameter, received ${args.named.entries.filter(e => e.name.chars !== 'key').map(e => e.name.chars).join(', ')}`, args.named.loc));
    }

    if (args.positional.size > 1) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#each}} can only receive one positional parameter, the collection being iterated. Received ${args.positional.size} parameters`, args.positional.loc));
    }

    let value = args.nth(0);
    let key = args.get('key');

    if (value === null) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#each}} requires an iterable value to be passed as its first positional parameter, did not receive any parameters`, args.loc));
    }

    return (0, _result.Ok)({
      value,
      key
    });
  },

  translate({
    node,
    state
  }, {
    value,
    key
  }) {
    let block = node.blocks.get('default');
    let inverse = node.blocks.get('else');

    let valueResult = _expressions.VISIT_EXPRS.visit(value, state);

    let keyResult = key ? _expressions.VISIT_EXPRS.visit(key, state) : (0, _result.Ok)(null);

    let blockResult = _statements.VISIT_STMTS.NamedBlock(block, state);

    let inverseResult = inverse ? _statements.VISIT_STMTS.NamedBlock(inverse, state) : (0, _result.Ok)(null);
    return _result.Result.all(valueResult, keyResult, blockResult, inverseResult).mapOk(([value, key, block, inverse]) => new mir.Each({
      loc: node.loc,
      value,
      key,
      block,
      inverse
    }));
  }

}).kw('with', {
  assert(node) {
    let {
      args
    } = node;

    if (!args.named.isEmpty()) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#with}} cannot receive named parameters, received ${args.named.entries.map(e => e.name.chars).join(', ')}`, args.named.loc));
    }

    if (args.positional.size > 1) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#with}} can only receive one positional parameter. Received ${args.positional.size} parameters`, args.positional.loc));
    }

    let value = args.nth(0);

    if (value === null) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#with}} requires a value as its first positional parameter, did not receive any parameters`, args.loc));
    }

    return (0, _result.Ok)({
      value
    });
  },

  translate({
    node,
    state
  }, {
    value
  }) {
    let block = node.blocks.get('default');
    let inverse = node.blocks.get('else');

    let valueResult = _expressions.VISIT_EXPRS.visit(value, state);

    let blockResult = _statements.VISIT_STMTS.NamedBlock(block, state);

    let inverseResult = inverse ? _statements.VISIT_STMTS.NamedBlock(inverse, state) : (0, _result.Ok)(null);
    return _result.Result.all(valueResult, blockResult, inverseResult).mapOk(([value, block, inverse]) => new mir.With({
      loc: node.loc,
      value,
      block,
      inverse
    }));
  }

}).kw('let', {
  assert(node) {
    let {
      args
    } = node;

    if (!args.named.isEmpty()) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#let}} cannot receive named parameters, received ${args.named.entries.map(e => e.name.chars).join(', ')}`, args.named.loc));
    }

    if (args.positional.size === 0) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#let}} requires at least one value as its first positional parameter, did not receive any parameters`, args.positional.loc));
    }

    if (node.blocks.get('else')) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`{{#let}} cannot receive an {{else}} block`, args.positional.loc));
    }

    return (0, _result.Ok)({
      positional: args.positional
    });
  },

  translate({
    node,
    state
  }, {
    positional
  }) {
    let block = node.blocks.get('default');

    let positionalResult = _expressions.VISIT_EXPRS.Positional(positional, state);

    let blockResult = _statements.VISIT_STMTS.NamedBlock(block, state);

    return _result.Result.all(positionalResult, blockResult).mapOk(([positional, block]) => new mir.Let({
      loc: node.loc,
      positional,
      block
    }));
  }

}).kw('-with-dynamic-vars', {
  assert(node) {
    return (0, _result.Ok)({
      named: node.args.named
    });
  },

  translate({
    node,
    state
  }, {
    named
  }) {
    let block = node.blocks.get('default');

    let namedResult = _expressions.VISIT_EXPRS.NamedArguments(named, state);

    let blockResult = _statements.VISIT_STMTS.NamedBlock(block, state);

    return _result.Result.all(namedResult, blockResult).mapOk(([named, block]) => new mir.WithDynamicVars({
      loc: node.loc,
      named,
      block
    }));
  }

}).kw('component', {
  assert: (0, _curry.assertCurryKeyword)(0
  /* Component */
  ),

  translate({
    node,
    state
  }, {
    definition,
    args
  }) {
    let definitionResult = _expressions.VISIT_EXPRS.visit(definition, state);

    let argsResult = _expressions.VISIT_EXPRS.Args(args, state);

    let blocksResult = _statements.VISIT_STMTS.NamedBlocks(node.blocks, state);

    return _result.Result.all(definitionResult, argsResult, blocksResult).mapOk(([definition, args, blocks]) => new mir.InvokeComponent({
      loc: node.loc,
      definition,
      args,
      blocks
    }));
  }

});
exports.BLOCK_KEYWORDS = BLOCK_KEYWORDS;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL2tleXdvcmRzL2Jsb2NrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRU8sTUFBTSxjQUFjLEdBQUcsb0JBQUEsT0FBQSxFQUFBLEVBQUEsQ0FBQSxZQUFBLEVBQ1Y7QUFDaEIsRUFBQSxNQUFNLENBQUEsSUFBQSxFQUNtQjtBQUt2QixRQUFJO0FBQUUsTUFBQTtBQUFGLFFBQUosSUFBQTtBQUVBLFFBQUksSUFBSSxHQUFHLElBQUksQ0FBSixHQUFBLENBQVgsTUFBVyxDQUFYOztBQUVBLFFBQUEsSUFBQSxFQUFVO0FBQ1IsYUFBTyxpQkFBSSxpQ0FBbUIsNkNBQW5CLEVBQW1FLElBQUksQ0FBbEYsR0FBVyxDQUFKLENBQVA7QUFDRDs7QUFFRCxRQUFJLFlBQVksR0FBRyxJQUFJLENBQUosR0FBQSxDQUFuQixjQUFtQixDQUFuQjtBQUNBLFFBQUksV0FBVyxHQUFHLElBQUksQ0FBSixHQUFBLENBQWxCLENBQWtCLENBQWxCOztBQUVBLFFBQUksV0FBVyxLQUFmLElBQUEsRUFBMEI7QUFDeEIsYUFBTyxpQkFDTCxpQ0FBbUIsNkVBQW5CLEVBRUUsSUFBSSxDQUhSLEdBQ0UsQ0FESyxDQUFQO0FBakJxQixLQUFBLENBeUJ2Qjs7O0FBRUEsV0FBTyxnQkFBRztBQUFBLE1BQUEsWUFBQTtBQUFnQixNQUFBO0FBQWhCLEtBQUgsQ0FBUDtBQTdCYyxHQUFBOztBQWdDaEIsRUFBQSxTQUFTLENBQ1A7QUFBQSxJQUFBLElBQUE7QUFBUSxJQUFBO0FBQVIsR0FETyxFQUVQO0FBQUEsSUFBQSxZQUFBO0FBRUUsSUFBQTtBQUZGLEdBRk8sRUFLNEU7QUFFbkYsUUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFKLE1BQUEsQ0FBQSxHQUFBLENBQVosU0FBWSxDQUFaOztBQUNBLFFBQUksSUFBSSxHQUFHLHdCQUFBLFVBQUEsQ0FBQSxLQUFBLEVBQVgsS0FBVyxDQUFYOztBQUNBLFFBQUksaUJBQWlCLEdBQUcseUJBQUEsS0FBQSxDQUFBLFdBQUEsRUFBeEIsS0FBd0IsQ0FBeEI7O0FBRUEsV0FBTyxlQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsaUJBQUEsRUFBQSxPQUFBLENBRUgsQ0FBQyxDQUFBLElBQUEsRUFBRCxXQUFDLENBQUQsS0FJSztBQUNILFVBQUEsWUFBQSxFQUFrQjtBQUNoQixlQUFPLHlCQUFBLEtBQUEsQ0FBQSxZQUFBLEVBQUEsS0FBQSxFQUFBLEtBQUEsQ0FBOEMsWUFBRCxLQUFtQjtBQUFBLFVBQUEsSUFBQTtBQUFBLFVBQUEsV0FBQTtBQUdyRSxVQUFBO0FBSHFFLFNBQW5CLENBQTdDLENBQVA7QUFERixPQUFBLE1BTU87QUFDTCxlQUFPLGdCQUFHO0FBQUEsVUFBQSxJQUFBO0FBQUEsVUFBQSxXQUFBO0FBR1IsVUFBQSxZQUFZLEVBQUUsSUFBSSxHQUFHLENBQVAsT0FBQSxDQUFnQjtBQUM1QixZQUFBLEdBQUcsRUFBRSxJQUFJLENBQUosTUFBQSxDQUFBLEdBQUEsQ0FBQSxRQUFBLENBQUEsS0FBQTtBQUR1QixXQUFoQjtBQUhOLFNBQUgsQ0FBUDtBQU9EO0FBckJBLEtBQUEsRUFBQSxLQUFBLENBeUJILENBQUM7QUFBQSxNQUFBLElBQUE7QUFBQSxNQUFBLFdBQUE7QUFBcUIsTUFBQTtBQUFyQixLQUFELEtBQ0UsSUFBSSxHQUFHLENBQVAsU0FBQSxDQUFrQjtBQUNoQixNQUFBLEdBQUcsRUFBRSxJQUFJLENBRE8sR0FBQTtBQUVoQixNQUFBLEtBQUssRUFGVyxJQUFBO0FBQUEsTUFBQSxZQUFBO0FBSWhCLE1BQUEsSUFBSSxFQUFFLEtBQUssQ0FKSyxvQkFJVixFQUpVO0FBS2hCLE1BQUE7QUFMZ0IsS0FBbEIsQ0ExQkMsQ0FBUDtBQWtDRDs7QUE3RWUsQ0FEVSxFQUFBLEVBQUEsQ0FBQSxJQUFBLEVBZ0ZsQjtBQUNSLEVBQUEsTUFBTSxDQUFBLElBQUEsRUFDbUI7QUFJdkIsUUFBSTtBQUFFLE1BQUE7QUFBRixRQUFKLElBQUE7O0FBRUEsUUFBSSxDQUFDLElBQUksQ0FBSixLQUFBLENBQUwsT0FBSyxFQUFMLEVBQTJCO0FBQ3pCLGFBQU8saUJBQ0wsaUNBQ0UscURBQXFELElBQUksQ0FBSixLQUFBLENBQUEsT0FBQSxDQUFBLEdBQUEsQ0FDN0MsQ0FBRCxJQUFPLENBQUMsQ0FBRCxJQUFBLENBRHVDLEtBQUEsRUFBQSxJQUFBLENBQUEsSUFBQSxDQURwQyxFQUFuQixFQUlFLElBQUksQ0FMUixHQUNFLENBREssQ0FBUDtBQVFEOztBQUVELFFBQUksSUFBSSxDQUFKLFVBQUEsQ0FBQSxJQUFBLEdBQUosQ0FBQSxFQUE4QjtBQUM1QixhQUFPLGlCQUNMLGlDQUNFLG9HQUFvRyxJQUFJLENBQUosVUFBQSxDQUFnQixJQURuRyxhQUFuQixFQUVFLElBQUksQ0FIUixHQUNFLENBREssQ0FBUDtBQU1EOztBQUVELFFBQUksU0FBUyxHQUFHLElBQUksQ0FBSixHQUFBLENBQWhCLENBQWdCLENBQWhCOztBQUVBLFFBQUksU0FBUyxLQUFiLElBQUEsRUFBd0I7QUFDdEIsYUFBTyxpQkFDTCxpQ0FBbUIsZ0dBQW5CLEVBRUUsSUFBSSxDQUhSLEdBQ0UsQ0FESyxDQUFQO0FBTUQ7O0FBRUQsV0FBTyxnQkFBRztBQUFFLE1BQUE7QUFBRixLQUFILENBQVA7QUF2Q00sR0FBQTs7QUEwQ1IsRUFBQSxTQUFTLENBQ1A7QUFBQSxJQUFBLElBQUE7QUFBUSxJQUFBO0FBQVIsR0FETyxFQUVQO0FBQUUsSUFBQTtBQUFGLEdBRk8sRUFFMkM7QUFFbEQsUUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFKLE1BQUEsQ0FBQSxHQUFBLENBQVosU0FBWSxDQUFaO0FBQ0EsUUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFKLE1BQUEsQ0FBQSxHQUFBLENBQWQsTUFBYyxDQUFkOztBQUVBLFFBQUksZUFBZSxHQUFHLHlCQUFBLEtBQUEsQ0FBQSxTQUFBLEVBQXRCLEtBQXNCLENBQXRCOztBQUNBLFFBQUksV0FBVyxHQUFHLHdCQUFBLFVBQUEsQ0FBQSxLQUFBLEVBQWxCLEtBQWtCLENBQWxCOztBQUNBLFFBQUksYUFBYSxHQUFHLE9BQU8sR0FBRyx3QkFBQSxVQUFBLENBQUEsT0FBQSxFQUFILEtBQUcsQ0FBSCxHQUE0QyxnQkFBdkUsSUFBdUUsQ0FBdkU7QUFFQSxXQUFPLGVBQUEsR0FBQSxDQUFBLGVBQUEsRUFBQSxXQUFBLEVBQUEsYUFBQSxFQUFBLEtBQUEsQ0FDTCxDQUFDLENBQUEsU0FBQSxFQUFBLEtBQUEsRUFBRCxPQUFDLENBQUQsS0FDRSxJQUFJLEdBQUcsQ0FBUCxFQUFBLENBQVc7QUFDVCxNQUFBLEdBQUcsRUFBRSxJQUFJLENBREEsR0FBQTtBQUFBLE1BQUEsU0FBQTtBQUFBLE1BQUEsS0FBQTtBQUlULE1BQUE7QUFKUyxLQUFYLENBRkcsQ0FBUDtBQVNEOztBQTlETyxDQWhGa0IsRUFBQSxFQUFBLENBQUEsUUFBQSxFQWdKZDtBQUNaLEVBQUEsTUFBTSxDQUFBLElBQUEsRUFDbUI7QUFJdkIsUUFBSTtBQUFFLE1BQUE7QUFBRixRQUFKLElBQUE7O0FBRUEsUUFBSSxDQUFDLElBQUksQ0FBSixLQUFBLENBQUwsT0FBSyxFQUFMLEVBQTJCO0FBQ3pCLGFBQU8saUJBQ0wsaUNBQ0UseURBQXlELElBQUksQ0FBSixLQUFBLENBQUEsT0FBQSxDQUFBLEdBQUEsQ0FDakQsQ0FBRCxJQUFPLENBQUMsQ0FBRCxJQUFBLENBRDJDLEtBQUEsRUFBQSxJQUFBLENBQUEsSUFBQSxDQUR4QyxFQUFuQixFQUlFLElBQUksQ0FMUixHQUNFLENBREssQ0FBUDtBQVFEOztBQUVELFFBQUksSUFBSSxDQUFKLFVBQUEsQ0FBQSxJQUFBLEdBQUosQ0FBQSxFQUE4QjtBQUM1QixhQUFPLGlCQUNMLGlDQUNFLHdHQUF3RyxJQUFJLENBQUosVUFBQSxDQUFnQixJQUR2RyxhQUFuQixFQUVFLElBQUksQ0FIUixHQUNFLENBREssQ0FBUDtBQU1EOztBQUVELFFBQUksU0FBUyxHQUFHLElBQUksQ0FBSixHQUFBLENBQWhCLENBQWdCLENBQWhCOztBQUVBLFFBQUksU0FBUyxLQUFiLElBQUEsRUFBd0I7QUFDdEIsYUFBTyxpQkFDTCxpQ0FBbUIsb0dBQW5CLEVBRUUsSUFBSSxDQUhSLEdBQ0UsQ0FESyxDQUFQO0FBTUQ7O0FBRUQsV0FBTyxnQkFBRztBQUFFLE1BQUE7QUFBRixLQUFILENBQVA7QUF2Q1UsR0FBQTs7QUEwQ1osRUFBQSxTQUFTLENBQ1A7QUFBQSxJQUFBLElBQUE7QUFBUSxJQUFBO0FBQVIsR0FETyxFQUVQO0FBQUUsSUFBQTtBQUFGLEdBRk8sRUFFMkM7QUFFbEQsUUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFKLE1BQUEsQ0FBQSxHQUFBLENBQVosU0FBWSxDQUFaO0FBQ0EsUUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFKLE1BQUEsQ0FBQSxHQUFBLENBQWQsTUFBYyxDQUFkOztBQUVBLFFBQUksZUFBZSxHQUFHLHlCQUFBLEtBQUEsQ0FBQSxTQUFBLEVBQXRCLEtBQXNCLENBQXRCOztBQUNBLFFBQUksV0FBVyxHQUFHLHdCQUFBLFVBQUEsQ0FBQSxLQUFBLEVBQWxCLEtBQWtCLENBQWxCOztBQUNBLFFBQUksYUFBYSxHQUFHLE9BQU8sR0FBRyx3QkFBQSxVQUFBLENBQUEsT0FBQSxFQUFILEtBQUcsQ0FBSCxHQUE0QyxnQkFBdkUsSUFBdUUsQ0FBdkU7QUFFQSxXQUFPLGVBQUEsR0FBQSxDQUFBLGVBQUEsRUFBQSxXQUFBLEVBQUEsYUFBQSxFQUFBLEtBQUEsQ0FDTCxDQUFDLENBQUEsU0FBQSxFQUFBLEtBQUEsRUFBRCxPQUFDLENBQUQsS0FDRSxJQUFJLEdBQUcsQ0FBUCxFQUFBLENBQVc7QUFDVCxNQUFBLEdBQUcsRUFBRSxJQUFJLENBREEsR0FBQTtBQUVULE1BQUEsU0FBUyxFQUFFLElBQUksR0FBRyxDQUFQLEdBQUEsQ0FBWTtBQUFFLFFBQUEsS0FBSyxFQUFQLFNBQUE7QUFBb0IsUUFBQSxHQUFHLEVBQUUsSUFBSSxDQUFDO0FBQTlCLE9BQVosQ0FGRjtBQUFBLE1BQUEsS0FBQTtBQUlULE1BQUE7QUFKUyxLQUFYLENBRkcsQ0FBUDtBQVNEOztBQTlEVyxDQWhKYyxFQUFBLEVBQUEsQ0FBQSxNQUFBLEVBZ05oQjtBQUNWLEVBQUEsTUFBTSxDQUFBLElBQUEsRUFDbUI7QUFLdkIsUUFBSTtBQUFFLE1BQUE7QUFBRixRQUFKLElBQUE7O0FBRUEsUUFBSSxDQUFDLElBQUksQ0FBSixLQUFBLENBQUEsT0FBQSxDQUFBLEtBQUEsQ0FBMEIsQ0FBRCxJQUFPLENBQUMsQ0FBRCxJQUFBLENBQUEsS0FBQSxLQUFyQyxLQUFLLENBQUwsRUFBOEQ7QUFDNUQsYUFBTyxpQkFDTCxpQ0FDRSxrRUFBa0UsSUFBSSxDQUFKLEtBQUEsQ0FBQSxPQUFBLENBQUEsTUFBQSxDQUN2RCxDQUFELElBQU8sQ0FBQyxDQUFELElBQUEsQ0FBQSxLQUFBLEtBRGlELEtBQUEsRUFBQSxHQUFBLENBRTFELENBQUQsSUFBTyxDQUFDLENBQUQsSUFBQSxDQUZvRCxLQUFBLEVBQUEsSUFBQSxDQUFBLElBQUEsQ0FEakQsRUFBbkIsRUFLRSxJQUFJLENBQUosS0FBQSxDQU5KLEdBQ0UsQ0FESyxDQUFQO0FBU0Q7O0FBRUQsUUFBSSxJQUFJLENBQUosVUFBQSxDQUFBLElBQUEsR0FBSixDQUFBLEVBQThCO0FBQzVCLGFBQU8saUJBQ0wsaUNBQ0UsZ0dBQWdHLElBQUksQ0FBSixVQUFBLENBQWdCLElBRC9GLGFBQW5CLEVBRUUsSUFBSSxDQUFKLFVBQUEsQ0FISixHQUNFLENBREssQ0FBUDtBQU1EOztBQUVELFFBQUksS0FBSyxHQUFHLElBQUksQ0FBSixHQUFBLENBQVosQ0FBWSxDQUFaO0FBQ0EsUUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFKLEdBQUEsQ0FBVixLQUFVLENBQVY7O0FBRUEsUUFBSSxLQUFLLEtBQVQsSUFBQSxFQUFvQjtBQUNsQixhQUFPLGlCQUNMLGlDQUFtQixxSEFBbkIsRUFFRSxJQUFJLENBSFIsR0FDRSxDQURLLENBQVA7QUFNRDs7QUFFRCxXQUFPLGdCQUFHO0FBQUEsTUFBQSxLQUFBO0FBQVMsTUFBQTtBQUFULEtBQUgsQ0FBUDtBQTFDUSxHQUFBOztBQTZDVixFQUFBLFNBQVMsQ0FDUDtBQUFBLElBQUEsSUFBQTtBQUFRLElBQUE7QUFBUixHQURPLEVBRVA7QUFBQSxJQUFBLEtBQUE7QUFBUyxJQUFBO0FBQVQsR0FGTyxFQUUwRTtBQUVqRixRQUFJLEtBQUssR0FBRyxJQUFJLENBQUosTUFBQSxDQUFBLEdBQUEsQ0FBWixTQUFZLENBQVo7QUFDQSxRQUFJLE9BQU8sR0FBRyxJQUFJLENBQUosTUFBQSxDQUFBLEdBQUEsQ0FBZCxNQUFjLENBQWQ7O0FBRUEsUUFBSSxXQUFXLEdBQUcseUJBQUEsS0FBQSxDQUFBLEtBQUEsRUFBbEIsS0FBa0IsQ0FBbEI7O0FBQ0EsUUFBSSxTQUFTLEdBQUcsR0FBRyxHQUFHLHlCQUFBLEtBQUEsQ0FBQSxHQUFBLEVBQUgsS0FBRyxDQUFILEdBQW1DLGdCQUF0RCxJQUFzRCxDQUF0RDs7QUFFQSxRQUFJLFdBQVcsR0FBRyx3QkFBQSxVQUFBLENBQUEsS0FBQSxFQUFsQixLQUFrQixDQUFsQjs7QUFDQSxRQUFJLGFBQWEsR0FBRyxPQUFPLEdBQUcsd0JBQUEsVUFBQSxDQUFBLE9BQUEsRUFBSCxLQUFHLENBQUgsR0FBNEMsZ0JBQXZFLElBQXVFLENBQXZFO0FBRUEsV0FBTyxlQUFBLEdBQUEsQ0FBQSxXQUFBLEVBQUEsU0FBQSxFQUFBLFdBQUEsRUFBQSxhQUFBLEVBQUEsS0FBQSxDQUNMLENBQUMsQ0FBQSxLQUFBLEVBQUEsR0FBQSxFQUFBLEtBQUEsRUFBRCxPQUFDLENBQUQsS0FDRSxJQUFJLEdBQUcsQ0FBUCxJQUFBLENBQWE7QUFDWCxNQUFBLEdBQUcsRUFBRSxJQUFJLENBREUsR0FBQTtBQUFBLE1BQUEsS0FBQTtBQUFBLE1BQUEsR0FBQTtBQUFBLE1BQUEsS0FBQTtBQUtYLE1BQUE7QUFMVyxLQUFiLENBRkcsQ0FBUDtBQVVEOztBQXBFUyxDQWhOZ0IsRUFBQSxFQUFBLENBQUEsTUFBQSxFQXNSaEI7QUFDVixFQUFBLE1BQU0sQ0FBQSxJQUFBLEVBQ21CO0FBSXZCLFFBQUk7QUFBRSxNQUFBO0FBQUYsUUFBSixJQUFBOztBQUVBLFFBQUksQ0FBQyxJQUFJLENBQUosS0FBQSxDQUFMLE9BQUssRUFBTCxFQUEyQjtBQUN6QixhQUFPLGlCQUNMLGlDQUNFLHVEQUF1RCxJQUFJLENBQUosS0FBQSxDQUFBLE9BQUEsQ0FBQSxHQUFBLENBQy9DLENBQUQsSUFBTyxDQUFDLENBQUQsSUFBQSxDQUR5QyxLQUFBLEVBQUEsSUFBQSxDQUFBLElBQUEsQ0FEdEMsRUFBbkIsRUFJRSxJQUFJLENBQUosS0FBQSxDQUxKLEdBQ0UsQ0FESyxDQUFQO0FBUUQ7O0FBRUQsUUFBSSxJQUFJLENBQUosVUFBQSxDQUFBLElBQUEsR0FBSixDQUFBLEVBQThCO0FBQzVCLGFBQU8saUJBQ0wsaUNBQ0UsaUVBQWlFLElBQUksQ0FBSixVQUFBLENBQWdCLElBRGhFLGFBQW5CLEVBRUUsSUFBSSxDQUFKLFVBQUEsQ0FISixHQUNFLENBREssQ0FBUDtBQU1EOztBQUVELFFBQUksS0FBSyxHQUFHLElBQUksQ0FBSixHQUFBLENBQVosQ0FBWSxDQUFaOztBQUVBLFFBQUksS0FBSyxLQUFULElBQUEsRUFBb0I7QUFDbEIsYUFBTyxpQkFDTCxpQ0FBbUIsOEZBQW5CLEVBRUUsSUFBSSxDQUhSLEdBQ0UsQ0FESyxDQUFQO0FBTUQ7O0FBRUQsV0FBTyxnQkFBRztBQUFFLE1BQUE7QUFBRixLQUFILENBQVA7QUF2Q1EsR0FBQTs7QUEwQ1YsRUFBQSxTQUFTLENBQ1A7QUFBQSxJQUFBLElBQUE7QUFBUSxJQUFBO0FBQVIsR0FETyxFQUVQO0FBQUUsSUFBQTtBQUFGLEdBRk8sRUFFbUM7QUFFMUMsUUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFKLE1BQUEsQ0FBQSxHQUFBLENBQVosU0FBWSxDQUFaO0FBQ0EsUUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFKLE1BQUEsQ0FBQSxHQUFBLENBQWQsTUFBYyxDQUFkOztBQUVBLFFBQUksV0FBVyxHQUFHLHlCQUFBLEtBQUEsQ0FBQSxLQUFBLEVBQWxCLEtBQWtCLENBQWxCOztBQUNBLFFBQUksV0FBVyxHQUFHLHdCQUFBLFVBQUEsQ0FBQSxLQUFBLEVBQWxCLEtBQWtCLENBQWxCOztBQUNBLFFBQUksYUFBYSxHQUFHLE9BQU8sR0FBRyx3QkFBQSxVQUFBLENBQUEsT0FBQSxFQUFILEtBQUcsQ0FBSCxHQUE0QyxnQkFBdkUsSUFBdUUsQ0FBdkU7QUFFQSxXQUFPLGVBQUEsR0FBQSxDQUFBLFdBQUEsRUFBQSxXQUFBLEVBQUEsYUFBQSxFQUFBLEtBQUEsQ0FDTCxDQUFDLENBQUEsS0FBQSxFQUFBLEtBQUEsRUFBRCxPQUFDLENBQUQsS0FDRSxJQUFJLEdBQUcsQ0FBUCxJQUFBLENBQWE7QUFDWCxNQUFBLEdBQUcsRUFBRSxJQUFJLENBREUsR0FBQTtBQUFBLE1BQUEsS0FBQTtBQUFBLE1BQUEsS0FBQTtBQUlYLE1BQUE7QUFKVyxLQUFiLENBRkcsQ0FBUDtBQVNEOztBQTlEUyxDQXRSZ0IsRUFBQSxFQUFBLENBQUEsS0FBQSxFQXNWakI7QUFDVCxFQUFBLE1BQU0sQ0FBQSxJQUFBLEVBQ21CO0FBSXZCLFFBQUk7QUFBRSxNQUFBO0FBQUYsUUFBSixJQUFBOztBQUVBLFFBQUksQ0FBQyxJQUFJLENBQUosS0FBQSxDQUFMLE9BQUssRUFBTCxFQUEyQjtBQUN6QixhQUFPLGlCQUNMLGlDQUNFLHNEQUFzRCxJQUFJLENBQUosS0FBQSxDQUFBLE9BQUEsQ0FBQSxHQUFBLENBQzlDLENBQUQsSUFBTyxDQUFDLENBQUQsSUFBQSxDQUR3QyxLQUFBLEVBQUEsSUFBQSxDQUFBLElBQUEsQ0FEckMsRUFBbkIsRUFJRSxJQUFJLENBQUosS0FBQSxDQUxKLEdBQ0UsQ0FESyxDQUFQO0FBUUQ7O0FBRUQsUUFBSSxJQUFJLENBQUosVUFBQSxDQUFBLElBQUEsS0FBSixDQUFBLEVBQWdDO0FBQzlCLGFBQU8saUJBQ0wsaUNBQW1CLHdHQUFuQixFQUVFLElBQUksQ0FBSixVQUFBLENBSEosR0FDRSxDQURLLENBQVA7QUFNRDs7QUFFRCxRQUFJLElBQUksQ0FBSixNQUFBLENBQUEsR0FBQSxDQUFKLE1BQUksQ0FBSixFQUE2QjtBQUMzQixhQUFPLGlCQUNMLGlDQUFtQiwyQ0FBbkIsRUFBaUUsSUFBSSxDQUFKLFVBQUEsQ0FEbkUsR0FDRSxDQURLLENBQVA7QUFHRDs7QUFFRCxXQUFPLGdCQUFHO0FBQUUsTUFBQSxVQUFVLEVBQUUsSUFBSSxDQUFDO0FBQW5CLEtBQUgsQ0FBUDtBQWxDTyxHQUFBOztBQXFDVCxFQUFBLFNBQVMsQ0FDUDtBQUFBLElBQUEsSUFBQTtBQUFRLElBQUE7QUFBUixHQURPLEVBRVA7QUFBRSxJQUFBO0FBQUYsR0FGTyxFQUVrRDtBQUV6RCxRQUFJLEtBQUssR0FBRyxJQUFJLENBQUosTUFBQSxDQUFBLEdBQUEsQ0FBWixTQUFZLENBQVo7O0FBRUEsUUFBSSxnQkFBZ0IsR0FBRyx5QkFBQSxVQUFBLENBQUEsVUFBQSxFQUF2QixLQUF1QixDQUF2Qjs7QUFDQSxRQUFJLFdBQVcsR0FBRyx3QkFBQSxVQUFBLENBQUEsS0FBQSxFQUFsQixLQUFrQixDQUFsQjs7QUFFQSxXQUFPLGVBQUEsR0FBQSxDQUFBLGdCQUFBLEVBQUEsV0FBQSxFQUFBLEtBQUEsQ0FDTCxDQUFDLENBQUEsVUFBQSxFQUFELEtBQUMsQ0FBRCxLQUNFLElBQUksR0FBRyxDQUFQLEdBQUEsQ0FBWTtBQUNWLE1BQUEsR0FBRyxFQUFFLElBQUksQ0FEQyxHQUFBO0FBQUEsTUFBQSxVQUFBO0FBR1YsTUFBQTtBQUhVLEtBQVosQ0FGRyxDQUFQO0FBUUQ7O0FBdERRLENBdFZpQixFQUFBLEVBQUEsQ0FBQSxvQkFBQSxFQThZRjtBQUN4QixFQUFBLE1BQU0sQ0FBQSxJQUFBLEVBQ21CO0FBSXZCLFdBQU8sZ0JBQUc7QUFBRSxNQUFBLEtBQUssRUFBRSxJQUFJLENBQUosSUFBQSxDQUFVO0FBQW5CLEtBQUgsQ0FBUDtBQU5zQixHQUFBOztBQVN4QixFQUFBLFNBQVMsQ0FDUDtBQUFBLElBQUEsSUFBQTtBQUFRLElBQUE7QUFBUixHQURPLEVBRVA7QUFBRSxJQUFBO0FBQUYsR0FGTyxFQUVtQztBQUUxQyxRQUFJLEtBQUssR0FBRyxJQUFJLENBQUosTUFBQSxDQUFBLEdBQUEsQ0FBWixTQUFZLENBQVo7O0FBRUEsUUFBSSxXQUFXLEdBQUcseUJBQUEsY0FBQSxDQUFBLEtBQUEsRUFBbEIsS0FBa0IsQ0FBbEI7O0FBQ0EsUUFBSSxXQUFXLEdBQUcsd0JBQUEsVUFBQSxDQUFBLEtBQUEsRUFBbEIsS0FBa0IsQ0FBbEI7O0FBRUEsV0FBTyxlQUFBLEdBQUEsQ0FBQSxXQUFBLEVBQUEsV0FBQSxFQUFBLEtBQUEsQ0FDTCxDQUFDLENBQUEsS0FBQSxFQUFELEtBQUMsQ0FBRCxLQUNFLElBQUksR0FBRyxDQUFQLGVBQUEsQ0FBd0I7QUFDdEIsTUFBQSxHQUFHLEVBQUUsSUFBSSxDQURhLEdBQUE7QUFBQSxNQUFBLEtBQUE7QUFHdEIsTUFBQTtBQUhzQixLQUF4QixDQUZHLENBQVA7QUFRRDs7QUExQnVCLENBOVlFLEVBQUEsRUFBQSxDQUFBLFdBQUEsRUEwYVg7QUFDZixFQUFBLE1BQU0sRUFBRSwrQkFBa0I7QUFBQTtBQUFsQixHQURPOztBQUdmLEVBQUEsU0FBUyxDQUNQO0FBQUEsSUFBQSxJQUFBO0FBQVEsSUFBQTtBQUFSLEdBRE8sRUFFUDtBQUFBLElBQUEsVUFBQTtBQUFjLElBQUE7QUFBZCxHQUZPLEVBRXFFO0FBRTVFLFFBQUksZ0JBQWdCLEdBQUcseUJBQUEsS0FBQSxDQUFBLFVBQUEsRUFBdkIsS0FBdUIsQ0FBdkI7O0FBQ0EsUUFBSSxVQUFVLEdBQUcseUJBQUEsSUFBQSxDQUFBLElBQUEsRUFBakIsS0FBaUIsQ0FBakI7O0FBQ0EsUUFBSSxZQUFZLEdBQUcsd0JBQUEsV0FBQSxDQUF3QixJQUFJLENBQTVCLE1BQUEsRUFBbkIsS0FBbUIsQ0FBbkI7O0FBRUEsV0FBTyxlQUFBLEdBQUEsQ0FBQSxnQkFBQSxFQUFBLFVBQUEsRUFBQSxZQUFBLEVBQUEsS0FBQSxDQUNMLENBQUMsQ0FBQSxVQUFBLEVBQUEsSUFBQSxFQUFELE1BQUMsQ0FBRCxLQUNFLElBQUksR0FBRyxDQUFQLGVBQUEsQ0FBd0I7QUFDdEIsTUFBQSxHQUFHLEVBQUUsSUFBSSxDQURhLEdBQUE7QUFBQSxNQUFBLFVBQUE7QUFBQSxNQUFBLElBQUE7QUFJdEIsTUFBQTtBQUpzQixLQUF4QixDQUZHLENBQVA7QUFTRDs7QUFwQmMsQ0ExYVcsQ0FBdkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDdXJyaWVkVHlwZSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgQVNUdjIsIGdlbmVyYXRlU3ludGF4RXJyb3IgfSBmcm9tICdAZ2xpbW1lci9zeW50YXgnO1xuXG5pbXBvcnQgeyBFcnIsIE9rLCBSZXN1bHQgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvcmVzdWx0JztcbmltcG9ydCAqIGFzIG1pciBmcm9tICcuLi8uLi8yLWVuY29kaW5nL21pcic7XG5pbXBvcnQgeyBOb3JtYWxpemF0aW9uU3RhdGUgfSBmcm9tICcuLi9jb250ZXh0JztcbmltcG9ydCB7IFZJU0lUX0VYUFJTIH0gZnJvbSAnLi4vdmlzaXRvcnMvZXhwcmVzc2lvbnMnO1xuaW1wb3J0IHsgVklTSVRfU1RNVFMgfSBmcm9tICcuLi92aXNpdG9ycy9zdGF0ZW1lbnRzJztcbmltcG9ydCB7IGtleXdvcmRzIH0gZnJvbSAnLi9pbXBsJztcbmltcG9ydCB7IGFzc2VydEN1cnJ5S2V5d29yZCB9IGZyb20gJy4vdXRpbHMvY3VycnknO1xuXG5leHBvcnQgY29uc3QgQkxPQ0tfS0VZV09SRFMgPSBrZXl3b3JkcygnQmxvY2snKVxuICAua3coJ2luLWVsZW1lbnQnLCB7XG4gICAgYXNzZXJ0KFxuICAgICAgbm9kZTogQVNUdjIuSW52b2tlQmxvY2tcbiAgICApOiBSZXN1bHQ8e1xuICAgICAgaW5zZXJ0QmVmb3JlOiBBU1R2Mi5FeHByZXNzaW9uTm9kZSB8IG51bGw7XG4gICAgICBkZXN0aW5hdGlvbjogQVNUdjIuRXhwcmVzc2lvbk5vZGU7XG4gICAgfT4ge1xuICAgICAgbGV0IHsgYXJncyB9ID0gbm9kZTtcblxuICAgICAgbGV0IGd1aWQgPSBhcmdzLmdldCgnZ3VpZCcpO1xuXG4gICAgICBpZiAoZ3VpZCkge1xuICAgICAgICByZXR1cm4gRXJyKGdlbmVyYXRlU3ludGF4RXJyb3IoYENhbm5vdCBwYXNzIFxcYGd1aWRcXGAgdG8gXFxge3sjaW4tZWxlbWVudH19XFxgYCwgZ3VpZC5sb2MpKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGluc2VydEJlZm9yZSA9IGFyZ3MuZ2V0KCdpbnNlcnRCZWZvcmUnKTtcbiAgICAgIGxldCBkZXN0aW5hdGlvbiA9IGFyZ3MubnRoKDApO1xuXG4gICAgICBpZiAoZGVzdGluYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIEVycihcbiAgICAgICAgICBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgICAgYHt7I2luLWVsZW1lbnR9fSByZXF1aXJlcyBhIHRhcmdldCBlbGVtZW50IGFzIGl0cyBmaXJzdCBwb3NpdGlvbmFsIHBhcmFtZXRlcmAsXG4gICAgICAgICAgICBhcmdzLmxvY1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETyBCZXR0ZXIgc3ludGF4IGNoZWNrc1xuXG4gICAgICByZXR1cm4gT2soeyBpbnNlcnRCZWZvcmUsIGRlc3RpbmF0aW9uIH0pO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGUoXG4gICAgICB7IG5vZGUsIHN0YXRlIH06IHsgbm9kZTogQVNUdjIuSW52b2tlQmxvY2s7IHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGUgfSxcbiAgICAgIHtcbiAgICAgICAgaW5zZXJ0QmVmb3JlLFxuICAgICAgICBkZXN0aW5hdGlvbixcbiAgICAgIH06IHsgaW5zZXJ0QmVmb3JlOiBBU1R2Mi5FeHByZXNzaW9uTm9kZSB8IG51bGw7IGRlc3RpbmF0aW9uOiBBU1R2Mi5FeHByZXNzaW9uTm9kZSB9XG4gICAgKTogUmVzdWx0PG1pci5JbkVsZW1lbnQ+IHtcbiAgICAgIGxldCBuYW1lZCA9IG5vZGUuYmxvY2tzLmdldCgnZGVmYXVsdCcpO1xuICAgICAgbGV0IGJvZHkgPSBWSVNJVF9TVE1UUy5OYW1lZEJsb2NrKG5hbWVkLCBzdGF0ZSk7XG4gICAgICBsZXQgZGVzdGluYXRpb25SZXN1bHQgPSBWSVNJVF9FWFBSUy52aXNpdChkZXN0aW5hdGlvbiwgc3RhdGUpO1xuXG4gICAgICByZXR1cm4gUmVzdWx0LmFsbChib2R5LCBkZXN0aW5hdGlvblJlc3VsdClcbiAgICAgICAgLmFuZFRoZW4oXG4gICAgICAgICAgKFtib2R5LCBkZXN0aW5hdGlvbl0pOiBSZXN1bHQ8e1xuICAgICAgICAgICAgYm9keTogbWlyLk5hbWVkQmxvY2s7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogbWlyLkV4cHJlc3Npb25Ob2RlO1xuICAgICAgICAgICAgaW5zZXJ0QmVmb3JlOiBtaXIuRXhwcmVzc2lvbk5vZGU7XG4gICAgICAgICAgfT4gPT4ge1xuICAgICAgICAgICAgaWYgKGluc2VydEJlZm9yZSkge1xuICAgICAgICAgICAgICByZXR1cm4gVklTSVRfRVhQUlMudmlzaXQoaW5zZXJ0QmVmb3JlLCBzdGF0ZSkubWFwT2soKGluc2VydEJlZm9yZSkgPT4gKHtcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZSxcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIE9rKHtcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgIGluc2VydEJlZm9yZTogbmV3IG1pci5NaXNzaW5nKHtcbiAgICAgICAgICAgICAgICAgIGxvYzogbm9kZS5jYWxsZWUubG9jLmNvbGxhcHNlKCdlbmQnKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAgIC5tYXBPayhcbiAgICAgICAgICAoeyBib2R5LCBkZXN0aW5hdGlvbiwgaW5zZXJ0QmVmb3JlIH0pID0+XG4gICAgICAgICAgICBuZXcgbWlyLkluRWxlbWVudCh7XG4gICAgICAgICAgICAgIGxvYzogbm9kZS5sb2MsXG4gICAgICAgICAgICAgIGJsb2NrOiBib2R5LFxuICAgICAgICAgICAgICBpbnNlcnRCZWZvcmUsXG4gICAgICAgICAgICAgIGd1aWQ6IHN0YXRlLmdlbmVyYXRlVW5pcXVlQ3Vyc29yKCksXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9LFxuICB9KVxuICAua3coJ2lmJywge1xuICAgIGFzc2VydChcbiAgICAgIG5vZGU6IEFTVHYyLkludm9rZUJsb2NrXG4gICAgKTogUmVzdWx0PHtcbiAgICAgIGNvbmRpdGlvbjogQVNUdjIuRXhwcmVzc2lvbk5vZGU7XG4gICAgfT4ge1xuICAgICAgbGV0IHsgYXJncyB9ID0gbm9kZTtcblxuICAgICAgaWYgKCFhcmdzLm5hbWVkLmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gRXJyKFxuICAgICAgICAgIGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgICBge3sjaWZ9fSBjYW5ub3QgcmVjZWl2ZSBuYW1lZCBwYXJhbWV0ZXJzLCByZWNlaXZlZCAke2FyZ3MubmFtZWQuZW50cmllc1xuICAgICAgICAgICAgICAubWFwKChlKSA9PiBlLm5hbWUuY2hhcnMpXG4gICAgICAgICAgICAgIC5qb2luKCcsICcpfWAsXG4gICAgICAgICAgICBub2RlLmxvY1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3MucG9zaXRpb25hbC5zaXplID4gMSkge1xuICAgICAgICByZXR1cm4gRXJyKFxuICAgICAgICAgIGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgICBge3sjaWZ9fSBjYW4gb25seSByZWNlaXZlIG9uZSBwb3NpdGlvbmFsIHBhcmFtZXRlciBpbiBibG9jayBmb3JtLCB0aGUgY29uZGl0aW9uYWwgdmFsdWUuIFJlY2VpdmVkICR7YXJncy5wb3NpdGlvbmFsLnNpemV9IHBhcmFtZXRlcnNgLFxuICAgICAgICAgICAgbm9kZS5sb2NcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCBjb25kaXRpb24gPSBhcmdzLm50aCgwKTtcblxuICAgICAgaWYgKGNvbmRpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gRXJyKFxuICAgICAgICAgIGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgICBge3sjaWZ9fSByZXF1aXJlcyBhIGNvbmRpdGlvbiBhcyBpdHMgZmlyc3QgcG9zaXRpb25hbCBwYXJhbWV0ZXIsIGRpZCBub3QgcmVjZWl2ZSBhbnkgcGFyYW1ldGVyc2AsXG4gICAgICAgICAgICBub2RlLmxvY1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9rKHsgY29uZGl0aW9uIH0pO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGUoXG4gICAgICB7IG5vZGUsIHN0YXRlIH06IHsgbm9kZTogQVNUdjIuSW52b2tlQmxvY2s7IHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGUgfSxcbiAgICAgIHsgY29uZGl0aW9uIH06IHsgY29uZGl0aW9uOiBBU1R2Mi5FeHByZXNzaW9uTm9kZSB9XG4gICAgKTogUmVzdWx0PG1pci5JZj4ge1xuICAgICAgbGV0IGJsb2NrID0gbm9kZS5ibG9ja3MuZ2V0KCdkZWZhdWx0Jyk7XG4gICAgICBsZXQgaW52ZXJzZSA9IG5vZGUuYmxvY2tzLmdldCgnZWxzZScpO1xuXG4gICAgICBsZXQgY29uZGl0aW9uUmVzdWx0ID0gVklTSVRfRVhQUlMudmlzaXQoY29uZGl0aW9uLCBzdGF0ZSk7XG4gICAgICBsZXQgYmxvY2tSZXN1bHQgPSBWSVNJVF9TVE1UUy5OYW1lZEJsb2NrKGJsb2NrLCBzdGF0ZSk7XG4gICAgICBsZXQgaW52ZXJzZVJlc3VsdCA9IGludmVyc2UgPyBWSVNJVF9TVE1UUy5OYW1lZEJsb2NrKGludmVyc2UsIHN0YXRlKSA6IE9rKG51bGwpO1xuXG4gICAgICByZXR1cm4gUmVzdWx0LmFsbChjb25kaXRpb25SZXN1bHQsIGJsb2NrUmVzdWx0LCBpbnZlcnNlUmVzdWx0KS5tYXBPayhcbiAgICAgICAgKFtjb25kaXRpb24sIGJsb2NrLCBpbnZlcnNlXSkgPT5cbiAgICAgICAgICBuZXcgbWlyLklmKHtcbiAgICAgICAgICAgIGxvYzogbm9kZS5sb2MsXG4gICAgICAgICAgICBjb25kaXRpb24sXG4gICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgIGludmVyc2UsXG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSxcbiAgfSlcbiAgLmt3KCd1bmxlc3MnLCB7XG4gICAgYXNzZXJ0KFxuICAgICAgbm9kZTogQVNUdjIuSW52b2tlQmxvY2tcbiAgICApOiBSZXN1bHQ8e1xuICAgICAgY29uZGl0aW9uOiBBU1R2Mi5FeHByZXNzaW9uTm9kZTtcbiAgICB9PiB7XG4gICAgICBsZXQgeyBhcmdzIH0gPSBub2RlO1xuXG4gICAgICBpZiAoIWFyZ3MubmFtZWQuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiBFcnIoXG4gICAgICAgICAgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICAgIGB7eyN1bmxlc3N9fSBjYW5ub3QgcmVjZWl2ZSBuYW1lZCBwYXJhbWV0ZXJzLCByZWNlaXZlZCAke2FyZ3MubmFtZWQuZW50cmllc1xuICAgICAgICAgICAgICAubWFwKChlKSA9PiBlLm5hbWUuY2hhcnMpXG4gICAgICAgICAgICAgIC5qb2luKCcsICcpfWAsXG4gICAgICAgICAgICBub2RlLmxvY1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3MucG9zaXRpb25hbC5zaXplID4gMSkge1xuICAgICAgICByZXR1cm4gRXJyKFxuICAgICAgICAgIGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgICBge3sjdW5sZXNzfX0gY2FuIG9ubHkgcmVjZWl2ZSBvbmUgcG9zaXRpb25hbCBwYXJhbWV0ZXIgaW4gYmxvY2sgZm9ybSwgdGhlIGNvbmRpdGlvbmFsIHZhbHVlLiBSZWNlaXZlZCAke2FyZ3MucG9zaXRpb25hbC5zaXplfSBwYXJhbWV0ZXJzYCxcbiAgICAgICAgICAgIG5vZGUubG9jXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBsZXQgY29uZGl0aW9uID0gYXJncy5udGgoMCk7XG5cbiAgICAgIGlmIChjb25kaXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIEVycihcbiAgICAgICAgICBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgICAgYHt7I3VubGVzc319IHJlcXVpcmVzIGEgY29uZGl0aW9uIGFzIGl0cyBmaXJzdCBwb3NpdGlvbmFsIHBhcmFtZXRlciwgZGlkIG5vdCByZWNlaXZlIGFueSBwYXJhbWV0ZXJzYCxcbiAgICAgICAgICAgIG5vZGUubG9jXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gT2soeyBjb25kaXRpb24gfSk7XG4gICAgfSxcblxuICAgIHRyYW5zbGF0ZShcbiAgICAgIHsgbm9kZSwgc3RhdGUgfTogeyBub2RlOiBBU1R2Mi5JbnZva2VCbG9jazsgc3RhdGU6IE5vcm1hbGl6YXRpb25TdGF0ZSB9LFxuICAgICAgeyBjb25kaXRpb24gfTogeyBjb25kaXRpb246IEFTVHYyLkV4cHJlc3Npb25Ob2RlIH1cbiAgICApOiBSZXN1bHQ8bWlyLklmPiB7XG4gICAgICBsZXQgYmxvY2sgPSBub2RlLmJsb2Nrcy5nZXQoJ2RlZmF1bHQnKTtcbiAgICAgIGxldCBpbnZlcnNlID0gbm9kZS5ibG9ja3MuZ2V0KCdlbHNlJyk7XG5cbiAgICAgIGxldCBjb25kaXRpb25SZXN1bHQgPSBWSVNJVF9FWFBSUy52aXNpdChjb25kaXRpb24sIHN0YXRlKTtcbiAgICAgIGxldCBibG9ja1Jlc3VsdCA9IFZJU0lUX1NUTVRTLk5hbWVkQmxvY2soYmxvY2ssIHN0YXRlKTtcbiAgICAgIGxldCBpbnZlcnNlUmVzdWx0ID0gaW52ZXJzZSA/IFZJU0lUX1NUTVRTLk5hbWVkQmxvY2soaW52ZXJzZSwgc3RhdGUpIDogT2sobnVsbCk7XG5cbiAgICAgIHJldHVybiBSZXN1bHQuYWxsKGNvbmRpdGlvblJlc3VsdCwgYmxvY2tSZXN1bHQsIGludmVyc2VSZXN1bHQpLm1hcE9rKFxuICAgICAgICAoW2NvbmRpdGlvbiwgYmxvY2ssIGludmVyc2VdKSA9PlxuICAgICAgICAgIG5ldyBtaXIuSWYoe1xuICAgICAgICAgICAgbG9jOiBub2RlLmxvYyxcbiAgICAgICAgICAgIGNvbmRpdGlvbjogbmV3IG1pci5Ob3QoeyB2YWx1ZTogY29uZGl0aW9uLCBsb2M6IG5vZGUubG9jIH0pLFxuICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICBpbnZlcnNlLFxuICAgICAgICAgIH0pXG4gICAgICApO1xuICAgIH0sXG4gIH0pXG4gIC5rdygnZWFjaCcsIHtcbiAgICBhc3NlcnQoXG4gICAgICBub2RlOiBBU1R2Mi5JbnZva2VCbG9ja1xuICAgICk6IFJlc3VsdDx7XG4gICAgICB2YWx1ZTogQVNUdjIuRXhwcmVzc2lvbk5vZGU7XG4gICAgICBrZXk6IEFTVHYyLkV4cHJlc3Npb25Ob2RlIHwgbnVsbDtcbiAgICB9PiB7XG4gICAgICBsZXQgeyBhcmdzIH0gPSBub2RlO1xuXG4gICAgICBpZiAoIWFyZ3MubmFtZWQuZW50cmllcy5ldmVyeSgoZSkgPT4gZS5uYW1lLmNoYXJzID09PSAna2V5JykpIHtcbiAgICAgICAgcmV0dXJuIEVycihcbiAgICAgICAgICBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgICAgYHt7I2VhY2h9fSBjYW4gb25seSByZWNlaXZlIHRoZSAna2V5JyBuYW1lZCBwYXJhbWV0ZXIsIHJlY2VpdmVkICR7YXJncy5uYW1lZC5lbnRyaWVzXG4gICAgICAgICAgICAgIC5maWx0ZXIoKGUpID0+IGUubmFtZS5jaGFycyAhPT0gJ2tleScpXG4gICAgICAgICAgICAgIC5tYXAoKGUpID0+IGUubmFtZS5jaGFycylcbiAgICAgICAgICAgICAgLmpvaW4oJywgJyl9YCxcbiAgICAgICAgICAgIGFyZ3MubmFtZWQubG9jXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJncy5wb3NpdGlvbmFsLnNpemUgPiAxKSB7XG4gICAgICAgIHJldHVybiBFcnIoXG4gICAgICAgICAgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICAgIGB7eyNlYWNofX0gY2FuIG9ubHkgcmVjZWl2ZSBvbmUgcG9zaXRpb25hbCBwYXJhbWV0ZXIsIHRoZSBjb2xsZWN0aW9uIGJlaW5nIGl0ZXJhdGVkLiBSZWNlaXZlZCAke2FyZ3MucG9zaXRpb25hbC5zaXplfSBwYXJhbWV0ZXJzYCxcbiAgICAgICAgICAgIGFyZ3MucG9zaXRpb25hbC5sb2NcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCB2YWx1ZSA9IGFyZ3MubnRoKDApO1xuICAgICAgbGV0IGtleSA9IGFyZ3MuZ2V0KCdrZXknKTtcblxuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBFcnIoXG4gICAgICAgICAgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICAgIGB7eyNlYWNofX0gcmVxdWlyZXMgYW4gaXRlcmFibGUgdmFsdWUgdG8gYmUgcGFzc2VkIGFzIGl0cyBmaXJzdCBwb3NpdGlvbmFsIHBhcmFtZXRlciwgZGlkIG5vdCByZWNlaXZlIGFueSBwYXJhbWV0ZXJzYCxcbiAgICAgICAgICAgIGFyZ3MubG9jXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gT2soeyB2YWx1ZSwga2V5IH0pO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGUoXG4gICAgICB7IG5vZGUsIHN0YXRlIH06IHsgbm9kZTogQVNUdjIuSW52b2tlQmxvY2s7IHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGUgfSxcbiAgICAgIHsgdmFsdWUsIGtleSB9OiB7IHZhbHVlOiBBU1R2Mi5FeHByZXNzaW9uTm9kZTsga2V5OiBBU1R2Mi5FeHByZXNzaW9uTm9kZSB8IG51bGwgfVxuICAgICk6IFJlc3VsdDxtaXIuRWFjaD4ge1xuICAgICAgbGV0IGJsb2NrID0gbm9kZS5ibG9ja3MuZ2V0KCdkZWZhdWx0Jyk7XG4gICAgICBsZXQgaW52ZXJzZSA9IG5vZGUuYmxvY2tzLmdldCgnZWxzZScpO1xuXG4gICAgICBsZXQgdmFsdWVSZXN1bHQgPSBWSVNJVF9FWFBSUy52aXNpdCh2YWx1ZSwgc3RhdGUpO1xuICAgICAgbGV0IGtleVJlc3VsdCA9IGtleSA/IFZJU0lUX0VYUFJTLnZpc2l0KGtleSwgc3RhdGUpIDogT2sobnVsbCk7XG5cbiAgICAgIGxldCBibG9ja1Jlc3VsdCA9IFZJU0lUX1NUTVRTLk5hbWVkQmxvY2soYmxvY2ssIHN0YXRlKTtcbiAgICAgIGxldCBpbnZlcnNlUmVzdWx0ID0gaW52ZXJzZSA/IFZJU0lUX1NUTVRTLk5hbWVkQmxvY2soaW52ZXJzZSwgc3RhdGUpIDogT2sobnVsbCk7XG5cbiAgICAgIHJldHVybiBSZXN1bHQuYWxsKHZhbHVlUmVzdWx0LCBrZXlSZXN1bHQsIGJsb2NrUmVzdWx0LCBpbnZlcnNlUmVzdWx0KS5tYXBPayhcbiAgICAgICAgKFt2YWx1ZSwga2V5LCBibG9jaywgaW52ZXJzZV0pID0+XG4gICAgICAgICAgbmV3IG1pci5FYWNoKHtcbiAgICAgICAgICAgIGxvYzogbm9kZS5sb2MsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgaW52ZXJzZSxcbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9LFxuICB9KVxuICAua3coJ3dpdGgnLCB7XG4gICAgYXNzZXJ0KFxuICAgICAgbm9kZTogQVNUdjIuSW52b2tlQmxvY2tcbiAgICApOiBSZXN1bHQ8e1xuICAgICAgdmFsdWU6IEFTVHYyLkV4cHJlc3Npb25Ob2RlO1xuICAgIH0+IHtcbiAgICAgIGxldCB7IGFyZ3MgfSA9IG5vZGU7XG5cbiAgICAgIGlmICghYXJncy5uYW1lZC5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIEVycihcbiAgICAgICAgICBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgICAgYHt7I3dpdGh9fSBjYW5ub3QgcmVjZWl2ZSBuYW1lZCBwYXJhbWV0ZXJzLCByZWNlaXZlZCAke2FyZ3MubmFtZWQuZW50cmllc1xuICAgICAgICAgICAgICAubWFwKChlKSA9PiBlLm5hbWUuY2hhcnMpXG4gICAgICAgICAgICAgIC5qb2luKCcsICcpfWAsXG4gICAgICAgICAgICBhcmdzLm5hbWVkLmxvY1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3MucG9zaXRpb25hbC5zaXplID4gMSkge1xuICAgICAgICByZXR1cm4gRXJyKFxuICAgICAgICAgIGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgICBge3sjd2l0aH19IGNhbiBvbmx5IHJlY2VpdmUgb25lIHBvc2l0aW9uYWwgcGFyYW1ldGVyLiBSZWNlaXZlZCAke2FyZ3MucG9zaXRpb25hbC5zaXplfSBwYXJhbWV0ZXJzYCxcbiAgICAgICAgICAgIGFyZ3MucG9zaXRpb25hbC5sb2NcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCB2YWx1ZSA9IGFyZ3MubnRoKDApO1xuXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIEVycihcbiAgICAgICAgICBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgICAgYHt7I3dpdGh9fSByZXF1aXJlcyBhIHZhbHVlIGFzIGl0cyBmaXJzdCBwb3NpdGlvbmFsIHBhcmFtZXRlciwgZGlkIG5vdCByZWNlaXZlIGFueSBwYXJhbWV0ZXJzYCxcbiAgICAgICAgICAgIGFyZ3MubG9jXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gT2soeyB2YWx1ZSB9KTtcbiAgICB9LFxuXG4gICAgdHJhbnNsYXRlKFxuICAgICAgeyBub2RlLCBzdGF0ZSB9OiB7IG5vZGU6IEFTVHYyLkludm9rZUJsb2NrOyBzdGF0ZTogTm9ybWFsaXphdGlvblN0YXRlIH0sXG4gICAgICB7IHZhbHVlIH06IHsgdmFsdWU6IEFTVHYyLkV4cHJlc3Npb25Ob2RlIH1cbiAgICApOiBSZXN1bHQ8bWlyLldpdGg+IHtcbiAgICAgIGxldCBibG9jayA9IG5vZGUuYmxvY2tzLmdldCgnZGVmYXVsdCcpO1xuICAgICAgbGV0IGludmVyc2UgPSBub2RlLmJsb2Nrcy5nZXQoJ2Vsc2UnKTtcblxuICAgICAgbGV0IHZhbHVlUmVzdWx0ID0gVklTSVRfRVhQUlMudmlzaXQodmFsdWUsIHN0YXRlKTtcbiAgICAgIGxldCBibG9ja1Jlc3VsdCA9IFZJU0lUX1NUTVRTLk5hbWVkQmxvY2soYmxvY2ssIHN0YXRlKTtcbiAgICAgIGxldCBpbnZlcnNlUmVzdWx0ID0gaW52ZXJzZSA/IFZJU0lUX1NUTVRTLk5hbWVkQmxvY2soaW52ZXJzZSwgc3RhdGUpIDogT2sobnVsbCk7XG5cbiAgICAgIHJldHVybiBSZXN1bHQuYWxsKHZhbHVlUmVzdWx0LCBibG9ja1Jlc3VsdCwgaW52ZXJzZVJlc3VsdCkubWFwT2soXG4gICAgICAgIChbdmFsdWUsIGJsb2NrLCBpbnZlcnNlXSkgPT5cbiAgICAgICAgICBuZXcgbWlyLldpdGgoe1xuICAgICAgICAgICAgbG9jOiBub2RlLmxvYyxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICBpbnZlcnNlLFxuICAgICAgICAgIH0pXG4gICAgICApO1xuICAgIH0sXG4gIH0pXG4gIC5rdygnbGV0Jywge1xuICAgIGFzc2VydChcbiAgICAgIG5vZGU6IEFTVHYyLkludm9rZUJsb2NrXG4gICAgKTogUmVzdWx0PHtcbiAgICAgIHBvc2l0aW9uYWw6IEFTVHYyLlBvc2l0aW9uYWxBcmd1bWVudHM7XG4gICAgfT4ge1xuICAgICAgbGV0IHsgYXJncyB9ID0gbm9kZTtcblxuICAgICAgaWYgKCFhcmdzLm5hbWVkLmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gRXJyKFxuICAgICAgICAgIGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgICBge3sjbGV0fX0gY2Fubm90IHJlY2VpdmUgbmFtZWQgcGFyYW1ldGVycywgcmVjZWl2ZWQgJHthcmdzLm5hbWVkLmVudHJpZXNcbiAgICAgICAgICAgICAgLm1hcCgoZSkgPT4gZS5uYW1lLmNoYXJzKVxuICAgICAgICAgICAgICAuam9pbignLCAnKX1gLFxuICAgICAgICAgICAgYXJncy5uYW1lZC5sb2NcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcmdzLnBvc2l0aW9uYWwuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gRXJyKFxuICAgICAgICAgIGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgICBge3sjbGV0fX0gcmVxdWlyZXMgYXQgbGVhc3Qgb25lIHZhbHVlIGFzIGl0cyBmaXJzdCBwb3NpdGlvbmFsIHBhcmFtZXRlciwgZGlkIG5vdCByZWNlaXZlIGFueSBwYXJhbWV0ZXJzYCxcbiAgICAgICAgICAgIGFyZ3MucG9zaXRpb25hbC5sb2NcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLmJsb2Nrcy5nZXQoJ2Vsc2UnKSkge1xuICAgICAgICByZXR1cm4gRXJyKFxuICAgICAgICAgIGdlbmVyYXRlU3ludGF4RXJyb3IoYHt7I2xldH19IGNhbm5vdCByZWNlaXZlIGFuIHt7ZWxzZX19IGJsb2NrYCwgYXJncy5wb3NpdGlvbmFsLmxvYylcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9rKHsgcG9zaXRpb25hbDogYXJncy5wb3NpdGlvbmFsIH0pO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGUoXG4gICAgICB7IG5vZGUsIHN0YXRlIH06IHsgbm9kZTogQVNUdjIuSW52b2tlQmxvY2s7IHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGUgfSxcbiAgICAgIHsgcG9zaXRpb25hbCB9OiB7IHBvc2l0aW9uYWw6IEFTVHYyLlBvc2l0aW9uYWxBcmd1bWVudHMgfVxuICAgICk6IFJlc3VsdDxtaXIuTGV0PiB7XG4gICAgICBsZXQgYmxvY2sgPSBub2RlLmJsb2Nrcy5nZXQoJ2RlZmF1bHQnKTtcblxuICAgICAgbGV0IHBvc2l0aW9uYWxSZXN1bHQgPSBWSVNJVF9FWFBSUy5Qb3NpdGlvbmFsKHBvc2l0aW9uYWwsIHN0YXRlKTtcbiAgICAgIGxldCBibG9ja1Jlc3VsdCA9IFZJU0lUX1NUTVRTLk5hbWVkQmxvY2soYmxvY2ssIHN0YXRlKTtcblxuICAgICAgcmV0dXJuIFJlc3VsdC5hbGwocG9zaXRpb25hbFJlc3VsdCwgYmxvY2tSZXN1bHQpLm1hcE9rKFxuICAgICAgICAoW3Bvc2l0aW9uYWwsIGJsb2NrXSkgPT5cbiAgICAgICAgICBuZXcgbWlyLkxldCh7XG4gICAgICAgICAgICBsb2M6IG5vZGUubG9jLFxuICAgICAgICAgICAgcG9zaXRpb25hbCxcbiAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgIH0pXG4gICAgICApO1xuICAgIH0sXG4gIH0pXG4gIC5rdygnLXdpdGgtZHluYW1pYy12YXJzJywge1xuICAgIGFzc2VydChcbiAgICAgIG5vZGU6IEFTVHYyLkludm9rZUJsb2NrXG4gICAgKTogUmVzdWx0PHtcbiAgICAgIG5hbWVkOiBBU1R2Mi5OYW1lZEFyZ3VtZW50cztcbiAgICB9PiB7XG4gICAgICByZXR1cm4gT2soeyBuYW1lZDogbm9kZS5hcmdzLm5hbWVkIH0pO1xuICAgIH0sXG5cbiAgICB0cmFuc2xhdGUoXG4gICAgICB7IG5vZGUsIHN0YXRlIH06IHsgbm9kZTogQVNUdjIuSW52b2tlQmxvY2s7IHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGUgfSxcbiAgICAgIHsgbmFtZWQgfTogeyBuYW1lZDogQVNUdjIuTmFtZWRBcmd1bWVudHMgfVxuICAgICk6IFJlc3VsdDxtaXIuV2l0aER5bmFtaWNWYXJzPiB7XG4gICAgICBsZXQgYmxvY2sgPSBub2RlLmJsb2Nrcy5nZXQoJ2RlZmF1bHQnKTtcblxuICAgICAgbGV0IG5hbWVkUmVzdWx0ID0gVklTSVRfRVhQUlMuTmFtZWRBcmd1bWVudHMobmFtZWQsIHN0YXRlKTtcbiAgICAgIGxldCBibG9ja1Jlc3VsdCA9IFZJU0lUX1NUTVRTLk5hbWVkQmxvY2soYmxvY2ssIHN0YXRlKTtcblxuICAgICAgcmV0dXJuIFJlc3VsdC5hbGwobmFtZWRSZXN1bHQsIGJsb2NrUmVzdWx0KS5tYXBPayhcbiAgICAgICAgKFtuYW1lZCwgYmxvY2tdKSA9PlxuICAgICAgICAgIG5ldyBtaXIuV2l0aER5bmFtaWNWYXJzKHtcbiAgICAgICAgICAgIGxvYzogbm9kZS5sb2MsXG4gICAgICAgICAgICBuYW1lZCxcbiAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgIH0pXG4gICAgICApO1xuICAgIH0sXG4gIH0pXG4gIC5rdygnY29tcG9uZW50Jywge1xuICAgIGFzc2VydDogYXNzZXJ0Q3VycnlLZXl3b3JkKEN1cnJpZWRUeXBlLkNvbXBvbmVudCksXG5cbiAgICB0cmFuc2xhdGUoXG4gICAgICB7IG5vZGUsIHN0YXRlIH06IHsgbm9kZTogQVNUdjIuSW52b2tlQmxvY2s7IHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGUgfSxcbiAgICAgIHsgZGVmaW5pdGlvbiwgYXJncyB9OiB7IGRlZmluaXRpb246IEFTVHYyLkV4cHJlc3Npb25Ob2RlOyBhcmdzOiBBU1R2Mi5BcmdzIH1cbiAgICApOiBSZXN1bHQ8bWlyLkludm9rZUNvbXBvbmVudD4ge1xuICAgICAgbGV0IGRlZmluaXRpb25SZXN1bHQgPSBWSVNJVF9FWFBSUy52aXNpdChkZWZpbml0aW9uLCBzdGF0ZSk7XG4gICAgICBsZXQgYXJnc1Jlc3VsdCA9IFZJU0lUX0VYUFJTLkFyZ3MoYXJncywgc3RhdGUpO1xuICAgICAgbGV0IGJsb2Nrc1Jlc3VsdCA9IFZJU0lUX1NUTVRTLk5hbWVkQmxvY2tzKG5vZGUuYmxvY2tzLCBzdGF0ZSk7XG5cbiAgICAgIHJldHVybiBSZXN1bHQuYWxsKGRlZmluaXRpb25SZXN1bHQsIGFyZ3NSZXN1bHQsIGJsb2Nrc1Jlc3VsdCkubWFwT2soXG4gICAgICAgIChbZGVmaW5pdGlvbiwgYXJncywgYmxvY2tzXSkgPT5cbiAgICAgICAgICBuZXcgbWlyLkludm9rZUNvbXBvbmVudCh7XG4gICAgICAgICAgICBsb2M6IG5vZGUubG9jLFxuICAgICAgICAgICAgZGVmaW5pdGlvbixcbiAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICBibG9ja3MsXG4gICAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSxcbiAgfSk7XG4iXSwic291cmNlUm9vdCI6IiJ9