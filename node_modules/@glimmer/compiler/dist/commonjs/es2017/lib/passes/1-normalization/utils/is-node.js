"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasPath = hasPath;
exports.isHelperInvocation = isHelperInvocation;
exports.isSimplePath = isSimplePath;
exports.isStrictHelper = isStrictHelper;
exports.assertIsValidModifier = assertIsValidModifier;
exports.isTrustingNode = isTrustingNode;

var _syntax = require("@glimmer/syntax");

var _util = require("@glimmer/util");

function hasPath(node) {
  return node.callee.type === 'Path';
}

function isHelperInvocation(node) {
  if (!hasPath(node)) {
    return false;
  }

  return !node.args.isEmpty();
}

function isSimplePath(path) {
  if (path.type === 'Path') {
    let {
      ref: head,
      tail: parts
    } = path;
    return head.type === 'Free' && head.resolution !== _syntax.ASTv2.STRICT_RESOLUTION && parts.length === 0;
  } else {
    return false;
  }
}

function isStrictHelper(expr) {
  if (expr.callee.type !== 'Path') {
    return true;
  }

  if (expr.callee.ref.type !== 'Free') {
    return true;
  }

  return expr.callee.ref.resolution === _syntax.ASTv2.STRICT_RESOLUTION;
}

function assertIsValidModifier(helper) {
  if (isStrictHelper(helper) || isSimplePath(helper.callee)) {
    return;
  }

  throw (0, _syntax.generateSyntaxError)(`\`${printPath(helper.callee)}\` is not a valid name for a modifier`, helper.loc);
}

function printPath(path) {
  switch (path.type) {
    case 'Literal':
      return JSON.stringify(path.value);

    case 'Path':
      {
        let printedPath = [printPathHead(path.ref)];
        printedPath.push(...path.tail.map(t => t.chars));
        return printedPath.join('.');
      }

    case 'Call':
      return `(${printPath(path.callee)} ...)`;

    case 'DeprecatedCall':
      return `${path.callee.name}`;

    case 'Interpolate':
      throw (0, _util.unreachable)('a concat statement cannot appear as the head of an expression');
  }
}

function printPathHead(head) {
  switch (head.type) {
    case 'Arg':
      return head.name.chars;

    case 'Free':
    case 'Local':
      return head.name;

    case 'This':
      return 'this';
  }
}
/**
 * This function is checking whether an AST node is a triple-curly, which means that it's
 * a "trusting" node. In the Handlebars AST, this is indicated by the `escaped` flag, which
 * is a bit of a double-negative, so we change the terminology here for clarity.
 */


function isTrustingNode(value) {
  if (value.type === 'AppendContent') {
    return value.trusting;
  } else {
    return false;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL3V0aWxzL2lzLW5vZGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQ0E7O0FBQ0E7O0FBbUJNLFNBQUEsT0FBQSxDQUFBLElBQUEsRUFBbUQ7QUFDdkQsU0FBTyxJQUFJLENBQUosTUFBQSxDQUFBLElBQUEsS0FBUCxNQUFBO0FBQ0Q7O0FBRUssU0FBQSxrQkFBQSxDQUFBLElBQUEsRUFDZ0I7QUFFcEIsTUFBSSxDQUFDLE9BQU8sQ0FBWixJQUFZLENBQVosRUFBb0I7QUFDbEIsV0FBQSxLQUFBO0FBQ0Q7O0FBRUQsU0FBTyxDQUFDLElBQUksQ0FBSixJQUFBLENBQVIsT0FBUSxFQUFSO0FBQ0Q7O0FBWUssU0FBQSxZQUFBLENBQUEsSUFBQSxFQUFpRDtBQUNyRCxNQUFJLElBQUksQ0FBSixJQUFBLEtBQUosTUFBQSxFQUEwQjtBQUN4QixRQUFJO0FBQUUsTUFBQSxHQUFHLEVBQUwsSUFBQTtBQUFhLE1BQUEsSUFBSSxFQUFFO0FBQW5CLFFBQUosSUFBQTtBQUVBLFdBQ0UsSUFBSSxDQUFKLElBQUEsS0FBQSxNQUFBLElBQXdCLElBQUksQ0FBSixVQUFBLEtBQW9CLGNBQTVDLGlCQUFBLElBQXVFLEtBQUssQ0FBTCxNQUFBLEtBRHpFLENBQUE7QUFIRixHQUFBLE1BTU87QUFDTCxXQUFBLEtBQUE7QUFDRDtBQUNGOztBQUVLLFNBQUEsY0FBQSxDQUFBLElBQUEsRUFBc0M7QUFDMUMsTUFBSSxJQUFJLENBQUosTUFBQSxDQUFBLElBQUEsS0FBSixNQUFBLEVBQWlDO0FBQy9CLFdBQUEsSUFBQTtBQUNEOztBQUVELE1BQUksSUFBSSxDQUFKLE1BQUEsQ0FBQSxHQUFBLENBQUEsSUFBQSxLQUFKLE1BQUEsRUFBcUM7QUFDbkMsV0FBQSxJQUFBO0FBQ0Q7O0FBRUQsU0FBTyxJQUFJLENBQUosTUFBQSxDQUFBLEdBQUEsQ0FBQSxVQUFBLEtBQStCLGNBQXRDLGlCQUFBO0FBQ0Q7O0FBRUssU0FBQSxxQkFBQSxDQUFBLE1BQUEsRUFDSztBQUVULE1BQUksY0FBYyxDQUFkLE1BQWMsQ0FBZCxJQUEwQixZQUFZLENBQUMsTUFBTSxDQUFqRCxNQUEwQyxDQUExQyxFQUEyRDtBQUN6RDtBQUNEOztBQUVELFFBQU0saUNBQ0osS0FBSyxTQUFTLENBQUMsTUFBTSxDQUFQLE1BQUEsQ0FEUyx1Q0FBbkIsRUFFSixNQUFNLENBRlIsR0FBTSxDQUFOO0FBSUQ7O0FBRUQsU0FBQSxTQUFBLENBQUEsSUFBQSxFQUE2QztBQUMzQyxVQUFRLElBQUksQ0FBWixJQUFBO0FBQ0UsU0FBQSxTQUFBO0FBQ0UsYUFBTyxJQUFJLENBQUosU0FBQSxDQUFlLElBQUksQ0FBMUIsS0FBTyxDQUFQOztBQUNGLFNBQUEsTUFBQTtBQUFhO0FBQ1gsWUFBSSxXQUFXLEdBQUcsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFyQyxHQUFnQyxDQUFkLENBQWxCO0FBQ0EsUUFBQSxXQUFXLENBQVgsSUFBQSxDQUFpQixHQUFHLElBQUksQ0FBSixJQUFBLENBQUEsR0FBQSxDQUFlLENBQUQsSUFBTyxDQUFDLENBQTFDLEtBQW9CLENBQXBCO0FBQ0EsZUFBTyxXQUFXLENBQVgsSUFBQSxDQUFQLEdBQU8sQ0FBUDtBQUNEOztBQUNELFNBQUEsTUFBQTtBQUNFLGFBQU8sSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFMLE1BQUEsQ0FBcEIsT0FBQTs7QUFDRixTQUFBLGdCQUFBO0FBQ0UsYUFBTyxHQUFHLElBQUksQ0FBSixNQUFBLENBQVksSUFBdEIsRUFBQTs7QUFDRixTQUFBLGFBQUE7QUFDRSxZQUFNLHVCQUFOLCtEQUFNLENBQU47QUFiSjtBQWVEOztBQUVELFNBQUEsYUFBQSxDQUFBLElBQUEsRUFBb0Q7QUFDbEQsVUFBUSxJQUFJLENBQVosSUFBQTtBQUNFLFNBQUEsS0FBQTtBQUNFLGFBQU8sSUFBSSxDQUFKLElBQUEsQ0FBUCxLQUFBOztBQUNGLFNBQUEsTUFBQTtBQUNBLFNBQUEsT0FBQTtBQUNFLGFBQU8sSUFBSSxDQUFYLElBQUE7O0FBQ0YsU0FBQSxNQUFBO0FBQ0UsYUFBQSxNQUFBO0FBUEo7QUFTRDtBQUVEOzs7Ozs7O0FBS00sU0FBQSxjQUFBLENBQUEsS0FBQSxFQUNxRTtBQUV6RSxNQUFJLEtBQUssQ0FBTCxJQUFBLEtBQUosZUFBQSxFQUFvQztBQUNsQyxXQUFPLEtBQUssQ0FBWixRQUFBO0FBREYsR0FBQSxNQUVPO0FBQ0wsV0FBQSxLQUFBO0FBQ0Q7QUFDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFByZXNlbnRBcnJheSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgQVNUdjIsIGdlbmVyYXRlU3ludGF4RXJyb3IsIFNvdXJjZVNsaWNlIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcbmltcG9ydCB7IHVucmVhY2hhYmxlIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmV4cG9ydCB0eXBlIEhhc1BhdGg8Tm9kZSBleHRlbmRzIEFTVHYyLkNhbGxOb2RlID0gQVNUdjIuQ2FsbE5vZGU+ID0gTm9kZSAmIHtcbiAgaGVhZDogQVNUdjIuUGF0aEV4cHJlc3Npb247XG59O1xuXG5leHBvcnQgdHlwZSBIYXNBcmd1bWVudHMgPVxuICB8IHtcbiAgICAgIHBhcmFtczogUHJlc2VudEFycmF5PEFTVHYyLkV4cHJlc3Npb25Ob2RlPjtcbiAgICB9XG4gIHwge1xuICAgICAgaGFzaDoge1xuICAgICAgICBwYWlyczogUHJlc2VudEFycmF5PEFTVHYyLk5hbWVkQXJndW1lbnQ+O1xuICAgICAgfTtcbiAgICB9O1xuXG5leHBvcnQgdHlwZSBIZWxwZXJJbnZvY2F0aW9uPE5vZGUgZXh0ZW5kcyBBU1R2Mi5DYWxsTm9kZSA9IEFTVHYyLkNhbGxOb2RlPiA9IEhhc1BhdGg8Tm9kZT4gJlxuICBIYXNBcmd1bWVudHM7XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNQYXRoPE4gZXh0ZW5kcyBBU1R2Mi5DYWxsTm9kZT4obm9kZTogTik6IG5vZGUgaXMgSGFzUGF0aDxOPiB7XG4gIHJldHVybiBub2RlLmNhbGxlZS50eXBlID09PSAnUGF0aCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hlbHBlckludm9jYXRpb248TiBleHRlbmRzIEFTVHYyLkNhbGxOb2RlPihcbiAgbm9kZTogQVNUdjIuQ2FsbE5vZGVcbik6IG5vZGUgaXMgSGVscGVySW52b2NhdGlvbjxOPiB7XG4gIGlmICghaGFzUGF0aChub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiAhbm9kZS5hcmdzLmlzRW1wdHkoKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVQYXRoIGV4dGVuZHMgQVNUdjIuUGF0aEV4cHJlc3Npb24ge1xuICB0YWlsOiBbU291cmNlU2xpY2VdO1xuICBkYXRhOiBmYWxzZTtcbiAgdGhpczogZmFsc2U7XG59XG5cbmV4cG9ydCB0eXBlIFNpbXBsZUhlbHBlcjxOIGV4dGVuZHMgSGFzUGF0aD4gPSBOICYge1xuICBwYXRoOiBTaW1wbGVQYXRoO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2ltcGxlUGF0aChwYXRoOiBBU1R2Mi5FeHByZXNzaW9uTm9kZSk6IHBhdGggaXMgU2ltcGxlUGF0aCB7XG4gIGlmIChwYXRoLnR5cGUgPT09ICdQYXRoJykge1xuICAgIGxldCB7IHJlZjogaGVhZCwgdGFpbDogcGFydHMgfSA9IHBhdGg7XG5cbiAgICByZXR1cm4gKFxuICAgICAgaGVhZC50eXBlID09PSAnRnJlZScgJiYgaGVhZC5yZXNvbHV0aW9uICE9PSBBU1R2Mi5TVFJJQ1RfUkVTT0xVVElPTiAmJiBwYXJ0cy5sZW5ndGggPT09IDBcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpY3RIZWxwZXIoZXhwcjogSGFzUGF0aCk6IGJvb2xlYW4ge1xuICBpZiAoZXhwci5jYWxsZWUudHlwZSAhPT0gJ1BhdGgnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoZXhwci5jYWxsZWUucmVmLnR5cGUgIT09ICdGcmVlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGV4cHIuY2FsbGVlLnJlZi5yZXNvbHV0aW9uID09PSBBU1R2Mi5TVFJJQ1RfUkVTT0xVVElPTjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydElzVmFsaWRNb2RpZmllcjxOIGV4dGVuZHMgSGFzUGF0aD4oXG4gIGhlbHBlcjogTlxuKTogYXNzZXJ0cyBoZWxwZXIgaXMgU2ltcGxlSGVscGVyPE4+IHtcbiAgaWYgKGlzU3RyaWN0SGVscGVyKGhlbHBlcikgfHwgaXNTaW1wbGVQYXRoKGhlbHBlci5jYWxsZWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICBgXFxgJHtwcmludFBhdGgoaGVscGVyLmNhbGxlZSl9XFxgIGlzIG5vdCBhIHZhbGlkIG5hbWUgZm9yIGEgbW9kaWZpZXJgLFxuICAgIGhlbHBlci5sb2NcbiAgKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRQYXRoKHBhdGg6IEFTVHYyLkV4cHJlc3Npb25Ob2RlKTogc3RyaW5nIHtcbiAgc3dpdGNoIChwYXRoLnR5cGUpIHtcbiAgICBjYXNlICdMaXRlcmFsJzpcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXRoLnZhbHVlKTtcbiAgICBjYXNlICdQYXRoJzoge1xuICAgICAgbGV0IHByaW50ZWRQYXRoID0gW3ByaW50UGF0aEhlYWQocGF0aC5yZWYpXTtcbiAgICAgIHByaW50ZWRQYXRoLnB1c2goLi4ucGF0aC50YWlsLm1hcCgodCkgPT4gdC5jaGFycykpO1xuICAgICAgcmV0dXJuIHByaW50ZWRQYXRoLmpvaW4oJy4nKTtcbiAgICB9XG4gICAgY2FzZSAnQ2FsbCc6XG4gICAgICByZXR1cm4gYCgke3ByaW50UGF0aChwYXRoLmNhbGxlZSl9IC4uLilgO1xuICAgIGNhc2UgJ0RlcHJlY2F0ZWRDYWxsJzpcbiAgICAgIHJldHVybiBgJHtwYXRoLmNhbGxlZS5uYW1lfWA7XG4gICAgY2FzZSAnSW50ZXJwb2xhdGUnOlxuICAgICAgdGhyb3cgdW5yZWFjaGFibGUoJ2EgY29uY2F0IHN0YXRlbWVudCBjYW5ub3QgYXBwZWFyIGFzIHRoZSBoZWFkIG9mIGFuIGV4cHJlc3Npb24nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFBhdGhIZWFkKGhlYWQ6IEFTVHYyLlZhcmlhYmxlUmVmZXJlbmNlKTogc3RyaW5nIHtcbiAgc3dpdGNoIChoZWFkLnR5cGUpIHtcbiAgICBjYXNlICdBcmcnOlxuICAgICAgcmV0dXJuIGhlYWQubmFtZS5jaGFycztcbiAgICBjYXNlICdGcmVlJzpcbiAgICBjYXNlICdMb2NhbCc6XG4gICAgICByZXR1cm4gaGVhZC5uYW1lO1xuICAgIGNhc2UgJ1RoaXMnOlxuICAgICAgcmV0dXJuICd0aGlzJztcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgY2hlY2tpbmcgd2hldGhlciBhbiBBU1Qgbm9kZSBpcyBhIHRyaXBsZS1jdXJseSwgd2hpY2ggbWVhbnMgdGhhdCBpdCdzXG4gKiBhIFwidHJ1c3RpbmdcIiBub2RlLiBJbiB0aGUgSGFuZGxlYmFycyBBU1QsIHRoaXMgaXMgaW5kaWNhdGVkIGJ5IHRoZSBgZXNjYXBlZGAgZmxhZywgd2hpY2hcbiAqIGlzIGEgYml0IG9mIGEgZG91YmxlLW5lZ2F0aXZlLCBzbyB3ZSBjaGFuZ2UgdGhlIHRlcm1pbm9sb2d5IGhlcmUgZm9yIGNsYXJpdHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1RydXN0aW5nTm9kZShcbiAgdmFsdWU6IEFTVHYyLkFwcGVuZENvbnRlbnQgfCBBU1R2Mi5IdG1sVGV4dCB8IEFTVHYyLkludGVycG9sYXRlRXhwcmVzc2lvblxuKTogYm9vbGVhbiB7XG4gIGlmICh2YWx1ZS50eXBlID09PSAnQXBwZW5kQ29udGVudCcpIHtcbiAgICByZXR1cm4gdmFsdWUudHJ1c3Rpbmc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9