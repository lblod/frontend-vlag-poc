"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.logKeyword = void 0;

var _syntax = require("@glimmer/syntax");

var _result = require("../../../../shared/result");

var mir = _interopRequireWildcard(require("../../../2-encoding/mir"));

var _expressions = require("../../visitors/expressions");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function assertLogKeyword(node) {
  let {
    args: {
      named,
      positional
    }
  } = node;

  if (named && !named.isEmpty()) {
    return (0, _result.Err)((0, _syntax.generateSyntaxError)(`(log) does not take any named arguments`, node.loc));
  }

  return (0, _result.Ok)(positional);
}

function translateLogKeyword({
  node,
  state
}, positional) {
  return _expressions.VISIT_EXPRS.Positional(positional, state).mapOk(positional => new mir.Log({
    positional,
    loc: node.loc
  }));
}

const logKeyword = {
  assert: assertLogKeyword,
  translate: translateLogKeyword
};
exports.logKeyword = logKeyword;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL2tleXdvcmRzL3V0aWxzL2xvZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7O0FBRUE7Ozs7OztBQUdBLFNBQUEsZ0JBQUEsQ0FBQSxJQUFBLEVBQWtEO0FBQ2hELE1BQUk7QUFDRixJQUFBLElBQUksRUFBRTtBQUFBLE1BQUEsS0FBQTtBQUFTLE1BQUE7QUFBVDtBQURKLE1BQUosSUFBQTs7QUFJQSxNQUFJLEtBQUssSUFBSSxDQUFDLEtBQUssQ0FBbkIsT0FBYyxFQUFkLEVBQStCO0FBQzdCLFdBQU8saUJBQUksaUNBQW1CLHlDQUFuQixFQUErRCxJQUFJLENBQTlFLEdBQVcsQ0FBSixDQUFQO0FBQ0Q7O0FBRUQsU0FBTyxnQkFBUCxVQUFPLENBQVA7QUFDRDs7QUFFRCxTQUFBLG1CQUFBLENBQ0U7QUFBQSxFQUFBLElBQUE7QUFBUSxFQUFBO0FBQVIsQ0FERixFQUFBLFVBQUEsRUFFdUM7QUFFckMsU0FBTyx5QkFBQSxVQUFBLENBQUEsVUFBQSxFQUFBLEtBQUEsRUFBQSxLQUFBLENBQ0osVUFBRCxJQUFnQixJQUFJLEdBQUcsQ0FBUCxHQUFBLENBQVk7QUFBQSxJQUFBLFVBQUE7QUFBYyxJQUFBLEdBQUcsRUFBRSxJQUFJLENBQUM7QUFBeEIsR0FBWixDQURYLENBQVA7QUFHRDs7QUFFTSxNQUFNLFVBQVUsR0FJbkI7QUFDRixFQUFBLE1BQU0sRUFESixnQkFBQTtBQUVGLEVBQUEsU0FBUyxFQUFFO0FBRlQsQ0FKRyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFTVHYyLCBnZW5lcmF0ZVN5bnRheEVycm9yIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcblxuaW1wb3J0IHsgRXJyLCBPaywgUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL3Jlc3VsdCc7XG5pbXBvcnQgKiBhcyBtaXIgZnJvbSAnLi4vLi4vLi4vMi1lbmNvZGluZy9taXInO1xuaW1wb3J0IHsgTm9ybWFsaXphdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vY29udGV4dCc7XG5pbXBvcnQgeyBWSVNJVF9FWFBSUyB9IGZyb20gJy4uLy4uL3Zpc2l0b3JzL2V4cHJlc3Npb25zJztcbmltcG9ydCB7IEdlbmVyaWNLZXl3b3JkTm9kZSwgS2V5d29yZERlbGVnYXRlIH0gZnJvbSAnLi4vaW1wbCc7XG5cbmZ1bmN0aW9uIGFzc2VydExvZ0tleXdvcmQobm9kZTogR2VuZXJpY0tleXdvcmROb2RlKTogUmVzdWx0PEFTVHYyLlBvc2l0aW9uYWxBcmd1bWVudHM+IHtcbiAgbGV0IHtcbiAgICBhcmdzOiB7IG5hbWVkLCBwb3NpdGlvbmFsIH0sXG4gIH0gPSBub2RlO1xuXG4gIGlmIChuYW1lZCAmJiAhbmFtZWQuaXNFbXB0eSgpKSB7XG4gICAgcmV0dXJuIEVycihnZW5lcmF0ZVN5bnRheEVycm9yKGAobG9nKSBkb2VzIG5vdCB0YWtlIGFueSBuYW1lZCBhcmd1bWVudHNgLCBub2RlLmxvYykpO1xuICB9XG5cbiAgcmV0dXJuIE9rKHBvc2l0aW9uYWwpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVMb2dLZXl3b3JkKFxuICB7IG5vZGUsIHN0YXRlIH06IHsgbm9kZTogQVNUdjIuQ2FsbEV4cHJlc3Npb247IHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGUgfSxcbiAgcG9zaXRpb25hbDogQVNUdjIuUG9zaXRpb25hbEFyZ3VtZW50c1xuKTogUmVzdWx0PG1pci5Mb2c+IHtcbiAgcmV0dXJuIFZJU0lUX0VYUFJTLlBvc2l0aW9uYWwocG9zaXRpb25hbCwgc3RhdGUpLm1hcE9rKFxuICAgIChwb3NpdGlvbmFsKSA9PiBuZXcgbWlyLkxvZyh7IHBvc2l0aW9uYWwsIGxvYzogbm9kZS5sb2MgfSlcbiAgKTtcbn1cblxuZXhwb3J0IGNvbnN0IGxvZ0tleXdvcmQ6IEtleXdvcmREZWxlZ2F0ZTxcbiAgQVNUdjIuQ2FsbEV4cHJlc3Npb24gfCBBU1R2Mi5BcHBlbmRDb250ZW50LFxuICBBU1R2Mi5Qb3NpdGlvbmFsQXJndW1lbnRzLFxuICBtaXIuTG9nXG4+ID0ge1xuICBhc3NlcnQ6IGFzc2VydExvZ0tleXdvcmQsXG4gIHRyYW5zbGF0ZTogdHJhbnNsYXRlTG9nS2V5d29yZCxcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9