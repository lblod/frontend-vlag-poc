"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ifUnlessInlineKeyword = ifUnlessInlineKeyword;

var _syntax = require("@glimmer/syntax");

var _result = require("../../../../shared/result");

var mir = _interopRequireWildcard(require("../../../2-encoding/mir"));

var _expressions = require("../../visitors/expressions");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function assertIfUnlessInlineKeyword(type) {
  return originalNode => {
    var _a;

    let inverted = type === 'unless';
    let node = originalNode.type === 'AppendContent' ? originalNode.value : originalNode;
    let named = node.type === 'Call' ? node.args.named : null;
    let positional = node.type === 'Call' ? node.args.positional : null;

    if (named && !named.isEmpty()) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`(${type}) cannot receive named parameters, received ${named.entries.map(e => e.name.chars).join(', ')}`, originalNode.loc));
    }

    let condition = positional === null || positional === void 0 ? void 0 : positional.nth(0);

    if (!positional || !condition) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`When used inline, (${type}) requires at least two parameters 1. the condition that determines the state of the (${type}), and 2. the value to return if the condition is ${inverted ? 'false' : 'true'}. Did not receive any parameters`, originalNode.loc));
    }

    let truthy = positional.nth(1);
    let falsy = positional.nth(2);

    if (truthy === null) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`When used inline, (${type}) requires at least two parameters 1. the condition that determines the state of the (${type}), and 2. the value to return if the condition is ${inverted ? 'false' : 'true'}. Received only one parameter, the condition`, originalNode.loc));
    }

    if (positional.size > 3) {
      return (0, _result.Err)((0, _syntax.generateSyntaxError)(`When used inline, (${type}) can receive a maximum of three positional parameters 1. the condition that determines the state of the (${type}), 2. the value to return if the condition is ${inverted ? 'false' : 'true'}, and 3. the value to return if the condition is ${inverted ? 'true' : 'false'}. Received ${(_a = positional === null || positional === void 0 ? void 0 : positional.size) !== null && _a !== void 0 ? _a : 0} parameters`, originalNode.loc));
    }

    return (0, _result.Ok)({
      condition,
      truthy,
      falsy
    });
  };
}

function translateIfUnlessInlineKeyword(type) {
  let inverted = type === 'unless';
  return ({
    node,
    state
  }, {
    condition,
    truthy,
    falsy
  }) => {
    let conditionResult = _expressions.VISIT_EXPRS.visit(condition, state);

    let truthyResult = _expressions.VISIT_EXPRS.visit(truthy, state);

    let falsyResult = falsy ? _expressions.VISIT_EXPRS.visit(falsy, state) : (0, _result.Ok)(null);
    return _result.Result.all(conditionResult, truthyResult, falsyResult).mapOk(([condition, truthy, falsy]) => {
      if (inverted) {
        condition = new mir.Not({
          value: condition,
          loc: node.loc
        });
      }

      return new mir.IfInline({
        loc: node.loc,
        condition,
        truthy,
        falsy
      });
    });
  };
}

function ifUnlessInlineKeyword(type) {
  return {
    assert: assertIfUnlessInlineKeyword(type),
    translate: translateIfUnlessInlineKeyword(type)
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL2tleXdvcmRzL3V0aWxzL2lmLXVubGVzcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBRUE7O0FBQ0E7O0FBRUE7Ozs7OztBQUdBLFNBQUEsMkJBQUEsQ0FBQSxJQUFBLEVBQWlEO0FBQy9DLFNBQ0UsWUFESyxJQU1GOzs7QUFDSCxRQUFJLFFBQVEsR0FBRyxJQUFJLEtBQW5CLFFBQUE7QUFFQSxRQUFJLElBQUksR0FBRyxZQUFZLENBQVosSUFBQSxLQUFBLGVBQUEsR0FBd0MsWUFBWSxDQUFwRCxLQUFBLEdBQVgsWUFBQTtBQUNBLFFBQUksS0FBSyxHQUFHLElBQUksQ0FBSixJQUFBLEtBQUEsTUFBQSxHQUF1QixJQUFJLENBQUosSUFBQSxDQUF2QixLQUFBLEdBQVosSUFBQTtBQUNBLFFBQUksVUFBVSxHQUFHLElBQUksQ0FBSixJQUFBLEtBQUEsTUFBQSxHQUF1QixJQUFJLENBQUosSUFBQSxDQUF2QixVQUFBLEdBQWpCLElBQUE7O0FBRUEsUUFBSSxLQUFLLElBQUksQ0FBQyxLQUFLLENBQW5CLE9BQWMsRUFBZCxFQUErQjtBQUM3QixhQUFPLGlCQUNMLGlDQUNFLElBQUksSUFBSSwrQ0FBK0MsS0FBSyxDQUFMLE9BQUEsQ0FBQSxHQUFBLENBQy9DLENBQUQsSUFBTyxDQUFDLENBQUQsSUFBQSxDQUR5QyxLQUFBLEVBQUEsSUFBQSxDQUFBLElBQUEsQ0FEdEMsRUFBbkIsRUFJRSxZQUFZLENBTGhCLEdBQ0UsQ0FESyxDQUFQO0FBUUQ7O0FBRUQsUUFBSSxTQUFTLEdBQUcsVUFBVSxLQUFWLElBQUEsSUFBQSxVQUFVLEtBQUEsS0FBVixDQUFBLEdBQVUsS0FBVixDQUFBLEdBQUEsVUFBVSxDQUFWLEdBQUEsQ0FBaEIsQ0FBZ0IsQ0FBaEI7O0FBRUEsUUFBSSxDQUFBLFVBQUEsSUFB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ZW50IjpbImltcG9ydCB7IEFTVHYyLCBnZW5lcmF0ZVN5bnRheEVycm9yIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcblxuaW1wb3J0IHsgRXJyLCBPaywgUmVzdWx0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL3Jlc3VsdCc7XG5pbXBvcnQgKiBhcyBtaXIgZnJvbSAnLi4vLi4vLi4vMi1lbmNvZGluZy9taXInO1xuaW1wb3J0IHsgTm9ybWFsaXphdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vY29udGV4dCc7XG5pbXBvcnQgeyBWSVNJVF9FWFBSUyB9IGZyb20gJy4uLy4uL3Zpc2l0b3JzL2V4cHJlc3Npb25zJztcbmltcG9ydCB7IEtleXdvcmREZWxlZ2F0ZSB9IGZyb20gJy4uL2ltcGwnO1xuXG5mdW5jdGlvbiBhc3NlcnRJZlVubGVzc0lubGluZUtleXdvcmQodHlwZTogc3RyaW5nKSB7XG4gIHJldHVybiAoXG4gICAgb3JpZ2luYWxOb2RlOiBBU1R2Mi5BcHBlbmRDb250ZW50IHwgQVNUdjIuRXhwcmVzc2lvbk5vZGVcbiAgKTogUmVzdWx0PHtcbiAgICBjb25kaXRpb246IEFTVHYyLkV4cHJlc3Npb25Ob2RlO1xuICAgIHRydXRoeTogQVNUdjIuRXhwcmVzc2lvbk5vZGU7XG4gICAgZmFsc3k6IEFTVHYyLkV4cHJlc3Npb25Ob2RlIHwgbnVsbDtcbiAgfT4gPT4ge1xuICAgIGxldCBpbnZlcnRlZCA9IHR5cGUgPT09ICd1bmxlc3MnO1xuXG4gICAgbGV0IG5vZGUgPSBvcmlnaW5hbE5vZGUudHlwZSA9PT0gJ0FwcGVuZENvbnRlbnQnID8gb3JpZ2luYWxOb2RlLnZhbHVlIDogb3JpZ2luYWxOb2RlO1xuICAgIGxldCBuYW1lZCA9IG5vZGUudHlwZSA9PT0gJ0NhbGwnID8gbm9kZS5hcmdzLm5hbWVkIDogbnVsbDtcbiAgICBsZXQgcG9zaXRpb25hbCA9IG5vZGUudHlwZSA9PT0gJ0NhbGwnID8gbm9kZS5hcmdzLnBvc2l0aW9uYWwgOiBudWxsO1xuXG4gICAgaWYgKG5hbWVkICYmICFuYW1lZC5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBFcnIoXG4gICAgICAgIGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgYCgke3R5cGV9KSBjYW5ub3QgcmVjZWl2ZSBuYW1lZCBwYXJhbWV0ZXJzLCByZWNlaXZlZCAke25hbWVkLmVudHJpZXNcbiAgICAgICAgICAgIC5tYXAoKGUpID0+IGUubmFtZS5jaGFycylcbiAgICAgICAgICAgIC5qb2luKCcsICcpfWAsXG4gICAgICAgICAgb3JpZ2luYWxOb2RlLmxvY1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBjb25kaXRpb24gPSBwb3NpdGlvbmFsPy5udGgoMCk7XG5cbiAgICBpZiAoIXBvc2l0aW9uYWwgfHwgIWNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuIEVycihcbiAgICAgICAgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgV2hlbiB1c2VkIGlubGluZSwgKCR7dHlwZX0pIHJlcXVpcmVzIGF0IGxlYXN0IHR3byBwYXJhbWV0ZXJzIDEuIHRoZSBjb25kaXRpb24gdGhhdCBkZXRlcm1pbmVzIHRoZSBzdGF0ZSBvZiB0aGUgKCR7dHlwZX0pLCBhbmQgMi4gdGhlIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgY29uZGl0aW9uIGlzICR7XG4gICAgICAgICAgICBpbnZlcnRlZCA/ICdmYWxzZScgOiAndHJ1ZSdcbiAgICAgICAgICB9LiBEaWQgbm90IHJlY2VpdmUgYW55IHBhcmFtZXRlcnNgLFxuICAgICAgICAgIG9yaWdpbmFsTm9kZS5sb2NcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgdHJ1dGh5ID0gcG9zaXRpb25hbC5udGgoMSk7XG4gICAgbGV0IGZhbHN5ID0gcG9zaXRpb25hbC5udGgoMik7XG5cbiAgICBpZiAodHJ1dGh5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gRXJyKFxuICAgICAgICBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBXaGVuIHVzZWQgaW5saW5lLCAoJHt0eXBlfSkgcmVxdWlyZXMgYXQgbGVhc3QgdHdvIHBhcmFtZXRlcnMgMS4gdGhlIGNvbmRpdGlvbiB0aGF0IGRldGVybWluZXMgdGhlIHN0YXRlIG9mIHRoZSAoJHt0eXBlfSksIGFuZCAyLiB0aGUgdmFsdWUgdG8gcmV0dXJuIGlmIHRoZSBjb25kaXRpb24gaXMgJHtcbiAgICAgICAgICAgIGludmVydGVkID8gJ2ZhbHNlJyA6ICd0cnVlJ1xuICAgICAgICAgIH0uIFJlY2VpdmVkIG9ubHkgb25lIHBhcmFtZXRlciwgdGhlIGNvbmRpdGlvbmAsXG4gICAgICAgICAgb3JpZ2luYWxOb2RlLmxvY1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbmFsLnNpemUgPiAzKSB7XG4gICAgICByZXR1cm4gRXJyKFxuICAgICAgICBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBXaGVuIHVzZWQgaW5saW5lLCAoJHt0eXBlfSkgY2FuIHJlY2VpdmUgYSBtYXhpbXVtIG9mIHRocmVlIHBvc2l0aW9uYWwgcGFyYW1ldGVycyAxLiB0aGUgY29uZGl0aW9uIHRoYXQgZGV0ZXJtaW5lcyB0aGUgc3RhdGUgb2YgdGhlICgke3R5cGV9KSwgMi4gdGhlIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgY29uZGl0aW9uIGlzICR7XG4gICAgICAgICAgICBpbnZlcnRlZCA/ICdmYWxzZScgOiAndHJ1ZSdcbiAgICAgICAgICB9LCBhbmQgMy4gdGhlIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgY29uZGl0aW9uIGlzICR7XG4gICAgICAgICAgICBpbnZlcnRlZCA/ICd0cnVlJyA6ICdmYWxzZSdcbiAgICAgICAgICB9LiBSZWNlaXZlZCAke3Bvc2l0aW9uYWw/LnNpemUgPz8gMH0gcGFyYW1ldGVyc2AsXG4gICAgICAgICAgb3JpZ2luYWxOb2RlLmxvY1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBPayh7IGNvbmRpdGlvbiwgdHJ1dGh5LCBmYWxzeSB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlSWZVbmxlc3NJbmxpbmVLZXl3b3JkKHR5cGU6IHN0cmluZykge1xuICBsZXQgaW52ZXJ0ZWQgPSB0eXBlID09PSAndW5sZXNzJztcblxuICByZXR1cm4gKFxuICAgIHtcbiAgICAgIG5vZGUsXG4gICAgICBzdGF0ZSxcbiAgICB9OiB7IG5vZGU6IEFTVHYyLkFwcGVuZENvbnRlbnQgfCBBU1R2Mi5FeHByZXNzaW9uTm9kZTsgc3RhdGU6IE5vcm1hbGl6YXRpb25TdGF0ZSB9LFxuICAgIHtcbiAgICAgIGNvbmRpdGlvbixcbiAgICAgIHRydXRoeSxcbiAgICAgIGZhbHN5LFxuICAgIH06IHtcbiAgICAgIGNvbmRpdGlvbjogQVNUdjIuRXhwcmVzc2lvbk5vZGU7XG4gICAgICB0cnV0aHk6IEFTVHYyLkV4cHJlc3Npb25Ob2RlO1xuICAgICAgZmFsc3k6IEFTVHYyLkV4cHJlc3Npb25Ob2RlIHwgbnVsbDtcbiAgICB9XG4gICk6IFJlc3VsdDxtaXIuSWZJbmxpbmU+ID0+IHtcbiAgICBsZXQgY29uZGl0aW9uUmVzdWx0ID0gVklTSVRfRVhQUlMudmlzaXQoY29uZGl0aW9uLCBzdGF0ZSk7XG4gICAgbGV0IHRydXRoeVJlc3VsdCA9IFZJU0lUX0VYUFJTLnZpc2l0KHRydXRoeSwgc3RhdGUpO1xuICAgIGxldCBmYWxzeVJlc3VsdCA9IGZhbHN5ID8gVklTSVRfRVhQUlMudmlzaXQoZmFsc3ksIHN0YXRlKSA6IE9rKG51bGwpO1xuXG4gICAgcmV0dXJuIFJlc3VsdC5hbGwoY29uZGl0aW9uUmVzdWx0LCB0cnV0aHlSZXN1bHQsIGZhbHN5UmVzdWx0KS5tYXBPayhcbiAgICAgIChbY29uZGl0aW9uLCB0cnV0aHksIGZhbHN5XSkgPT4ge1xuICAgICAgICBpZiAoaW52ZXJ0ZWQpIHtcbiAgICAgICAgICBjb25kaXRpb24gPSBuZXcgbWlyLk5vdCh7IHZhbHVlOiBjb25kaXRpb24sIGxvYzogbm9kZS5sb2MgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IG1pci5JZklubGluZSh7XG4gICAgICAgICAgbG9jOiBub2RlLmxvYyxcbiAgICAgICAgICBjb25kaXRpb24sXG4gICAgICAgICAgdHJ1dGh5LFxuICAgICAgICAgIGZhbHN5LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaWZVbmxlc3NJbmxpbmVLZXl3b3JkKFxuICB0eXBlOiBzdHJpbmdcbik6IEtleXdvcmREZWxlZ2F0ZTxcbiAgQVNUdjIuQ2FsbEV4cHJlc3Npb24gfCBBU1R2Mi5BcHBlbmRDb250ZW50LFxuICB7XG4gICAgY29uZGl0aW9uOiBBU1R2Mi5FeHByZXNzaW9uTm9kZTtcbiAgICB0cnV0aHk6IEFTVHYyLkV4cHJlc3Npb25Ob2RlO1xuICAgIGZhbHN5OiBBU1R2Mi5FeHByZXNzaW9uTm9kZSB8IG51bGw7XG4gIH0sXG4gIG1pci5JZklubGluZVxuPiB7XG4gIHJldHVybiB7XG4gICAgYXNzZXJ0OiBhc3NlcnRJZlVubGVzc0lubGluZUtleXdvcmQodHlwZSksXG4gICAgdHJhbnNsYXRlOiB0cmFuc2xhdGVJZlVubGVzc0lubGluZUtleXdvcmQodHlwZSksXG4gIH07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9