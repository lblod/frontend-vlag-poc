"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasDynamicFeatures = hasDynamicFeatures;
exports.ClassifiedElement = void 0;

var _syntax = require("@glimmer/syntax");

var _list = require("../../../../shared/list");

var _result = require("../../../../shared/result");

var _utils = require("../../../../utils");

var mir = _interopRequireWildcard(require("../../../2-encoding/mir"));

var _keywords = require("../../keywords");

var _isNode = require("../../utils/is-node");

var _expressions = require("../expressions");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

class ClassifiedElement {
  constructor(element, delegate, state) {
    this.element = element;
    this.state = state;
    this.delegate = delegate;
  }

  toStatement() {
    return this.prepare().andThen(prepared => this.delegate.toStatement(this, prepared));
  }

  attr(attr) {
    let name = attr.name;
    let rawValue = attr.value;
    let namespace = (0, _utils.getAttrNamespace)(name.chars) || undefined;

    if (_syntax.ASTv2.isLiteral(rawValue, 'string')) {
      return (0, _result.Ok)(new mir.StaticAttr({
        loc: attr.loc,
        name,
        value: rawValue.toSlice(),
        namespace,
        kind: {
          component: this.delegate.dynamicFeatures
        }
      }));
    }

    return _expressions.VISIT_EXPRS.visit((0, _expressions.convertPathToCallIfKeyword)(rawValue), this.state).mapOk(value => {
      let isTrusting = attr.trusting;
      return new mir.DynamicAttr({
        loc: attr.loc,
        name,
        value: value,
        namespace,
        kind: {
          trusting: isTrusting,
          component: this.delegate.dynamicFeatures
        }
      });
    });
  }

  modifier(modifier) {
    if ((0, _isNode.isHelperInvocation)(modifier)) {
      (0, _isNode.assertIsValidModifier)(modifier);
    }

    let translated = _keywords.MODIFIER_KEYWORDS.translate(modifier, this.state);

    if (translated !== null) {
      return translated;
    }

    let head = _expressions.VISIT_EXPRS.visit(modifier.callee, this.state);

    let args = _expressions.VISIT_EXPRS.Args(modifier.args, this.state);

    return _result.Result.all(head, args).mapOk(([head, args]) => new mir.Modifier({
      loc: modifier.loc,
      callee: head,
      args
    }));
  }

  attrs() {
    let attrs = new _result.ResultArray();
    let args = new _result.ResultArray(); // Unlike most attributes, the `type` attribute can change how
    // subsequent attributes are interpreted by the browser. To address
    // this, in simple cases, we special case the `type` attribute to be set
    // last. For elements with splattributes, where attribute order affects
    // precedence, this re-ordering happens at runtime instead.
    // See https://github.com/glimmerjs/glimmer-vm/pull/726

    let typeAttr = null;
    let simple = this.element.attrs.filter(attr => attr.type === 'SplatAttr').length === 0;

    for (let attr of this.element.attrs) {
      if (attr.type === 'SplatAttr') {
        attrs.add((0, _result.Ok)(new mir.SplatAttr({
          loc: attr.loc,
          symbol: this.state.scope.allocateBlock('attrs')
        })));
      } else if (attr.name.chars === 'type' && simple) {
        typeAttr = attr;
      } else {
        attrs.add(this.attr(attr));
      }
    }

    for (let arg of this.element.componentArgs) {
      args.add(this.delegate.arg(arg, this));
    }

    if (typeAttr) {
      attrs.add(this.attr(typeAttr));
    }

    return _result.Result.all(args.toArray(), attrs.toArray()).mapOk(([args, attrs]) => ({
      attrs,
      args: new mir.NamedArguments({
        loc: (0, _syntax.maybeLoc)(args, _syntax.SourceSpan.NON_EXISTENT),
        entries: (0, _list.OptionalList)(args)
      })
    }));
  }

  prepare() {
    let attrs = this.attrs();
    let modifiers = new _result.ResultArray(this.element.modifiers.map(m => this.modifier(m))).toArray();
    return _result.Result.all(attrs, modifiers).mapOk(([result, modifiers]) => {
      let {
        attrs,
        args
      } = result;
      let elementParams = [...attrs, ...modifiers];
      let params = new mir.ElementParameters({
        loc: (0, _syntax.maybeLoc)(elementParams, _syntax.SourceSpan.NON_EXISTENT),
        body: (0, _list.OptionalList)(elementParams)
      });
      return {
        args,
        params
      };
    });
  }

}

exports.ClassifiedElement = ClassifiedElement;

function hasDynamicFeatures({
  attrs,
  modifiers
}) {
  // ElementModifier needs the special ComponentOperations
  if (modifiers.length > 0) {
    return true;
  } // Splattributes need the special ComponentOperations to merge into


  return !!attrs.filter(attr => attr.type === 'SplatAttr')[0];
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2NvbXBpbGVyL2xpYi9wYXNzZXMvMS1ub3JtYWxpemF0aW9uL3Zpc2l0b3JzL2VsZW1lbnQvY2xhc3NpZmllZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOzs7Ozs7QUFnQk0sTUFBQSxpQkFBQSxDQUF3QjtBQUc1QixFQUFBLFdBQUEsQ0FBQSxPQUFBLEVBQUEsUUFBQSxFQUFBLEtBQUEsRUFHb0M7QUFGekIsU0FBQSxPQUFBLEdBQUEsT0FBQTtBQUVBLFNBQUEsS0FBQSxHQUFBLEtBQUE7QUFFVCxTQUFBLFFBQUEsR0FBQSxRQUFBO0FBQ0Q7O0FBRUQsRUFBQSxXQUFXLEdBQUE7QUFDVCxXQUFPLEtBQUEsT0FBQSxHQUFBLE9BQUEsQ0FBd0IsUUFBRCxJQUFjLEtBQUEsUUFBQSxDQUFBLFdBQUEsQ0FBQSxJQUFBLEVBQTVDLFFBQTRDLENBQXJDLENBQVA7QUFDRDs7QUFFTyxFQUFBLElBQUksQ0FBQSxJQUFBLEVBQXFCO0FBQy9CLFFBQUksSUFBSSxHQUFHLElBQUksQ0FBZixJQUFBO0FBQ0EsUUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFuQixLQUFBO0FBQ0EsUUFBSSxTQUFTLEdBQUcsNkJBQWlCLElBQUksQ0FBckIsS0FBQSxLQUFoQixTQUFBOztBQUVBLFFBQUksY0FBQSxTQUFBLENBQUEsUUFBQSxFQUFKLFFBQUksQ0FBSixFQUF5QztBQUN2QyxhQUFPLGdCQUNMLElBQUksR0FBRyxDQUFQLFVBQUEsQ0FBbUI7QUFDakIsUUFBQSxHQUFHLEVBQUUsSUFBSSxDQURRLEdBQUE7QUFBQSxRQUFBLElBQUE7QUFHakIsUUFBQSxLQUFLLEVBQUUsUUFBUSxDQUhFLE9BR1YsRUFIVTtBQUFBLFFBQUEsU0FBQTtBQUtqQixRQUFBLElBQUksRUFBRTtBQUNKLFVBQUEsU0FBUyxFQUFF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QSxHQUFHLEVBQUUsc0JBQVEsYUFBUixFQUF3QixtQkFEUSxZQUNoQyxDQURnQztBQUVyQyxRQUFBLElBQUksRUFBRSx3QkFBWSxhQUFaO0FBRitCLE9BQTFCLENBQWI7QUFLQSxhQUFPO0FBQUEsUUFBQSxJQUFBO0FBQVEsUUFBQTtBQUFSLE9BQVA7QUFWRixLQUFPLENBQVA7QUFZRDs7QUFwSTJCOzs7O0FBNEl4QixTQUFBLGtCQUFBLENBQTZCO0FBQUEsRUFBQSxLQUFBO0FBRWpDLEVBQUE7QUFGaUMsQ0FBN0IsRUFHMkM7QUFDL0M7QUFDQSxNQUFJLFNBQVMsQ0FBVCxNQUFBLEdBQUosQ0FBQSxFQUEwQjtBQUN4QixXQUFBLElBQUE7QUFINkMsR0FBQSxDQU0vQzs7O0FBQ0EsU0FBTyxDQUFDLENBQUMsS0FBSyxDQUFMLE1BQUEsQ0FBYyxJQUFELElBQVUsSUFBSSxDQUFKLElBQUEsS0FBdkIsV0FBQSxFQUFULENBQVMsQ0FBVDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQVNUdjIsIG1heWJlTG9jLCBTb3VyY2VTcGFuIH0gZnJvbSAnQGdsaW1tZXIvc3ludGF4JztcblxuaW1wb3J0IHsgT3B0aW9uYWxMaXN0IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2xpc3QnO1xuaW1wb3J0IHsgT2ssIFJlc3VsdCwgUmVzdWx0QXJyYXkgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvcmVzdWx0JztcbmltcG9ydCB7IGdldEF0dHJOYW1lc3BhY2UgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlscyc7XG5pbXBvcnQgKiBhcyBtaXIgZnJvbSAnLi4vLi4vLi4vMi1lbmNvZGluZy9taXInO1xuaW1wb3J0IHsgTm9ybWFsaXphdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vY29udGV4dCc7XG5pbXBvcnQgeyBNT0RJRklFUl9LRVlXT1JEUyB9IGZyb20gJy4uLy4uL2tleXdvcmRzJztcbmltcG9ydCB7IGFzc2VydElzVmFsaWRNb2RpZmllciwgaXNIZWxwZXJJbnZvY2F0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbHMvaXMtbm9kZSc7XG5pbXBvcnQgeyBjb252ZXJ0UGF0aFRvQ2FsbElmS2V5d29yZCwgVklTSVRfRVhQUlMgfSBmcm9tICcuLi9leHByZXNzaW9ucyc7XG5cbmV4cG9ydCB0eXBlIFZhbGlkQXR0ciA9IG1pci5TdGF0aWNBdHRyIHwgbWlyLkR5bmFtaWNBdHRyIHwgbWlyLlNwbGF0QXR0cjtcblxudHlwZSBQcm9jZXNzZWRBdHRyaWJ1dGVzID0ge1xuICBhdHRyczogVmFsaWRBdHRyW107XG4gIGFyZ3M6IG1pci5OYW1lZEFyZ3VtZW50cztcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xhc3NpZmllZCB7XG4gIHJlYWRvbmx5IGR5bmFtaWNGZWF0dXJlczogYm9vbGVhbjtcblxuICBhcmcoYXR0cjogQVNUdjIuQXR0ck5vZGUsIGNsYXNzaWZpZWQ6IENsYXNzaWZpZWRFbGVtZW50KTogUmVzdWx0PG1pci5OYW1lZEFyZ3VtZW50PjtcbiAgdG9TdGF0ZW1lbnQoY2xhc3NpZmllZDogQ2xhc3NpZmllZEVsZW1lbnQsIHByZXBhcmVkOiBQcmVwYXJlZEFyZ3MpOiBSZXN1bHQ8bWlyLlN0YXRlbWVudD47XG59XG5cbmV4cG9ydCBjbGFzcyBDbGFzc2lmaWVkRWxlbWVudCB7XG4gIHJlYWRvbmx5IGRlbGVnYXRlOiBDbGFzc2lmaWVkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGVsZW1lbnQ6IEFTVHYyLkVsZW1lbnROb2RlLFxuICAgIGRlbGVnYXRlOiBDbGFzc2lmaWVkLFxuICAgIHJlYWRvbmx5IHN0YXRlOiBOb3JtYWxpemF0aW9uU3RhdGVcbiAgKSB7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICB9XG5cbiAgdG9TdGF0ZW1lbnQoKTogUmVzdWx0PG1pci5TdGF0ZW1lbnQ+IHtcbiAgICByZXR1cm4gdGhpcy5wcmVwYXJlKCkuYW5kVGhlbigocHJlcGFyZWQpID0+IHRoaXMuZGVsZWdhdGUudG9TdGF0ZW1lbnQodGhpcywgcHJlcGFyZWQpKTtcbiAgfVxuXG4gIHByaXZhdGUgYXR0cihhdHRyOiBBU1R2Mi5IdG1sQXR0cik6IFJlc3VsdDxWYWxpZEF0dHI+IHtcbiAgICBsZXQgbmFtZSA9IGF0dHIubmFtZTtcbiAgICBsZXQgcmF3VmFsdWUgPSBhdHRyLnZhbHVlO1xuICAgIGxldCBuYW1lc3BhY2UgPSBnZXRBdHRyTmFtZXNwYWNlKG5hbWUuY2hhcnMpIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmIChBU1R2Mi5pc0xpdGVyYWwocmF3VmFsdWUsICdzdHJpbmcnKSkge1xuICAgICAgcmV0dXJuIE9rKFxuICAgICAgICBuZXcgbWlyLlN0YXRpY0F0dHIoe1xuICAgICAgICAgIGxvYzogYXR0ci5sb2MsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICB2YWx1ZTogcmF3VmFsdWUudG9TbGljZSgpLFxuICAgICAgICAgIG5hbWVzcGFjZSxcbiAgICAgICAgICBraW5kOiB7XG4gICAgICAgICAgICBjb21wb25lbnQ6IHRoaXMuZGVsZWdhdGUuZHluYW1pY0ZlYXR1cmVzLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBWSVNJVF9FWFBSUy52aXNpdChjb252ZXJ0UGF0aFRvQ2FsbElmS2V5d29yZChyYXdWYWx1ZSksIHRoaXMuc3RhdGUpLm1hcE9rKCh2YWx1ZSkgPT4ge1xuICAgICAgbGV0IGlzVHJ1c3RpbmcgPSBhdHRyLnRydXN0aW5nO1xuXG4gICAgICByZXR1cm4gbmV3IG1pci5EeW5hbWljQXR0cih7XG4gICAgICAgIGxvYzogYXR0ci5sb2MsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgbmFtZXNwYWNlLFxuICAgICAgICBraW5kOiB7XG4gICAgICAgICAgdHJ1c3Rpbmc6IGlzVHJ1c3RpbmcsXG4gICAgICAgICAgY29tcG9uZW50OiB0aGlzLmRlbGVnYXRlLmR5bmFtaWNGZWF0dXJlcyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBtb2RpZmllcihtb2RpZmllcjogQVNUdjIuRWxlbWVudE1vZGlmaWVyKTogUmVzdWx0PG1pci5Nb2RpZmllcj4ge1xuICAgIGlmIChpc0hlbHBlckludm9jYXRpb24obW9kaWZpZXIpKSB7XG4gICAgICBhc3NlcnRJc1ZhbGlkTW9kaWZpZXIobW9kaWZpZXIpO1xuICAgIH1cblxuICAgIGxldCB0cmFuc2xhdGVkID0gTU9ESUZJRVJfS0VZV09SRFMudHJhbnNsYXRlKG1vZGlmaWVyLCB0aGlzLnN0YXRlKTtcblxuICAgIGlmICh0cmFuc2xhdGVkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJhbnNsYXRlZDtcbiAgICB9XG5cbiAgICBsZXQgaGVhZCA9IFZJU0lUX0VYUFJTLnZpc2l0KG1vZGlmaWVyLmNhbGxlZSwgdGhpcy5zdGF0ZSk7XG4gICAgbGV0IGFyZ3MgPSBWSVNJVF9FWFBSUy5BcmdzKG1vZGlmaWVyLmFyZ3MsIHRoaXMuc3RhdGUpO1xuXG4gICAgcmV0dXJuIFJlc3VsdC5hbGwoaGVhZCwgYXJncykubWFwT2soXG4gICAgICAoW2hlYWQsIGFyZ3NdKSA9PlxuICAgICAgICBuZXcgbWlyLk1vZGlmaWVyKHtcbiAgICAgICAgICBsb2M6IG1vZGlmaWVyLmxvYyxcbiAgICAgICAgICBjYWxsZWU6IGhlYWQsXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBhdHRycygpOiBSZXN1bHQ8UHJvY2Vzc2VkQXR0cmlidXRlcz4ge1xuICAgIGxldCBhdHRycyA9IG5ldyBSZXN1bHRBcnJheTxWYWxpZEF0dHI+KCk7XG4gICAgbGV0IGFyZ3MgPSBuZXcgUmVzdWx0QXJyYXk8bWlyLk5hbWVkQXJndW1lbnQ+KCk7XG5cbiAgICAvLyBVbmxpa2UgbW9zdCBhdHRyaWJ1dGVzLCB0aGUgYHR5cGVgIGF0dHJpYnV0ZSBjYW4gY2hhbmdlIGhvd1xuICAgIC8vIHN1YnNlcXVlbnQgYXR0cmlidXRlcyBhcmUgaW50ZXJwcmV0ZWQgYnkgdGhlIGJyb3dzZXIuIFRvIGFkZHJlc3NcbiAgICAvLyB0aGlzLCBpbiBzaW1wbGUgY2FzZXMsIHdlIHNwZWNpYWwgY2FzZSB0aGUgYHR5cGVgIGF0dHJpYnV0ZSB0byBiZSBzZXRcbiAgICAvLyBsYXN0LiBGb3IgZWxlbWVudHMgd2l0aCBzcGxhdHRyaWJ1dGVzLCB3aGVyZSBhdHRyaWJ1dGUgb3JkZXIgYWZmZWN0c1xuICAgIC8vIHByZWNlZGVuY2UsIHRoaXMgcmUtb3JkZXJpbmcgaGFwcGVucyBhdCBydW50aW1lIGluc3RlYWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGltbWVyanMvZ2xpbW1lci12bS9wdWxsLzcyNlxuICAgIGxldCB0eXBlQXR0cjogQVNUdjIuQXR0ck5vZGUgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgc2ltcGxlID0gdGhpcy5lbGVtZW50LmF0dHJzLmZpbHRlcigoYXR0cikgPT4gYXR0ci50eXBlID09PSAnU3BsYXRBdHRyJykubGVuZ3RoID09PSAwO1xuXG4gICAgZm9yIChsZXQgYXR0ciBvZiB0aGlzLmVsZW1lbnQuYXR0cnMpIHtcbiAgICAgIGlmIChhdHRyLnR5cGUgPT09ICdTcGxhdEF0dHInKSB7XG4gICAgICAgIGF0dHJzLmFkZChcbiAgICAgICAgICBPayhuZXcgbWlyLlNwbGF0QXR0cih7IGxvYzogYXR0ci5sb2MsIHN5bWJvbDogdGhpcy5zdGF0ZS5zY29wZS5hbGxvY2F0ZUJsb2NrKCdhdHRycycpIH0pKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChhdHRyLm5hbWUuY2hhcnMgPT09ICd0eXBlJyAmJiBzaW1wbGUpIHtcbiAgICAgICAgdHlwZUF0dHIgPSBhdHRyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMuYWRkKHRoaXMuYXR0cihhdHRyKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChsZXQgYXJnIG9mIHRoaXMuZWxlbWVudC5jb21wb25lbnRBcmdzKSB7XG4gICAgICBhcmdzLmFkZCh0aGlzLmRlbGVnYXRlLmFyZyhhcmcsIHRoaXMpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZUF0dHIpIHtcbiAgICAgIGF0dHJzLmFkZCh0aGlzLmF0dHIodHlwZUF0dHIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVzdWx0LmFsbChhcmdzLnRvQXJyYXkoKSwgYXR0cnMudG9BcnJheSgpKS5tYXBPaygoW2FyZ3MsIGF0dHJzXSkgPT4gKHtcbiAgICAgIGF0dHJzLFxuICAgICAgYXJnczogbmV3IG1pci5OYW1lZEFyZ3VtZW50cyh7XG4gICAgICAgIGxvYzogbWF5YmVMb2MoYXJncywgU291cmNlU3Bhbi5OT05fRVhJU1RFTlQpLFxuICAgICAgICBlbnRyaWVzOiBPcHRpb25hbExpc3QoYXJncyksXG4gICAgICB9KSxcbiAgICB9KSk7XG4gIH1cblxuICBwcml2YXRlIHByZXBhcmUoKTogUmVzdWx0PFByZXBhcmVkQXJncz4ge1xuICAgIGxldCBhdHRycyA9IHRoaXMuYXR0cnMoKTtcbiAgICBsZXQgbW9kaWZpZXJzID0gbmV3IFJlc3VsdEFycmF5KHRoaXMuZWxlbWVudC5tb2RpZmllcnMubWFwKChtKSA9PiB0aGlzLm1vZGlmaWVyKG0pKSkudG9BcnJheSgpO1xuXG4gICAgcmV0dXJuIFJlc3VsdC5hbGwoYXR0cnMsIG1vZGlmaWVycykubWFwT2soKFtyZXN1bHQsIG1vZGlmaWVyc10pID0+IHtcbiAgICAgIGxldCB7IGF0dHJzLCBhcmdzIH0gPSByZXN1bHQ7XG5cbiAgICAgIGxldCBlbGVtZW50UGFyYW1zID0gWy4uLmF0dHJzLCAuLi5tb2RpZmllcnNdO1xuXG4gICAgICBsZXQgcGFyYW1zID0gbmV3IG1pci5FbGVtZW50UGFyYW1ldGVycyh7XG4gICAgICAgIGxvYzogbWF5YmVMb2MoZWxlbWVudFBhcmFtcywgU291cmNlU3Bhbi5OT05fRVhJU1RFTlQpLFxuICAgICAgICBib2R5OiBPcHRpb25hbExpc3QoZWxlbWVudFBhcmFtcyksXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHsgYXJncywgcGFyYW1zIH07XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmVwYXJlZEFyZ3Mge1xuICBhcmdzOiBtaXIuTmFtZWRBcmd1bWVudHM7XG4gIHBhcmFtczogbWlyLkVsZW1lbnRQYXJhbWV0ZXJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzRHluYW1pY0ZlYXR1cmVzKHtcbiAgYXR0cnMsXG4gIG1vZGlmaWVycyxcbn06IFBpY2s8QVNUdjIuRWxlbWVudE5vZGUsICdhdHRycycgfCAnbW9kaWZpZXJzJz4pOiBib29sZWFuIHtcbiAgLy8gRWxlbWVudE1vZGlmaWVyIG5lZWRzIHRoZSBzcGVjaWFsIENvbXBvbmVudE9wZXJhdGlvbnNcbiAgaWYgKG1vZGlmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBTcGxhdHRyaWJ1dGVzIG5lZWQgdGhlIHNwZWNpYWwgQ29tcG9uZW50T3BlcmF0aW9ucyB0byBtZXJnZSBpbnRvXG4gIHJldHVybiAhIWF0dHJzLmZpbHRlcigoYXR0cikgPT4gYXR0ci50eXBlID09PSAnU3BsYXRBdHRyJylbMF07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9