import { DynamicScope, Dict, PartialScope, ScopeSlot, ScopeBlock, Option, Scope, Owner } from '@glimmer/interfaces';
import { Reference } from '@glimmer/reference';
export declare class DynamicScopeImpl implements DynamicScope {
    private bucket;
    constructor(bucket?: Dict<Reference>);
    get(key: string): Reference;
    set(key: string, reference: Reference): Reference;
    child(): DynamicScopeImpl;
}
export declare function isScopeReference(s: ScopeSlot): s is Reference;
export declare class PartialScopeImpl implements PartialScope {
    readonly slots: Array<ScopeSlot>;
    readonly owner: Owner;
    private callerScope;
    private evalScope;
    private partialMap;
    static root(self: Reference<unknown>, size: number | undefined, owner: Owner): PartialScope;
    static sized(size: number | undefined, owner: Owner): Scope;
    constructor(slots: Array<ScopeSlot>, owner: Owner, callerScope: Scope | null, evalScope: Dict<ScopeSlot> | null, partialMap: Dict<Reference<unknown>> | null);
    init({ self }: {
        self: Reference<unknown>;
    }): this;
    getSelf(): Reference<unknown>;
    getSymbol(symbol: number): Reference<unknown>;
    getBlock(symbol: number): Option<ScopeBlock>;
    getEvalScope(): Option<Dict<ScopeSlot>>;
    getPartialMap(): Option<Dict<Reference<unknown>>>;
    bind(symbol: number, value: ScopeSlot): void;
    bindSelf(self: Reference<unknown>): void;
    bindSymbol(symbol: number, value: Reference<unknown>): void;
    bindBlock(symbol: number, value: Option<ScopeBlock>): void;
    bindEvalScope(map: Option<Dict<ScopeSlot>>): void;
    bindPartialMap(map: Dict<Reference<unknown>>): void;
    bindCallerScope(scope: Option<Scope>): void;
    getCallerScope(): Option<Scope>;
    child(): Scope;
    private get;
    private set;
}
//# sourceMappingURL=scope.d.ts.map