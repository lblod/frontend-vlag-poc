import { CapturedArguments, CurriedType, Owner } from '@glimmer/interfaces';
import { Reference } from '@glimmer/reference';
declare const TYPE: unique symbol;
declare const INNER: unique symbol;
declare const OWNER: unique symbol;
declare const ARGS: unique symbol;
declare const RESOLVED: unique symbol;
export declare function isCurriedValue(value: unknown): value is CurriedValue<CurriedType>;
export declare function isCurriedType<T extends CurriedType>(value: unknown, type: T): value is CurriedValue<T>;
export declare class CurriedValue<T extends CurriedType = CurriedType> {
    [TYPE]: T;
    [INNER]: object | string | CurriedValue<T>;
    [OWNER]: Owner;
    [ARGS]: CapturedArguments | null;
    [RESOLVED]: boolean;
    /** @internal */
    constructor(type: T, inner: object | string | CurriedValue<T>, owner: Owner, args: CapturedArguments | null, resolved?: boolean);
}
interface ResolvedCurriedValue<T> {
    definition: T;
    owner: Owner;
    resolved: boolean;
    positional: Reference[] | undefined;
    named: Record<string, Reference>[] | undefined;
}
export declare function resolveCurriedValue(curriedValue: CurriedValue<CurriedType.Component>): ResolvedCurriedValue<object | string>;
export declare function resolveCurriedValue(curriedValue: CurriedValue<CurriedType.Helper> | CurriedValue<CurriedType.Modifier>): ResolvedCurriedValue<object>;
export declare function curry<T extends CurriedType>(type: T, spec: object | string | CurriedValue<T>, owner: Owner, args: CapturedArguments | null, resolved?: boolean): CurriedValue<T>;
export {};
//# sourceMappingURL=curried-value.d.ts.map