import { CompilableTemplate, Destroyable, DynamicScope, ElementBuilder, Environment, Option, PartialScope, RenderResult, RichIteratorResult, RuntimeConstants, RuntimeContext, RuntimeProgram, Scope, CompileTimeCompilationContext, VM as PublicVM, ResolutionTimeConstants, Owner, UpdatingOpcode } from '@glimmer/interfaces';
import { OpaqueIterationItem, OpaqueIterator, Reference } from '@glimmer/reference';
import { MachineRegister, Register, SyscallRegister } from '@glimmer/vm';
import { ARGS, CONSTANTS, DESTROYABLE_STACK, HEAP, INNER_VM, STACKS } from '../symbols';
import { VMArgumentsImpl } from './arguments';
import LowLevelVM from './low-level';
import { EvaluationStack } from './stack';
import { ListBlockOpcode, ListItemOpcode, ResumableVMState, VMState } from './update';
/**
 * This interface is used by internal opcodes, and is more stable than
 * the implementation of the Append VM itself.
 */
export interface InternalVM {
    readonly [CONSTANTS]: RuntimeConstants & ResolutionTimeConstants;
    readonly [ARGS]: VMArgumentsImpl;
    readonly env: Environment;
    readonly stack: EvaluationStack;
    readonly runtime: RuntimeContext;
    readonly context: CompileTimeCompilationContext;
    loadValue(register: MachineRegister, value: number): void;
    loadValue(register: Register, value: unknown): void;
    loadValue(register: Register | MachineRegister, value: unknown): void;
    fetchValue(register: MachineRegister.ra | MachineRegister.pc): number;
    fetchValue<T>(register: Register): T;
    fetchValue(register: Register): unknown;
    load(register: Register): void;
    fetch(register: Register): void;
    compile(block: CompilableTemplate): number;
    scope(): Scope;
    elements(): ElementBuilder;
    getOwner(): Owner;
    getSelf(): Reference;
    updateWith(opcode: UpdatingOpcode): void;
    associateDestroyable(d: Destroyable): void;
    beginCacheGroup(name?: string): void;
    commitCacheGroup(): void;
    enterList(iterableRef: Reference<OpaqueIterator>, offset: number): void;
    exitList(): void;
    enterItem(item: OpaqueIterationItem): ListItemOpcode;
    registerItem(item: ListItemOpcode): void;
    pushRootScope(size: number, owner: Owner): PartialScope;
    pushChildScope(): void;
    popScope(): void;
    pushScope(scope: Scope): void;
    dynamicScope(): DynamicScope;
    bindDynamicScope(names: string[]): void;
    pushDynamicScope(): void;
    popDynamicScope(): void;
    enter(args: number): void;
    exit(): void;
    goto(pc: number): void;
    call(handle: number): void;
    pushFrame(): void;
    referenceForSymbol(symbol: number): Reference;
    execute(initialize?: (vm: this) => void): RenderResult;
    pushUpdating(list?: UpdatingOpcode[]): void;
    next(): RichIteratorResult<null, RenderResult>;
}
export default class VM implements PublicVM, InternalVM {
    readonly runtime: RuntimeContext;
    private readonly elementStack;
    readonly context: CompileTimeCompilationContext;
    private readonly [STACKS];
    private readonly [HEAP];
    private readonly destructor;
    private readonly [DESTROYABLE_STACK];
    readonly [CONSTANTS]: RuntimeConstants & ResolutionTimeConstants;
    readonly [ARGS]: VMArgumentsImpl;
    readonly [INNER_VM]: LowLevelVM;
    get stack(): EvaluationStack;
    get pc(): number;
    s0: unknown;
    s1: unknown;
    t0: unknown;
    t1: unknown;
    v0: unknown;
    fetch(register: SyscallRegister): void;
    load(register: SyscallRegister): void;
    fetchValue(register: MachineRegister): number;
    fetchValue<T>(register: Register): T;
    loadValue<T>(register: Register | MachineRegister, value: T): void;
    /**
     * Migrated to Inner
     */
    pushFrame(): void;
    popFrame(): void;
    goto(offset: number): void;
    call(handle: number): void;
    returnTo(offset: number): void;
    return(): void;
    /**
     * End of migrated.
     */
    constructor(runtime: RuntimeContext, { pc, scope, dynamicScope, stack }: VMState, elementStack: ElementBuilder, context: CompileTimeCompilationContext);
    static initial(runtime: RuntimeContext, context: CompileTimeCompilationContext, { handle, self, dynamicScope, treeBuilder, numSymbols, owner }: InitOptions): InternalVM;
    static empty(runtime: RuntimeContext, { handle, treeBuilder, dynamicScope, owner }: MinimalInitOptions, context: CompileTimeCompilationContext): InternalVM;
    private resume;
    compile(block: CompilableTemplate): number;
    get program(): RuntimeProgram;
    get env(): Environment;
    captureState(args: number, pc?: number): VMState;
    capture(args: number, pc?: number): ResumableVMState;
    beginCacheGroup(name?: string): void;
    commitCacheGroup(): void;
    enter(args: number): void;
    enterItem({ key, value, memo }: OpaqueIterationItem): ListItemOpcode;
    registerItem(opcode: ListItemOpcode): void;
    enterList(iterableRef: Reference<OpaqueIterator>, offset: number): void;
    private didEnter;
    exit(): void;
    exitList(): void;
    pushUpdating(list?: UpdatingOpcode[]): void;
    popUpdating(): UpdatingOpcode[];
    updateWith(opcode: UpdatingOpcode): void;
    listBlock(): ListBlockOpcode;
    associateDestroyable(child: Destroyable): void;
    tryUpdating(): Option<UpdatingOpcode[]>;
    updating(): UpdatingOpcode[];
    elements(): ElementBuilder;
    scope(): Scope;
    dynamicScope(): DynamicScope;
    pushChildScope(): void;
    pushDynamicScope(): DynamicScope;
    pushRootScope(size: number, owner: Owner): PartialScope;
    pushScope(scope: Scope): void;
    popScope(): void;
    popDynamicScope(): void;
    getOwner(): Owner;
    getSelf(): Reference<any>;
    referenceForSymbol(symbol: number): Reference;
    execute(initialize?: (vm: this) => void): RenderResult;
    private _execute;
    next(): RichIteratorResult<null, RenderResult>;
    bindDynamicScope(names: string[]): void;
}
export interface MinimalInitOptions {
    handle: number;
    treeBuilder: ElementBuilder;
    dynamicScope: DynamicScope;
    owner: Owner;
}
export interface InitOptions extends MinimalInitOptions {
    self: Reference;
    numSymbols: number;
}
export declare type VmInitCallback = (this: void, runtime: RuntimeContext, state: VMState, builder: ElementBuilder) => InternalVM;
//# sourceMappingURL=append.d.ts.map