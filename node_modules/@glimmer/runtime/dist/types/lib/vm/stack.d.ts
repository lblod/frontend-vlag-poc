import { MachineRegister } from '@glimmer/vm';
import { REGISTERS } from '../symbols';
import { LowLevelRegisters } from './low-level';
export interface EvaluationStack {
    [REGISTERS]: LowLevelRegisters;
    push(value: unknown): void;
    dup(position?: MachineRegister): void;
    copy(from: number, to: number): void;
    pop<T>(n?: number): T;
    peek<T>(offset?: number): T;
    get<T>(offset: number, base?: number): T;
    set(value: unknown, offset: number, base?: number): void;
    slice<T = unknown>(start: number, end: number): T[];
    capture(items: number): unknown[];
    reset(): void;
    toArray(): unknown[];
}
export default class EvaluationStackImpl implements EvaluationStack {
    private stack;
    static restore(snapshot: unknown[]): EvaluationStackImpl;
    readonly [REGISTERS]: LowLevelRegisters;
    constructor(stack: unknown[], registers: LowLevelRegisters);
    push(value: unknown): void;
    dup(position?: number): void;
    copy(from: number, to: number): void;
    pop<T>(n?: number): T;
    peek<T>(offset?: number): T;
    get<T>(offset: number, base?: number): T;
    set(value: unknown, offset: number, base?: number): void;
    slice<T = unknown>(start: number, end: number): T[];
    capture(items: number): unknown[];
    reset(): void;
    toArray(): unknown[];
}
//# sourceMappingURL=stack.d.ts.map