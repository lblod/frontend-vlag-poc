import { BlockArguments, BlockValue, CapturedArguments, CapturedBlockArguments, CapturedNamedArguments, CapturedPositionalArguments, Dict, NamedArguments, Option, PositionalArguments, ScopeBlock, VMArguments } from '@glimmer/interfaces';
import { Reference } from '@glimmer/reference';
import { Tag } from '@glimmer/validator';
import { EvaluationStack } from './stack';
export declare class VMArgumentsImpl implements VMArguments {
    private stack;
    positional: PositionalArgumentsImpl;
    named: NamedArgumentsImpl;
    blocks: BlockArgumentsImpl;
    empty(stack: EvaluationStack): this;
    setup(stack: EvaluationStack, names: readonly string[], blockNames: readonly string[], positionalCount: number, atNames: boolean): void;
    get base(): number;
    get length(): number;
    at(pos: number): Reference;
    realloc(offset: number): void;
    capture(): CapturedArguments;
    clear(): void;
}
export declare class PositionalArgumentsImpl implements PositionalArguments {
    base: number;
    length: number;
    private stack;
    private _references;
    empty(stack: EvaluationStack, base: number): void;
    setup(stack: EvaluationStack, base: number, length: number): void;
    at(position: number): Reference;
    capture(): CapturedPositionalArguments;
    prepend(other: Reference[]): void;
    private get references();
}
export declare class NamedArgumentsImpl implements NamedArguments {
    base: number;
    length: number;
    private stack;
    private _references;
    private _names;
    private _atNames;
    empty(stack: EvaluationStack, base: number): void;
    setup(stack: EvaluationStack, base: number, length: number, names: readonly string[], atNames: boolean): void;
    get names(): readonly string[];
    get atNames(): readonly string[];
    has(name: string): boolean;
    get(name: string, atNames?: boolean): Reference;
    capture(): CapturedNamedArguments;
    merge(other: Record<string, Reference>): void;
    private get references();
    private toSyntheticName;
    private toAtName;
}
export declare class BlockArgumentsImpl implements BlockArguments {
    private stack;
    private internalValues;
    private _symbolNames;
    internalTag: Option<Tag>;
    names: readonly string[];
    length: number;
    base: number;
    empty(stack: EvaluationStack, base: number): void;
    setup(stack: EvaluationStack, base: number, length: number, names: readonly string[]): void;
    get values(): readonly BlockValue[];
    has(name: string): boolean;
    get(name: string): Option<ScopeBlock>;
    capture(): CapturedBlockArguments;
    get symbolNames(): readonly string[];
}
export declare function createCapturedArgs(named: Dict<Reference>, positional: Reference[]): CapturedArguments;
export declare function reifyNamed(named: CapturedNamedArguments): Dict<unknown>;
export declare function reifyPositional(positional: CapturedPositionalArguments): unknown[];
export declare function reifyArgs(args: CapturedArguments): {
    named: Dict<unknown>;
    positional: unknown[];
};
export declare const EMPTY_NAMED: CapturedNamedArguments;
export declare const EMPTY_POSITIONAL: CapturedPositionalArguments;
export declare const EMPTY_ARGS: CapturedArguments;
//# sourceMappingURL=arguments.d.ts.map