import { Bounds, DynamicScope, ElementBuilder, Environment, ExceptionHandler, GlimmerTreeChanges, LiveBlock, Option, RuntimeContext, Scope, UpdatableBlock, UpdatingVM, UpdatingOpcode } from '@glimmer/interfaces';
import { OpaqueIterationItem, OpaqueIterator, Reference } from '@glimmer/reference';
import { InternalVM, VmInitCallback } from './append';
import { LiveBlockList } from './element-builder';
export default class UpdatingVMImpl implements UpdatingVM {
    env: Environment;
    dom: GlimmerTreeChanges;
    alwaysRevalidate: boolean;
    private frameStack;
    constructor(env: Environment, { alwaysRevalidate }: {
        alwaysRevalidate?: boolean | undefined;
    });
    execute(opcodes: UpdatingOpcode[], handler: ExceptionHandler): void;
    private _execute;
    private get frame();
    goto(index: number): void;
    try(ops: UpdatingOpcode[], handler: Option<ExceptionHandler>): void;
    throw(): void;
}
export interface VMState {
    readonly pc: number;
    readonly scope: Scope;
    readonly dynamicScope: DynamicScope;
    readonly stack: unknown[];
}
export interface ResumableVMState {
    resume(runtime: RuntimeContext, builder: ElementBuilder): InternalVM;
}
export declare class ResumableVMStateImpl implements ResumableVMState {
    readonly state: VMState;
    private resumeCallback;
    constructor(state: VMState, resumeCallback: VmInitCallback);
    resume(runtime: RuntimeContext, builder: ElementBuilder): InternalVM;
}
export declare abstract class BlockOpcode implements UpdatingOpcode, Bounds {
    protected state: ResumableVMState;
    protected runtime: RuntimeContext;
    children: UpdatingOpcode[];
    protected readonly bounds: LiveBlock;
    constructor(state: ResumableVMState, runtime: RuntimeContext, bounds: LiveBlock, children: UpdatingOpcode[]);
    parentElement(): import("@simple-dom/interface").SimpleElement;
    firstNode(): import("@simple-dom/interface").SimpleNode;
    lastNode(): import("@simple-dom/interface").SimpleNode;
    evaluate(vm: UpdatingVMImpl): void;
}
export declare class TryOpcode extends BlockOpcode implements ExceptionHandler {
    type: string;
    protected bounds: UpdatableBlock;
    evaluate(vm: UpdatingVMImpl): void;
    handleException(): void;
}
export declare class ListItemOpcode extends TryOpcode {
    key: unknown;
    memo: Reference;
    value: Reference;
    retained: boolean;
    index: number;
    constructor(state: ResumableVMState, runtime: RuntimeContext, bounds: UpdatableBlock, key: unknown, memo: Reference, value: Reference);
    updateReferences(item: OpaqueIterationItem): void;
    shouldRemove(): boolean;
    reset(): void;
}
export declare class ListBlockOpcode extends BlockOpcode {
    private iterableRef;
    type: string;
    children: ListItemOpcode[];
    private opcodeMap;
    private marker;
    private lastIterator;
    protected readonly bounds: LiveBlockList;
    constructor(state: ResumableVMState, runtime: RuntimeContext, bounds: LiveBlockList, children: ListItemOpcode[], iterableRef: Reference<OpaqueIterator>);
    initializeChild(opcode: ListItemOpcode): void;
    evaluate(vm: UpdatingVMImpl): void;
    private sync;
    private retainItem;
    private insertItem;
    private moveItem;
    private deleteItem;
}
//# sourceMappingURL=update.d.ts.map