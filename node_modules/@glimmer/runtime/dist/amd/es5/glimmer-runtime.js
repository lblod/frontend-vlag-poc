define('@glimmer/runtime', ['exports', '@glimmer/reference', '@glimmer/util', '@glimmer/vm', '@glimmer/destroyable', '@glimmer/global-context', '@glimmer/env', '@glimmer/validator', '@glimmer/manager', '@glimmer/program', '@glimmer/owner', '@glimmer/runtime'], function (exports, reference, util, vm, destroyable, globalContext, env, validator, manager, program, owner, runtime) { 'use strict';

  var DynamicScopeImpl = /*#__PURE__*/function () {
    function DynamicScopeImpl(bucket) {
      if (bucket) {
        this.bucket = util.assign({}, bucket);
      } else {
        this.bucket = {};
      }
    }

    var _proto = DynamicScopeImpl.prototype;

    _proto.get = function get(key) {
      return this.bucket[key];
    };

    _proto.set = function set(key, reference) {
      return this.bucket[key] = reference;
    };

    _proto.child = function child() {
      return new DynamicScopeImpl(this.bucket);
    };

    return DynamicScopeImpl;
  }();
  var PartialScopeImpl = /*#__PURE__*/function () {
    function PartialScopeImpl( // the 0th slot is `self`
    slots, owner, callerScope, // named arguments and blocks passed to a layout that uses eval
    evalScope, // locals in scope when the partial was invoked
    partialMap) {
      this.slots = slots;
      this.owner = owner;
      this.callerScope = callerScope;
      this.evalScope = evalScope;
      this.partialMap = partialMap;
    }

    PartialScopeImpl.root = function root(self, size, owner) {
      if (size === void 0) {
        size = 0;
      }

      var refs = new Array(size + 1);

      for (var i = 0; i <= size; i++) {
        refs[i] = reference.UNDEFINED_REFERENCE;
      }

      return new PartialScopeImpl(refs, owner, null, null, null).init({
        self: self
      });
    };

    PartialScopeImpl.sized = function sized(size, owner) {
      if (size === void 0) {
        size = 0;
      }

      var refs = new Array(size + 1);

      for (var i = 0; i <= size; i++) {
        refs[i] = reference.UNDEFINED_REFERENCE;
      }

      return new PartialScopeImpl(refs, owner, null, null, null);
    };

    var _proto2 = PartialScopeImpl.prototype;

    _proto2.init = function init(_ref) {
      var self = _ref.self;
      this.slots[0] = self;
      return this;
    };

    _proto2.getSelf = function getSelf() {
      return this.get(0);
    };

    _proto2.getSymbol = function getSymbol(symbol) {
      return this.get(symbol);
    };

    _proto2.getBlock = function getBlock(symbol) {
      var block = this.get(symbol);
      return block === reference.UNDEFINED_REFERENCE ? null : block;
    };

    _proto2.getEvalScope = function getEvalScope() {
      return this.evalScope;
    };

    _proto2.getPartialMap = function getPartialMap() {
      return this.partialMap;
    };

    _proto2.bind = function bind(symbol, value) {
      this.set(symbol, value);
    };

    _proto2.bindSelf = function bindSelf(self) {
      this.set(0, self);
    };

    _proto2.bindSymbol = function bindSymbol(symbol, value) {
      this.set(symbol, value);
    };

    _proto2.bindBlock = function bindBlock(symbol, value) {
      this.set(symbol, value);
    };

    _proto2.bindEvalScope = function bindEvalScope(map) {
      this.evalScope = map;
    };

    _proto2.bindPartialMap = function bindPartialMap(map) {
      this.partialMap = map;
    };

    _proto2.bindCallerScope = function bindCallerScope(scope) {
      this.callerScope = scope;
    };

    _proto2.getCallerScope = function getCallerScope() {
      return this.callerScope;
    };

    _proto2.child = function child() {
      return new PartialScopeImpl(this.slots.slice(), this.owner, this.callerScope, this.evalScope, this.partialMap);
    };

    _proto2.get = function get(index) {
      if (index >= this.slots.length) {
        throw new RangeError("BUG: cannot get $" + index + " from scope; length=" + this.slots.length);
      }

      return this.slots[index];
    };

    _proto2.set = function set(index, value) {
      if (index >= this.slots.length) {
        throw new RangeError("BUG: cannot get $" + index + " from scope; length=" + this.slots.length);
      }

      this.slots[index] = value;
    };

    return PartialScopeImpl;
  }();

  // the VM in other classes, but are not intended to be a part of
  // Glimmer's API.

  var INNER_VM = util.symbol('INNER_VM');
  var DESTROYABLE_STACK = util.symbol('DESTROYABLE_STACK');
  var STACKS = util.symbol('STACKS');
  var REGISTERS = util.symbol('REGISTERS');
  var HEAP = util.symbol('HEAP');
  var CONSTANTS = util.symbol('CONSTANTS');
  var ARGS = util.symbol('ARGS');
  var PC = util.symbol('PC');

  var CursorImpl = function CursorImpl(element, nextSibling) {
    this.element = element;
    this.nextSibling = nextSibling;
  };
  var ConcreteBounds = /*#__PURE__*/function () {
    function ConcreteBounds(parentNode, first, last) {
      this.parentNode = parentNode;
      this.first = first;
      this.last = last;
    }

    var _proto = ConcreteBounds.prototype;

    _proto.parentElement = function parentElement() {
      return this.parentNode;
    };

    _proto.firstNode = function firstNode() {
      return this.first;
    };

    _proto.lastNode = function lastNode() {
      return this.last;
    };

    return ConcreteBounds;
  }();
  var SingleNodeBounds = /*#__PURE__*/function () {
    function SingleNodeBounds(parentNode, node) {
      this.parentNode = parentNode;
      this.node = node;
    }

    var _proto2 = SingleNodeBounds.prototype;

    _proto2.parentElement = function parentElement() {
      return this.parentNode;
    };

    _proto2.firstNode = function firstNode() {
      return this.node;
    };

    _proto2.lastNode = function lastNode() {
      return this.node;
    };

    return SingleNodeBounds;
  }();
  function move(bounds, reference) {
    var parent = bounds.parentElement();
    var first = bounds.firstNode();
    var last = bounds.lastNode();
    var current = first;

    while (true) {
      var next = current.nextSibling;
      parent.insertBefore(current, reference);

      if (current === last) {
        return next;
      }

      current = next;
    }
  }
  function clear(bounds) {
    var parent = bounds.parentElement();
    var first = bounds.firstNode();
    var last = bounds.lastNode();
    var current = first;

    while (true) {
      var next = current.nextSibling;
      parent.removeChild(current);

      if (current === last) {
        return next;
      }

      current = next;
    }
  }

  function normalizeStringValue(value) {
    if (isEmpty(value)) {
      return '';
    }

    return String(value);
  }
  function shouldCoerce(value) {
    return isString(value) || isEmpty(value) || typeof value === 'boolean' || typeof value === 'number';
  }
  function isEmpty(value) {
    return value === null || value === undefined || typeof value.toString !== 'function';
  }
  function isSafeString(value) {
    return typeof value === 'object' && value !== null && typeof value.toHTML === 'function';
  }
  function isNode(value) {
    return typeof value === 'object' && value !== null && typeof value.nodeType === 'number';
  }
  function isFragment(value) {
    return isNode(value) && value.nodeType === 11;
  }
  function isString(value) {
    return typeof value === 'string';
  }

  /*
   * @method normalizeProperty
   * @param element {HTMLElement}
   * @param slotName {String}
   * @returns {Object} { name, type }
   */
  function normalizeProperty(element, slotName) {
    var type, normalized;

    if (slotName in element) {
      normalized = slotName;
      type = 'prop';
    } else {
      var lower = slotName.toLowerCase();

      if (lower in element) {
        type = 'prop';
        normalized = lower;
      } else {
        type = 'attr';
        normalized = slotName;
      }
    }

    if (type === 'prop' && (normalized.toLowerCase() === 'style' || preferAttr(element.tagName, normalized))) {
      type = 'attr';
    }

    return {
      normalized: normalized,
      type: type
    };
  }
  // * browser bug
  // * strange spec outlier

  var ATTR_OVERRIDES = {
    INPUT: {
      form: true,
      // Chrome 46.0.2464.0: 'autocorrect' in document.createElement('input') === false
      // Safari 8.0.7: 'autocorrect' in document.createElement('input') === false
      // Mobile Safari (iOS 8.4 simulator): 'autocorrect' in document.createElement('input') === true
      autocorrect: true,
      // Chrome 54.0.2840.98: 'list' in document.createElement('input') === true
      // Safari 9.1.3: 'list' in document.createElement('input') === false
      list: true
    },
    // element.form is actually a legitimate readOnly property, that is to be
    // mutated, but must be mutated by setAttribute...
    SELECT: {
      form: true
    },
    OPTION: {
      form: true
    },
    TEXTAREA: {
      form: true
    },
    LABEL: {
      form: true
    },
    FIELDSET: {
      form: true
    },
    LEGEND: {
      form: true
    },
    OBJECT: {
      form: true
    },
    OUTPUT: {
      form: true
    },
    BUTTON: {
      form: true
    }
  };

  function preferAttr(tagName, propName) {
    var tag = ATTR_OVERRIDES[tagName.toUpperCase()];
    return tag && tag[propName.toLowerCase()] || false;
  }

  var badProtocols = ['javascript:', 'vbscript:'];
  var badTags = ['A', 'BODY', 'LINK', 'IMG', 'IFRAME', 'BASE', 'FORM'];
  var badTagsForDataURI = ['EMBED'];
  var badAttributes = ['href', 'src', 'background', 'action'];
  var badAttributesForDataURI = ['src'];

  function has(array, item) {
    return array.indexOf(item) !== -1;
  }

  function checkURI(tagName, attribute) {
    return (tagName === null || has(badTags, tagName)) && has(badAttributes, attribute);
  }

  function checkDataURI(tagName, attribute) {
    if (tagName === null) return false;
    return has(badTagsForDataURI, tagName) && has(badAttributesForDataURI, attribute);
  }

  function requiresSanitization(tagName, attribute) {
    return checkURI(tagName, attribute) || checkDataURI(tagName, attribute);
  }
  var protocolForUrl;

  if (typeof URL === 'object' && URL !== null && // this is super annoying, TS thinks that URL **must** be a function so `URL.parse` check
  // thinks it is `never` without this `as unknown as any`
  typeof URL.parse === 'function') {
    // In Ember-land the `fastboot` package sets the `URL` global to `require('url')`
    // ultimately, this should be changed (so that we can either rely on the natural `URL` global
    // that exists) but for now we have to detect the specific `FastBoot` case first
    //
    // a future version of `fastboot` will detect if this legacy URL setup is required (by
    // inspecting Ember version) and if new enough, it will avoid shadowing the `URL` global
    // constructor with `require('url')`.
    var nodeURL = URL;

    protocolForUrl = function protocolForUrl(url) {
      var protocol = null;

      if (typeof url === 'string') {
        protocol = nodeURL.parse(url).protocol;
      }

      return protocol === null ? ':' : protocol;
    };
  } else if (typeof URL === 'function') {
    protocolForUrl = function protocolForUrl(_url) {
      try {
        var url = new URL(_url);
        return url.protocol;
      } catch (error) {
        // any non-fully qualified url string will trigger an error (because there is no
        // baseURI that we can provide; in that case we **know** that the protocol is
        // "safe" because it isn't specifically one of the `badProtocols` listed above
        // (and those protocols can never be the default baseURI)
        return ':';
      }
    };
  } else {
    // fallback for IE11 support
    var parsingNode = document.createElement('a');

    protocolForUrl = function protocolForUrl(url) {
      parsingNode.href = url;
      return parsingNode.protocol;
    };
  }

  function sanitizeAttributeValue(element, attribute, value) {
    var tagName = null;

    if (value === null || value === undefined) {
      return value;
    }

    if (isSafeString(value)) {
      return value.toHTML();
    }

    if (!element) {
      tagName = null;
    } else {
      tagName = element.tagName.toUpperCase();
    }

    var str = normalizeStringValue(value);

    if (checkURI(tagName, attribute)) {
      var protocol = protocolForUrl(str);

      if (has(badProtocols, protocol)) {
        return "unsafe:" + str;
      }
    }

    if (checkDataURI(tagName, attribute)) {
      return "unsafe:" + str;
    }

    return str;
  }

  function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  function dynamicAttribute(element, attr, namespace, isTrusting) {
    if (isTrusting === void 0) {
      isTrusting = false;
    }

    var tagName = element.tagName,
        namespaceURI = element.namespaceURI;
    var attribute = {
      element: element,
      name: attr,
      namespace: namespace
    };

    if (env.DEBUG && attr === 'style' && !isTrusting) {
      return new DebugStyleAttributeManager(attribute);
    }

    if (namespaceURI === "http://www.w3.org/2000/svg"
    /* SVG */
    ) {
        return buildDynamicAttribute(tagName, attr, attribute);
      }

    var _normalizeProperty = normalizeProperty(element, attr),
        type = _normalizeProperty.type,
        normalized = _normalizeProperty.normalized;

    if (type === 'attr') {
      return buildDynamicAttribute(tagName, normalized, attribute);
    } else {
      return buildDynamicProperty(tagName, normalized, attribute);
    }
  }

  function buildDynamicAttribute(tagName, name, attribute) {
    if (requiresSanitization(tagName, name)) {
      return new SafeDynamicAttribute(attribute);
    } else {
      return new SimpleDynamicAttribute(attribute);
    }
  }

  function buildDynamicProperty(tagName, name, attribute) {
    if (requiresSanitization(tagName, name)) {
      return new SafeDynamicProperty(name, attribute);
    }

    if (isUserInputValue(tagName, name)) {
      return new InputValueDynamicAttribute(name, attribute);
    }

    if (isOptionSelected(tagName, name)) {
      return new OptionSelectedDynamicAttribute(name, attribute);
    }

    return new DefaultDynamicProperty(name, attribute);
  }

  var DynamicAttribute = function DynamicAttribute(attribute) {
    this.attribute = attribute;
  };
  var SimpleDynamicAttribute = /*#__PURE__*/function (_DynamicAttribute) {
    _inheritsLoose(SimpleDynamicAttribute, _DynamicAttribute);

    function SimpleDynamicAttribute() {
      return _DynamicAttribute.apply(this, arguments) || this;
    }

    var _proto = SimpleDynamicAttribute.prototype;

    _proto.set = function set(dom, value, _env) {
      var normalizedValue = normalizeValue(value);

      if (normalizedValue !== null) {
        var _this$attribute = this.attribute,
            name = _this$attribute.name,
            namespace = _this$attribute.namespace;

        dom.__setAttribute(name, normalizedValue, namespace);
      }
    };

    _proto.update = function update(value, _env) {
      var normalizedValue = normalizeValue(value);
      var _this$attribute2 = this.attribute,
          element = _this$attribute2.element,
          name = _this$attribute2.name;

      if (normalizedValue === null) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, normalizedValue);
      }
    };

    return SimpleDynamicAttribute;
  }(DynamicAttribute);
  var DefaultDynamicProperty = /*#__PURE__*/function (_DynamicAttribute2) {
    _inheritsLoose(DefaultDynamicProperty, _DynamicAttribute2);

    function DefaultDynamicProperty(normalizedName, attribute) {
      var _this;

      _this = _DynamicAttribute2.call(this, attribute) || this;
      _this.normalizedName = normalizedName;
      return _this;
    }

    var _proto2 = DefaultDynamicProperty.prototype;

    _proto2.set = function set(dom, value, _env) {
      if (value !== null && value !== undefined) {
        this.value = value;

        dom.__setProperty(this.normalizedName, value);
      }
    };

    _proto2.update = function update(value, _env) {
      var element = this.attribute.element;

      if (this.value !== value) {
        element[this.normalizedName] = this.value = value;

        if (value === null || value === undefined) {
          this.removeAttribute();
        }
      }
    };

    _proto2.removeAttribute = function removeAttribute() {
      // TODO this sucks but to preserve properties first and to meet current
      // semantics we must do this.
      var _this$attribute3 = this.attribute,
          element = _this$attribute3.element,
          namespace = _this$attribute3.namespace;

      if (namespace) {
        element.removeAttributeNS(namespace, this.normalizedName);
      } else {
        element.removeAttribute(this.normalizedName);
      }
    };

    return DefaultDynamicProperty;
  }(DynamicAttribute);
  var SafeDynamicProperty = /*#__PURE__*/function (_DefaultDynamicProper) {
    _inheritsLoose(SafeDynamicProperty, _DefaultDynamicProper);

    function SafeDynamicProperty() {
      return _DefaultDynamicProper.apply(this, arguments) || this;
    }

    var _proto3 = SafeDynamicProperty.prototype;

    _proto3.set = function set(dom, value, env) {
      var _this$attribute4 = this.attribute,
          element = _this$attribute4.element,
          name = _this$attribute4.name;
      var sanitized = sanitizeAttributeValue(element, name, value);

      _DefaultDynamicProper.prototype.set.call(this, dom, sanitized, env);
    };

    _proto3.update = function update(value, env) {
      var _this$attribute5 = this.attribute,
          element = _this$attribute5.element,
          name = _this$attribute5.name;
      var sanitized = sanitizeAttributeValue(element, name, value);

      _DefaultDynamicProper.prototype.update.call(this, sanitized, env);
    };

    return SafeDynamicProperty;
  }(DefaultDynamicProperty);
  var SafeDynamicAttribute = /*#__PURE__*/function (_SimpleDynamicAttribu) {
    _inheritsLoose(SafeDynamicAttribute, _SimpleDynamicAttribu);

    function SafeDynamicAttribute() {
      return _SimpleDynamicAttribu.apply(this, arguments) || this;
    }

    var _proto4 = SafeDynamicAttribute.prototype;

    _proto4.set = function set(dom, value, env) {
      var _this$attribute6 = this.attribute,
          element = _this$attribute6.element,
          name = _this$attribute6.name;
      var sanitized = sanitizeAttributeValue(element, name, value);

      _SimpleDynamicAttribu.prototype.set.call(this, dom, sanitized, env);
    };

    _proto4.update = function update(value, env) {
      var _this$attribute7 = this.attribute,
          element = _this$attribute7.element,
          name = _this$attribute7.name;
      var sanitized = sanitizeAttributeValue(element, name, value);

      _SimpleDynamicAttribu.prototype.update.call(this, sanitized, env);
    };

    return SafeDynamicAttribute;
  }(SimpleDynamicAttribute);
  var InputValueDynamicAttribute = /*#__PURE__*/function (_DefaultDynamicProper2) {
    _inheritsLoose(InputValueDynamicAttribute, _DefaultDynamicProper2);

    function InputValueDynamicAttribute() {
      return _DefaultDynamicProper2.apply(this, arguments) || this;
    }

    var _proto5 = InputValueDynamicAttribute.prototype;

    _proto5.set = function set(dom, value) {
      dom.__setProperty('value', normalizeStringValue(value));
    };

    _proto5.update = function update(value) {
      var input = this.attribute.element;
      var currentValue = input.value;
      var normalizedValue = normalizeStringValue(value);

      if (currentValue !== normalizedValue) {
        input.value = normalizedValue;
      }
    };

    return InputValueDynamicAttribute;
  }(DefaultDynamicProperty);
  var OptionSelectedDynamicAttribute = /*#__PURE__*/function (_DefaultDynamicProper3) {
    _inheritsLoose(OptionSelectedDynamicAttribute, _DefaultDynamicProper3);

    function OptionSelectedDynamicAttribute() {
      return _DefaultDynamicProper3.apply(this, arguments) || this;
    }

    var _proto6 = OptionSelectedDynamicAttribute.prototype;

    _proto6.set = function set(dom, value) {
      if (value !== null && value !== undefined && value !== false) {
        dom.__setProperty('selected', true);
      }
    };

    _proto6.update = function update(value) {
      var option = this.attribute.element;

      if (value) {
        option.selected = true;
      } else {
        option.selected = false;
      }
    };

    return OptionSelectedDynamicAttribute;
  }(DefaultDynamicProperty);

  function isOptionSelected(tagName, attribute) {
    return tagName === 'OPTION' && attribute === 'selected';
  }

  function isUserInputValue(tagName, attribute) {
    return (tagName === 'INPUT' || tagName === 'TEXTAREA') && attribute === 'value';
  }

  function normalizeValue(value) {
    if (value === false || value === undefined || value === null || typeof value.toString === 'undefined') {
      return null;
    }

    if (value === true) {
      return '';
    } // onclick function etc in SSR


    if (typeof value === 'function') {
      return null;
    }

    return String(value);
  }

  var DebugStyleAttributeManager;

  if (env.DEBUG) {
    DebugStyleAttributeManager = /*#__PURE__*/function (_SimpleDynamicAttribu2) {
      _inheritsLoose(DebugStyleAttributeManager, _SimpleDynamicAttribu2);

      function DebugStyleAttributeManager() {
        return _SimpleDynamicAttribu2.apply(this, arguments) || this;
      }

      var _proto7 = DebugStyleAttributeManager.prototype;

      _proto7.set = function set(dom, value, env) {
        globalContext.warnIfStyleNotTrusted(value);

        _SimpleDynamicAttribu2.prototype.set.call(this, dom, value, env);
      };

      _proto7.update = function update(value, env) {
        globalContext.warnIfStyleNotTrusted(value);

        _SimpleDynamicAttribu2.prototype.update.call(this, value, env);
      };

      return DebugStyleAttributeManager;
    }(SimpleDynamicAttribute);
  }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var _a;

  var First = /*#__PURE__*/function () {
    function First(node) {
      this.node = node;
    }

    var _proto = First.prototype;

    _proto.firstNode = function firstNode() {
      return this.node;
    };

    return First;
  }();

  var Last = /*#__PURE__*/function () {
    function Last(node) {
      this.node = node;
    }

    var _proto2 = Last.prototype;

    _proto2.lastNode = function lastNode() {
      return this.node;
    };

    return Last;
  }();
  var CURSOR_STACK = util.symbol('CURSOR_STACK');
  var NewElementBuilder = /*#__PURE__*/function () {
    function NewElementBuilder(env, parentNode, nextSibling) {
      this.constructing = null;
      this.operations = null;
      this[_a] = new util.Stack();
      this.modifierStack = new util.Stack();
      this.blockStack = new util.Stack();
      this.pushElement(parentNode, nextSibling);
      this.env = env;
      this.dom = env.getAppendOperations();
      this.updateOperations = env.getDOM();
    }

    NewElementBuilder.forInitialRender = function forInitialRender(env, cursor) {
      return new this(env, cursor.element, cursor.nextSibling).initialize();
    };

    NewElementBuilder.resume = function resume(env, block) {
      var parentNode = block.parentElement();
      var nextSibling = block.reset(env);
      var stack = new this(env, parentNode, nextSibling).initialize();
      stack.pushLiveBlock(block);
      return stack;
    };

    var _proto4 = NewElementBuilder.prototype;

    _proto4.initialize = function initialize() {
      this.pushSimpleBlock();
      return this;
    };

    _proto4.debugBlocks = function debugBlocks() {
      return this.blockStack.toArray();
    };

    _proto4.block = function block() {
      return this.blockStack.current;
    };

    _proto4.popElement = function popElement() {
      this[CURSOR_STACK].pop();
      this[CURSOR_STACK].current;
    };

    _proto4.pushSimpleBlock = function pushSimpleBlock() {
      return this.pushLiveBlock(new SimpleLiveBlock(this.element));
    };

    _proto4.pushUpdatableBlock = function pushUpdatableBlock() {
      return this.pushLiveBlock(new UpdatableBlockImpl(this.element));
    };

    _proto4.pushBlockList = function pushBlockList(list) {
      return this.pushLiveBlock(new LiveBlockList(this.element, list));
    };

    _proto4.pushLiveBlock = function pushLiveBlock(block, isRemote) {
      if (isRemote === void 0) {
        isRemote = false;
      }

      var current = this.blockStack.current;

      if (current !== null) {
        if (!isRemote) {
          current.didAppendBounds(block);
        }
      }

      this.__openBlock();

      this.blockStack.push(block);
      return block;
    };

    _proto4.popBlock = function popBlock() {
      this.block().finalize(this);

      this.__closeBlock();

      return this.blockStack.pop();
    };

    _proto4.__openBlock = function __openBlock() {};

    _proto4.__closeBlock = function __closeBlock() {} // todo return seems unused
    ;

    _proto4.openElement = function openElement(tag) {
      var element = this.__openElement(tag);

      this.constructing = element;
      return element;
    };

    _proto4.__openElement = function __openElement(tag) {
      return this.dom.createElement(tag, this.element);
    };

    _proto4.flushElement = function flushElement(modifiers) {
      var parent = this.element;
      var element = this.constructing;

      this.__flushElement(parent, element);

      this.constructing = null;
      this.operations = null;
      this.pushModifiers(modifiers);
      this.pushElement(element, null);
      this.didOpenElement(element);
    };

    _proto4.__flushElement = function __flushElement(parent, constructing) {
      this.dom.insertBefore(parent, constructing, this.nextSibling);
    };

    _proto4.closeElement = function closeElement() {
      this.willCloseElement();
      this.popElement();
      return this.popModifiers();
    };

    _proto4.pushRemoteElement = function pushRemoteElement(element, guid, insertBefore) {
      return this.__pushRemoteElement(element, guid, insertBefore);
    };

    _proto4.__pushRemoteElement = function __pushRemoteElement(element, _guid, insertBefore) {
      this.pushElement(element, insertBefore);

      if (insertBefore === undefined) {
        while (element.lastChild) {
          element.removeChild(element.lastChild);
        }
      }

      var block = new RemoteLiveBlock(element);
      return this.pushLiveBlock(block, true);
    };

    _proto4.popRemoteElement = function popRemoteElement() {
      this.popBlock();
      this.popElement();
    };

    _proto4.pushElement = function pushElement(element, nextSibling) {
      if (nextSibling === void 0) {
        nextSibling = null;
      }

      this[CURSOR_STACK].push(new CursorImpl(element, nextSibling));
    };

    _proto4.pushModifiers = function pushModifiers(modifiers) {
      this.modifierStack.push(modifiers);
    };

    _proto4.popModifiers = function popModifiers() {
      return this.modifierStack.pop();
    };

    _proto4.didAppendBounds = function didAppendBounds(bounds) {
      this.block().didAppendBounds(bounds);
      return bounds;
    };

    _proto4.didAppendNode = function didAppendNode(node) {
      this.block().didAppendNode(node);
      return node;
    };

    _proto4.didOpenElement = function didOpenElement(element) {
      this.block().openElement(element);
      return element;
    };

    _proto4.willCloseElement = function willCloseElement() {
      this.block().closeElement();
    };

    _proto4.appendText = function appendText(string) {
      return this.didAppendNode(this.__appendText(string));
    };

    _proto4.__appendText = function __appendText(text) {
      var dom = this.dom,
          element = this.element,
          nextSibling = this.nextSibling;
      var node = dom.createTextNode(text);
      dom.insertBefore(element, node, nextSibling);
      return node;
    };

    _proto4.__appendNode = function __appendNode(node) {
      this.dom.insertBefore(this.element, node, this.nextSibling);
      return node;
    };

    _proto4.__appendFragment = function __appendFragment(fragment) {
      var first = fragment.firstChild;

      if (first) {
        var ret = new ConcreteBounds(this.element, first, fragment.lastChild);
        this.dom.insertBefore(this.element, fragment, this.nextSibling);
        return ret;
      } else {
        return new SingleNodeBounds(this.element, this.__appendComment(''));
      }
    };

    _proto4.__appendHTML = function __appendHTML(html) {
      return this.dom.insertHTMLBefore(this.element, this.nextSibling, html);
    };

    _proto4.appendDynamicHTML = function appendDynamicHTML(value) {
      var bounds = this.trustedContent(value);
      this.didAppendBounds(bounds);
    };

    _proto4.appendDynamicText = function appendDynamicText(value) {
      var node = this.untrustedContent(value);
      this.didAppendNode(node);
      return node;
    };

    _proto4.appendDynamicFragment = function appendDynamicFragment(value) {
      var bounds = this.__appendFragment(value);

      this.didAppendBounds(bounds);
    };

    _proto4.appendDynamicNode = function appendDynamicNode(value) {
      var node = this.__appendNode(value);

      var bounds = new SingleNodeBounds(this.element, node);
      this.didAppendBounds(bounds);
    };

    _proto4.trustedContent = function trustedContent(value) {
      return this.__appendHTML(value);
    };

    _proto4.untrustedContent = function untrustedContent(value) {
      return this.__appendText(value);
    };

    _proto4.appendComment = function appendComment(string) {
      return this.didAppendNode(this.__appendComment(string));
    };

    _proto4.__appendComment = function __appendComment(string) {
      var dom = this.dom,
          element = this.element,
          nextSibling = this.nextSibling;
      var node = dom.createComment(string);
      dom.insertBefore(element, node, nextSibling);
      return node;
    };

    _proto4.__setAttribute = function __setAttribute(name, value, namespace) {
      this.dom.setAttribute(this.constructing, name, value, namespace);
    };

    _proto4.__setProperty = function __setProperty(name, value) {
      this.constructing[name] = value;
    };

    _proto4.setStaticAttribute = function setStaticAttribute(name, value, namespace) {
      this.__setAttribute(name, value, namespace);
    };

    _proto4.setDynamicAttribute = function setDynamicAttribute(name, value, trusting, namespace) {
      var element = this.constructing;
      var attribute = dynamicAttribute(element, name, namespace, trusting);
      attribute.set(this, value, this.env);
      return attribute;
    };

    _createClass(NewElementBuilder, [{
      key: "element",
      get: function get() {
        return this[CURSOR_STACK].current.element;
      }
    }, {
      key: "nextSibling",
      get: function get() {
        return this[CURSOR_STACK].current.nextSibling;
      }
    }, {
      key: "hasBlocks",
      get: function get() {
        return this.blockStack.size > 0;
      }
    }]);

    return NewElementBuilder;
  }();
  _a = CURSOR_STACK;
  var SimpleLiveBlock = /*#__PURE__*/function () {
    function SimpleLiveBlock(parent) {
      this.parent = parent;
      this.first = null;
      this.last = null;
      this.nesting = 0;
    }

    var _proto5 = SimpleLiveBlock.prototype;

    _proto5.parentElement = function parentElement() {
      return this.parent;
    };

    _proto5.firstNode = function firstNode() {
      var first = this.first;
      return first.firstNode();
    };

    _proto5.lastNode = function lastNode() {
      var last = this.last;
      return last.lastNode();
    };

    _proto5.openElement = function openElement(element) {
      this.didAppendNode(element);
      this.nesting++;
    };

    _proto5.closeElement = function closeElement() {
      this.nesting--;
    };

    _proto5.didAppendNode = function didAppendNode(node) {
      if (this.nesting !== 0) return;

      if (!this.first) {
        this.first = new First(node);
      }

      this.last = new Last(node);
    };

    _proto5.didAppendBounds = function didAppendBounds(bounds) {
      if (this.nesting !== 0) return;

      if (!this.first) {
        this.first = bounds;
      }

      this.last = bounds;
    };

    _proto5.finalize = function finalize(stack) {
      if (this.first === null) {
        stack.appendComment('');
      }
    };

    return SimpleLiveBlock;
  }();
  var RemoteLiveBlock = /*#__PURE__*/function (_SimpleLiveBlock) {
    _inheritsLoose$1(RemoteLiveBlock, _SimpleLiveBlock);

    function RemoteLiveBlock(parent) {
      var _this;

      _this = _SimpleLiveBlock.call(this, parent) || this;
      destroyable.registerDestructor(_assertThisInitialized(_this), function () {
        // In general, you only need to clear the root of a hierarchy, and should never
        // need to clear any child nodes. This is an important constraint that gives us
        // a strong guarantee that clearing a subtree is a single DOM operation.
        //
        // Because remote blocks are not normally physically nested inside of the tree
        // that they are logically nested inside, we manually clear remote blocks when
        // a logical parent is cleared.
        //
        // HOWEVER, it is currently possible for a remote block to be physically nested
        // inside of the block it is logically contained inside of. This happens when
        // the remote block is appended to the end of the application's entire element.
        //
        // The problem with that scenario is that Glimmer believes that it owns more of
        // the DOM than it actually does. The code is attempting to write past the end
        // of the Glimmer-managed root, but Glimmer isn't aware of that.
        //
        // The correct solution to that problem is for Glimmer to be aware of the end
        // of the bounds that it owns, and once we make that change, this check could
        // be removed.
        //
        // For now, a more targeted fix is to check whether the node was already removed
        // and avoid clearing the node if it was. In most cases this shouldn't happen,
        // so this might hide bugs where the code clears nested nodes unnecessarily,
        // so we should eventually try to do the correct fix.
        if (_this.parentElement() === _this.firstNode().parentNode) {
          clear(_assertThisInitialized(_this));
        }
      });
      return _this;
    }

    return RemoteLiveBlock;
  }(SimpleLiveBlock);
  var UpdatableBlockImpl = /*#__PURE__*/function (_SimpleLiveBlock2) {
    _inheritsLoose$1(UpdatableBlockImpl, _SimpleLiveBlock2);

    function UpdatableBlockImpl() {
      return _SimpleLiveBlock2.apply(this, arguments) || this;
    }

    var _proto6 = UpdatableBlockImpl.prototype;

    _proto6.reset = function reset() {
      destroyable.destroy(this);
      var nextSibling = clear(this);
      this.first = null;
      this.last = null;
      this.nesting = 0;
      return nextSibling;
    };

    return UpdatableBlockImpl;
  }(SimpleLiveBlock); // FIXME: All the noops in here indicate a modelling problem

  var LiveBlockList = /*#__PURE__*/function () {
    function LiveBlockList(parent, boundList) {
      this.parent = parent;
      this.boundList = boundList;
      this.parent = parent;
      this.boundList = boundList;
    }

    var _proto7 = LiveBlockList.prototype;

    _proto7.parentElement = function parentElement() {
      return this.parent;
    };

    _proto7.firstNode = function firstNode() {
      var head = this.boundList[0];
      return head.firstNode();
    };

    _proto7.lastNode = function lastNode() {
      var boundList = this.boundList;
      var tail = boundList[boundList.length - 1];
      return tail.lastNode();
    };

    _proto7.openElement = function openElement(_element) {
    };

    _proto7.closeElement = function closeElement() {
    };

    _proto7.didAppendNode = function didAppendNode(_node) {
    };

    _proto7.didAppendBounds = function didAppendBounds(_bounds) {};

    _proto7.finalize = function finalize(_stack) {
    };

    return LiveBlockList;
  }();
  function clientBuilder(env, cursor) {
    return NewElementBuilder.forInitialRender(env, cursor);
  }

  var AppendOpcodes = /*#__PURE__*/function () {
    function AppendOpcodes() {
      this.evaluateOpcode = util.fillNulls(104
      /* Size */
      ).slice();
    }

    var _proto = AppendOpcodes.prototype;

    _proto.add = function add(name, evaluate, kind) {
      if (kind === void 0) {
        kind = 'syscall';
      }

      this.evaluateOpcode[name] = {
        syscall: kind !== 'machine',
        evaluate: evaluate
      };
    };

    _proto.debugBefore = function debugBefore(vm$1, opcode) {
      var params = undefined;
      var opName = undefined;

      var sp;

      return {
        sp: sp,
        pc: vm$1.fetchValue(vm.$pc),
        name: opName,
        params: params,
        type: opcode.type,
        isMachine: opcode.isMachine,
        size: opcode.size,
        state: undefined
      };
    };

    _proto.debugAfter = function debugAfter(vm$1, pre) {
      var sp = pre.sp,
          type = pre.type,
          isMachine = pre.isMachine,
          pc = pre.pc;
    };

    _proto.evaluate = function evaluate(vm, opcode, type) {
      var operation = this.evaluateOpcode[type];

      if (operation.syscall) {
        operation.evaluate(vm, opcode);
      } else {
        operation.evaluate(vm[INNER_VM], opcode);
      }
    };

    return AppendOpcodes;
  }();
  var APPEND_OPCODES = new AppendOpcodes();

  function createConcatRef(partsRefs) {
    return reference.createComputeRef(function () {
      var parts = new Array();

      for (var i = 0; i < partsRefs.length; i++) {
        var value = reference.valueForRef(partsRefs[i]);

        if (value !== null && value !== undefined) {
          parts[i] = castToString(value);
        }
      }

      if (parts.length > 0) {
        return parts.join('');
      }

      return null;
    });
  }

  function castToString(value) {
    if (typeof value.toString !== 'function') {
      return '';
    }

    return String(value);
  }

  var TYPE = util.symbol('TYPE');
  var INNER = util.symbol('INNER');
  var OWNER = util.symbol('OWNER');
  var ARGS$1 = util.symbol('ARGS');
  var RESOLVED = util.symbol('RESOLVED');
  var CURRIED_VALUES = new util._WeakSet();
  function isCurriedValue(value) {
    return CURRIED_VALUES.has(value);
  }
  function isCurriedType(value, type) {
    return isCurriedValue(value) && value[TYPE] === type;
  }
  var CurriedValue =
  /** @internal */
  function CurriedValue(type, inner, owner, args, resolved) {
    if (resolved === void 0) {
      resolved = false;
    }

    CURRIED_VALUES.add(this);
    this[TYPE] = type;
    this[INNER] = inner;
    this[OWNER] = owner;
    this[ARGS$1] = args;
    this[RESOLVED] = resolved;
  };
  function resolveCurriedValue(curriedValue) {
    var currentWrapper = curriedValue;
    var positional;
    var named;
    var definition, owner, resolved;

    while (true) {
      var _currentWrapper = currentWrapper,
          curriedArgs = _currentWrapper[ARGS$1],
          inner = _currentWrapper[INNER];

      if (curriedArgs !== null) {
        var curriedNamed = curriedArgs.named,
            curriedPositional = curriedArgs.positional;

        if (curriedPositional.length > 0) {
          positional = positional === undefined ? curriedPositional : curriedPositional.concat(positional);
        }

        if (named === undefined) {
          named = [];
        }

        named.unshift(curriedNamed);
      }

      if (!isCurriedValue(inner)) {
        // Save off the owner that this helper was curried with. Later on,
        // we'll fetch the value of this register and set it as the owner on the
        // new root scope.
        definition = inner;
        owner = currentWrapper[OWNER];
        resolved = currentWrapper[RESOLVED];
        break;
      }

      currentWrapper = inner;
    }

    return {
      definition: definition,
      owner: owner,
      resolved: resolved,
      positional: positional,
      named: named
    };
  }
  function curry(type, spec, owner, args, resolved) {
    if (resolved === void 0) {
      resolved = false;
    }

    return new CurriedValue(type, spec, owner, args, resolved);
  }

  function createCurryRef(type, inner, owner, args, resolver, isStrict) {
    var lastValue, curriedDefinition;
    return reference.createComputeRef(function () {
      var value = reference.valueForRef(inner);

      if (value === lastValue) {
        return curriedDefinition;
      }

      if (isCurriedType(value, type)) {
        curriedDefinition = args ? curry(type, value, owner, args) : args;
      } else if (type === 0
      /* Component */
      && typeof value === 'string' && value) {
        // Only components should enter this path, as helpers and modifiers do not
        // support string based resolution
        if (env.DEBUG) {
          if (isStrict) {
            throw new Error("Attempted to resolve a dynamic component with a string definition, `" + value + "` in a strict mode template. In strict mode, using strings to resolve component definitions is prohibited. You can instead import the component definition and use it directly.");
          }

          var resolvedDefinition = resolver.lookupComponent(value, owner);

          if (!resolvedDefinition) {
            throw new Error("Attempted to resolve `" + value + "`, which was expected to be a component, but nothing was found.");
          }
        }

        curriedDefinition = curry(type, value, owner, args);
      } else if (util.isObject(value)) {
        curriedDefinition = curry(type, value, owner, args);
      } else {
        curriedDefinition = null;
      }

      lastValue = value;
      return curriedDefinition;
    });
  }

  function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }
  /*
    The calling convention is:

    * 0-N block arguments at the bottom
    * 0-N positional arguments next (left-to-right)
    * 0-N named arguments next
  */

  var VMArgumentsImpl = /*#__PURE__*/function () {
    function VMArgumentsImpl() {
      this.stack = null;
      this.positional = new PositionalArgumentsImpl();
      this.named = new NamedArgumentsImpl();
      this.blocks = new BlockArgumentsImpl();
    }

    var _proto = VMArgumentsImpl.prototype;

    _proto.empty = function empty(stack) {
      var base = stack[REGISTERS][vm.$sp] + 1;
      this.named.empty(stack, base);
      this.positional.empty(stack, base);
      this.blocks.empty(stack, base);
      return this;
    };

    _proto.setup = function setup(stack, names, blockNames, positionalCount, atNames) {
      this.stack = stack;
      /*
             | ... | blocks      | positional  | named |
             | ... | b0    b1    | p0 p1 p2 p3 | n0 n1 |
       index | ... | 4/5/6 7/8/9 | 10 11 12 13 | 14 15 |
                     ^             ^             ^  ^
                   bbase         pbase       nbase  sp
      */

      var named = this.named;
      var namedCount = names.length;
      var namedBase = stack[REGISTERS][vm.$sp] - namedCount + 1;
      named.setup(stack, namedBase, namedCount, names, atNames);
      var positional = this.positional;
      var positionalBase = namedBase - positionalCount;
      positional.setup(stack, positionalBase, positionalCount);
      var blocks = this.blocks;
      var blocksCount = blockNames.length;
      var blocksBase = positionalBase - blocksCount * 3;
      blocks.setup(stack, blocksBase, blocksCount, blockNames);
    };

    _proto.at = function at(pos) {
      return this.positional.at(pos);
    };

    _proto.realloc = function realloc(offset) {
      var stack = this.stack;

      if (offset > 0 && stack !== null) {
        var positional = this.positional,
            named = this.named;
        var newBase = positional.base + offset;
        var length = positional.length + named.length;

        for (var i = length - 1; i >= 0; i--) {
          stack.copy(i + positional.base, i + newBase);
        }

        positional.base += offset;
        named.base += offset;
        stack[REGISTERS][vm.$sp] += offset;
      }
    };

    _proto.capture = function capture() {
      var positional = this.positional.length === 0 ? EMPTY_POSITIONAL : this.positional.capture();
      var named = this.named.length === 0 ? EMPTY_NAMED : this.named.capture();
      return {
        named: named,
        positional: positional
      };
    };

    _proto.clear = function clear() {
      var stack = this.stack,
          length = this.length;
      if (length > 0 && stack !== null) stack.pop(length);
    };

    _createClass$1(VMArgumentsImpl, [{
      key: "base",
      get: function get() {
        return this.blocks.base;
      }
    }, {
      key: "length",
      get: function get() {
        return this.positional.length + this.named.length + this.blocks.length * 3;
      }
    }]);

    return VMArgumentsImpl;
  }();
  var EMPTY_REFERENCES = util.emptyArray();
  var PositionalArgumentsImpl = /*#__PURE__*/function () {
    function PositionalArgumentsImpl() {
      this.base = 0;
      this.length = 0;
      this.stack = null;
      this._references = null;
    }

    var _proto2 = PositionalArgumentsImpl.prototype;

    _proto2.empty = function empty(stack, base) {
      this.stack = stack;
      this.base = base;
      this.length = 0;
      this._references = EMPTY_REFERENCES;
    };

    _proto2.setup = function setup(stack, base, length) {
      this.stack = stack;
      this.base = base;
      this.length = length;

      if (length === 0) {
        this._references = EMPTY_REFERENCES;
      } else {
        this._references = null;
      }
    };

    _proto2.at = function at(position) {
      var base = this.base,
          length = this.length,
          stack = this.stack;

      if (position < 0 || position >= length) {
        return reference.UNDEFINED_REFERENCE;
      }

      return stack.get(position, base);
    };

    _proto2.capture = function capture() {
      return this.references;
    };

    _proto2.prepend = function prepend(other) {
      var additions = other.length;

      if (additions > 0) {
        var base = this.base,
            length = this.length,
            stack = this.stack;
        this.base = base = base - additions;
        this.length = length + additions;

        for (var i = 0; i < additions; i++) {
          stack.set(other[i], i, base);
        }

        this._references = null;
      }
    };

    _createClass$1(PositionalArgumentsImpl, [{
      key: "references",
      get: function get() {
        var references = this._references;

        if (!references) {
          var stack = this.stack,
              base = this.base,
              length = this.length;
          references = this._references = stack.slice(base, base + length);
        }

        return references;
      }
    }]);

    return PositionalArgumentsImpl;
  }();
  var NamedArgumentsImpl = /*#__PURE__*/function () {
    function NamedArgumentsImpl() {
      this.base = 0;
      this.length = 0;
      this._references = null;
      this._names = util.EMPTY_STRING_ARRAY;
      this._atNames = util.EMPTY_STRING_ARRAY;
    }

    var _proto3 = NamedArgumentsImpl.prototype;

    _proto3.empty = function empty(stack, base) {
      this.stack = stack;
      this.base = base;
      this.length = 0;
      this._references = EMPTY_REFERENCES;
      this._names = util.EMPTY_STRING_ARRAY;
      this._atNames = util.EMPTY_STRING_ARRAY;
    };

    _proto3.setup = function setup(stack, base, length, names, atNames) {
      this.stack = stack;
      this.base = base;
      this.length = length;

      if (length === 0) {
        this._references = EMPTY_REFERENCES;
        this._names = util.EMPTY_STRING_ARRAY;
        this._atNames = util.EMPTY_STRING_ARRAY;
      } else {
        this._references = null;

        if (atNames) {
          this._names = null;
          this._atNames = names;
        } else {
          this._names = names;
          this._atNames = null;
        }
      }
    };

    _proto3.has = function has(name) {
      return this.names.indexOf(name) !== -1;
    };

    _proto3.get = function get(name, atNames) {
      if (atNames === void 0) {
        atNames = false;
      }

      var base = this.base,
          stack = this.stack;
      var names = atNames ? this.atNames : this.names;
      var idx = names.indexOf(name);

      if (idx === -1) {
        return reference.UNDEFINED_REFERENCE;
      }

      var ref = stack.get(idx, base);

      if (env.DEBUG) {
        return reference.createDebugAliasRef(atNames ? name : "@" + name, ref);
      } else {
        return ref;
      }
    };

    _proto3.capture = function capture() {
      var names = this.names,
          references = this.references;
      var map = util.dict();

      for (var i = 0; i < names.length; i++) {
        var name = names[i];

        if (env.DEBUG) {
          map[name] = reference.createDebugAliasRef("@" + name, references[i]);
        } else {
          map[name] = references[i];
        }
      }

      return map;
    };

    _proto3.merge = function merge(other) {
      var keys = Object.keys(other);

      if (keys.length > 0) {
        var names = this.names,
            length = this.length,
            stack = this.stack;
        var newNames = names.slice();

        for (var i = 0; i < keys.length; i++) {
          var name = keys[i];
          var idx = newNames.indexOf(name);

          if (idx === -1) {
            length = newNames.push(name);
            stack.push(other[name]);
          }
        }

        this.length = length;
        this._references = null;
        this._names = newNames;
        this._atNames = null;
      }
    };

    _proto3.toSyntheticName = function toSyntheticName(name) {
      return name.slice(1);
    };

    _proto3.toAtName = function toAtName(name) {
      return "@" + name;
    };

    _createClass$1(NamedArgumentsImpl, [{
      key: "names",
      get: function get() {
        var names = this._names;

        if (!names) {
          names = this._names = this._atNames.map(this.toSyntheticName);
        }

        return names;
      }
    }, {
      key: "atNames",
      get: function get() {
        var atNames = this._atNames;

        if (!atNames) {
          atNames = this._atNames = this._names.map(this.toAtName);
        }

        return atNames;
      }
    }, {
      key: "references",
      get: function get() {
        var references = this._references;

        if (!references) {
          var base = this.base,
              length = this.length,
              stack = this.stack;
          references = this._references = stack.slice(base, base + length);
        }

        return references;
      }
    }]);

    return NamedArgumentsImpl;
  }();

  function toSymbolName(name) {
    return "&" + name;
  }

  var EMPTY_BLOCK_VALUES = util.emptyArray();
  var BlockArgumentsImpl = /*#__PURE__*/function () {
    function BlockArgumentsImpl() {
      this.internalValues = null;
      this._symbolNames = null;
      this.internalTag = null;
      this.names = util.EMPTY_STRING_ARRAY;
      this.length = 0;
      this.base = 0;
    }

    var _proto4 = BlockArgumentsImpl.prototype;

    _proto4.empty = function empty(stack, base) {
      this.stack = stack;
      this.names = util.EMPTY_STRING_ARRAY;
      this.base = base;
      this.length = 0;
      this._symbolNames = null;
      this.internalTag = validator.CONSTANT_TAG;
      this.internalValues = EMPTY_BLOCK_VALUES;
    };

    _proto4.setup = function setup(stack, base, length, names) {
      this.stack = stack;
      this.names = names;
      this.base = base;
      this.length = length;
      this._symbolNames = null;

      if (length === 0) {
        this.internalTag = validator.CONSTANT_TAG;
        this.internalValues = EMPTY_BLOCK_VALUES;
      } else {
        this.internalTag = null;
        this.internalValues = null;
      }
    };

    _proto4.has = function has(name) {
      return this.names.indexOf(name) !== -1;
    };

    _proto4.get = function get(name) {
      var idx = this.names.indexOf(name);

      if (idx === -1) {
        return null;
      }

      var base = this.base,
          stack = this.stack;
      var table = stack.get(idx * 3, base);
      var scope = stack.get(idx * 3 + 1, base);
      var handle = stack.get(idx * 3 + 2, base);
      return handle === null ? null : [handle, scope, table];
    };

    _proto4.capture = function capture() {
      return new CapturedBlockArgumentsImpl(this.names, this.values);
    };

    _createClass$1(BlockArgumentsImpl, [{
      key: "values",
      get: function get() {
        var values = this.internalValues;

        if (!values) {
          var base = this.base,
              length = this.length,
              stack = this.stack;
          values = this.internalValues = stack.slice(base, base + length * 3);
        }

        return values;
      }
    }, {
      key: "symbolNames",
      get: function get() {
        var symbolNames = this._symbolNames;

        if (symbolNames === null) {
          symbolNames = this._symbolNames = this.names.map(toSymbolName);
        }

        return symbolNames;
      }
    }]);

    return BlockArgumentsImpl;
  }();

  var CapturedBlockArgumentsImpl = /*#__PURE__*/function () {
    function CapturedBlockArgumentsImpl(names, values) {
      this.names = names;
      this.values = values;
      this.length = names.length;
    }

    var _proto5 = CapturedBlockArgumentsImpl.prototype;

    _proto5.has = function has(name) {
      return this.names.indexOf(name) !== -1;
    };

    _proto5.get = function get(name) {
      var idx = this.names.indexOf(name);
      if (idx === -1) return null;
      return [this.values[idx * 3 + 2], this.values[idx * 3 + 1], this.values[idx * 3]];
    };

    return CapturedBlockArgumentsImpl;
  }();

  function createCapturedArgs(named, positional) {
    return {
      named: named,
      positional: positional
    };
  }
  function reifyNamed(named) {
    var reified = util.dict();

    for (var key in named) {
      reified[key] = reference.valueForRef(named[key]);
    }

    return reified;
  }
  function reifyPositional(positional) {
    return positional.map(reference.valueForRef);
  }
  function reifyArgs(args) {
    return {
      named: reifyNamed(args.named),
      positional: reifyPositional(args.positional)
    };
  }
  var EMPTY_NAMED = Object.freeze(Object.create(null));
  var EMPTY_POSITIONAL = EMPTY_REFERENCES;
  var EMPTY_ARGS = createCapturedArgs(EMPTY_NAMED, EMPTY_POSITIONAL);

  APPEND_OPCODES.add(77
  /* Curry */
  , function (vm$1, _ref) {
    var type = _ref.op1,
        _isStrict = _ref.op2;
    var stack = vm$1.stack;
    var definition = stack.pop();
    var capturedArgs = stack.pop();
    var owner = vm$1.getOwner();
    var resolver = vm$1.runtime.resolver;
    var isStrict = false;

    if (env.DEBUG) {
      // strict check only happens in DEBUG builds, no reason to load it otherwise
      isStrict = vm$1[CONSTANTS].getValue(util.decodeHandle(_isStrict));
    }

    vm$1.loadValue(vm.$v0, createCurryRef(type, definition, owner, capturedArgs, resolver, isStrict));
  });
  APPEND_OPCODES.add(107
  /* DynamicHelper */
  , function (vm$1) {
    var stack = vm$1.stack;
    var ref = stack.pop();
    var args = stack.pop().capture();
    var helperRef;
    var initialOwner = vm$1.getOwner();
    var helperInstanceRef = reference.createComputeRef(function () {
      if (helperRef !== undefined) {
        destroyable.destroy(helperRef);
      }

      var definition = reference.valueForRef(ref);

      if (isCurriedType(definition, 1
      /* Helper */
      )) {
        var _resolveCurriedValue = resolveCurriedValue(definition),
            resolvedDef = _resolveCurriedValue.definition,
            owner = _resolveCurriedValue.owner,
            positional = _resolveCurriedValue.positional,
            named = _resolveCurriedValue.named;

        var helper = resolveHelper(vm$1[CONSTANTS], resolvedDef, ref);

        if (named !== undefined) {
          args.named = util.assign.apply(void 0, [{}].concat(named, [args.named]));
        }

        if (positional !== undefined) {
          args.positional = positional.concat(args.positional);
        }

        helperRef = helper(args, owner);
        destroyable.associateDestroyableChild(helperInstanceRef, helperRef);
      } else if (util.isObject(definition)) {
        var _helper = resolveHelper(vm$1[CONSTANTS], definition, ref);

        helperRef = _helper(args, initialOwner);

        if (destroyable._hasDestroyableChildren(helperRef)) {
          destroyable.associateDestroyableChild(helperInstanceRef, helperRef);
        }
      } else {
        helperRef = reference.UNDEFINED_REFERENCE;
      }
    });
    var helperValueRef = reference.createComputeRef(function () {
      reference.valueForRef(helperInstanceRef);
      return reference.valueForRef(helperRef);
    });
    vm$1.associateDestroyable(helperInstanceRef);
    vm$1.loadValue(vm.$v0, helperValueRef);
  });

  function resolveHelper(constants, definition, ref) {
    var handle = constants.helper(definition, null, true);

    if (env.DEBUG && handle === null) {
      throw new Error("Expected a dynamic helper definition, but received an object or function that did not have a helper manager associated with it. The dynamic invocation was `{{" + ref.debugLabel + "}}` or `(" + ref.debugLabel + ")`, and the incorrect definition is the value at the path `" + ref.debugLabel + "`, which was: " + util.debugToString(definition));
    }

    return constants.getValue(handle);
  }

  APPEND_OPCODES.add(16
  /* Helper */
  , function (vm$1, _ref2) {
    var handle = _ref2.op1;
    var stack = vm$1.stack;
    var helper = vm$1[CONSTANTS].getValue(handle);
    var args = stack.pop();
    var value = helper(args.capture(), vm$1.getOwner(), vm$1.dynamicScope());

    if (destroyable._hasDestroyableChildren(value)) {
      vm$1.associateDestroyable(value);
    }

    vm$1.loadValue(vm.$v0, value);
  });
  APPEND_OPCODES.add(21
  /* GetVariable */
  , function (vm, _ref3) {
    var symbol = _ref3.op1;
    var expr = vm.referenceForSymbol(symbol);
    vm.stack.push(expr);
  });
  APPEND_OPCODES.add(19
  /* SetVariable */
  , function (vm, _ref4) {
    var symbol = _ref4.op1;
    var expr = vm.stack.pop();
    vm.scope().bindSymbol(symbol, expr);
  });
  APPEND_OPCODES.add(20
  /* SetBlock */
  , function (vm, _ref5) {
    var symbol = _ref5.op1;
    var handle = vm.stack.pop();
    var scope = vm.stack.pop();
    var table = vm.stack.pop();
    vm.scope().bindBlock(symbol, [handle, scope, table]);
  });
  APPEND_OPCODES.add(102
  /* ResolveMaybeLocal */
  , function (vm, _ref6) {
    var _name = _ref6.op1;
    var name = vm[CONSTANTS].getValue(_name);
    var locals = vm.scope().getPartialMap();
    var ref = locals[name];

    if (ref === undefined) {
      ref = reference.childRefFor(vm.getSelf(), name);
    }

    vm.stack.push(ref);
  });
  APPEND_OPCODES.add(37
  /* RootScope */
  , function (vm, _ref7) {
    var symbols = _ref7.op1;
    vm.pushRootScope(symbols, vm.getOwner());
  });
  APPEND_OPCODES.add(22
  /* GetProperty */
  , function (vm, _ref8) {
    var _key = _ref8.op1;
    var key = vm[CONSTANTS].getValue(_key);
    var expr = vm.stack.pop();
    vm.stack.push(reference.childRefFor(expr, key));
  });
  APPEND_OPCODES.add(23
  /* GetBlock */
  , function (vm, _ref9) {
    var _block = _ref9.op1;
    var stack = vm.stack;
    var block = vm.scope().getBlock(_block);
    stack.push(block);
  });
  APPEND_OPCODES.add(24
  /* SpreadBlock */
  , function (vm) {
    var stack = vm.stack;
    var block = stack.pop();

    if (block && !isUndefinedReference(block)) {
      var handleOrCompilable = block[0],
          scope = block[1],
          table = block[2];
      stack.push(table);
      stack.push(scope);
      stack.push(handleOrCompilable);
    } else {
      stack.push(null);
      stack.push(null);
      stack.push(null);
    }
  });

  function isUndefinedReference(input) {
    return input === reference.UNDEFINED_REFERENCE;
  }

  APPEND_OPCODES.add(25
  /* HasBlock */
  , function (vm) {
    var stack = vm.stack;
    var block = stack.pop();

    if (block && !isUndefinedReference(block)) {
      stack.push(reference.TRUE_REFERENCE);
    } else {
      stack.push(reference.FALSE_REFERENCE);
    }
  });
  APPEND_OPCODES.add(26
  /* HasBlockParams */
  , function (vm) {
    // FIXME(mmun): should only need to push the symbol table
    var block = vm.stack.pop();
    var scope = vm.stack.pop();
    var table = vm.stack.pop();
    var hasBlockParams = table && table.parameters.length;
    vm.stack.push(hasBlockParams ? reference.TRUE_REFERENCE : reference.FALSE_REFERENCE);
  });
  APPEND_OPCODES.add(27
  /* Concat */
  , function (vm, _ref10) {
    var count = _ref10.op1;
    var out = new Array(count);

    for (var i = count; i > 0; i--) {
      var offset = i - 1;
      out[offset] = vm.stack.pop();
    }

    vm.stack.push(createConcatRef(out));
  });
  APPEND_OPCODES.add(109
  /* IfInline */
  , function (vm) {
    var condition = vm.stack.pop();
    var truthy = vm.stack.pop();
    var falsy = vm.stack.pop();
    vm.stack.push(reference.createComputeRef(function () {
      if (globalContext.toBool(reference.valueForRef(condition)) === true) {
        return reference.valueForRef(truthy);
      } else {
        return reference.valueForRef(falsy);
      }
    }));
  });
  APPEND_OPCODES.add(110
  /* Not */
  , function (vm) {
    var ref = vm.stack.pop();
    vm.stack.push(reference.createComputeRef(function () {
      return !globalContext.toBool(reference.valueForRef(ref));
    }));
  });
  APPEND_OPCODES.add(111
  /* GetDynamicVar */
  , function (vm) {
    var scope = vm.dynamicScope();
    var stack = vm.stack;
    var nameRef = stack.pop();
    stack.push(reference.createComputeRef(function () {
      var name = String(reference.valueForRef(nameRef));
      return reference.valueForRef(scope.get(name));
    }));
  });
  APPEND_OPCODES.add(112
  /* Log */
  , function (vm$1) {
    var _vm$stack$pop$capture = vm$1.stack.pop().capture(),
        positional = _vm$stack$pop$capture.positional;

    vm$1.loadValue(vm.$v0, reference.createComputeRef(function () {
      var _console;

      // eslint-disable-next-line no-console
      (_console = console).log.apply(_console, reifyPositional(positional));
    }));
  });

  function resolveComponent(resolver, constants, name, owner) {
    var definition = resolver.lookupComponent(name, owner);

    if (env.DEBUG && !definition) {
      throw new Error("Attempted to resolve `" + name + "`, which was expected to be a component, but nothing was found.");
    }

    return constants.resolvedComponent(definition, name);
  }

  /** @internal */
  function hasCustomDebugRenderTreeLifecycle(manager) {
    return 'getDebugCustomRenderTree' in manager;
  }

  function createClassListRef(list) {
    return reference.createComputeRef(function () {
      var ret = [];

      for (var i = 0; i < list.length; i++) {
        var ref = list[i];
        var value = normalizeStringValue(typeof ref === 'string' ? ref : reference.valueForRef(list[i]));
        if (value) ret.push(value);
      }

      return ret.length === 0 ? null : ret.join(' ');
    });
  }

  APPEND_OPCODES.add(39
  /* ChildScope */
  , function (vm) {
    return vm.pushChildScope();
  });
  APPEND_OPCODES.add(40
  /* PopScope */
  , function (vm) {
    return vm.popScope();
  });
  APPEND_OPCODES.add(59
  /* PushDynamicScope */
  , function (vm) {
    return vm.pushDynamicScope();
  });
  APPEND_OPCODES.add(60
  /* PopDynamicScope */
  , function (vm) {
    return vm.popDynamicScope();
  });
  APPEND_OPCODES.add(28
  /* Constant */
  , function (vm, _ref) {
    var other = _ref.op1;
    vm.stack.push(vm[CONSTANTS].getValue(util.decodeHandle(other)));
  });
  APPEND_OPCODES.add(29
  /* ConstantReference */
  , function (vm, _ref2) {
    var other = _ref2.op1;
    vm.stack.push(reference.createConstRef(vm[CONSTANTS].getValue(util.decodeHandle(other)), false));
  });
  APPEND_OPCODES.add(30
  /* Primitive */
  , function (vm, _ref3) {
    var primitive = _ref3.op1;
    var stack = vm.stack;

    if (util.isHandle(primitive)) {
      // it is a handle which does not already exist on the stack
      var value = vm[CONSTANTS].getValue(util.decodeHandle(primitive));
      stack.push(value);
    } else {
      // is already an encoded immediate or primitive handle
      stack.push(util.decodeImmediate(primitive));
    }
  });
  APPEND_OPCODES.add(31
  /* PrimitiveReference */
  , function (vm) {
    var stack = vm.stack;
    var value = stack.pop();
    var ref;

    if (value === undefined) {
      ref = reference.UNDEFINED_REFERENCE;
    } else if (value === null) {
      ref = reference.NULL_REFERENCE;
    } else if (value === true) {
      ref = reference.TRUE_REFERENCE;
    } else if (value === false) {
      ref = reference.FALSE_REFERENCE;
    } else {
      ref = reference.createPrimitiveRef(value);
    }

    stack.push(ref);
  });
  APPEND_OPCODES.add(33
  /* Dup */
  , function (vm, _ref4) {
    var register = _ref4.op1,
        offset = _ref4.op2;
    var position = vm.fetchValue(register) - offset;
    vm.stack.dup(position);
  });
  APPEND_OPCODES.add(34
  /* Pop */
  , function (vm, _ref5) {
    var count = _ref5.op1;
    vm.stack.pop(count);
  });
  APPEND_OPCODES.add(35
  /* Load */
  , function (vm, _ref6) {
    var register = _ref6.op1;
    vm.load(register);
  });
  APPEND_OPCODES.add(36
  /* Fetch */
  , function (vm, _ref7) {
    var register = _ref7.op1;
    vm.fetch(register);
  });
  APPEND_OPCODES.add(58
  /* BindDynamicScope */
  , function (vm, _ref8) {
    var _names = _ref8.op1;
    var names = vm[CONSTANTS].getArray(_names);
    vm.bindDynamicScope(names);
  });
  APPEND_OPCODES.add(69
  /* Enter */
  , function (vm, _ref9) {
    var args = _ref9.op1;
    vm.enter(args);
  });
  APPEND_OPCODES.add(70
  /* Exit */
  , function (vm) {
    vm.exit();
  });
  APPEND_OPCODES.add(63
  /* PushSymbolTable */
  , function (vm, _ref10) {
    var _table = _ref10.op1;
    var stack = vm.stack;
    stack.push(vm[CONSTANTS].getValue(_table));
  });
  APPEND_OPCODES.add(62
  /* PushBlockScope */
  , function (vm) {
    var stack = vm.stack;
    stack.push(vm.scope());
  });
  APPEND_OPCODES.add(61
  /* CompileBlock */
  , function (vm) {
    var stack = vm.stack;
    var block = stack.pop();

    if (block) {
      stack.push(vm.compile(block));
    } else {
      stack.push(null);
    }
  });
  APPEND_OPCODES.add(64
  /* InvokeYield */
  , function (vm) {
    var stack = vm.stack;
    var handle = stack.pop();
    var scope = stack.pop();
    var table = stack.pop();
    var args = stack.pop();

    if (table === null) {
      // To balance the pop{Frame,Scope}
      vm.pushFrame();
      vm.pushScope(scope !== null && scope !== void 0 ? scope : vm.scope());
      return;
    }

    var invokingScope = scope; // If necessary, create a child scope

    {
      var locals = table.parameters;
      var localsCount = locals.length;

      if (localsCount > 0) {
        invokingScope = invokingScope.child();

        for (var i = 0; i < localsCount; i++) {
          invokingScope.bindSymbol(locals[i], args.at(i));
        }
      }
    }
    vm.pushFrame();
    vm.pushScope(invokingScope);
    vm.call(handle);
  });
  APPEND_OPCODES.add(65
  /* JumpIf */
  , function (vm, _ref11) {
    var target = _ref11.op1;
    var reference$1 = vm.stack.pop();
    var value = Boolean(reference.valueForRef(reference$1));

    if (reference.isConstRef(reference$1)) {
      if (value === true) {
        vm["goto"](target);
      }
    } else {
      if (value === true) {
        vm["goto"](target);
      }

      vm.updateWith(new Assert(reference$1));
    }
  });
  APPEND_OPCODES.add(66
  /* JumpUnless */
  , function (vm, _ref12) {
    var target = _ref12.op1;
    var reference$1 = vm.stack.pop();
    var value = Boolean(reference.valueForRef(reference$1));

    if (reference.isConstRef(reference$1)) {
      if (value === false) {
        vm["goto"](target);
      }
    } else {
      if (value === false) {
        vm["goto"](target);
      }

      vm.updateWith(new Assert(reference$1));
    }
  });
  APPEND_OPCODES.add(67
  /* JumpEq */
  , function (vm, _ref13) {
    var target = _ref13.op1,
        comparison = _ref13.op2;
    var other = vm.stack.peek();

    if (other === comparison) {
      vm["goto"](target);
    }
  });
  APPEND_OPCODES.add(68
  /* AssertSame */
  , function (vm) {
    var reference$1 = vm.stack.peek();

    if (reference.isConstRef(reference$1) === false) {
      vm.updateWith(new Assert(reference$1));
    }
  });
  APPEND_OPCODES.add(71
  /* ToBoolean */
  , function (vm) {
    var stack = vm.stack;
    var valueRef = stack.pop();
    stack.push(reference.createComputeRef(function () {
      return globalContext.toBool(reference.valueForRef(valueRef));
    }));
  });
  var Assert = /*#__PURE__*/function () {
    function Assert(ref) {
      this.ref = ref;
      this.last = reference.valueForRef(ref);
    }

    var _proto = Assert.prototype;

    _proto.evaluate = function evaluate(vm) {
      var last = this.last,
          ref = this.ref;
      var current = reference.valueForRef(ref);

      if (last !== current) {
        vm["throw"]();
      }
    };

    return Assert;
  }();
  var AssertFilter = /*#__PURE__*/function () {
    function AssertFilter(ref, filter) {
      this.ref = ref;
      this.filter = filter;
      this.last = filter(reference.valueForRef(ref));
    }

    var _proto2 = AssertFilter.prototype;

    _proto2.evaluate = function evaluate(vm) {
      var last = this.last,
          ref = this.ref,
          filter = this.filter;
      var current = filter(reference.valueForRef(ref));

      if (last !== current) {
        vm["throw"]();
      }
    };

    return AssertFilter;
  }();
  var JumpIfNotModifiedOpcode = /*#__PURE__*/function () {
    function JumpIfNotModifiedOpcode() {
      this.tag = validator.CONSTANT_TAG;
      this.lastRevision = validator.INITIAL;
    }

    var _proto3 = JumpIfNotModifiedOpcode.prototype;

    _proto3.finalize = function finalize(tag, target) {
      this.target = target;
      this.didModify(tag);
    };

    _proto3.evaluate = function evaluate(vm) {
      var tag = this.tag,
          target = this.target,
          lastRevision = this.lastRevision;

      if (!vm.alwaysRevalidate && validator.validateTag(tag, lastRevision)) {
        validator.consumeTag(tag);
        vm["goto"](target);
      }
    };

    _proto3.didModify = function didModify(tag) {
      this.tag = tag;
      this.lastRevision = validator.valueForTag(this.tag);
      validator.consumeTag(tag);
    };

    return JumpIfNotModifiedOpcode;
  }();
  var BeginTrackFrameOpcode = /*#__PURE__*/function () {
    function BeginTrackFrameOpcode(debugLabel) {
      this.debugLabel = debugLabel;
    }

    var _proto4 = BeginTrackFrameOpcode.prototype;

    _proto4.evaluate = function evaluate() {
      validator.beginTrackFrame(this.debugLabel);
    };

    return BeginTrackFrameOpcode;
  }();
  var EndTrackFrameOpcode = /*#__PURE__*/function () {
    function EndTrackFrameOpcode(target) {
      this.target = target;
    }

    var _proto5 = EndTrackFrameOpcode.prototype;

    _proto5.evaluate = function evaluate() {
      var tag = validator.endTrackFrame();
      this.target.didModify(tag);
    };

    return EndTrackFrameOpcode;
  }();

  APPEND_OPCODES.add(41
  /* Text */
  , function (vm, _ref) {
    var text = _ref.op1;
    vm.elements().appendText(vm[CONSTANTS].getValue(text));
  });
  APPEND_OPCODES.add(42
  /* Comment */
  , function (vm, _ref2) {
    var text = _ref2.op1;
    vm.elements().appendComment(vm[CONSTANTS].getValue(text));
  });
  APPEND_OPCODES.add(48
  /* OpenElement */
  , function (vm, _ref3) {
    var tag = _ref3.op1;
    vm.elements().openElement(vm[CONSTANTS].getValue(tag));
  });
  APPEND_OPCODES.add(49
  /* OpenDynamicElement */
  , function (vm) {
    var tagName = reference.valueForRef(vm.stack.pop());
    vm.elements().openElement(tagName);
  });
  APPEND_OPCODES.add(50
  /* PushRemoteElement */
  , function (vm) {
    var elementRef = vm.stack.pop();
    var insertBeforeRef = vm.stack.pop();
    var guidRef = vm.stack.pop();
    var element = reference.valueForRef(elementRef);
    var insertBefore = reference.valueForRef(insertBeforeRef);
    var guid = reference.valueForRef(guidRef);

    if (!reference.isConstRef(elementRef)) {
      vm.updateWith(new Assert(elementRef));
    }

    if (insertBefore !== undefined && !reference.isConstRef(insertBeforeRef)) {
      vm.updateWith(new Assert(insertBeforeRef));
    }

    var block = vm.elements().pushRemoteElement(element, guid, insertBefore);
    if (block) vm.associateDestroyable(block);
  });
  APPEND_OPCODES.add(56
  /* PopRemoteElement */
  , function (vm) {
    vm.elements().popRemoteElement();
  });
  APPEND_OPCODES.add(54
  /* FlushElement */
  , function (vm$1) {
    var operations = vm$1.fetchValue(vm.$t0);
    var modifiers = null;

    if (operations) {
      modifiers = operations.flush(vm$1);
      vm$1.loadValue(vm.$t0, null);
    }

    vm$1.elements().flushElement(modifiers);
  });
  APPEND_OPCODES.add(55
  /* CloseElement */
  , function (vm) {
    var modifiers = vm.elements().closeElement();

    if (modifiers) {
      modifiers.forEach(function (modifier) {
        vm.env.scheduleInstallModifier(modifier);
        var manager = modifier.manager,
            state = modifier.state;
        var d = manager.getDestroyable(state);

        if (d) {
          vm.associateDestroyable(d);
        }
      });
    }
  });
  APPEND_OPCODES.add(57
  /* Modifier */
  , function (vm$1, _ref4) {
    var handle = _ref4.op1;

    if (vm$1.env.isInteractive === false) {
      return;
    }

    var owner = vm$1.getOwner();
    var args = vm$1.stack.pop();
    var definition = vm$1[CONSTANTS].getValue(handle);
    var manager = definition.manager;

    var _vm$elements = vm$1.elements(),
        constructing = _vm$elements.constructing;

    var state = manager.create(owner, constructing, definition.state, args.capture());
    var instance = {
      manager: manager,
      state: state,
      definition: definition
    };
    var operations = vm$1.fetchValue(vm.$t0);
    operations.addModifier(instance);
    var tag = manager.getTag(state);

    if (tag !== null) {
      validator.consumeTag(tag);
      return vm$1.updateWith(new UpdateModifierOpcode(tag, instance));
    }
  });
  APPEND_OPCODES.add(108
  /* DynamicModifier */
  , function (vm$1) {
    if (vm$1.env.isInteractive === false) {
      return;
    }

    var stack = vm$1.stack,
        constants = vm$1[CONSTANTS];
    var ref = stack.pop();
    var args = stack.pop().capture();

    var _vm$elements2 = vm$1.elements(),
        constructing = _vm$elements2.constructing;

    var initialOwner = vm$1.getOwner();
    var instanceRef = reference.createComputeRef(function () {
      var value = reference.valueForRef(ref);
      var owner;

      if (!util.isObject(value)) {
        return;
      }

      var hostDefinition;

      if (isCurriedType(value, 2
      /* Modifier */
      )) {
        var _resolveCurriedValue = resolveCurriedValue(value),
            resolvedDefinition = _resolveCurriedValue.definition,
            curriedOwner = _resolveCurriedValue.owner,
            positional = _resolveCurriedValue.positional,
            named = _resolveCurriedValue.named;

        hostDefinition = resolvedDefinition;
        owner = curriedOwner;

        if (positional !== undefined) {
          args.positional = positional.concat(args.positional);
        }

        if (named !== undefined) {
          args.named = util.assign.apply(void 0, [{}].concat(named, [args.named]));
        }
      } else {
        hostDefinition = value;
        owner = initialOwner;
      }

      var handle = constants.modifier(hostDefinition, null, true);

      if (env.DEBUG && handle === null) {
        throw new Error("Expected a dynamic modifier definition, but received an object or function that did not have a modifier manager associated with it. The dynamic invocation was `{{" + ref.debugLabel + "}}`, and the incorrect definition is the value at the path `" + ref.debugLabel + "`, which was: " + util.debugToString(hostDefinition));
      }

      var definition = constants.getValue(handle);
      var manager = definition.manager;
      var state = manager.create(owner, constructing, definition.state, args);
      return {
        manager: manager,
        state: state,
        definition: definition
      };
    });
    var instance = reference.valueForRef(instanceRef);
    var tag = null;

    if (instance !== undefined) {
      var operations = vm$1.fetchValue(vm.$t0);
      operations.addModifier(instance);
      tag = instance.manager.getTag(instance.state);

      if (tag !== null) {
        validator.consumeTag(tag);
      }
    }

    if (!reference.isConstRef(ref) || tag) {
      return vm$1.updateWith(new UpdateDynamicModifierOpcode(tag, instance, instanceRef));
    }
  });
  var UpdateModifierOpcode = /*#__PURE__*/function () {
    function UpdateModifierOpcode(tag, modifier) {
      this.tag = tag;
      this.modifier = modifier;
      this.lastUpdated = validator.valueForTag(tag);
    }

    var _proto = UpdateModifierOpcode.prototype;

    _proto.evaluate = function evaluate(vm) {
      var modifier = this.modifier,
          tag = this.tag,
          lastUpdated = this.lastUpdated;
      validator.consumeTag(tag);

      if (!validator.validateTag(tag, lastUpdated)) {
        vm.env.scheduleUpdateModifier(modifier);
        this.lastUpdated = validator.valueForTag(tag);
      }
    };

    return UpdateModifierOpcode;
  }();
  var UpdateDynamicModifierOpcode = /*#__PURE__*/function () {
    function UpdateDynamicModifierOpcode(tag, instance, instanceRef) {
      this.tag = tag;
      this.instance = instance;
      this.instanceRef = instanceRef;
      this.lastUpdated = validator.valueForTag(tag !== null && tag !== void 0 ? tag : validator.CURRENT_TAG);
    }

    var _proto2 = UpdateDynamicModifierOpcode.prototype;

    _proto2.evaluate = function evaluate(vm) {
      var tag = this.tag,
          lastUpdated = this.lastUpdated,
          instance = this.instance,
          instanceRef = this.instanceRef;
      var newInstance = reference.valueForRef(instanceRef);

      if (newInstance !== instance) {
        if (instance !== undefined) {
          var destroyable$1 = instance.manager.getDestroyable(instance.state);

          if (destroyable$1 !== null) {
            destroyable.destroy(destroyable$1);
          }
        }

        if (newInstance !== undefined) {
          var manager = newInstance.manager,
              state = newInstance.state;

          var _destroyable = manager.getDestroyable(state);

          if (_destroyable !== null) {
            destroyable.associateDestroyableChild(this, _destroyable);
          }

          tag = manager.getTag(state);

          if (tag !== null) {
            this.lastUpdated = validator.valueForTag(tag);
          }

          this.tag = tag;
          vm.env.scheduleInstallModifier(newInstance);
        }

        this.instance = newInstance;
      } else if (tag !== null && !validator.validateTag(tag, lastUpdated)) {
        vm.env.scheduleUpdateModifier(instance);
        this.lastUpdated = validator.valueForTag(tag);
      }

      if (tag !== null) {
        validator.consumeTag(tag);
      }
    };

    return UpdateDynamicModifierOpcode;
  }();
  APPEND_OPCODES.add(51
  /* StaticAttr */
  , function (vm, _ref5) {
    var _name = _ref5.op1,
        _value = _ref5.op2,
        _namespace = _ref5.op3;
    var name = vm[CONSTANTS].getValue(_name);
    var value = vm[CONSTANTS].getValue(_value);
    var namespace = _namespace ? vm[CONSTANTS].getValue(_namespace) : null;
    vm.elements().setStaticAttribute(name, value, namespace);
  });
  APPEND_OPCODES.add(52
  /* DynamicAttr */
  , function (vm, _ref6) {
    var _name = _ref6.op1,
        _trusting = _ref6.op2,
        _namespace = _ref6.op3;
    var name = vm[CONSTANTS].getValue(_name);
    var trusting = vm[CONSTANTS].getValue(_trusting);
    var reference$1 = vm.stack.pop();
    var value = reference.valueForRef(reference$1);
    var namespace = _namespace ? vm[CONSTANTS].getValue(_namespace) : null;
    var attribute = vm.elements().setDynamicAttribute(name, value, trusting, namespace);

    if (!reference.isConstRef(reference$1)) {
      vm.updateWith(new UpdateDynamicAttributeOpcode(reference$1, attribute, vm.env));
    }
  });
  var UpdateDynamicAttributeOpcode = /*#__PURE__*/function () {
    function UpdateDynamicAttributeOpcode(reference$1, attribute, env) {
      var initialized = false;
      this.updateRef = reference.createComputeRef(function () {
        var value = reference.valueForRef(reference$1);

        if (initialized === true) {
          attribute.update(value, env);
        } else {
          initialized = true;
        }
      });
      reference.valueForRef(this.updateRef);
    }

    var _proto3 = UpdateDynamicAttributeOpcode.prototype;

    _proto3.evaluate = function evaluate() {
      reference.valueForRef(this.updateRef);
    };

    return UpdateDynamicAttributeOpcode;
  }();

  APPEND_OPCODES.add(78
  /* PushComponentDefinition */
  , function (vm, _ref) {
    var handle = _ref.op1;
    var definition = vm[CONSTANTS].getValue(handle);
    var manager = definition.manager,
        capabilities = definition.capabilities;
    var instance = {
      definition: definition,
      manager: manager,
      capabilities: capabilities,
      state: null,
      handle: null,
      table: null,
      lookup: null
    };
    vm.stack.push(instance);
  });
  APPEND_OPCODES.add(80
  /* ResolveDynamicComponent */
  , function (vm$1, _ref2) {
    var _isStrict = _ref2.op1;
    var stack = vm$1.stack;
    var component = reference.valueForRef(stack.pop());
    var constants = vm$1[CONSTANTS];
    var owner = vm$1.getOwner();
    var isStrict = constants.getValue(_isStrict);
    vm$1.loadValue(vm.$t1, null); // Clear the temp register

    var definition;

    if (typeof component === 'string') {
      if (env.DEBUG && isStrict) {
        throw new Error("Attempted to resolve a dynamic component with a string definition, `" + component + "` in a strict mode template. In strict mode, using strings to resolve component definitions is prohibited. You can instead import the component definition and use it directly.");
      }

      var resolvedDefinition = resolveComponent(vm$1.runtime.resolver, constants, component, owner);
      definition = resolvedDefinition;
    } else if (isCurriedValue(component)) {
      definition = component;
    } else {
      definition = constants.component(component, owner);
    }

    stack.push(definition);
  });
  APPEND_OPCODES.add(81
  /* ResolveCurriedComponent */
  , function (vm) {
    var stack = vm.stack;
    var ref = stack.pop();
    var value = reference.valueForRef(ref);
    var constants = vm[CONSTANTS];
    var definition;

    if (env.DEBUG && !(typeof value === 'function' || typeof value === 'object' && value !== null)) {
      throw new Error("Expected a component definition, but received " + value + ". You may have accidentally done <" + ref.debugLabel + ">, where \"" + ref.debugLabel + "\" was a string instead of a curried component definition. You must either use the component definition directly, or use the {{component}} helper to create a curried component definition when invoking dynamically.");
    }

    if (isCurriedValue(value)) {
      definition = value;
    } else {
      definition = constants.component(value, vm.getOwner(), true);

      if (env.DEBUG && definition === null) {
        throw new Error("Expected a dynamic component definition, but received an object or function that did not have a component manager associated with it. The dynamic invocation was `<" + ref.debugLabel + ">` or `{{" + ref.debugLabel + "}}`, and the incorrect definition is the value at the path `" + ref.debugLabel + "`, which was: " + util.debugToString(value));
      }
    }

    stack.push(definition);
  });
  APPEND_OPCODES.add(79
  /* PushDynamicComponentInstance */
  , function (vm) {
    var stack = vm.stack;
    var definition = stack.pop();
    var capabilities, manager;

    if (isCurriedValue(definition)) {
      manager = capabilities = null;
    } else {
      manager = definition.manager;
      capabilities = definition.capabilities;
    }

    stack.push({
      definition: definition,
      capabilities: capabilities,
      manager: manager,
      state: null,
      handle: null,
      table: null
    });
  });
  APPEND_OPCODES.add(82
  /* PushArgs */
  , function (vm, _ref3) {
    var _names = _ref3.op1,
        _blockNames = _ref3.op2,
        flags = _ref3.op3;
    var stack = vm.stack;
    var names = vm[CONSTANTS].getArray(_names);
    var positionalCount = flags >> 4;
    var atNames = flags & 8;
    var blockNames = flags & 7 ? vm[CONSTANTS].getArray(_blockNames) : util.EMPTY_STRING_ARRAY;
    vm[ARGS].setup(stack, names, blockNames, positionalCount, !!atNames);
    stack.push(vm[ARGS]);
  });
  APPEND_OPCODES.add(83
  /* PushEmptyArgs */
  , function (vm) {
    var stack = vm.stack;
    stack.push(vm[ARGS].empty(stack));
  });
  APPEND_OPCODES.add(86
  /* CaptureArgs */
  , function (vm) {
    var stack = vm.stack;
    var args = stack.pop();
    var capturedArgs = args.capture();
    stack.push(capturedArgs);
  });
  APPEND_OPCODES.add(85
  /* PrepareArgs */
  , function (vm$1, _ref4) {
    var _state = _ref4.op1;
    var stack = vm$1.stack;
    var instance = vm$1.fetchValue(_state);
    var args = stack.pop();
    var definition = instance.definition;

    if (isCurriedType(definition, 0
    /* Component */
    )) {
      var constants = vm$1[CONSTANTS];

      var _resolveCurriedValue = resolveCurriedValue(definition),
          resolvedDefinition = _resolveCurriedValue.definition,
          owner = _resolveCurriedValue.owner,
          resolved = _resolveCurriedValue.resolved,
          positional = _resolveCurriedValue.positional,
          named = _resolveCurriedValue.named;

      if (resolved === true) {
        definition = resolvedDefinition;
      } else if (typeof resolvedDefinition === 'string') {
        var resolvedValue = vm$1.runtime.resolver.lookupComponent(resolvedDefinition, owner);
        definition = constants.resolvedComponent(resolvedValue, resolvedDefinition);
      } else {
        definition = constants.component(resolvedDefinition, owner);
      }

      if (named !== undefined) {
        args.named.merge(util.assign.apply(void 0, [{}].concat(named)));
      }

      if (positional !== undefined) {
        args.realloc(positional.length);
        args.positional.prepend(positional);
      }

      var _definition = definition,
          _manager = _definition.manager;
      instance.definition = definition;
      instance.manager = _manager;
      instance.capabilities = definition.capabilities; // Save off the owner that this component was curried with. Later on,
      // we'll fetch the value of this register and set it as the owner on the
      // new root scope.

      vm$1.loadValue(vm.$t1, owner);
    }

    var _definition2 = definition,
        manager$1 = _definition2.manager,
        state = _definition2.state;
    var capabilities = instance.capabilities;

    if (!manager.managerHasCapability(manager$1, capabilities, 4
    /* PrepareArgs */
    )) {
      stack.push(args);
      return;
    }

    var blocks = args.blocks.values;
    var blockNames = args.blocks.names;
    var preparedArgs = manager$1.prepareArgs(state, args);

    if (preparedArgs) {
      args.clear();

      for (var i = 0; i < blocks.length; i++) {
        stack.push(blocks[i]);
      }

      var _positional = preparedArgs.positional,
          _named = preparedArgs.named;
      var positionalCount = _positional.length;

      for (var _i = 0; _i < positionalCount; _i++) {
        stack.push(_positional[_i]);
      }

      var names = Object.keys(_named);

      for (var _i2 = 0; _i2 < names.length; _i2++) {
        stack.push(_named[names[_i2]]);
      }

      args.setup(stack, names, blockNames, positionalCount, false);
    }

    stack.push(args);
  });
  APPEND_OPCODES.add(87
  /* CreateComponent */
  , function (vm, _ref5) {
    var flags = _ref5.op1,
        _state = _ref5.op2;
    var instance = vm.fetchValue(_state);
    var definition = instance.definition,
        manager$1 = instance.manager,
        capabilities = instance.capabilities;

    if (!manager.managerHasCapability(manager$1, capabilities, 512
    /* CreateInstance */
    )) {
      // TODO: Closure and Main components are always invoked dynamically, so this
      // opcode may run even if this capability is not enabled. In the future we
      // should handle this in a better way.
      return;
    }

    var dynamicScope = null;

    if (manager.managerHasCapability(manager$1, capabilities, 64
    /* DynamicScope */
    )) {
      dynamicScope = vm.dynamicScope();
    }

    var hasDefaultBlock = flags & 1;
    var args = null;

    if (manager.managerHasCapability(manager$1, capabilities, 8
    /* CreateArgs */
    )) {
      args = vm.stack.peek();
    }

    var self = null;

    if (manager.managerHasCapability(manager$1, capabilities, 128
    /* CreateCaller */
    )) {
      self = vm.getSelf();
    }

    var state = manager$1.create(vm.getOwner(), definition.state, args, vm.env, dynamicScope, self, !!hasDefaultBlock); // We want to reuse the `state` POJO here, because we know that the opcodes
    // only transition at exactly one place.

    instance.state = state;

    if (manager.managerHasCapability(manager$1, capabilities, 256
    /* UpdateHook */
    )) {
      vm.updateWith(new UpdateComponentOpcode(state, manager$1, dynamicScope));
    }
  });
  APPEND_OPCODES.add(88
  /* RegisterComponentDestructor */
  , function (vm, _ref6) {
    var _state = _ref6.op1;

    var _vm$fetchValue = vm.fetchValue(_state),
        manager$1 = _vm$fetchValue.manager,
        state = _vm$fetchValue.state,
        capabilities = _vm$fetchValue.capabilities;

    var d = manager$1.getDestroyable(state);

    if (env.DEBUG && !manager.managerHasCapability(manager$1, capabilities, 2048
    /* WillDestroy */
    ) && d !== null && typeof 'willDestroy' in d) {
      throw new Error('BUG: Destructor has willDestroy, but the willDestroy capability was not enabled for this component. Pre-destruction hooks must be explicitly opted into');
    }

    if (d) vm.associateDestroyable(d);
  });
  APPEND_OPCODES.add(97
  /* BeginComponentTransaction */
  , function (vm, _ref7) {
    var _state = _ref7.op1;

    var _a;

    var name;

    if (env.DEBUG) {
      var _vm$fetchValue2 = vm.fetchValue(_state),
          definition = _vm$fetchValue2.definition,
          manager = _vm$fetchValue2.manager;

      name = (_a = definition.resolvedName) !== null && _a !== void 0 ? _a : manager.getDebugName(definition.state);
    }

    vm.beginCacheGroup(name);
    vm.elements().pushSimpleBlock();
  });
  APPEND_OPCODES.add(89
  /* PutComponentOperations */
  , function (vm$1) {
    vm$1.loadValue(vm.$t0, new ComponentElementOperations());
  });
  APPEND_OPCODES.add(53
  /* ComponentAttr */
  , function (vm$1, _ref8) {
    var _name = _ref8.op1,
        _trusting = _ref8.op2,
        _namespace = _ref8.op3;
    var name = vm$1[CONSTANTS].getValue(_name);
    var trusting = vm$1[CONSTANTS].getValue(_trusting);
    var reference = vm$1.stack.pop();
    var namespace = _namespace ? vm$1[CONSTANTS].getValue(_namespace) : null;
    vm$1.fetchValue(vm.$t0).setAttribute(name, reference, trusting, namespace);
  });
  APPEND_OPCODES.add(105
  /* StaticComponentAttr */
  , function (vm$1, _ref9) {
    var _name = _ref9.op1,
        _value = _ref9.op2,
        _namespace = _ref9.op3;
    var name = vm$1[CONSTANTS].getValue(_name);
    var value = vm$1[CONSTANTS].getValue(_value);
    var namespace = _namespace ? vm$1[CONSTANTS].getValue(_namespace) : null;
    vm$1.fetchValue(vm.$t0).setStaticAttribute(name, value, namespace);
  });
  var ComponentElementOperations = /*#__PURE__*/function () {
    function ComponentElementOperations() {
      this.attributes = util.dict();
      this.classes = [];
      this.modifiers = [];
    }

    var _proto = ComponentElementOperations.prototype;

    _proto.setAttribute = function setAttribute(name, value, trusting, namespace) {
      var deferred = {
        value: value,
        namespace: namespace,
        trusting: trusting
      };

      if (name === 'class') {
        this.classes.push(value);
      }

      this.attributes[name] = deferred;
    };

    _proto.setStaticAttribute = function setStaticAttribute(name, value, namespace) {
      var deferred = {
        value: value,
        namespace: namespace
      };

      if (name === 'class') {
        this.classes.push(value);
      }

      this.attributes[name] = deferred;
    };

    _proto.addModifier = function addModifier(modifier) {
      this.modifiers.push(modifier);
    };

    _proto.flush = function flush(vm) {
      var type;
      var attributes = this.attributes;

      for (var name in this.attributes) {
        if (name === 'type') {
          type = attributes[name];
          continue;
        }

        var attr = this.attributes[name];

        if (name === 'class') {
          setDeferredAttr(vm, 'class', mergeClasses(this.classes), attr.namespace, attr.trusting);
        } else {
          setDeferredAttr(vm, name, attr.value, attr.namespace, attr.trusting);
        }
      }

      if (type !== undefined) {
        setDeferredAttr(vm, 'type', type.value, type.namespace, type.trusting);
      }

      return this.modifiers;
    };

    return ComponentElementOperations;
  }();

  function mergeClasses(classes) {
    if (classes.length === 0) {
      return '';
    }

    if (classes.length === 1) {
      return classes[0];
    }

    if (allStringClasses(classes)) {
      return classes.join(' ');
    }

    return createClassListRef(classes);
  }

  function allStringClasses(classes) {
    for (var i = 0; i < classes.length; i++) {
      if (typeof classes[i] !== 'string') {
        return false;
      }
    }

    return true;
  }

  function setDeferredAttr(vm, name, value, namespace, trusting) {
    if (trusting === void 0) {
      trusting = false;
    }

    if (typeof value === 'string') {
      vm.elements().setStaticAttribute(name, value, namespace);
    } else {
      var attribute = vm.elements().setDynamicAttribute(name, reference.valueForRef(value), trusting, namespace);

      if (!reference.isConstRef(value)) {
        vm.updateWith(new UpdateDynamicAttributeOpcode(value, attribute, vm.env));
      }
    }
  }

  APPEND_OPCODES.add(99
  /* DidCreateElement */
  , function (vm$1, _ref10) {
    var _state = _ref10.op1;

    var _vm$fetchValue3 = vm$1.fetchValue(_state),
        definition = _vm$fetchValue3.definition,
        state = _vm$fetchValue3.state;

    var manager = definition.manager;
    var operations = vm$1.fetchValue(vm.$t0);
    manager.didCreateElement(state, vm$1.elements().constructing, operations);
  });
  APPEND_OPCODES.add(90
  /* GetComponentSelf */
  , function (vm, _ref11) {
    var _state = _ref11.op1,
        _names = _ref11.op2;

    var _a;

    var instance = vm.fetchValue(_state);
    var definition = instance.definition,
        state = instance.state;
    var manager$1 = definition.manager;
    var selfRef = manager$1.getSelf(state);

    if (vm.env.debugRenderTree !== undefined) {
      var _instance = vm.fetchValue(_state);

      var _definition3 = _instance.definition,
          _manager2 = _instance.manager;
      var args;

      if (vm.stack.peek() === vm[ARGS]) {
        args = vm[ARGS].capture();
      } else {
        var names = vm[CONSTANTS].getArray(_names);
        vm[ARGS].setup(vm.stack, names, [], 0, true);
        args = vm[ARGS].capture();
      }

      var moduleName;
      var compilable = _definition3.compilable;

      if (compilable === null) {
        compilable = _manager2.getDynamicLayout(state, vm.runtime.resolver);

        if (compilable !== null) {
          moduleName = compilable.moduleName;
        } else {
          moduleName = '__default__.hbs';
        }
      } else {
        moduleName = compilable.moduleName;
      } // For tearing down the debugRenderTree


      vm.associateDestroyable(_instance);

      if (hasCustomDebugRenderTreeLifecycle(_manager2)) {
        var nodes = _manager2.getDebugCustomRenderTree(_instance.definition.state, _instance.state, args, moduleName);

        nodes.forEach(function (node) {
          var bucket = node.bucket;
          vm.env.debugRenderTree.create(bucket, node);
          destroyable.registerDestructor(_instance, function () {
            var _a;

            (_a = vm.env.debugRenderTree) === null || _a === void 0 ? void 0 : _a.willDestroy(bucket);
          });
          vm.updateWith(new DebugRenderTreeUpdateOpcode(bucket));
        });
      } else {
        var name = (_a = _definition3.resolvedName) !== null && _a !== void 0 ? _a : _manager2.getDebugName(_definition3.state);
        vm.env.debugRenderTree.create(_instance, {
          type: 'component',
          name: name,
          args: args,
          template: moduleName,
          instance: reference.valueForRef(selfRef)
        });
        vm.associateDestroyable(_instance);
        destroyable.registerDestructor(_instance, function () {
          var _a;

          (_a = vm.env.debugRenderTree) === null || _a === void 0 ? void 0 : _a.willDestroy(_instance);
        });
        vm.updateWith(new DebugRenderTreeUpdateOpcode(_instance));
      }
    }

    vm.stack.push(selfRef);
  });
  APPEND_OPCODES.add(91
  /* GetComponentTagName */
  , function (vm, _ref12) {
    var _state = _ref12.op1;

    var _vm$fetchValue4 = vm.fetchValue(_state),
        definition = _vm$fetchValue4.definition,
        state = _vm$fetchValue4.state;

    var manager = definition.manager;
    var tagName = manager.getTagName(state); // User provided value from JS, so we don't bother to encode

    vm.stack.push(tagName);
  }); // Dynamic Invocation Only

  APPEND_OPCODES.add(92
  /* GetComponentLayout */
  , function (vm, _ref13) {
    var _state = _ref13.op1;
    var instance = vm.fetchValue(_state);
    var manager$1 = instance.manager,
        definition = instance.definition;
    var stack = vm.stack;
    var compilable = definition.compilable;

    if (compilable === null) {
      var capabilities = instance.capabilities;
      compilable = manager$1.getDynamicLayout(instance.state, vm.runtime.resolver);

      if (compilable === null) {
        if (manager.managerHasCapability(manager$1, capabilities, 1024
        /* Wrapped */
        )) {
          compilable = util.unwrapTemplate(vm[CONSTANTS].defaultTemplate).asWrappedLayout();
        } else {
          compilable = util.unwrapTemplate(vm[CONSTANTS].defaultTemplate).asLayout();
        }
      }
    }

    var handle = compilable.compile(vm.context);
    stack.push(compilable.symbolTable);
    stack.push(handle);
  });
  APPEND_OPCODES.add(75
  /* Main */
  , function (vm, _ref14) {
    var register = _ref14.op1;
    var definition = vm.stack.pop();
    var invocation = vm.stack.pop();
    var manager = definition.manager,
        capabilities = definition.capabilities;
    var state = {
      definition: definition,
      manager: manager,
      capabilities: capabilities,
      state: null,
      handle: invocation.handle,
      table: invocation.symbolTable,
      lookup: null
    };
    vm.loadValue(register, state);
  });
  APPEND_OPCODES.add(95
  /* PopulateLayout */
  , function (vm, _ref15) {
    var _state = _ref15.op1;
    var stack = vm.stack; // In DEBUG handles could be ErrHandle objects

    var handle = stack.pop();
    var table = stack.pop();
    var state = vm.fetchValue(_state);
    state.handle = handle;
    state.table = table;
  });
  APPEND_OPCODES.add(38
  /* VirtualRootScope */
  , function (vm$1, _ref16) {
    var _state = _ref16.op1;

    var _vm$fetchValue5 = vm$1.fetchValue(_state),
        table = _vm$fetchValue5.table,
        manager$1 = _vm$fetchValue5.manager,
        capabilities = _vm$fetchValue5.capabilities,
        state = _vm$fetchValue5.state;

    var owner;

    if (manager.managerHasCapability(manager$1, capabilities, 4096
    /* HasSubOwner */
    )) {
      owner = manager$1.getOwner(state);
      vm$1.loadValue(vm.$t1, null); // Clear the temp register
    } else {
      // Check the temp register to see if an owner was resolved from currying
      owner = vm$1.fetchValue(vm.$t1);

      if (owner === null) {
        // If an owner wasn't found, default to using the current owner. This
        // will happen for normal dynamic component invocation,
        // e.g. <SomeClassicEmberComponent/>
        owner = vm$1.getOwner();
      } else {
        // Else the owner was found, so clear the temp register. This will happen
        // if we are loading a curried component, e.g. <@someCurriedComponent/>
        vm$1.loadValue(vm.$t1, null);
      }
    }

    vm$1.pushRootScope(table.symbols.length + 1, owner);
  });
  APPEND_OPCODES.add(94
  /* SetupForEval */
  , function (vm, _ref17) {
    var _state = _ref17.op1;
    var state = vm.fetchValue(_state);

    if (state.table.hasEval) {
      var lookup = state.lookup = util.dict();
      vm.scope().bindEvalScope(lookup);
    }
  });
  APPEND_OPCODES.add(17
  /* SetNamedVariables */
  , function (vm, _ref18) {
    var _state = _ref18.op1;
    var state = vm.fetchValue(_state);
    var scope = vm.scope();
    var args = vm.stack.peek();
    var callerNames = args.named.atNames;

    for (var i = callerNames.length - 1; i >= 0; i--) {
      var atName = callerNames[i];
      var symbol = state.table.symbols.indexOf(callerNames[i]);
      var value = args.named.get(atName, true);
      if (symbol !== -1) scope.bindSymbol(symbol + 1, value);
      if (state.lookup) state.lookup[atName] = value;
    }
  });

  function bindBlock(symbolName, blockName, state, blocks, vm) {
    var symbol = state.table.symbols.indexOf(symbolName);
    var block = blocks.get(blockName);
    if (symbol !== -1) vm.scope().bindBlock(symbol + 1, block);
    if (state.lookup) state.lookup[symbolName] = block;
  }

  APPEND_OPCODES.add(18
  /* SetBlocks */
  , function (vm, _ref19) {
    var _state = _ref19.op1;
    var state = vm.fetchValue(_state);

    var _vm$stack$peek = vm.stack.peek(),
        blocks = _vm$stack$peek.blocks;

    for (var i = 0; i < blocks.names.length; i++) {
      bindBlock(blocks.symbolNames[i], blocks.names[i], state, blocks, vm);
    }
  }); // Dynamic Invocation Only

  APPEND_OPCODES.add(96
  /* InvokeComponentLayout */
  , function (vm, _ref20) {
    var _state = _ref20.op1;
    var state = vm.fetchValue(_state);
    vm.call(state.handle);
  });
  APPEND_OPCODES.add(100
  /* DidRenderLayout */
  , function (vm, _ref21) {
    var _state = _ref21.op1;
    var instance = vm.fetchValue(_state);
    var manager$1 = instance.manager,
        state = instance.state,
        capabilities = instance.capabilities;
    var bounds = vm.elements().popBlock();

    if (vm.env.debugRenderTree !== undefined) {
      if (hasCustomDebugRenderTreeLifecycle(manager$1)) {
        var nodes = manager$1.getDebugCustomRenderTree(instance.definition.state, state, EMPTY_ARGS);
        nodes.reverse().forEach(function (node) {
          var bucket = node.bucket;
          vm.env.debugRenderTree.didRender(bucket, bounds);
          vm.updateWith(new DebugRenderTreeDidRenderOpcode(bucket, bounds));
        });
      } else {
        vm.env.debugRenderTree.didRender(instance, bounds);
        vm.updateWith(new DebugRenderTreeDidRenderOpcode(instance, bounds));
      }
    }

    if (manager.managerHasCapability(manager$1, capabilities, 512
    /* CreateInstance */
    )) {
      var mgr = manager$1;
      mgr.didRenderLayout(state, bounds);
      vm.env.didCreate(instance);
      vm.updateWith(new DidUpdateLayoutOpcode(instance, bounds));
    }
  });
  APPEND_OPCODES.add(98
  /* CommitComponentTransaction */
  , function (vm) {
    vm.commitCacheGroup();
  });
  var UpdateComponentOpcode = /*#__PURE__*/function () {
    function UpdateComponentOpcode(component, manager, dynamicScope) {
      this.component = component;
      this.manager = manager;
      this.dynamicScope = dynamicScope;
    }

    var _proto2 = UpdateComponentOpcode.prototype;

    _proto2.evaluate = function evaluate(_vm) {
      var component = this.component,
          manager = this.manager,
          dynamicScope = this.dynamicScope;
      manager.update(component, dynamicScope);
    };

    return UpdateComponentOpcode;
  }();
  var DidUpdateLayoutOpcode = /*#__PURE__*/function () {
    function DidUpdateLayoutOpcode(component, bounds) {
      this.component = component;
      this.bounds = bounds;
    }

    var _proto3 = DidUpdateLayoutOpcode.prototype;

    _proto3.evaluate = function evaluate(vm) {
      var component = this.component,
          bounds = this.bounds;
      var manager = component.manager,
          state = component.state;
      manager.didUpdateLayout(state, bounds);
      vm.env.didUpdate(component);
    };

    return DidUpdateLayoutOpcode;
  }();

  var DebugRenderTreeUpdateOpcode = /*#__PURE__*/function () {
    function DebugRenderTreeUpdateOpcode(bucket) {
      this.bucket = bucket;
    }

    var _proto4 = DebugRenderTreeUpdateOpcode.prototype;

    _proto4.evaluate = function evaluate(vm) {
      var _a;

      (_a = vm.env.debugRenderTree) === null || _a === void 0 ? void 0 : _a.update(this.bucket);
    };

    return DebugRenderTreeUpdateOpcode;
  }();

  var DebugRenderTreeDidRenderOpcode = /*#__PURE__*/function () {
    function DebugRenderTreeDidRenderOpcode(bucket, bounds) {
      this.bucket = bucket;
      this.bounds = bounds;
    }

    var _proto5 = DebugRenderTreeDidRenderOpcode.prototype;

    _proto5.evaluate = function evaluate(vm) {
      var _a;

      (_a = vm.env.debugRenderTree) === null || _a === void 0 ? void 0 : _a.didRender(this.bucket, this.bounds);
    };

    return DebugRenderTreeDidRenderOpcode;
  }();

  var DynamicTextContent = /*#__PURE__*/function () {
    function DynamicTextContent(node, reference, lastValue) {
      this.node = node;
      this.reference = reference;
      this.lastValue = lastValue;
    }

    var _proto = DynamicTextContent.prototype;

    _proto.evaluate = function evaluate() {
      var value = reference.valueForRef(this.reference);
      var lastValue = this.lastValue;
      if (value === lastValue) return;
      var normalized;

      if (isEmpty(value)) {
        normalized = '';
      } else if (isString(value)) {
        normalized = value;
      } else {
        normalized = String(value);
      }

      if (normalized !== lastValue) {
        var textNode = this.node;
        textNode.nodeValue = this.lastValue = normalized;
      }
    };

    return DynamicTextContent;
  }();

  function toContentType(value) {
    if (shouldCoerce(value)) {
      return 2
      /* String */
      ;
    } else if (isCurriedType(value, 0
    /* Component */
    ) || manager.hasInternalComponentManager(value)) {
      return 0
      /* Component */
      ;
    } else if (isCurriedType(value, 1
    /* Helper */
    ) || manager.hasInternalHelperManager(value)) {
      return 1
      /* Helper */
      ;
    } else if (isSafeString(value)) {
      return 4
      /* SafeString */
      ;
    } else if (isFragment(value)) {
      return 5
      /* Fragment */
      ;
    } else if (isNode(value)) {
      return 6
      /* Node */
      ;
    } else {
        return 2
        /* String */
        ;
      }
  }

  function toDynamicContentType(value) {
    if (!util.isObject(value)) {
      return 2
      /* String */
      ;
    }

    if (isCurriedType(value, 0
    /* Component */
    ) || manager.hasInternalComponentManager(value)) {
      return 0
      /* Component */
      ;
    } else {
      if (env.DEBUG && !isCurriedType(value, 1
      /* Helper */
      ) && !manager.hasInternalHelperManager(value)) {
        throw new Error("Attempted use a dynamic value as a component or helper, but that value did not have an associated component or helper manager. The value was: " + value);
      }

      return 1
      /* Helper */
      ;
    }
  }

  APPEND_OPCODES.add(76
  /* ContentType */
  , function (vm) {
    var reference$1 = vm.stack.peek();
    vm.stack.push(toContentType(reference.valueForRef(reference$1)));

    if (!reference.isConstRef(reference$1)) {
      vm.updateWith(new AssertFilter(reference$1, toContentType));
    }
  });
  APPEND_OPCODES.add(106
  /* DynamicContentType */
  , function (vm) {
    var reference$1 = vm.stack.peek();
    vm.stack.push(toDynamicContentType(reference.valueForRef(reference$1)));

    if (!reference.isConstRef(reference$1)) {
      vm.updateWith(new AssertFilter(reference$1, toDynamicContentType));
    }
  });
  APPEND_OPCODES.add(43
  /* AppendHTML */
  , function (vm) {
    var reference$1 = vm.stack.pop();
    var rawValue = reference.valueForRef(reference$1);
    var value = isEmpty(rawValue) ? '' : String(rawValue);
    vm.elements().appendDynamicHTML(value);
  });
  APPEND_OPCODES.add(44
  /* AppendSafeHTML */
  , function (vm) {
    var reference$1 = vm.stack.pop();
    var rawValue = reference.valueForRef(reference$1).toHTML();
    var value = isEmpty(rawValue) ? '' : rawValue;
    vm.elements().appendDynamicHTML(value);
  });
  APPEND_OPCODES.add(47
  /* AppendText */
  , function (vm) {
    var reference$1 = vm.stack.pop();
    var rawValue = reference.valueForRef(reference$1);
    var value = isEmpty(rawValue) ? '' : String(rawValue);
    var node = vm.elements().appendDynamicText(value);

    if (!reference.isConstRef(reference$1)) {
      vm.updateWith(new DynamicTextContent(node, reference$1, value));
    }
  });
  APPEND_OPCODES.add(45
  /* AppendDocumentFragment */
  , function (vm) {
    var reference$1 = vm.stack.pop();
    var value = reference.valueForRef(reference$1);
    vm.elements().appendDynamicFragment(value);
  });
  APPEND_OPCODES.add(46
  /* AppendNode */
  , function (vm) {
    var reference$1 = vm.stack.pop();
    var value = reference.valueForRef(reference$1);
    vm.elements().appendDynamicNode(value);
  });

  function debugCallback(context, get) {
    // eslint-disable-next-line no-console
    console.info('Use `context`, and `get(<path>)` to debug this template.'); // for example...
    // eslint-disable-next-line no-unused-expressions

    context === get('this'); // eslint-disable-next-line no-debugger

    debugger;
  }

  var callback = debugCallback; // For testing purposes

  function setDebuggerCallback(cb) {
    callback = cb;
  }
  function resetDebuggerCallback() {
    callback = debugCallback;
  }

  var ScopeInspector = /*#__PURE__*/function () {
    function ScopeInspector(scope, symbols, evalInfo) {
      this.scope = scope;
      this.locals = util.dict();

      for (var i = 0; i < evalInfo.length; i++) {
        var slot = evalInfo[i];
        var name = symbols[slot - 1];
        var ref = scope.getSymbol(slot);
        this.locals[name] = ref;
      }
    }

    var _proto = ScopeInspector.prototype;

    _proto.get = function get(path) {
      var scope = this.scope,
          locals = this.locals;
      var parts = path.split('.');

      var _path$split = path.split('.'),
          head = _path$split[0],
          tail = _path$split.slice(1);

      var evalScope = scope.getEvalScope();
      var ref;

      if (head === 'this') {
        ref = scope.getSelf();
      } else if (locals[head]) {
        ref = locals[head];
      } else if (head.indexOf('@') === 0 && evalScope[head]) {
        ref = evalScope[head];
      } else {
        ref = this.scope.getSelf();
        tail = parts;
      }

      return tail.reduce(function (r, part) {
        return reference.childRefFor(r, part);
      }, ref);
    };

    return ScopeInspector;
  }();

  APPEND_OPCODES.add(103
  /* Debugger */
  , function (vm, _ref) {
    var _symbols = _ref.op1,
        _evalInfo = _ref.op2;
    var symbols = vm[CONSTANTS].getArray(_symbols);
    var evalInfo = vm[CONSTANTS].getArray(util.decodeHandle(_evalInfo));
    var inspector = new ScopeInspector(vm.scope(), symbols, evalInfo);
    callback(reference.valueForRef(vm.getSelf()), function (path) {
      return reference.valueForRef(inspector.get(path));
    });
  });

  APPEND_OPCODES.add(72
  /* EnterList */
  , function (vm, _ref) {
    var relativeStart = _ref.op1,
        elseTarget = _ref.op2;
    var stack = vm.stack;
    var listRef = stack.pop();
    var keyRef = stack.pop();
    var keyValue = reference.valueForRef(keyRef);
    var key = keyValue === null ? '@identity' : String(keyValue);
    var iteratorRef = reference.createIteratorRef(listRef, key);
    var iterator = reference.valueForRef(iteratorRef);
    vm.updateWith(new AssertFilter(iteratorRef, function (iterator) {
      return iterator.isEmpty();
    }));

    if (iterator.isEmpty() === true) {
      // TODO: Fix this offset, should be accurate
      vm["goto"](elseTarget + 1);
    } else {
      vm.enterList(iteratorRef, relativeStart);
      vm.stack.push(iterator);
    }
  });
  APPEND_OPCODES.add(73
  /* ExitList */
  , function (vm) {
    vm.exitList();
  });
  APPEND_OPCODES.add(74
  /* Iterate */
  , function (vm, _ref2) {
    var breaks = _ref2.op1;
    var stack = vm.stack;
    var iterator = stack.peek();
    var item = iterator.next();

    if (item !== null) {
      vm.registerItem(vm.enterItem(item));
    } else {
      vm["goto"](breaks);
    }
  });

  var CAPABILITIES = {
    dynamicLayout: false,
    dynamicTag: false,
    prepareArgs: false,
    createArgs: false,
    attributeHook: false,
    elementHook: false,
    createCaller: false,
    dynamicScope: false,
    updateHook: false,
    createInstance: false,
    wrapped: false,
    willDestroy: false,
    hasSubOwner: false
  };
  var TemplateOnlyComponentManager = /*#__PURE__*/function () {
    function TemplateOnlyComponentManager() {}

    var _proto = TemplateOnlyComponentManager.prototype;

    _proto.getCapabilities = function getCapabilities() {
      return CAPABILITIES;
    };

    _proto.getDebugName = function getDebugName(_ref) {
      var name = _ref.name;
      return name;
    };

    _proto.getSelf = function getSelf() {
      return reference.NULL_REFERENCE;
    };

    _proto.getDestroyable = function getDestroyable() {
      return null;
    };

    return TemplateOnlyComponentManager;
  }();
  var TEMPLATE_ONLY_COMPONENT_MANAGER = new TemplateOnlyComponentManager(); // This is only exported for types, don't use this class directly

  var TemplateOnlyComponentDefinition = /*#__PURE__*/function () {
    function TemplateOnlyComponentDefinition(moduleName, name) {
      if (moduleName === void 0) {
        moduleName = '@glimmer/component/template-only';
      }

      if (name === void 0) {
        name = '(unknown template-only component)';
      }

      this.moduleName = moduleName;
      this.name = name;
    }

    var _proto2 = TemplateOnlyComponentDefinition.prototype;

    _proto2.toString = function toString() {
      return this.moduleName;
    };

    return TemplateOnlyComponentDefinition;
  }();
  manager.setInternalComponentManager(TEMPLATE_ONLY_COMPONENT_MANAGER, TemplateOnlyComponentDefinition.prototype);
  /**
    This utility function is used to declare a given component has no backing class. When the rendering engine detects this it
    is able to perform a number of optimizations. Templates that are associated with `templateOnly()` will be rendered _as is_
    without adding a wrapping `<div>` (or any of the other element customization behaviors of [@ember/component](/ember/release/classes/Component)).
    Specifically, this means that the template will be rendered as "outer HTML".

    In general, this method will be used by build time tooling and would not be directly written in an application. However,
    at times it may be useful to use directly to leverage the "outer HTML" semantics mentioned above. For example, if an addon would like
    to use these semantics for its templates but cannot be certain it will only be consumed by applications that have enabled the
    `template-only-glimmer-components` optional feature.

    @example

    ```js
    import { templateOnlyComponent } from '@glimmer/runtime';

    export default templateOnlyComponent();
    ```

    @public
    @method templateOnly
    @param {String} moduleName the module name that the template only component represents, this will be used for debugging purposes
    @category EMBER_GLIMMER_SET_COMPONENT_TEMPLATE
  */

  function templateOnlyComponent(moduleName, name) {
    return new TemplateOnlyComponentDefinition(moduleName, name);
  }

  var SVG_INTEGRATION_POINTS = {
    foreignObject: 1,
    desc: 1,
    title: 1
  }; // http://www.w3.org/TR/html/syntax.html#adjust-svg-attributes
  // TODO: Adjust SVG attributes
  // http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
  // TODO: Adjust SVG elements
  // http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign

  var BLACKLIST_TABLE = Object.create(null);
  var DOMOperations = /*#__PURE__*/function () {
    function DOMOperations(document) {
      this.document = document;
      this.setupUselessElement();
    } // split into separate method so that NodeDOMTreeConstruction
    // can override it.


    var _proto = DOMOperations.prototype;

    _proto.setupUselessElement = function setupUselessElement() {
      this.uselessElement = this.document.createElement('div');
    };

    _proto.createElement = function createElement(tag, context) {
      var isElementInSVGNamespace, isHTMLIntegrationPoint;

      if (context) {
        isElementInSVGNamespace = context.namespaceURI === "http://www.w3.org/2000/svg"
        /* SVG */
        || tag === 'svg';
        isHTMLIntegrationPoint = !!SVG_INTEGRATION_POINTS[context.tagName];
      } else {
        isElementInSVGNamespace = tag === 'svg';
        isHTMLIntegrationPoint = false;
      }

      if (isElementInSVGNamespace && !isHTMLIntegrationPoint) {
        // FIXME: This does not properly handle <font> with color, face, or
        // size attributes, which is also disallowed by the spec. We should fix
        // this.
        if (BLACKLIST_TABLE[tag]) {
          throw new Error("Cannot create a " + tag + " inside an SVG context");
        }

        return this.document.createElementNS("http://www.w3.org/2000/svg"
        /* SVG */
        , tag);
      } else {
        return this.document.createElement(tag);
      }
    };

    _proto.insertBefore = function insertBefore(parent, node, reference) {
      parent.insertBefore(node, reference);
    };

    _proto.insertHTMLBefore = function insertHTMLBefore(parent, nextSibling, html) {
      if (html === '') {
        var comment = this.createComment('');
        parent.insertBefore(comment, nextSibling);
        return new ConcreteBounds(parent, comment, comment);
      }

      var prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;
      var last;

      if (nextSibling === null) {
        parent.insertAdjacentHTML("beforeend"
        /* beforeend */
        , html);
        last = parent.lastChild;
      } else if (nextSibling instanceof HTMLElement) {
        nextSibling.insertAdjacentHTML('beforebegin', html);
        last = nextSibling.previousSibling;
      } else {
        // Non-element nodes do not support insertAdjacentHTML, so add an
        // element and call it on that element. Then remove the element.
        //
        // This also protects Edge, IE and Firefox w/o the inspector open
        // from merging adjacent text nodes. See ./compat/text-node-merging-fix.ts
        var uselessElement = this.uselessElement;
        parent.insertBefore(uselessElement, nextSibling);
        uselessElement.insertAdjacentHTML("beforebegin"
        /* beforebegin */
        , html);
        last = uselessElement.previousSibling;
        parent.removeChild(uselessElement);
      }

      var first = prev ? prev.nextSibling : parent.firstChild;
      return new ConcreteBounds(parent, first, last);
    };

    _proto.createTextNode = function createTextNode(text) {
      return this.document.createTextNode(text);
    };

    _proto.createComment = function createComment(data) {
      return this.document.createComment(data);
    };

    return DOMOperations;
  }();
  function moveNodesBefore(source, target, nextSibling) {
    var first = source.firstChild;
    var last = first;
    var current = first;

    while (current) {
      var next = current.nextSibling;
      target.insertBefore(current, nextSibling);
      last = current;
      current = next;
    }

    return new ConcreteBounds(target, first, last);
  }

  function _inheritsLoose$2(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg"
  /* SVG */
  ; // Patch:    insertAdjacentHTML on SVG Fix
  // Browsers: Safari, IE, Edge, Firefox ~33-34
  // Reason:   insertAdjacentHTML does not exist on SVG elements in Safari. It is
  //           present but throws an exception on IE and Edge. Old versions of
  //           Firefox create nodes in the incorrect namespace.
  // Fix:      Since IE and Edge silently fail to create SVG nodes using
  //           innerHTML, and because Firefox may create nodes in the incorrect
  //           namespace using innerHTML on SVG elements, an HTML-string wrapping
  //           approach is used. A pre/post SVG tag is added to the string, then
  //           that whole string is added to a div. The created nodes are plucked
  //           out and applied to the target location on DOM.

  function applySVGInnerHTMLFix(document, DOMClass, svgNamespace) {
    if (!document) return DOMClass;

    if (!shouldApplyFix(document, svgNamespace)) {
      return DOMClass;
    }

    var div = document.createElement('div');
    return /*#__PURE__*/function (_DOMClass) {
      _inheritsLoose$2(DOMChangesWithSVGInnerHTMLFix, _DOMClass);

      function DOMChangesWithSVGInnerHTMLFix() {
        return _DOMClass.apply(this, arguments) || this;
      }

      var _proto = DOMChangesWithSVGInnerHTMLFix.prototype;

      _proto.insertHTMLBefore = function insertHTMLBefore(parent, nextSibling, html) {
        if (html === '') {
          return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
        }

        if (parent.namespaceURI !== svgNamespace) {
          return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
        }

        return fixSVG(parent, div, html, nextSibling);
      };

      return DOMChangesWithSVGInnerHTMLFix;
    }(DOMClass);
  }

  function fixSVG(parent, div, html, reference) {
    var source; // This is important, because descendants of the <foreignObject> integration
    // point are parsed in the HTML namespace

    if (parent.tagName.toUpperCase() === 'FOREIGNOBJECT') {
      // IE, Edge: also do not correctly support using `innerHTML` on SVG
      // namespaced elements. So here a wrapper is used.
      var wrappedHtml = '<svg><foreignObject>' + html + '</foreignObject></svg>';
      util.clearElement(div);
      div.insertAdjacentHTML("afterbegin"
      /* afterbegin */
      , wrappedHtml);
      source = div.firstChild.firstChild;
    } else {
      // IE, Edge: also do not correctly support using `innerHTML` on SVG
      // namespaced elements. So here a wrapper is used.
      var _wrappedHtml = '<svg>' + html + '</svg>';

      util.clearElement(div);
      div.insertAdjacentHTML("afterbegin"
      /* afterbegin */
      , _wrappedHtml);
      source = div.firstChild;
    }

    return moveNodesBefore(source, parent, reference);
  }

  function shouldApplyFix(document, svgNamespace) {
    var svg = document.createElementNS(svgNamespace, 'svg');

    try {
      svg.insertAdjacentHTML("beforeend"
      /* beforeend */
      , '<circle></circle>');
    } catch (e) {// IE, Edge: Will throw, insertAdjacentHTML is unsupported on SVG
      // Safari: Will throw, insertAdjacentHTML is not present on SVG
    } finally {
      // FF: Old versions will create a node in the wrong namespace
      if (svg.childNodes.length === 1 && svg.firstChild.namespaceURI === SVG_NAMESPACE) {
        // The test worked as expected, no fix required
        return false;
      }

      return true;
    }
  }

  function _inheritsLoose$3(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  // Patch:    Adjacent text node merging fix
  // Browsers: IE, Edge, Firefox w/o inspector open
  // Reason:   These browsers will merge adjacent text nodes. For example given
  //           <div>Hello</div> with div.insertAdjacentHTML(' world') browsers
  //           with proper behavior will populate div.childNodes with two items.
  //           These browsers will populate it with one merged node instead.
  // Fix:      Add these nodes to a wrapper element, then iterate the childNodes
  //           of that wrapper and move the nodes to their target location. Note
  //           that potential SVG bugs will have been handled before this fix.
  //           Note that this fix must only apply to the previous text node, as
  //           the base implementation of `insertHTMLBefore` already handles
  //           following text nodes correctly.
  function applyTextNodeMergingFix(document, DOMClass) {
    if (!document) return DOMClass;

    if (!shouldApplyFix$1(document)) {
      return DOMClass;
    }

    return /*#__PURE__*/function (_DOMClass) {
      _inheritsLoose$3(DOMChangesWithTextNodeMergingFix, _DOMClass);

      function DOMChangesWithTextNodeMergingFix(document) {
        var _this;

        _this = _DOMClass.call(this, document) || this;
        _this.uselessComment = document.createComment('');
        return _this;
      }

      var _proto = DOMChangesWithTextNodeMergingFix.prototype;

      _proto.insertHTMLBefore = function insertHTMLBefore(parent, nextSibling, html) {
        if (html === '') {
          return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
        }

        var didSetUselessComment = false;
        var nextPrevious = nextSibling ? nextSibling.previousSibling : parent.lastChild;

        if (nextPrevious && nextPrevious instanceof Text) {
          didSetUselessComment = true;
          parent.insertBefore(this.uselessComment, nextSibling);
        }

        var bounds = _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);

        if (didSetUselessComment) {
          parent.removeChild(this.uselessComment);
        }

        return bounds;
      };

      return DOMChangesWithTextNodeMergingFix;
    }(DOMClass);
  }

  function shouldApplyFix$1(document) {
    var mergingTextDiv = document.createElement('div');
    mergingTextDiv.appendChild(document.createTextNode('first'));
    mergingTextDiv.insertAdjacentHTML("beforeend"
    /* beforeend */
    , 'second');

    if (mergingTextDiv.childNodes.length === 2) {
      // It worked as expected, no fix required
      return false;
    }

    return true;
  }

  function _inheritsLoose$4(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  ['b', 'big', 'blockquote', 'body', 'br', 'center', 'code', 'dd', 'div', 'dl', 'dt', 'em', 'embed', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'hr', 'i', 'img', 'li', 'listing', 'main', 'meta', 'nobr', 'ol', 'p', 'pre', 'ruby', 's', 'small', 'span', 'strong', 'strike', 'sub', 'sup', 'table', 'tt', 'u', 'ul', 'var'].forEach(function (tag) {
    return BLACKLIST_TABLE[tag] = 1;
  });
  var WHITESPACE = /[\t-\r \xA0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/;
  var doc = typeof document === 'undefined' ? null : document;
  function isWhitespace(string) {
    return WHITESPACE.test(string);
  }
  var DOM;

  (function (DOM) {
    var TreeConstruction = /*#__PURE__*/function (_DOMOperations) {
      _inheritsLoose$4(TreeConstruction, _DOMOperations);

      function TreeConstruction() {
        return _DOMOperations.apply(this, arguments) || this;
      }

      var _proto = TreeConstruction.prototype;

      _proto.createElementNS = function createElementNS(namespace, tag) {
        return this.document.createElementNS(namespace, tag);
      };

      _proto.setAttribute = function setAttribute(element, name, value, namespace) {
        if (namespace === void 0) {
          namespace = null;
        }

        if (namespace) {
          element.setAttributeNS(namespace, name, value);
        } else {
          element.setAttribute(name, value);
        }
      };

      return TreeConstruction;
    }(DOMOperations);

    DOM.TreeConstruction = TreeConstruction;
    var appliedTreeConstruction = TreeConstruction;
    appliedTreeConstruction = applyTextNodeMergingFix(doc, appliedTreeConstruction);
    appliedTreeConstruction = applySVGInnerHTMLFix(doc, appliedTreeConstruction, "http://www.w3.org/2000/svg"
    /* SVG */
    );
    DOM.DOMTreeConstruction = appliedTreeConstruction;
  })(DOM || (DOM = {}));

  var DOMChangesImpl = /*#__PURE__*/function (_DOMOperations2) {
    _inheritsLoose$4(DOMChangesImpl, _DOMOperations2);

    function DOMChangesImpl(document) {
      var _this;

      _this = _DOMOperations2.call(this, document) || this;
      _this.document = document;
      _this.namespace = null;
      return _this;
    }

    var _proto2 = DOMChangesImpl.prototype;

    _proto2.setAttribute = function setAttribute(element, name, value) {
      element.setAttribute(name, value);
    };

    _proto2.removeAttribute = function removeAttribute(element, name) {
      element.removeAttribute(name);
    };

    _proto2.insertAfter = function insertAfter(element, node, reference) {
      this.insertBefore(element, node, reference.nextSibling);
    };

    return DOMChangesImpl;
  }(DOMOperations);
  var helper = DOMChangesImpl;
  helper = applyTextNodeMergingFix(doc, helper);
  helper = applySVGInnerHTMLFix(doc, helper, "http://www.w3.org/2000/svg"
  /* SVG */
  );
  var helper$1 = helper;
  var DOMTreeConstruction = DOM.DOMTreeConstruction;

  var GUID = 0;
  var Ref = /*#__PURE__*/function () {
    function Ref(value) {
      this.id = GUID++;
      this.value = value;
    }

    var _proto = Ref.prototype;

    _proto.get = function get() {
      return this.value;
    };

    _proto.release = function release() {
      if (env.DEBUG && this.value === null) {
        throw new Error('BUG: double release?');
      }

      this.value = null;
    };

    _proto.toString = function toString() {
      var label = "Ref " + this.id;

      if (this.value === null) {
        return label + " (released)";
      } else {
        try {
          return label + ": " + this.value;
        } catch (_a) {
          return label;
        }
      }
    };

    return Ref;
  }();

  var DebugRenderTreeImpl = /*#__PURE__*/function () {
    function DebugRenderTreeImpl() {
      this.stack = new util.Stack();
      this.refs = new WeakMap();
      this.roots = new Set();
      this.nodes = new WeakMap();
    }

    var _proto2 = DebugRenderTreeImpl.prototype;

    _proto2.begin = function begin() {
      this.reset();
    };

    _proto2.create = function create(state, node) {
      var internalNode = util.assign({}, node, {
        bounds: null,
        refs: new Set()
      });
      this.nodes.set(state, internalNode);
      this.appendChild(internalNode, state);
      this.enter(state);
    };

    _proto2.update = function update(state) {
      this.enter(state);
    };

    _proto2.didRender = function didRender(state, bounds) {
      if (env.DEBUG && this.stack.current !== state) {
        throw new Error("BUG: expecting " + this.stack.current + ", got " + state);
      }

      this.nodeFor(state).bounds = bounds;
      this.exit();
    };

    _proto2.willDestroy = function willDestroy(state) {
      this.refs.get(state).release();
    };

    _proto2.commit = function commit() {
      this.reset();
    };

    _proto2.capture = function capture() {
      return this.captureRefs(this.roots);
    };

    _proto2.reset = function reset() {
      if (this.stack.size !== 0) {
        // We probably encountered an error during the rendering loop. This will
        // likely trigger undefined behavior and memory leaks as the error left
        // things in an inconsistent state. It is recommended that the user
        // refresh the page.
        // TODO: We could warn here? But this happens all the time in our tests?
        // Clean up the root reference to prevent errors from happening if we
        // attempt to capture the render tree (Ember Inspector may do this)
        var root = this.stack.toArray()[0];
        var ref = this.refs.get(root);

        if (ref !== undefined) {
          this.roots["delete"](ref);
        }

        while (!this.stack.isEmpty()) {
          this.stack.pop();
        }
      }
    };

    _proto2.enter = function enter(state) {
      this.stack.push(state);
    };

    _proto2.exit = function exit() {
      if (env.DEBUG && this.stack.size === 0) {
        throw new Error('BUG: unbalanced pop');
      }

      this.stack.pop();
    };

    _proto2.nodeFor = function nodeFor(state) {
      return this.nodes.get(state);
    };

    _proto2.appendChild = function appendChild(node, state) {
      if (env.DEBUG && this.refs.has(state)) {
        throw new Error('BUG: child already appended');
      }

      var parent = this.stack.current;
      var ref = new Ref(state);
      this.refs.set(state, ref);

      if (parent) {
        var parentNode = this.nodeFor(parent);
        parentNode.refs.add(ref);
        node.parent = parentNode;
      } else {
        this.roots.add(ref);
      }
    };

    _proto2.captureRefs = function captureRefs(refs) {
      var _this = this;

      var captured = [];
      refs.forEach(function (ref) {
        var state = ref.get();

        if (state) {
          captured.push(_this.captureNode("render-node:" + ref.id, state));
        } else {
          refs["delete"](ref);
        }
      });
      return captured;
    };

    _proto2.captureNode = function captureNode(id, state) {
      var node = this.nodeFor(state);
      var type = node.type,
          name = node.name,
          args = node.args,
          instance = node.instance,
          refs = node.refs;
      var template = this.captureTemplate(node);
      var bounds = this.captureBounds(node);
      var children = this.captureRefs(refs);
      return {
        id: id,
        type: type,
        name: name,
        args: reifyArgs(args),
        instance: instance,
        template: template,
        bounds: bounds,
        children: children
      };
    };

    _proto2.captureTemplate = function captureTemplate(_ref) {
      var template = _ref.template;
      return template || null;
    };

    _proto2.captureBounds = function captureBounds(node) {
      var bounds = node.bounds;
      var parentElement = bounds.parentElement();
      var firstNode = bounds.firstNode();
      var lastNode = bounds.lastNode();
      return {
        parentElement: parentElement,
        firstNode: firstNode,
        lastNode: lastNode
      };
    };

    return DebugRenderTreeImpl;
  }();

  function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }

  var _a$1;
  var TRANSACTION = util.symbol('TRANSACTION');

  var TransactionImpl = /*#__PURE__*/function () {
    function TransactionImpl() {
      this.scheduledInstallModifiers = [];
      this.scheduledUpdateModifiers = [];
      this.createdComponents = [];
      this.updatedComponents = [];
    }

    var _proto = TransactionImpl.prototype;

    _proto.didCreate = function didCreate(component) {
      this.createdComponents.push(component);
    };

    _proto.didUpdate = function didUpdate(component) {
      this.updatedComponents.push(component);
    };

    _proto.scheduleInstallModifier = function scheduleInstallModifier(modifier) {
      this.scheduledInstallModifiers.push(modifier);
    };

    _proto.scheduleUpdateModifier = function scheduleUpdateModifier(modifier) {
      this.scheduledUpdateModifiers.push(modifier);
    };

    _proto.commit = function commit() {
      var createdComponents = this.createdComponents,
          updatedComponents = this.updatedComponents;

      for (var i = 0; i < createdComponents.length; i++) {
        var _createdComponents$i = createdComponents[i],
            _manager = _createdComponents$i.manager,
            _state = _createdComponents$i.state;

        _manager.didCreate(_state);
      }

      for (var _i = 0; _i < updatedComponents.length; _i++) {
        var _updatedComponents$_i = updatedComponents[_i],
            _manager2 = _updatedComponents$_i.manager,
            _state2 = _updatedComponents$_i.state;

        _manager2.didUpdate(_state2);
      }

      var scheduledInstallModifiers = this.scheduledInstallModifiers,
          scheduledUpdateModifiers = this.scheduledUpdateModifiers; // Prevent a transpilation issue we guard against in Ember, the
      // throw-if-closure-required issue

      var manager, state;

      for (var _i2 = 0; _i2 < scheduledInstallModifiers.length; _i2++) {
        var modifier = scheduledInstallModifiers[_i2];
        manager = modifier.manager;
        state = modifier.state;
        var modifierTag = manager.getTag(state);

        if (modifierTag !== null) {
          var tag = validator.track( // eslint-disable-next-line no-loop-func
          function () {
            return manager.install(state);
          }, env.DEBUG && "- While rendering:\n  (instance of a `" + (modifier.definition.resolvedName || manager.getDebugName(modifier.definition.state)) + "` modifier)");
          validator.updateTag(modifierTag, tag);
        } else {
          manager.install(state);
        }
      }

      for (var _i3 = 0; _i3 < scheduledUpdateModifiers.length; _i3++) {
        var _modifier = scheduledUpdateModifiers[_i3];
        manager = _modifier.manager;
        state = _modifier.state;

        var _modifierTag = manager.getTag(state);

        if (_modifierTag !== null) {
          var _tag = validator.track( // eslint-disable-next-line no-loop-func
          function () {
            return manager.update(state);
          }, env.DEBUG && "- While rendering:\n  (instance of a `" + (_modifier.definition.resolvedName || manager.getDebugName(_modifier.definition.state)) + "` modifier)");

          validator.updateTag(_modifierTag, _tag);
        } else {
          manager.update(state);
        }
      }
    };

    return TransactionImpl;
  }();

  var EnvironmentImpl = /*#__PURE__*/function () {
    function EnvironmentImpl(options, delegate) {
      this.delegate = delegate;
      this[_a$1] = null; // Delegate methods and values

      this.isInteractive = this.delegate.isInteractive;
      this.debugRenderTree = this.delegate.enableDebugTooling ? new DebugRenderTreeImpl() : undefined;

      if (options.appendOperations) {
        this.appendOperations = options.appendOperations;
        this.updateOperations = options.updateOperations;
      } else if (options.document) {
        this.appendOperations = new DOMTreeConstruction(options.document);
        this.updateOperations = new DOMChangesImpl(options.document);
      } else if (env.DEBUG) {
        throw new Error('you must pass document or appendOperations to a new runtime');
      }
    }

    var _proto2 = EnvironmentImpl.prototype;

    _proto2.getAppendOperations = function getAppendOperations() {
      return this.appendOperations;
    };

    _proto2.getDOM = function getDOM() {
      return this.updateOperations;
    };

    _proto2.begin = function begin() {
      var _b;
      (_b = this.debugRenderTree) === null || _b === void 0 ? void 0 : _b.begin();
      this[TRANSACTION] = new TransactionImpl();
    };

    _proto2.didCreate = function didCreate(component) {
      this.transaction.didCreate(component);
    };

    _proto2.didUpdate = function didUpdate(component) {
      this.transaction.didUpdate(component);
    };

    _proto2.scheduleInstallModifier = function scheduleInstallModifier(modifier) {
      if (this.isInteractive) {
        this.transaction.scheduleInstallModifier(modifier);
      }
    };

    _proto2.scheduleUpdateModifier = function scheduleUpdateModifier(modifier) {
      if (this.isInteractive) {
        this.transaction.scheduleUpdateModifier(modifier);
      }
    };

    _proto2.commit = function commit() {
      var _b;

      var transaction = this.transaction;
      this[TRANSACTION] = null;
      transaction.commit();
      (_b = this.debugRenderTree) === null || _b === void 0 ? void 0 : _b.commit();
      this.delegate.onTransactionCommit();
    };

    _createClass$2(EnvironmentImpl, [{
      key: "transaction",
      get: function get() {
        return this[TRANSACTION];
      }
    }]);

    return EnvironmentImpl;
  }();
  _a$1 = TRANSACTION;
  function runtimeContext(options, delegate, artifacts, resolver) {
    return {
      env: new EnvironmentImpl(options, delegate),
      program: new program.RuntimeProgramImpl(artifacts.constants, artifacts.heap),
      resolver: resolver
    };
  }
  function inTransaction(env, cb) {
    if (!env[TRANSACTION]) {
      env.begin();

      try {
        cb();
      } finally {
        env.commit();
      }
    } else {
      cb();
    }
  }

  function initializeRegistersWithSP(sp) {
    return [0, -1, sp, 0];
  }

  var LowLevelVM = /*#__PURE__*/function () {
    function LowLevelVM(stack, heap, program, externs, registers) {
      this.stack = stack;
      this.heap = heap;
      this.program = program;
      this.externs = externs;
      this.registers = registers;
      this.currentOpSize = 0;
    }

    var _proto = LowLevelVM.prototype;

    _proto.fetchRegister = function fetchRegister(register) {
      return this.registers[register];
    };

    _proto.loadRegister = function loadRegister(register, value) {
      this.registers[register] = value;
    };

    _proto.setPc = function setPc(pc) {
      this.registers[vm.$pc] = pc;
    } // Start a new frame and save $ra and $fp on the stack
    ;

    _proto.pushFrame = function pushFrame() {
      this.stack.push(this.registers[vm.$ra]);
      this.stack.push(this.registers[vm.$fp]);
      this.registers[vm.$fp] = this.registers[vm.$sp] - 1;
    } // Restore $ra, $sp and $fp
    ;

    _proto.popFrame = function popFrame() {
      this.registers[vm.$sp] = this.registers[vm.$fp] - 1;
      this.registers[vm.$ra] = this.stack.get(0);
      this.registers[vm.$fp] = this.stack.get(1);
    };

    _proto.pushSmallFrame = function pushSmallFrame() {
      this.stack.push(this.registers[vm.$ra]);
    };

    _proto.popSmallFrame = function popSmallFrame() {
      this.registers[vm.$ra] = this.stack.pop();
    } // Jump to an address in `program`
    ;

    _proto["goto"] = function goto(offset) {
      this.setPc(this.target(offset));
    };

    _proto.target = function target(offset) {
      return this.registers[vm.$pc] + offset - this.currentOpSize;
    } // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)
    ;

    _proto.call = function call(handle) {
      this.registers[vm.$ra] = this.registers[vm.$pc];
      this.setPc(this.heap.getaddr(handle));
    } // Put a specific `program` address in $ra
    ;

    _proto.returnTo = function returnTo(offset) {
      this.registers[vm.$ra] = this.target(offset);
    } // Return to the `program` address stored in $ra
    ;

    _proto["return"] = function _return() {
      this.setPc(this.registers[vm.$ra]);
    };

    _proto.nextStatement = function nextStatement() {
      var registers = this.registers,
          program = this.program;
      var pc = registers[vm.$pc];

      if (pc === -1) {
        return null;
      } // We have to save off the current operations size so that
      // when we do a jump we can calculate the correct offset
      // to where we are going. We can't simply ask for the size
      // in a jump because we have have already incremented the
      // program counter to the next instruction prior to executing.


      var opcode = program.opcode(pc);
      var operationSize = this.currentOpSize = opcode.size;
      this.registers[vm.$pc] += operationSize;
      return opcode;
    };

    _proto.evaluateOuter = function evaluateOuter(opcode, vm) {
      {
        this.evaluateInner(opcode, vm);
      }
    };

    _proto.evaluateInner = function evaluateInner(opcode, vm) {
      if (opcode.isMachine) {
        this.evaluateMachine(opcode);
      } else {
        this.evaluateSyscall(opcode, vm);
      }
    };

    _proto.evaluateMachine = function evaluateMachine(opcode) {
      switch (opcode.type) {
        case 0
        /* PushFrame */
        :
          return this.pushFrame();

        case 1
        /* PopFrame */
        :
          return this.popFrame();

        case 3
        /* InvokeStatic */
        :
          return this.call(opcode.op1);

        case 2
        /* InvokeVirtual */
        :
          return this.call(this.stack.pop());

        case 4
        /* Jump */
        :
          return this["goto"](opcode.op1);

        case 5
        /* Return */
        :
          return this["return"]();

        case 6
        /* ReturnTo */
        :
          return this.returnTo(opcode.op1);
      }
    };

    _proto.evaluateSyscall = function evaluateSyscall(opcode, vm) {
      APPEND_OPCODES.evaluate(vm, opcode, opcode.type);
    };

    return LowLevelVM;
  }();

  function _inheritsLoose$5(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

  function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$3(Constructor.prototype, protoProps); if (staticProps) _defineProperties$3(Constructor, staticProps); return Constructor; }

  var UpdatingVMImpl = /*#__PURE__*/function () {
    function UpdatingVMImpl(env, _ref) {
      var _ref$alwaysRevalidate = _ref.alwaysRevalidate,
          alwaysRevalidate = _ref$alwaysRevalidate === void 0 ? false : _ref$alwaysRevalidate;
      this.frameStack = new util.Stack();
      this.env = env;
      this.dom = env.getDOM();
      this.alwaysRevalidate = alwaysRevalidate;
    }

    var _proto = UpdatingVMImpl.prototype;

    _proto.execute = function execute(opcodes, handler) {
      var _this = this;

      if (env.DEBUG) {
        var hasErrored = true;

        try {
          validator.runInTrackingTransaction(function () {
            return _this._execute(opcodes, handler);
          }, '- While rendering:'); // using a boolean here to avoid breaking ergonomics of "pause on uncaught exceptions"
          // which would happen with a `catch` + `throw`

          hasErrored = false;
        } finally {
          if (hasErrored) {
            // eslint-disable-next-line no-console
            console.error("\n\nError occurred:\n\n" + validator.resetTracking() + "\n\n");
          }
        }
      } else {
        this._execute(opcodes, handler);
      }
    };

    _proto._execute = function _execute(opcodes, handler) {
      var frameStack = this.frameStack;
      this["try"](opcodes, handler);

      while (true) {
        if (frameStack.isEmpty()) break;
        var opcode = this.frame.nextStatement();

        if (opcode === undefined) {
          frameStack.pop();
          continue;
        }

        opcode.evaluate(this);
      }
    };

    _proto["goto"] = function goto(index) {
      this.frame["goto"](index);
    };

    _proto["try"] = function _try(ops, handler) {
      this.frameStack.push(new UpdatingVMFrame(ops, handler));
    };

    _proto["throw"] = function _throw() {
      this.frame.handleException();
      this.frameStack.pop();
    };

    _createClass$3(UpdatingVMImpl, [{
      key: "frame",
      get: function get() {
        return this.frameStack.current;
      }
    }]);

    return UpdatingVMImpl;
  }();
  var ResumableVMStateImpl = /*#__PURE__*/function () {
    function ResumableVMStateImpl(state, resumeCallback) {
      this.state = state;
      this.resumeCallback = resumeCallback;
    }

    var _proto2 = ResumableVMStateImpl.prototype;

    _proto2.resume = function resume(runtime, builder) {
      return this.resumeCallback(runtime, this.state, builder);
    };

    return ResumableVMStateImpl;
  }();
  var BlockOpcode = /*#__PURE__*/function () {
    function BlockOpcode(state, runtime, bounds, children) {
      this.state = state;
      this.runtime = runtime;
      this.children = children;
      this.bounds = bounds;
    }

    var _proto3 = BlockOpcode.prototype;

    _proto3.parentElement = function parentElement() {
      return this.bounds.parentElement();
    };

    _proto3.firstNode = function firstNode() {
      return this.bounds.firstNode();
    };

    _proto3.lastNode = function lastNode() {
      return this.bounds.lastNode();
    };

    _proto3.evaluate = function evaluate(vm) {
      vm["try"](this.children, null);
    };

    return BlockOpcode;
  }();
  var TryOpcode = /*#__PURE__*/function (_BlockOpcode) {
    _inheritsLoose$5(TryOpcode, _BlockOpcode);

    function TryOpcode() {
      var _this2;

      _this2 = _BlockOpcode.apply(this, arguments) || this;
      _this2.type = 'try';
      return _this2;
    }

    var _proto4 = TryOpcode.prototype;

    _proto4.evaluate = function evaluate(vm) {
      vm["try"](this.children, this);
    };

    _proto4.handleException = function handleException() {
      var _this3 = this;

      var state = this.state,
          bounds = this.bounds,
          runtime = this.runtime;
      destroyable.destroyChildren(this);
      var elementStack = NewElementBuilder.resume(runtime.env, bounds);
      var vm = state.resume(runtime, elementStack);
      var updating = [];
      var children = this.children = [];
      var result = vm.execute(function (vm) {
        vm.pushUpdating(updating);
        vm.updateWith(_this3);
        vm.pushUpdating(children);
      });
      destroyable.associateDestroyableChild(this, result.drop);
    };

    return TryOpcode;
  }(BlockOpcode);
  var ListItemOpcode = /*#__PURE__*/function (_TryOpcode) {
    _inheritsLoose$5(ListItemOpcode, _TryOpcode);

    function ListItemOpcode(state, runtime, bounds, key, memo, value) {
      var _this4;

      _this4 = _TryOpcode.call(this, state, runtime, bounds, []) || this;
      _this4.key = key;
      _this4.memo = memo;
      _this4.value = value;
      _this4.retained = false;
      _this4.index = -1;
      return _this4;
    }

    var _proto5 = ListItemOpcode.prototype;

    _proto5.updateReferences = function updateReferences(item) {
      this.retained = true;
      reference.updateRef(this.value, item.value);
      reference.updateRef(this.memo, item.memo);
    };

    _proto5.shouldRemove = function shouldRemove() {
      return !this.retained;
    };

    _proto5.reset = function reset() {
      this.retained = false;
    };

    return ListItemOpcode;
  }(TryOpcode);
  var ListBlockOpcode = /*#__PURE__*/function (_BlockOpcode2) {
    _inheritsLoose$5(ListBlockOpcode, _BlockOpcode2);

    function ListBlockOpcode(state, runtime, bounds, children, iterableRef) {
      var _this5;

      _this5 = _BlockOpcode2.call(this, state, runtime, bounds, children) || this;
      _this5.iterableRef = iterableRef;
      _this5.type = 'list-block';
      _this5.opcodeMap = new Map();
      _this5.marker = null;
      _this5.lastIterator = reference.valueForRef(iterableRef);
      return _this5;
    }

    var _proto6 = ListBlockOpcode.prototype;

    _proto6.initializeChild = function initializeChild(opcode) {
      opcode.index = this.children.length - 1;
      this.opcodeMap.set(opcode.key, opcode);
    };

    _proto6.evaluate = function evaluate(vm) {
      var iterator = reference.valueForRef(this.iterableRef);

      if (this.lastIterator !== iterator) {
        var bounds = this.bounds;
        var dom = vm.dom;
        var marker = this.marker = dom.createComment('');
        dom.insertAfter(bounds.parentElement(), marker, bounds.lastNode());
        this.sync(iterator);
        this.parentElement().removeChild(marker);
        this.marker = null;
        this.lastIterator = iterator;
      } // Run now-updated updating opcodes


      _BlockOpcode2.prototype.evaluate.call(this, vm);
    };

    _proto6.sync = function sync(iterator) {
      var itemMap = this.opcodeMap,
          children = this.children;
      var currentOpcodeIndex = 0;
      var seenIndex = 0;
      this.children = this.bounds.boundList = [];

      while (true) {
        var item = iterator.next();
        if (item === null) break;
        var opcode = children[currentOpcodeIndex];
        var key = item.key; // Items that have already been found and moved will already be retained,
        // we can continue until we find the next unretained item

        while (opcode !== undefined && opcode.retained === true) {
          opcode = children[++currentOpcodeIndex];
        }

        if (opcode !== undefined && opcode.key === key) {
          this.retainItem(opcode, item);
          currentOpcodeIndex++;
        } else if (itemMap.has(key)) {
          var itemOpcode = itemMap.get(key); // The item opcode was seen already, so we should move it.

          if (itemOpcode.index < seenIndex) {
            this.moveItem(itemOpcode, item, opcode);
          } else {
            // Update the seen index, we are going to be moving this item around
            // so any other items that come before it will likely need to move as
            // well.
            seenIndex = itemOpcode.index;
            var seenUnretained = false; // iterate through all of the opcodes between the current position and
            // the position of the item's opcode, and determine if they are all
            // retained.

            for (var i = currentOpcodeIndex + 1; i < seenIndex; i++) {
              if (children[i].retained === false) {
                seenUnretained = true;
                break;
              }
            } // If we have seen only retained opcodes between this and the matching
            // opcode, it means that all the opcodes in between have been moved
            // already, and we can safely retain this item's opcode.


            if (seenUnretained === false) {
              this.retainItem(itemOpcode, item);
              currentOpcodeIndex = seenIndex + 1;
            } else {
              this.moveItem(itemOpcode, item, opcode);
              currentOpcodeIndex++;
            }
          }
        } else {
          this.insertItem(item, opcode);
        }
      }

      for (var _i = 0; _i < children.length; _i++) {
        var _opcode = children[_i];

        if (_opcode.retained === false) {
          this.deleteItem(_opcode);
        } else {
          _opcode.reset();
        }
      }
    };

    _proto6.retainItem = function retainItem(opcode, item) {

      var children = this.children;
      reference.updateRef(opcode.memo, item.memo);
      reference.updateRef(opcode.value, item.value);
      opcode.retained = true;
      opcode.index = children.length;
      children.push(opcode);
    };

    _proto6.insertItem = function insertItem(item, before) {
      var _this6 = this;

      var opcodeMap = this.opcodeMap,
          bounds = this.bounds,
          state = this.state,
          runtime = this.runtime,
          children = this.children;
      var key = item.key;
      var nextSibling = before === undefined ? this.marker : before.firstNode();
      var elementStack = NewElementBuilder.forInitialRender(runtime.env, {
        element: bounds.parentElement(),
        nextSibling: nextSibling
      });
      var vm = state.resume(runtime, elementStack);
      vm.execute(function (vm) {
        vm.pushUpdating();
        var opcode = vm.enterItem(item);
        opcode.index = children.length;
        children.push(opcode);
        opcodeMap.set(key, opcode);
        destroyable.associateDestroyableChild(_this6, opcode);
      });
    };

    _proto6.moveItem = function moveItem(opcode, item, before) {
      var children = this.children;
      reference.updateRef(opcode.memo, item.memo);
      reference.updateRef(opcode.value, item.value);
      opcode.retained = true;
      var currentSibling, nextSibling;

      if (before === undefined) {
        move(opcode, this.marker);
      } else {
        currentSibling = opcode.lastNode().nextSibling;
        nextSibling = before.firstNode(); // Items are moved throughout the algorithm, so there are cases where the
        // the items already happen to be siblings (e.g. an item in between was
        // moved before this move happened). Check to see if they are siblings
        // first before doing the move.

        if (currentSibling !== nextSibling) {
          move(opcode, nextSibling);
        }
      }

      opcode.index = children.length;
      children.push(opcode);
    };

    _proto6.deleteItem = function deleteItem(opcode) {

      destroyable.destroy(opcode);
      clear(opcode);
      this.opcodeMap["delete"](opcode.key);
    };

    return ListBlockOpcode;
  }(BlockOpcode);

  var UpdatingVMFrame = /*#__PURE__*/function () {
    function UpdatingVMFrame(ops, exceptionHandler) {
      this.ops = ops;
      this.exceptionHandler = exceptionHandler;
      this.current = 0;
    }

    var _proto7 = UpdatingVMFrame.prototype;

    _proto7["goto"] = function goto(index) {
      this.current = index;
    };

    _proto7.nextStatement = function nextStatement() {
      return this.ops[this.current++];
    };

    _proto7.handleException = function handleException() {
      if (this.exceptionHandler) {
        this.exceptionHandler.handleException();
      }
    };

    return UpdatingVMFrame;
  }();

  var RenderResultImpl = /*#__PURE__*/function () {
    function RenderResultImpl(env, updating, bounds, drop) {
      var _this = this;

      this.env = env;
      this.updating = updating;
      this.bounds = bounds;
      this.drop = drop;
      destroyable.associateDestroyableChild(this, drop);
      destroyable.registerDestructor(this, function () {
        return clear(_this.bounds);
      });
    }

    var _proto = RenderResultImpl.prototype;

    _proto.rerender = function rerender(_temp) {
      var _ref = _temp === void 0 ? {
        alwaysRevalidate: false
      } : _temp,
          _ref$alwaysRevalidate = _ref.alwaysRevalidate,
          alwaysRevalidate = _ref$alwaysRevalidate === void 0 ? false : _ref$alwaysRevalidate;

      var env = this.env,
          updating = this.updating;
      var vm = new UpdatingVMImpl(env, {
        alwaysRevalidate: alwaysRevalidate
      });
      vm.execute(updating, this);
    };

    _proto.parentElement = function parentElement() {
      return this.bounds.parentElement();
    };

    _proto.firstNode = function firstNode() {
      return this.bounds.firstNode();
    };

    _proto.lastNode = function lastNode() {
      return this.bounds.lastNode();
    };

    _proto.handleException = function handleException() {
      throw 'this should never happen';
    };

    return RenderResultImpl;
  }();

  var EvaluationStackImpl = /*#__PURE__*/function () {
    // fp -> sp
    function EvaluationStackImpl(stack, registers) {
      if (stack === void 0) {
        stack = [];
      }

      this.stack = stack;
      this[REGISTERS] = registers;
    }

    EvaluationStackImpl.restore = function restore(snapshot) {
      return new this(snapshot.slice(), initializeRegistersWithSP(snapshot.length - 1));
    };

    var _proto = EvaluationStackImpl.prototype;

    _proto.push = function push(value) {
      this.stack[++this[REGISTERS][vm.$sp]] = value;
    };

    _proto.dup = function dup(position) {
      if (position === void 0) {
        position = this[REGISTERS][vm.$sp];
      }

      this.stack[++this[REGISTERS][vm.$sp]] = this.stack[position];
    };

    _proto.copy = function copy(from, to) {
      this.stack[to] = this.stack[from];
    };

    _proto.pop = function pop(n) {
      if (n === void 0) {
        n = 1;
      }

      var top = this.stack[this[REGISTERS][vm.$sp]];
      this[REGISTERS][vm.$sp] -= n;
      return top;
    };

    _proto.peek = function peek(offset) {
      if (offset === void 0) {
        offset = 0;
      }

      return this.stack[this[REGISTERS][vm.$sp] - offset];
    };

    _proto.get = function get(offset, base) {
      if (base === void 0) {
        base = this[REGISTERS][vm.$fp];
      }

      return this.stack[base + offset];
    };

    _proto.set = function set(value, offset, base) {
      if (base === void 0) {
        base = this[REGISTERS][vm.$fp];
      }

      this.stack[base + offset] = value;
    };

    _proto.slice = function slice(start, end) {
      return this.stack.slice(start, end);
    };

    _proto.capture = function capture(items) {
      var end = this[REGISTERS][vm.$sp] + 1;
      var start = end - items;
      return this.stack.slice(start, end);
    };

    _proto.reset = function reset() {
      this.stack.length = 0;
    };

    _proto.toArray = function toArray() {
      return this.stack.slice(this[REGISTERS][vm.$fp], this[REGISTERS][vm.$sp] + 1);
    };

    return EvaluationStackImpl;
  }();

  function _defineProperties$4(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$4(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$4(Constructor.prototype, protoProps); if (staticProps) _defineProperties$4(Constructor, staticProps); return Constructor; }

  var _a$2, _b;

  var Stacks = function Stacks() {
    this.scope = new util.Stack();
    this.dynamicScope = new util.Stack();
    this.updating = new util.Stack();
    this.cache = new util.Stack();
    this.list = new util.Stack();
  };

  var VM = /*#__PURE__*/function () {
    /**
     * End of migrated.
     */
    function VM(runtime, _ref, elementStack, context) {
      var _this = this;

      var pc = _ref.pc,
          scope = _ref.scope,
          dynamicScope = _ref.dynamicScope,
          stack = _ref.stack;
      this.runtime = runtime;
      this.elementStack = elementStack;
      this.context = context;
      this[_a$2] = new Stacks();
      this[_b] = new util.Stack();
      this.s0 = null;
      this.s1 = null;
      this.t0 = null;
      this.t1 = null;
      this.v0 = null;
      this.resume = initVM(this.context);

      if (env.DEBUG) {
        globalContext.assertGlobalContextWasSet();
      }

      var evalStack = EvaluationStackImpl.restore(stack);
      evalStack[REGISTERS][vm.$pc] = pc;
      evalStack[REGISTERS][vm.$sp] = stack.length - 1;
      evalStack[REGISTERS][vm.$fp] = -1;
      this[HEAP] = this.program.heap;
      this[CONSTANTS] = this.program.constants;
      this.elementStack = elementStack;
      this[STACKS].scope.push(scope);
      this[STACKS].dynamicScope.push(dynamicScope);
      this[ARGS] = new VMArgumentsImpl();
      this[INNER_VM] = new LowLevelVM(evalStack, this[HEAP], runtime.program, {
        debugBefore: function debugBefore(opcode) {
          return APPEND_OPCODES.debugBefore(_this, opcode);
        },
        debugAfter: function debugAfter(state) {
          APPEND_OPCODES.debugAfter(_this, state);
        }
      }, evalStack[REGISTERS]);
      this.destructor = {};
      this[DESTROYABLE_STACK].push(this.destructor);
    }

    var _proto = VM.prototype;

    // Fetch a value from a register onto the stack
    _proto.fetch = function fetch(register) {
      var value = this.fetchValue(register);
      this.stack.push(value);
    } // Load a value from the stack into a register
    ;

    _proto.load = function load(register) {
      var value = this.stack.pop();
      this.loadValue(register, value);
    };

    _proto.fetchValue = function fetchValue(register) {
      if (vm.isLowLevelRegister(register)) {
        return this[INNER_VM].fetchRegister(register);
      }

      switch (register) {
        case vm.$s0:
          return this.s0;

        case vm.$s1:
          return this.s1;

        case vm.$t0:
          return this.t0;

        case vm.$t1:
          return this.t1;

        case vm.$v0:
          return this.v0;
      }
    } // Load a value into a register
    ;

    _proto.loadValue = function loadValue(register, value) {
      if (vm.isLowLevelRegister(register)) {
        this[INNER_VM].loadRegister(register, value);
      }

      switch (register) {
        case vm.$s0:
          this.s0 = value;
          break;

        case vm.$s1:
          this.s1 = value;
          break;

        case vm.$t0:
          this.t0 = value;
          break;

        case vm.$t1:
          this.t1 = value;
          break;

        case vm.$v0:
          this.v0 = value;
          break;
      }
    }
    /**
     * Migrated to Inner
     */
    // Start a new frame and save $ra and $fp on the stack
    ;

    _proto.pushFrame = function pushFrame() {
      this[INNER_VM].pushFrame();
    } // Restore $ra, $sp and $fp
    ;

    _proto.popFrame = function popFrame() {
      this[INNER_VM].popFrame();
    } // Jump to an address in `program`
    ;

    _proto["goto"] = function goto(offset) {
      this[INNER_VM]["goto"](offset);
    } // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)
    ;

    _proto.call = function call(handle) {
      this[INNER_VM].call(handle);
    } // Put a specific `program` address in $ra
    ;

    _proto.returnTo = function returnTo(offset) {
      this[INNER_VM].returnTo(offset);
    } // Return to the `program` address stored in $ra
    ;

    _proto["return"] = function _return() {
      this[INNER_VM]["return"]();
    };

    VM.initial = function initial(runtime, context, _ref2) {
      var handle = _ref2.handle,
          self = _ref2.self,
          dynamicScope = _ref2.dynamicScope,
          treeBuilder = _ref2.treeBuilder,
          numSymbols = _ref2.numSymbols,
          owner = _ref2.owner;
      var scope = PartialScopeImpl.root(self, numSymbols, owner);
      var state = vmState(runtime.program.heap.getaddr(handle), scope, dynamicScope);
      var vm = initVM(context)(runtime, state, treeBuilder);
      vm.pushUpdating();
      return vm;
    };

    VM.empty = function empty(runtime, _ref3, context) {
      var handle = _ref3.handle,
          treeBuilder = _ref3.treeBuilder,
          dynamicScope = _ref3.dynamicScope,
          owner = _ref3.owner;
      var vm = initVM(context)(runtime, vmState(runtime.program.heap.getaddr(handle), PartialScopeImpl.root(reference.UNDEFINED_REFERENCE, 0, owner), dynamicScope), treeBuilder);
      vm.pushUpdating();
      return vm;
    };

    _proto.compile = function compile(block) {
      var handle = util.unwrapHandle(block.compile(this.context));
      return handle;
    };

    _proto.captureState = function captureState(args, pc) {
      if (pc === void 0) {
        pc = this[INNER_VM].fetchRegister(vm.$pc);
      }

      return {
        pc: pc,
        scope: this.scope(),
        dynamicScope: this.dynamicScope(),
        stack: this.stack.capture(args)
      };
    };

    _proto.capture = function capture(args, pc) {
      if (pc === void 0) {
        pc = this[INNER_VM].fetchRegister(vm.$pc);
      }

      return new ResumableVMStateImpl(this.captureState(args, pc), this.resume);
    };

    _proto.beginCacheGroup = function beginCacheGroup(name) {
      var opcodes = this.updating();
      var guard = new JumpIfNotModifiedOpcode();
      opcodes.push(guard);
      opcodes.push(new BeginTrackFrameOpcode(name));
      this[STACKS].cache.push(guard);
      validator.beginTrackFrame(name);
    };

    _proto.commitCacheGroup = function commitCacheGroup() {
      var opcodes = this.updating();
      var guard = this[STACKS].cache.pop();
      var tag = validator.endTrackFrame();
      opcodes.push(new EndTrackFrameOpcode(guard));
      guard.finalize(tag, opcodes.length);
    };

    _proto.enter = function enter(args) {
      var updating = [];
      var state = this.capture(args);
      var block = this.elements().pushUpdatableBlock();
      var tryOpcode = new TryOpcode(state, this.runtime, block, updating);
      this.didEnter(tryOpcode);
    };

    _proto.enterItem = function enterItem(_ref4) {
      var key = _ref4.key,
          value = _ref4.value,
          memo = _ref4.memo;
      var stack = this.stack;
      var valueRef = reference.createIteratorItemRef(value);
      var memoRef = reference.createIteratorItemRef(memo);
      stack.push(valueRef);
      stack.push(memoRef);
      var state = this.capture(2);
      var block = this.elements().pushUpdatableBlock();
      var opcode = new ListItemOpcode(state, this.runtime, block, key, memoRef, valueRef);
      this.didEnter(opcode);
      return opcode;
    };

    _proto.registerItem = function registerItem(opcode) {
      this.listBlock().initializeChild(opcode);
    };

    _proto.enterList = function enterList(iterableRef, offset) {
      var updating = [];
      var addr = this[INNER_VM].target(offset);
      var state = this.capture(0, addr);
      var list = this.elements().pushBlockList(updating);
      var opcode = new ListBlockOpcode(state, this.runtime, list, updating, iterableRef);
      this[STACKS].list.push(opcode);
      this.didEnter(opcode);
    };

    _proto.didEnter = function didEnter(opcode) {
      this.associateDestroyable(opcode);
      this[DESTROYABLE_STACK].push(opcode);
      this.updateWith(opcode);
      this.pushUpdating(opcode.children);
    };

    _proto.exit = function exit() {
      this[DESTROYABLE_STACK].pop();
      this.elements().popBlock();
      this.popUpdating();
    };

    _proto.exitList = function exitList() {
      this.exit();
      this[STACKS].list.pop();
    };

    _proto.pushUpdating = function pushUpdating(list) {
      if (list === void 0) {
        list = [];
      }

      this[STACKS].updating.push(list);
    };

    _proto.popUpdating = function popUpdating() {
      return this[STACKS].updating.pop();
    };

    _proto.updateWith = function updateWith(opcode) {
      this.updating().push(opcode);
    };

    _proto.listBlock = function listBlock() {
      return this[STACKS].list.current;
    };

    _proto.associateDestroyable = function associateDestroyable(child) {
      var parent = this[DESTROYABLE_STACK].current;
      destroyable.associateDestroyableChild(parent, child);
    };

    _proto.tryUpdating = function tryUpdating() {
      return this[STACKS].updating.current;
    };

    _proto.updating = function updating() {
      return this[STACKS].updating.current;
    };

    _proto.elements = function elements() {
      return this.elementStack;
    };

    _proto.scope = function scope() {
      return this[STACKS].scope.current;
    };

    _proto.dynamicScope = function dynamicScope() {
      return this[STACKS].dynamicScope.current;
    };

    _proto.pushChildScope = function pushChildScope() {
      this[STACKS].scope.push(this.scope().child());
    };

    _proto.pushDynamicScope = function pushDynamicScope() {
      var child = this.dynamicScope().child();
      this[STACKS].dynamicScope.push(child);
      return child;
    };

    _proto.pushRootScope = function pushRootScope(size, owner) {
      var scope = PartialScopeImpl.sized(size, owner);
      this[STACKS].scope.push(scope);
      return scope;
    };

    _proto.pushScope = function pushScope(scope) {
      this[STACKS].scope.push(scope);
    };

    _proto.popScope = function popScope() {
      this[STACKS].scope.pop();
    };

    _proto.popDynamicScope = function popDynamicScope() {
      this[STACKS].dynamicScope.pop();
    } /// SCOPE HELPERS
    ;

    _proto.getOwner = function getOwner() {
      return this.scope().owner;
    };

    _proto.getSelf = function getSelf() {
      return this.scope().getSelf();
    };

    _proto.referenceForSymbol = function referenceForSymbol(symbol) {
      return this.scope().getSymbol(symbol);
    } /// EXECUTION
    ;

    _proto.execute = function execute(initialize) {
      if (env.DEBUG) {
        var hasErrored = true;

        try {
          var value = this._execute(initialize); // using a boolean here to avoid breaking ergonomics of "pause on uncaught exceptions"
          // which would happen with a `catch` + `throw`


          hasErrored = false;
          return value;
        } finally {
          if (hasErrored) {
            // If any existing blocks are open, due to an error or something like
            // that, we need to close them all and clean things up properly.
            var elements = this.elements();

            while (elements.hasBlocks) {
              elements.popBlock();
            } // eslint-disable-next-line no-console


            console.error("\n\nError occurred:\n\n" + validator.resetTracking() + "\n\n");
          }
        }
      } else {
        return this._execute(initialize);
      }
    };

    _proto._execute = function _execute(initialize) {

      if (initialize) initialize(this);
      var result;

      while (true) {
        result = this.next();
        if (result.done) break;
      }

      return result.value;
    };

    _proto.next = function next() {
      var env = this.env,
          elementStack = this.elementStack;
      var opcode = this[INNER_VM].nextStatement();
      var result;

      if (opcode !== null) {
        this[INNER_VM].evaluateOuter(opcode, this);
        result = {
          done: false,
          value: null
        };
      } else {
        // Unload the stack
        this.stack.reset();
        result = {
          done: true,
          value: new RenderResultImpl(env, this.popUpdating(), elementStack.popBlock(), this.destructor)
        };
      }

      return result;
    };

    _proto.bindDynamicScope = function bindDynamicScope(names) {
      var scope = this.dynamicScope();

      for (var i = names.length - 1; i >= 0; i--) {
        var name = names[i];
        scope.set(name, this.stack.pop());
      }
    };

    _createClass$4(VM, [{
      key: "stack",
      get: function get() {
        return this[INNER_VM].stack;
      }
      /* Registers */

    }, {
      key: "pc",
      get: function get() {
        return this[INNER_VM].fetchRegister(vm.$pc);
      }
    }, {
      key: "program",
      get: function get() {
        return this.runtime.program;
      }
    }, {
      key: "env",
      get: function get() {
        return this.runtime.env;
      }
    }]);

    return VM;
  }();
  _a$2 = STACKS, _b = DESTROYABLE_STACK;

  function vmState(pc, scope, dynamicScope) {
    return {
      pc: pc,
      scope: scope,
      dynamicScope: dynamicScope,
      stack: []
    };
  }

  function initVM(context) {
    return function (runtime, state, builder) {
      return new VM(runtime, state, builder, context);
    };
  }

  var TemplateIteratorImpl = /*#__PURE__*/function () {
    function TemplateIteratorImpl(vm) {
      this.vm = vm;
    }

    var _proto = TemplateIteratorImpl.prototype;

    _proto.next = function next() {
      return this.vm.next();
    };

    _proto.sync = function sync() {
      var _this = this;

      if (env.DEBUG) {
        return validator.runInTrackingTransaction(function () {
          return _this.vm.execute();
        }, '- While rendering:');
      } else {
        return this.vm.execute();
      }
    };

    return TemplateIteratorImpl;
  }();

  function renderSync(env, iterator) {
    var result;
    inTransaction(env, function () {
      return result = iterator.sync();
    });
    return result;
  }
  function renderMain(runtime, context, owner, self, treeBuilder, layout, dynamicScope) {
    if (dynamicScope === void 0) {
      dynamicScope = new DynamicScopeImpl();
    }

    var handle = util.unwrapHandle(layout.compile(context));
    var numSymbols = layout.symbolTable.symbols.length;
    var vm = VM.initial(runtime, context, {
      self: self,
      dynamicScope: dynamicScope,
      treeBuilder: treeBuilder,
      handle: handle,
      numSymbols: numSymbols,
      owner: owner
    });
    return new TemplateIteratorImpl(vm);
  }

  function renderInvocation(vm, context, owner, definition, args) {
    // Get a list of tuples of argument names and references, like
    // [['title', reference], ['name', reference]]
    var argList = Object.keys(args).map(function (key) {
      return [key, args[key]];
    });
    var blockNames = ['main', 'else', 'attrs']; // Prefix argument names with `@` symbol

    var argNames = argList.map(function (_ref) {
      var name = _ref[0];
      return "@" + name;
    });
    var reified = vm[CONSTANTS].component(definition, owner);
    vm.pushFrame(); // Push blocks on to the stack, three stack values per block

    for (var i = 0; i < 3 * blockNames.length; i++) {
      vm.stack.push(null);
    }

    vm.stack.push(null); // For each argument, push its backing reference on to the stack

    argList.forEach(function (_ref2) {
      var reference = _ref2[1];
      vm.stack.push(reference);
    }); // Configure VM based on blocks and args just pushed on to the stack.

    vm[ARGS].setup(vm.stack, argNames, blockNames, 0, true);
    var compilable = reified.compilable;
    var layoutHandle = util.unwrapHandle(compilable.compile(context));
    var invocation = {
      handle: layoutHandle,
      symbolTable: compilable.symbolTable
    }; // Needed for the Op.Main opcode: arguments, component invocation object, and
    // component definition.

    vm.stack.push(vm[ARGS]);
    vm.stack.push(invocation);
    vm.stack.push(reified);
    return new TemplateIteratorImpl(vm);
  }

  function renderComponent(runtime, treeBuilder, context, owner, definition, args, dynamicScope) {
    if (args === void 0) {
      args = {};
    }

    if (dynamicScope === void 0) {
      dynamicScope = new DynamicScopeImpl();
    }

    var vm = VM.empty(runtime, {
      treeBuilder: treeBuilder,
      handle: context.stdlib.main,
      dynamicScope: dynamicScope,
      owner: owner
    }, context);
    return renderInvocation(vm, context, owner, definition, recordToReference(args));
  }

  function recordToReference(record) {
    var root = reference.createConstRef(record, 'args');
    return Object.keys(record).reduce(function (acc, key) {
      acc[key] = reference.childRefFor(root, key);
      return acc;
    }, {});
  }

  function _defineProperties$5(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$5(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$5(Constructor.prototype, protoProps); if (staticProps) _defineProperties$5(Constructor, staticProps); return Constructor; }

  function _inheritsLoose$6(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  var SERIALIZATION_FIRST_NODE_STRING = '%+b:0%';
  function isSerializationFirstNode(node) {
    return node.nodeValue === SERIALIZATION_FIRST_NODE_STRING;
  }
  var RehydratingCursor = /*#__PURE__*/function (_CursorImpl) {
    _inheritsLoose$6(RehydratingCursor, _CursorImpl);

    function RehydratingCursor(element, nextSibling, startingBlockDepth) {
      var _this;

      _this = _CursorImpl.call(this, element, nextSibling) || this;
      _this.startingBlockDepth = startingBlockDepth;
      _this.candidate = null;
      _this.injectedOmittedNode = false;
      _this.openBlockDepth = startingBlockDepth - 1;
      return _this;
    }

    return RehydratingCursor;
  }(CursorImpl);
  var RehydrateBuilder = /*#__PURE__*/function (_NewElementBuilder) {
    _inheritsLoose$6(RehydrateBuilder, _NewElementBuilder);

    function RehydrateBuilder(env, parentNode, nextSibling) {
      var _this2;

      _this2 = _NewElementBuilder.call(this, env, parentNode, nextSibling) || this;
      _this2.unmatchedAttributes = null;
      _this2.blockDepth = 0;
      if (nextSibling) throw new Error('Rehydration with nextSibling not supported');
      var node = _this2.currentCursor.element.firstChild;

      while (node !== null) {
        if (isOpenBlock(node)) {
          break;
        }

        node = node.nextSibling;
      }
      _this2.candidate = node;
      var startingBlockOffset = getBlockDepth(node);

      if (startingBlockOffset !== 0) {
        // We are rehydrating from a partial tree and not the root component
        // We need to add an extra block before the first block to rehydrate correctly
        // The extra block is needed since the renderComponent API creates a synthetic component invocation which generates the extra block
        var newBlockDepth = startingBlockOffset - 1;

        var newCandidate = _this2.dom.createComment("%+b:" + newBlockDepth + "%");

        node.parentNode.insertBefore(newCandidate, _this2.candidate);
        var closingNode = node.nextSibling;

        while (closingNode !== null) {
          if (isCloseBlock(closingNode) && getBlockDepth(closingNode) === startingBlockOffset) {
            break;
          }

          closingNode = closingNode.nextSibling;
        }

        var newClosingBlock = _this2.dom.createComment("%-b:" + newBlockDepth + "%");

        node.parentNode.insertBefore(newClosingBlock, closingNode.nextSibling);
        _this2.candidate = newCandidate;
        _this2.startingBlockOffset = newBlockDepth;
      } else {
        _this2.startingBlockOffset = 0;
      }

      return _this2;
    }

    var _proto = RehydrateBuilder.prototype;

    _proto.disableRehydration = function disableRehydration(nextSibling) {
      var currentCursor = this.currentCursor; // rehydration will be disabled until we either:
      // * hit popElement (and return to using the parent elements cursor)
      // * hit closeBlock and the next sibling is a close block comment
      //   matching the expected openBlockDepth

      currentCursor.candidate = null;
      currentCursor.nextSibling = nextSibling;
    };

    _proto.enableRehydration = function enableRehydration(candidate) {
      var currentCursor = this.currentCursor;
      currentCursor.candidate = candidate;
      currentCursor.nextSibling = null;
    };

    _proto.pushElement = function pushElement(element, nextSibling) {
      if (nextSibling === void 0) {
        nextSibling = null;
      }

      var cursor = new RehydratingCursor(element, nextSibling, this.blockDepth || 0);
      /**
       * <div>   <---------------  currentCursor.element
       *   <!--%+b:1%--> <-------  would have been removed during openBlock
       *   <div> <---------------  currentCursor.candidate -> cursor.element
       *     <!--%+b:2%--> <-----  currentCursor.candidate.firstChild -> cursor.candidate
       *     Foo
       *     <!--%-b:2%-->
       *   </div>
       *   <!--%-b:1%-->  <------  becomes currentCursor.candidate
       */

      if (this.candidate !== null) {
        cursor.candidate = element.firstChild;
        this.candidate = element.nextSibling;
      }

      this[CURSOR_STACK].push(cursor);
    } // clears until the end of the current container
    // either the current open block or higher
    ;

    _proto.clearMismatch = function clearMismatch(candidate) {
      var current = candidate;
      var currentCursor = this.currentCursor;

      if (currentCursor !== null) {
        var openBlockDepth = currentCursor.openBlockDepth;

        if (openBlockDepth >= currentCursor.startingBlockDepth) {
          while (current) {
            if (isCloseBlock(current)) {
              var closeBlockDepth = getBlockDepthWithOffset(current, this.startingBlockOffset);

              if (openBlockDepth >= closeBlockDepth) {
                break;
              }
            }

            current = this.remove(current);
          }
        } else {
          while (current !== null) {
            current = this.remove(current);
          }
        } // current cursor parentNode should be openCandidate if element
        // or openCandidate.parentNode if comment


        this.disableRehydration(current);
      }
    };

    _proto.__openBlock = function __openBlock() {
      var currentCursor = this.currentCursor;
      if (currentCursor === null) return;
      var blockDepth = this.blockDepth;
      this.blockDepth++;
      var candidate = currentCursor.candidate;
      if (candidate === null) return;
      var tagName = currentCursor.element.tagName;

      if (isOpenBlock(candidate) && getBlockDepthWithOffset(candidate, this.startingBlockOffset) === blockDepth) {
        this.candidate = this.remove(candidate);
        currentCursor.openBlockDepth = blockDepth;
      } else if (tagName !== 'TITLE' && tagName !== 'SCRIPT' && tagName !== 'STYLE') {
        this.clearMismatch(candidate);
      }
    };

    _proto.__closeBlock = function __closeBlock() {
      var currentCursor = this.currentCursor;
      if (currentCursor === null) return; // openBlock is the last rehydrated open block

      var openBlockDepth = currentCursor.openBlockDepth; // this currently is the expected next open block depth

      this.blockDepth--;
      var candidate = currentCursor.candidate;
      var isRehydrating = false;

      if (candidate !== null) {
        isRehydrating = true; //assert(
        //  openBlockDepth === this.blockDepth,
        //  'when rehydrating, openBlockDepth should match this.blockDepth here'
        //);

        if (isCloseBlock(candidate) && getBlockDepthWithOffset(candidate, this.startingBlockOffset) === openBlockDepth) {
          var nextSibling = this.remove(candidate);
          this.candidate = nextSibling;
          currentCursor.openBlockDepth--;
        } else {
          // close the block and clear mismatch in parent container
          // we will be either at the end of the element
          // or at the end of our containing block
          this.clearMismatch(candidate);
          isRehydrating = false;
        }
      }

      if (isRehydrating === false) {
        // check if nextSibling matches our expected close block
        // if so, we remove the close block comment and
        // restore rehydration after clearMismatch disabled
        var _nextSibling = currentCursor.nextSibling;

        if (_nextSibling !== null && isCloseBlock(_nextSibling) && getBlockDepthWithOffset(_nextSibling, this.startingBlockOffset) === this.blockDepth) {
          // restore rehydration state
          var _candidate2 = this.remove(_nextSibling);

          this.enableRehydration(_candidate2);
          currentCursor.openBlockDepth--;
        }
      }
    };

    _proto.__appendNode = function __appendNode(node) {
      var candidate = this.candidate; // This code path is only used when inserting precisely one node. It needs more
      // comparison logic, but we can probably lean on the cases where this code path
      // is actually used.

      if (candidate) {
        return candidate;
      } else {
        return _NewElementBuilder.prototype.__appendNode.call(this, node);
      }
    };

    _proto.__appendHTML = function __appendHTML(html) {
      var candidateBounds = this.markerBounds();

      if (candidateBounds) {
        var first = candidateBounds.firstNode();
        var last = candidateBounds.lastNode();
        var newBounds = new ConcreteBounds(this.element, first.nextSibling, last.previousSibling);
        var possibleEmptyMarker = this.remove(first);
        this.remove(last);

        if (possibleEmptyMarker !== null && isEmpty$1(possibleEmptyMarker)) {
          this.candidate = this.remove(possibleEmptyMarker);

          if (this.candidate !== null) {
            this.clearMismatch(this.candidate);
          }
        }

        return newBounds;
      } else {
        return _NewElementBuilder.prototype.__appendHTML.call(this, html);
      }
    };

    _proto.remove = function remove(node) {
      var element = node.parentNode;
      var next = node.nextSibling;
      element.removeChild(node);
      return next;
    };

    _proto.markerBounds = function markerBounds() {
      var _candidate = this.candidate;

      if (_candidate && isMarker(_candidate)) {
        var first = _candidate;
        var last = first.nextSibling;

        while (last && !isMarker(last)) {
          last = last.nextSibling;
        }

        return new ConcreteBounds(this.element, first, last);
      } else {
        return null;
      }
    };

    _proto.__appendText = function __appendText(string) {
      var candidate = this.candidate;

      if (candidate) {
        if (isTextNode(candidate)) {
          if (candidate.nodeValue !== string) {
            candidate.nodeValue = string;
          }

          this.candidate = candidate.nextSibling;
          return candidate;
        } else if (isSeparator(candidate)) {
          this.candidate = this.remove(candidate);
          return this.__appendText(string);
        } else if (isEmpty$1(candidate) && string === '') {
          this.candidate = this.remove(candidate);
          return this.__appendText(string);
        } else {
          this.clearMismatch(candidate);
          return _NewElementBuilder.prototype.__appendText.call(this, string);
        }
      } else {
        return _NewElementBuilder.prototype.__appendText.call(this, string);
      }
    };

    _proto.__appendComment = function __appendComment(string) {
      var _candidate = this.candidate;

      if (_candidate && isComment(_candidate)) {
        if (_candidate.nodeValue !== string) {
          _candidate.nodeValue = string;
        }

        this.candidate = _candidate.nextSibling;
        return _candidate;
      } else if (_candidate) {
        this.clearMismatch(_candidate);
      }

      return _NewElementBuilder.prototype.__appendComment.call(this, string);
    };

    _proto.__openElement = function __openElement(tag) {
      var _candidate = this.candidate;

      if (_candidate && isElement(_candidate) && isSameNodeType(_candidate, tag)) {
        this.unmatchedAttributes = [].slice.call(_candidate.attributes);
        return _candidate;
      } else if (_candidate) {
        if (isElement(_candidate) && _candidate.tagName === 'TBODY') {
          this.pushElement(_candidate, null);
          this.currentCursor.injectedOmittedNode = true;
          return this.__openElement(tag);
        }

        this.clearMismatch(_candidate);
      }

      return _NewElementBuilder.prototype.__openElement.call(this, tag);
    };

    _proto.__setAttribute = function __setAttribute(name, value, namespace) {
      var unmatched = this.unmatchedAttributes;

      if (unmatched) {
        var attr = findByName(unmatched, name);

        if (attr) {
          if (attr.value !== value) {
            attr.value = value;
          }

          unmatched.splice(unmatched.indexOf(attr), 1);
          return;
        }
      }

      return _NewElementBuilder.prototype.__setAttribute.call(this, name, value, namespace);
    };

    _proto.__setProperty = function __setProperty(name, value) {
      var unmatched = this.unmatchedAttributes;

      if (unmatched) {
        var attr = findByName(unmatched, name);

        if (attr) {
          if (attr.value !== value) {
            attr.value = value;
          }

          unmatched.splice(unmatched.indexOf(attr), 1);
          return;
        }
      }

      return _NewElementBuilder.prototype.__setProperty.call(this, name, value);
    };

    _proto.__flushElement = function __flushElement(parent, constructing) {
      var unmatched = this.unmatchedAttributes;

      if (unmatched) {
        for (var i = 0; i < unmatched.length; i++) {
          this.constructing.removeAttribute(unmatched[i].name);
        }

        this.unmatchedAttributes = null;
      } else {
        _NewElementBuilder.prototype.__flushElement.call(this, parent, constructing);
      }
    };

    _proto.willCloseElement = function willCloseElement() {
      var candidate = this.candidate,
          currentCursor = this.currentCursor;

      if (candidate !== null) {
        this.clearMismatch(candidate);
      }

      if (currentCursor && currentCursor.injectedOmittedNode) {
        this.popElement();
      }

      _NewElementBuilder.prototype.willCloseElement.call(this);
    };

    _proto.getMarker = function getMarker(element, guid) {
      var marker = element.querySelector("script[glmr=\"" + guid + "\"]");

      if (marker) {
        return marker;
      }

      return null;
    };

    _proto.__pushRemoteElement = function __pushRemoteElement(element, cursorId, insertBefore) {
      var marker = this.getMarker(element, cursorId);

      if (insertBefore === undefined) {
        while (element.firstChild !== null && element.firstChild !== marker) {
          this.remove(element.firstChild);
        }

        insertBefore = null;
      }

      var cursor = new RehydratingCursor(element, null, this.blockDepth);
      this[CURSOR_STACK].push(cursor);

      if (marker === null) {
        this.disableRehydration(insertBefore);
      } else {
        this.candidate = this.remove(marker);
      }

      var block = new RemoteLiveBlock(element);
      return this.pushLiveBlock(block, true);
    };

    _proto.didAppendBounds = function didAppendBounds(bounds) {
      _NewElementBuilder.prototype.didAppendBounds.call(this, bounds);

      if (this.candidate) {
        var last = bounds.lastNode();
        this.candidate = last && last.nextSibling;
      }

      return bounds;
    };

    _createClass$5(RehydrateBuilder, [{
      key: "currentCursor",
      get: function get() {
        return this[CURSOR_STACK].current;
      }
    }, {
      key: "candidate",
      get: function get() {
        if (this.currentCursor) {
          return this.currentCursor.candidate;
        }

        return null;
      },
      set: function set(node) {
        var currentCursor = this.currentCursor;
        currentCursor.candidate = node;
      }
    }]);

    return RehydrateBuilder;
  }(NewElementBuilder);

  function isTextNode(node) {
    return node.nodeType === 3;
  }

  function isComment(node) {
    return node.nodeType === 8;
  }

  function isOpenBlock(node) {
    return node.nodeType === 8
    /* COMMENT_NODE */
    && node.nodeValue.lastIndexOf('%+b:', 0) === 0;
  }

  function isCloseBlock(node) {
    return node.nodeType === 8
    /* COMMENT_NODE */
    && node.nodeValue.lastIndexOf('%-b:', 0) === 0;
  }

  function getBlockDepth(node) {
    return parseInt(node.nodeValue.slice(4), 10);
  }

  function getBlockDepthWithOffset(node, offset) {
    return getBlockDepth(node) - offset;
  }

  function isElement(node) {
    return node.nodeType === 1;
  }

  function isMarker(node) {
    return node.nodeType === 8 && node.nodeValue === '%glmr%';
  }

  function isSeparator(node) {
    return node.nodeType === 8 && node.nodeValue === '%|%';
  }

  function isEmpty$1(node) {
    return node.nodeType === 8 && node.nodeValue === '% %';
  }

  function isSameNodeType(candidate, tag) {
    if (candidate.namespaceURI === "http://www.w3.org/2000/svg"
    /* SVG */
    ) {
        return candidate.tagName === tag;
      }

    return candidate.tagName === tag.toUpperCase();
  }

  function findByName(array, name) {
    for (var i = 0; i < array.length; i++) {
      var attr = array[i];
      if (attr.name === name) return attr;
    }

    return undefined;
  }

  function rehydrationBuilder(env, cursor) {
    return RehydrateBuilder.forInitialRender(env, cursor);
  }

  function _defineProperties$6(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$6(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$6(Constructor.prototype, protoProps); if (staticProps) _defineProperties$6(Constructor, staticProps); return Constructor; }
  var ARGS_CACHES = env.DEBUG ? new WeakMap() : undefined;

  function getArgs(proxy) {
    return validator.getValue(env.DEBUG ? ARGS_CACHES.get(proxy) : proxy.argsCache);
  }

  var SimpleArgsProxy = /*#__PURE__*/function () {
    function SimpleArgsProxy(context, computeArgs) {
      if (computeArgs === void 0) {
        computeArgs = function computeArgs() {
          return EMPTY_ARGS;
        };
      }

      var argsCache = validator.createCache(function () {
        return computeArgs(context);
      });

      if (env.DEBUG) {
        ARGS_CACHES.set(this, argsCache);
        Object.freeze(this);
      } else {
        this.argsCache = argsCache;
      }
    }

    _createClass$6(SimpleArgsProxy, [{
      key: "named",
      get: function get() {
        return getArgs(this).named || EMPTY_NAMED;
      }
    }, {
      key: "positional",
      get: function get() {
        return getArgs(this).positional || EMPTY_POSITIONAL;
      }
    }]);

    return SimpleArgsProxy;
  }(); ////////////


  function invokeHelper(context, definition, computeArgs) {
    if (env.DEBUG && (typeof context !== 'object' || context === null)) {
      throw new Error("Expected a context object to be passed as the first parameter to invokeHelper, got " + context);
    }

    var owner$1 = owner.getOwner(context);
    var internalManager = manager.getInternalHelperManager(definition); // TODO: figure out why assert isn't using the TS assert thing

    if (env.DEBUG && !internalManager) {
      throw new Error("Expected a helper definition to be passed as the second parameter to invokeHelper, but no helper manager was found. The definition value that was passed was `" + util.debugToString(definition) + "`. Did you use setHelperManager to associate a helper manager with this value?");
    }

    if (env.DEBUG && typeof internalManager === 'function') {
      throw new Error('Found a helper manager, but it was an internal built-in helper manager. `invokeHelper` does not support internal helpers yet.');
    }

    var manager$1 = internalManager.getDelegateFor(owner$1);
    var args = new SimpleArgsProxy(context, computeArgs);
    var bucket = manager$1.createHelper(definition, args);
    var cache;

    if (manager.hasValue(manager$1)) {
      cache = validator.createCache(function () {
        if (env.DEBUG && (destroyable.isDestroying(cache) || destroyable.isDestroyed(cache))) {
          throw new Error("You attempted to get the value of a helper after the helper was destroyed, which is not allowed");
        }

        return manager$1.getValue(bucket);
      });
      destroyable.associateDestroyableChild(context, cache);
    } else {
      throw new Error('TODO: unreachable, to be implemented with hasScheduledEffect');
    }

    if (manager.hasDestroyable(manager$1)) {
      var destroyable$1 = manager$1.getDestroyable(bucket);
      destroyable.associateDestroyableChild(cache, destroyable$1);
    }

    return cache;
  }

  function internalHelper(helper) {
    return manager.setInternalHelperManager(helper, {});
  }

  var context = util.buildUntouchableThis('`fn` helper');
  /**
    The `fn` helper allows you to ensure a function that you are passing off
    to another component, helper, or modifier has access to arguments that are
    available in the template.

    For example, if you have an `each` helper looping over a number of items, you
    may need to pass a function that expects to receive the item as an argument
    to a component invoked within the loop. Here's how you could use the `fn`
    helper to pass both the function and its arguments together:

      ```app/templates/components/items-listing.hbs
    {{#each @items as |item|}}
      <DisplayItem @item=item @select={{fn this.handleSelected item}} />
    {{/each}}
    ```

    ```app/components/items-list.js
    import Component from '@glimmer/component';
    import { action } from '@ember/object';

    export default class ItemsList extends Component {
      handleSelected = (item) => {
        // ...snip...
      }
    }
    ```

    In this case the `display-item` component will receive a normal function
    that it can invoke. When it invokes the function, the `handleSelected`
    function will receive the `item` and any arguments passed, thanks to the
    `fn` helper.

    Let's take look at what that means in a couple circumstances:

    - When invoked as `this.args.select()` the `handleSelected` function will
      receive the `item` from the loop as its first and only argument.
    - When invoked as `this.args.select('foo')` the `handleSelected` function
      will receive the `item` from the loop as its first argument and the
      string `'foo'` as its second argument.

    In the example above, we used an arrow function to ensure that
    `handleSelected` is properly bound to the `items-list`, but let's explore what
    happens if we left out the arrow function:

    ```app/components/items-list.js
    import Component from '@glimmer/component';

    export default class ItemsList extends Component {
      handleSelected(item) {
        // ...snip...
      }
    }
    ```

    In this example, when `handleSelected` is invoked inside the `display-item`
    component, it will **not** have access to the component instance. In other
    words, it will have no `this` context, so please make sure your functions
    are bound (via an arrow function or other means) before passing into `fn`!

    See also [partial application](https://en.wikipedia.org/wiki/Partial_application).

    @method fn
    @public
  */

  var fn = internalHelper(function (_ref) {
    var positional = _ref.positional;
    var callbackRef = positional[0];
    if (env.DEBUG) assertCallbackIsFn(callbackRef);
    return reference.createComputeRef(function () {
      return function () {
        var _reifyPositional = runtime.reifyPositional(positional),
            fn = _reifyPositional[0],
            args = _reifyPositional.slice(1);

        if (env.DEBUG) assertCallbackIsFn(callbackRef);

        for (var _len = arguments.length, invocationArgs = new Array(_len), _key = 0; _key < _len; _key++) {
          invocationArgs[_key] = arguments[_key];
        }

        if (reference.isInvokableRef(callbackRef)) {
          var value = args.length > 0 ? args[0] : invocationArgs[0];
          return reference.updateRef(callbackRef, value);
        } else {
          return fn.call.apply(fn, [context].concat(args, invocationArgs));
        }
      };
    }, null, 'fn');
  });

  function assertCallbackIsFn(callbackRef) {
    if (!(callbackRef && (reference.isInvokableRef(callbackRef) || typeof reference.valueForRef(callbackRef) === 'function'))) {
      throw new Error("You must pass a function as the `fn` helper's first argument, you passed " + (callbackRef ? reference.valueForRef(callbackRef) : callbackRef) + ". While rendering:\n\n" + (callbackRef === null || callbackRef === void 0 ? void 0 : callbackRef.debugLabel));
    }
  }

  var wrapHashProxy;

  if (env.DEBUG) {
    wrapHashProxy = function wrapHashProxy(hash) {
      return new Proxy(hash, {
        set: function set(target, key, value) {
          globalContext.deprecate("You set the '" + String(key) + "' property on a {{hash}} object. Setting properties on objects generated by {{hash}} is deprecated. Please update to use an object created with a tracked property or getter, or with a custom helper.", false, {
            id: 'setting-on-hash'
          });
          target[key] = value;
          return true;
        }
      });
    };
  }
  /**
     Use the `{{hash}}` helper to create a hash to pass as an option to your
     components. This is specially useful for contextual components where you can
     just yield a hash:

     ```handlebars
     {{yield (hash
        name='Sarah'
        title=office
     )}}
     ```

     Would result in an object such as:

     ```js
     { name: 'Sarah', title: this.get('office') }
     ```

     Where the `title` is bound to updates of the `office` property.

     Note that the hash is an empty object with no prototype chain, therefore
     common methods like `toString` are not available in the resulting hash.
     If you need to use such a method, you can use the `call` or `apply`
     approach:

     ```js
     function toString(obj) {
       return Object.prototype.toString.apply(obj);
     }
     ```

     @method hash
     @param {Object} options
     @return {Object} Hash
     @public
   */


  var hash = internalHelper(function (_ref) {
    var named = _ref.named;
    var ref = reference.createComputeRef(function () {
      var hash = runtime.reifyNamed(named);

      if (env.DEBUG && util.HAS_NATIVE_PROXY) {
        hash = wrapHashProxy(hash);
      }

      return hash;
    }, null, 'hash'); // Setup the children so that templates can bypass getting the value of
    // the reference and treat children lazily

    var children = new Map();

    for (var name in named) {
      children.set(name, named[name]);
    }

    ref.children = children;
    return ref;
  });

  /**
     Use the `{{array}}` helper to create an array to pass as an option to your
     components.

     ```handlebars
     <MyComponent @people={{array
       'Tom Dale'
       'Yehuda Katz'
       this.myOtherPerson}}
     />
     ```
      or
     ```handlebars
     {{my-component people=(array
       'Tom Dale'
       'Yehuda Katz'
       this.myOtherPerson)
     }}
     ```

     Would result in an object such as:

     ```js
     ['Tom Dale', 'Yehuda Katz', this.get('myOtherPerson')]
     ```

     Where the 3rd item in the array is bound to updates of the `myOtherPerson` property.

     @method array
     @param {Array} options
     @return {Array} Array
     @public
   */

  var array = internalHelper(function (_ref) {
    var positional = _ref.positional;
    return reference.createComputeRef(function () {
      return runtime.reifyPositional(positional);
    }, null, 'array');
  });

  /**
    Dynamically look up a property on an object. The second argument to `{{get}}`
    should have a string value, although it can be bound.

    For example, these two usages are equivalent:

    ```app/components/developer-detail.js
    import Component from '@glimmer/component';
    import { tracked } from '@glimmer/tracking';

    export default class extends Component {
      @tracked developer = {
        name: "Sandi Metz",
        language: "Ruby"
      }
    }
    ```

    ```handlebars
    {{this.developer.name}}
    {{get this.developer "name"}}
    ```

    If there were several facts about a person, the `{{get}}` helper can dynamically
    pick one:

    ```app/templates/application.hbs
    <DeveloperDetail @factName="language" />
    ```

    ```handlebars
    {{get this.developer @factName}}
    ```

    For a more complex example, this template would allow the user to switch
    between showing the user's height and weight with a click:

    ```app/components/developer-detail.js
    import Component from '@glimmer/component';
    import { tracked } from '@glimmer/tracking';

    export default class extends Component {
      @tracked developer = {
        name: "Sandi Metz",
        language: "Ruby"
      }

      @tracked currentFact = 'name'

      showFact = (fact) => {
        this.currentFact = fact;
      }
    }
    ```

    ```app/components/developer-detail.js
    {{get this.developer this.currentFact}}

    <button {{on 'click' (fn this.showFact "name")}}>Show name</button>
    <button {{on 'click' (fn this.showFact "language")}}>Show language</button>
    ```

    The `{{get}}` helper can also respect mutable values itself. For example:

    ```app/components/developer-detail.js
    <Input @value={{mut (get this.person this.currentFact)}} />

    <button {{on 'click' (fn this.showFact "name")}}>Show name</button>
    <button {{on 'click' (fn this.showFact "language")}}>Show language</button>
    ```

    Would allow the user to swap what fact is being displayed, and also edit
    that fact via a two-way mutable binding.

    @public
    @method get
   */

  var get = internalHelper(function (_ref) {
    var positional = _ref.positional;

    var _a, _b;

    var sourceRef = (_a = positional[0]) !== null && _a !== void 0 ? _a : reference.UNDEFINED_REFERENCE;
    var pathRef = (_b = positional[1]) !== null && _b !== void 0 ? _b : reference.UNDEFINED_REFERENCE;
    return reference.createComputeRef(function () {
      var source = reference.valueForRef(sourceRef);

      if (util.isDict(source)) {
        return globalContext.getPath(source, String(reference.valueForRef(pathRef)));
      }
    }, function (value) {
      var source = reference.valueForRef(sourceRef);

      if (util.isDict(source)) {
        return globalContext.setPath(source, String(reference.valueForRef(pathRef)), value);
      }
    }, 'get');
  });

  var isEmpty$2 = function isEmpty(value) {
    return value === null || value === undefined || typeof value.toString !== 'function';
  };

  var normalizeTextValue = function normalizeTextValue(value) {
    if (isEmpty$2(value)) {
      return '';
    }

    return String(value);
  };
  /**
    Concatenates the given arguments into a string.

    Example:

    ```handlebars
    {{some-component name=(concat firstName " " lastName)}}

    {{! would pass name="<first name value> <last name value>" to the component}}
    ```

    or for angle bracket invocation, you actually don't need concat at all.

    ```handlebars
    <SomeComponent @name="{{firstName}} {{lastName}}" />
    ```

    @public
    @method concat
  */


  var concat = internalHelper(function (_ref) {
    var positional = _ref.positional;
    return reference.createComputeRef(function () {
      return runtime.reifyPositional(positional).map(normalizeTextValue).join('');
    }, null, 'concat');
  });

  function _defineProperties$7(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass$7(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$7(Constructor.prototype, protoProps); if (staticProps) _defineProperties$7(Constructor, staticProps); return Constructor; }
  var untouchableContext = util.buildUntouchableThis('`on` modifier');
  /*
    Internet Explorer 11 does not support `once` and also does not support
    passing `eventOptions`. In some situations it then throws a weird script
    error, like:

    ```
    Could not complete the operation due to error 80020101
    ```

    This flag determines, whether `{ once: true }` and thus also event options in
    general are supported.
  */

  var SUPPORTS_EVENT_OPTIONS = function () {
    try {
      var div = document.createElement('div');
      var counter = 0;
      div.addEventListener('click', function () {
        return counter++;
      }, {
        once: true
      });
      var event;

      if (typeof Event === 'function') {
        event = new Event('click');
      } else {
        event = document.createEvent('Event');
        event.initEvent('click', true, true);
      }

      div.dispatchEvent(event);
      div.dispatchEvent(event);
      return counter === 1;
    } catch (error) {
      return false;
    }
  }();

  var OnModifierState = /*#__PURE__*/function () {
    function OnModifierState(element, args) {
      this.tag = validator.createUpdatableTag();
      this.shouldUpdate = true;
      this.element = element;
      this.args = args;
    }

    var _proto = OnModifierState.prototype;

    _proto.updateFromArgs = function updateFromArgs() {
      var args = this.args;

      var _reifyNamed = runtime.reifyNamed(args.named),
          once = _reifyNamed.once,
          passive = _reifyNamed.passive,
          capture = _reifyNamed.capture;

      if (once !== this.once) {
        this.once = once;
        this.shouldUpdate = true;
      }

      if (passive !== this.passive) {
        this.passive = passive;
        this.shouldUpdate = true;
      }

      if (capture !== this.capture) {
        this.capture = capture;
        this.shouldUpdate = true;
      }

      var options;

      if (once || passive || capture) {
        options = this.options = {
          once: once,
          passive: passive,
          capture: capture
        };
      } else {
        this.options = undefined;
      }

      if (env.DEBUG && (args.positional[0] === undefined || typeof reference.valueForRef(args.positional[0]) !== 'string')) {
        throw new Error('You must pass a valid DOM event name as the first argument to the `on` modifier');
      }

      var eventName = reference.valueForRef(args.positional[0]);

      if (eventName !== this.eventName) {
        this.eventName = eventName;
        this.shouldUpdate = true;
      }

      var userProvidedCallbackReference = args.positional[1];

      if (env.DEBUG) {
        if (args.positional[1] === undefined) {
          throw new Error("You must pass a function as the second argument to the `on` modifier.");
        }

        var value = reference.valueForRef(userProvidedCallbackReference);

        if (typeof value !== 'function') {
          throw new Error("You must pass a function as the second argument to the `on` modifier; you passed " + (value === null ? 'null' : typeof value) + ". While rendering:\n\n" + userProvidedCallbackReference.debugLabel);
        }
      }

      var userProvidedCallback = reference.valueForRef(userProvidedCallbackReference);

      if (userProvidedCallback !== this.userProvidedCallback) {
        this.userProvidedCallback = userProvidedCallback;
        this.shouldUpdate = true;
      }

      if (env.DEBUG && args.positional.length !== 2) {
        throw new Error("You can only pass two positional arguments (event name and callback) to the `on` modifier, but you provided " + args.positional.length + ". Consider using the `fn` helper to provide additional arguments to the `on` callback.");
      }

      var needsCustomCallback = SUPPORTS_EVENT_OPTIONS === false && once ||
      /* needs manual once implementation */
      env.DEBUG && passive;
      /* needs passive enforcement */

      if (this.shouldUpdate) {
        if (needsCustomCallback) {
          var callback = this.callback = function (event) {
            if (env.DEBUG && passive) {
              event.preventDefault = function () {
                throw new Error("You marked this listener as 'passive', meaning that you must not call 'event.preventDefault()': \n\n" + userProvidedCallback);
              };
            }

            if (!SUPPORTS_EVENT_OPTIONS && once) {
              removeEventListener(this, eventName, callback, options);
            }

            return userProvidedCallback.call(untouchableContext, event);
          };
        } else if (env.DEBUG) {
          // prevent the callback from being bound to the element
          this.callback = userProvidedCallback.bind(untouchableContext);
        } else {
          this.callback = userProvidedCallback;
        }
      }
    };

    return OnModifierState;
  }();
  var adds = 0;
  var removes = 0;

  function removeEventListener(element, eventName, callback, options) {
    removes++;

    if (SUPPORTS_EVENT_OPTIONS) {
      // when options are supported, use them across the board
      element.removeEventListener(eventName, callback, options);
    } else if (options !== undefined && options.capture) {
      // used only in the following case:
      //
      // `{ once: true | false, passive: true | false, capture: true }
      //
      // `once` is handled via a custom callback that removes after first
      // invocation so we only care about capture here as a boolean
      element.removeEventListener(eventName, callback, true);
    } else {
      // used only in the following cases:
      //
      // * where there is no options
      // * `{ once: true | false, passive: true | false, capture: false }
      element.removeEventListener(eventName, callback);
    }
  }

  function addEventListener(element, eventName, callback, options) {
    adds++;

    if (SUPPORTS_EVENT_OPTIONS) {
      // when options are supported, use them across the board
      element.addEventListener(eventName, callback, options);
    } else if (options !== undefined && options.capture) {
      // used only in the following case:
      //
      // `{ once: true | false, passive: true | false, capture: true }
      //
      // `once` is handled via a custom callback that removes after first
      // invocation so we only care about capture here as a boolean
      element.addEventListener(eventName, callback, true);
    } else {
      // used only in the following cases:
      //
      // * where there is no options
      // * `{ once: true | false, passive: true | false, capture: false }
      element.addEventListener(eventName, callback);
    }
  }
  /**
    The `{{on}}` modifier lets you easily add event listeners (it uses
    [EventTarget.addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)
    internally).

    For example, if you'd like to run a function on your component when a `<button>`
    in the components template is clicked you might do something like:

    ```app/components/like-post.hbs
    <button {{on 'click' this.saveLike}}>Like this post!</button>
    ```

    ```app/components/like-post.js
    import Component from '@glimmer/component';
    import { action } from '@ember/object';

    export default class LikePostComponent extends Component {
      saveLike = () => {
        // someone likes your post!
        // better send a request off to your server...
      }
    }
    ```

    ### Arguments

    `{{on}}` accepts two positional arguments, and a few named arguments.

    The positional arguments are:

    - `event` -- the name to use when calling `addEventListener`
    - `callback` -- the function to be passed to `addEventListener`

    The named arguments are:

    - capture -- a `true` value indicates that events of this type will be dispatched
      to the registered listener before being dispatched to any EventTarget beneath it
      in the DOM tree.
    - once -- indicates that the listener should be invoked at most once after being
      added. If true, the listener would be automatically removed when invoked.
    - passive -- if `true`, indicates that the function specified by listener will never
      call preventDefault(). If a passive listener does call preventDefault(), the user
      agent will do nothing other than generate a console warning. See
      [Improving scrolling performance with passive listeners](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners)
      to learn more.

    The callback function passed to `{{on}}` will receive any arguments that are passed
    to the event handler. Most commonly this would be the `event` itself.

    If you would like to pass additional arguments to the function you should use
    the `{{fn}}` helper.

    For example, in our example case above if you'd like to pass in the post that
    was being liked when the button is clicked you could do something like:

    ```app/components/like-post.hbs
    <button {{on 'click' (fn this.saveLike @post)}}>Like this post!</button>
    ```

    In this case, the `saveLike` function will receive two arguments: the click event
    and the value of `@post`.

    ### Function Context

    In the example above, we used an arrow function to ensure that `likePost` is
    properly bound to the `items-list`, but let's explore what happens if we
    left out the arrow function:

    ```app/components/like-post.js
    import Component from '@glimmer/component';

    export default class LikePostComponent extends Component {
      saveLike() {
        // ...snip...
      }
    }
    ```

    In this example, when the button is clicked `saveLike` will be invoked,
    it will **not** have access to the component instance. In other
    words, it will have no `this` context, so please make sure your functions
    are bound (via an arrow function or other means) before passing into `on`!

    @method on
    @public
  */


  var OnModifierManager = /*#__PURE__*/function () {
    function OnModifierManager() {
      this.SUPPORTS_EVENT_OPTIONS = SUPPORTS_EVENT_OPTIONS;
    }

    var _proto2 = OnModifierManager.prototype;

    _proto2.getDebugName = function getDebugName() {
      return 'on';
    };

    _proto2.create = function create(_owner, element, _state, args) {
      return new OnModifierState(element, args);
    };

    _proto2.getTag = function getTag(state) {
      if (state === null) {
        return null;
      }

      return state.tag;
    };

    _proto2.install = function install(state) {
      if (state === null) {
        return;
      }

      state.updateFromArgs();
      var element = state.element,
          eventName = state.eventName,
          callback = state.callback,
          options = state.options;
      addEventListener(element, eventName, callback, options);
      destroyable.registerDestructor(state, function () {
        return removeEventListener(element, eventName, callback, options);
      });
      state.shouldUpdate = false;
    };

    _proto2.update = function update(state) {
      if (state === null) {
        return;
      } // stash prior state for el.removeEventListener


      var element = state.element,
          eventName = state.eventName,
          callback = state.callback,
          options = state.options;
      state.updateFromArgs();

      if (!state.shouldUpdate) {
        return;
      } // use prior state values for removal


      removeEventListener(element, eventName, callback, options); // read updated values from the state object

      addEventListener(state.element, state.eventName, state.callback, state.options);
      state.shouldUpdate = false;
    };

    _proto2.getDestroyable = function getDestroyable(state) {
      return state;
    };

    _createClass$7(OnModifierManager, [{
      key: "counters",
      get: function get() {
        return {
          adds: adds,
          removes: removes
        };
      }
    }]);

    return OnModifierManager;
  }();

  var on = manager.setInternalModifierManager(new OnModifierManager(), {});

  Object.defineProperty(exports, 'destroy', {
    enumerable: true,
    get: function () {
      return destroyable.destroy;
    }
  });
  Object.defineProperty(exports, 'isDestroyed', {
    enumerable: true,
    get: function () {
      return destroyable.isDestroyed;
    }
  });
  Object.defineProperty(exports, 'isDestroying', {
    enumerable: true,
    get: function () {
      return destroyable.isDestroying;
    }
  });
  Object.defineProperty(exports, 'registerDestructor', {
    enumerable: true,
    get: function () {
      return destroyable.registerDestructor;
    }
  });
  exports.ConcreteBounds = ConcreteBounds;
  exports.CurriedValue = CurriedValue;
  exports.CursorImpl = CursorImpl;
  exports.DOMChanges = helper$1;
  exports.DOMTreeConstruction = DOMTreeConstruction;
  exports.DynamicAttribute = DynamicAttribute;
  exports.DynamicScopeImpl = DynamicScopeImpl;
  exports.EMPTY_ARGS = EMPTY_ARGS;
  exports.EMPTY_NAMED = EMPTY_NAMED;
  exports.EMPTY_POSITIONAL = EMPTY_POSITIONAL;
  exports.EnvironmentImpl = EnvironmentImpl;
  exports.IDOMChanges = DOMChangesImpl;
  exports.LowLevelVM = VM;
  exports.NewElementBuilder = NewElementBuilder;
  exports.PartialScopeImpl = PartialScopeImpl;
  exports.RehydrateBuilder = RehydrateBuilder;
  exports.RemoteLiveBlock = RemoteLiveBlock;
  exports.SERIALIZATION_FIRST_NODE_STRING = SERIALIZATION_FIRST_NODE_STRING;
  exports.SimpleDynamicAttribute = SimpleDynamicAttribute;
  exports.TEMPLATE_ONLY_COMPONENT_MANAGER = TEMPLATE_ONLY_COMPONENT_MANAGER;
  exports.TemplateOnlyComponent = TemplateOnlyComponentDefinition;
  exports.TemplateOnlyComponentManager = TemplateOnlyComponentManager;
  exports.UpdatableBlockImpl = UpdatableBlockImpl;
  exports.UpdatingVM = UpdatingVMImpl;
  exports.array = array;
  exports.clear = clear;
  exports.clientBuilder = clientBuilder;
  exports.concat = concat;
  exports.createCapturedArgs = createCapturedArgs;
  exports.curry = curry;
  exports.dynamicAttribute = dynamicAttribute;
  exports.fn = fn;
  exports.get = get;
  exports.hash = hash;
  exports.inTransaction = inTransaction;
  exports.invokeHelper = invokeHelper;
  exports.isSerializationFirstNode = isSerializationFirstNode;
  exports.isWhitespace = isWhitespace;
  exports.normalizeProperty = normalizeProperty;
  exports.on = on;
  exports.rehydrationBuilder = rehydrationBuilder;
  exports.reifyArgs = reifyArgs;
  exports.reifyNamed = reifyNamed;
  exports.reifyPositional = reifyPositional;
  exports.renderComponent = renderComponent;
  exports.renderMain = renderMain;
  exports.renderSync = renderSync;
  exports.resetDebuggerCallback = resetDebuggerCallback;
  exports.runtimeContext = runtimeContext;
  exports.setDebuggerCallback = setDebuggerCallback;
  exports.templateOnlyComponent = templateOnlyComponent;

  Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci1ydW50aW1lLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9zY29wZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3N5bWJvbHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9ib3VuZHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9kb20vbm9ybWFsaXplLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvZG9tL3Byb3BzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvZG9tL3Nhbml0aXplZC12YWx1ZXMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi92bS9hdHRyaWJ1dGVzL2R5bmFtaWMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi92bS9lbGVtZW50LWJ1aWxkZXIudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9vcGNvZGVzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvY29tcGlsZWQvZXhwcmVzc2lvbnMvY29uY2F0LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvY3VycmllZC12YWx1ZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3JlZmVyZW5jZXMvY3VycnktdmFsdWUudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi92bS9hcmd1bWVudHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9jb21waWxlZC9vcGNvZGVzL2V4cHJlc3Npb25zLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvY29tcG9uZW50L3Jlc29sdmUudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9jb21wb25lbnQvaW50ZXJmYWNlcy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3JlZmVyZW5jZXMvY2xhc3MtbGlzdC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBpbGVkL29wY29kZXMvdm0udHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9jb21waWxlZC9vcGNvZGVzL2RvbS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBpbGVkL29wY29kZXMvY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvdm0vY29udGVudC90ZXh0LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvY29tcGlsZWQvb3Bjb2Rlcy9jb250ZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvY29tcGlsZWQvb3Bjb2Rlcy9kZWJ1Z2dlci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBpbGVkL29wY29kZXMvbGlzdHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9jb21wb25lbnQvdGVtcGxhdGUtb25seS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2RvbS9vcGVyYXRpb25zLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvY29tcGF0L3N2Zy1pbm5lci1odG1sLWZpeC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBhdC90ZXh0LW5vZGUtbWVyZ2luZy1maXgudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9kb20vaGVscGVyLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvZGVidWctcmVuZGVyLXRyZWUudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9lbnZpcm9ubWVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3ZtL2xvdy1sZXZlbC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3ZtL3VwZGF0ZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3ZtL3JlbmRlci1yZXN1bHQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi92bS9zdGFjay50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3ZtL2FwcGVuZC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3JlbmRlci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3ZtL3JlaHlkcmF0ZS1idWlsZGVyLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvaGVscGVycy9pbnZva2UudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9oZWxwZXJzL2ludGVybmFsLWhlbHBlci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2hlbHBlcnMvZm4udHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9oZWxwZXJzL2hhc2gudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9oZWxwZXJzL2FycmF5LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcnVudGltZS9saWIvaGVscGVycy9nZXQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9ydW50aW1lL2xpYi9oZWxwZXJzL2NvbmNhdC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL21vZGlmaWVycy9vbi50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEeW5hbWljU2NvcGUsXG4gIERpY3QsXG4gIFBhcnRpYWxTY29wZSxcbiAgU2NvcGVTbG90LFxuICBTY29wZUJsb2NrLFxuICBPcHRpb24sXG4gIFNjb3BlLFxuICBPd25lcixcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IFJlZmVyZW5jZSwgVU5ERUZJTkVEX1JFRkVSRU5DRSB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5cbmV4cG9ydCBjbGFzcyBEeW5hbWljU2NvcGVJbXBsIGltcGxlbWVudHMgRHluYW1pY1Njb3BlIHtcbiAgcHJpdmF0ZSBidWNrZXQ6IERpY3Q8UmVmZXJlbmNlPjtcblxuICBjb25zdHJ1Y3RvcihidWNrZXQ/OiBEaWN0PFJlZmVyZW5jZT4pIHtcbiAgICBpZiAoYnVja2V0KSB7XG4gICAgICB0aGlzLmJ1Y2tldCA9IGFzc2lnbih7fSwgYnVja2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5idWNrZXQgPSB7fTtcbiAgICB9XG4gIH1cblxuICBnZXQoa2V5OiBzdHJpbmcpOiBSZWZlcmVuY2Uge1xuICAgIHJldHVybiB0aGlzLmJ1Y2tldFtrZXldO1xuICB9XG5cbiAgc2V0KGtleTogc3RyaW5nLCByZWZlcmVuY2U6IFJlZmVyZW5jZSk6IFJlZmVyZW5jZSB7XG4gICAgcmV0dXJuICh0aGlzLmJ1Y2tldFtrZXldID0gcmVmZXJlbmNlKTtcbiAgfVxuXG4gIGNoaWxkKCk6IER5bmFtaWNTY29wZUltcGwge1xuICAgIHJldHVybiBuZXcgRHluYW1pY1Njb3BlSW1wbCh0aGlzLmJ1Y2tldCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2NvcGVSZWZlcmVuY2UoczogU2NvcGVTbG90KTogcyBpcyBSZWZlcmVuY2Uge1xuICBpZiAocyA9PT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KHMpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgY2xhc3MgUGFydGlhbFNjb3BlSW1wbCBpbXBsZW1lbnRzIFBhcnRpYWxTY29wZSB7XG4gIHN0YXRpYyByb290KHNlbGY6IFJlZmVyZW5jZTx1bmtub3duPiwgc2l6ZSA9IDAsIG93bmVyOiBPd25lcik6IFBhcnRpYWxTY29wZSB7XG4gICAgbGV0IHJlZnM6IFJlZmVyZW5jZTx1bmtub3duPltdID0gbmV3IEFycmF5KHNpemUgKyAxKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHNpemU7IGkrKykge1xuICAgICAgcmVmc1tpXSA9IFVOREVGSU5FRF9SRUZFUkVOQ0U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQYXJ0aWFsU2NvcGVJbXBsKHJlZnMsIG93bmVyLCBudWxsLCBudWxsLCBudWxsKS5pbml0KHsgc2VsZiB9KTtcbiAgfVxuXG4gIHN0YXRpYyBzaXplZChzaXplID0gMCwgb3duZXI6IE93bmVyKTogU2NvcGUge1xuICAgIGxldCByZWZzOiBSZWZlcmVuY2U8dW5rbm93bj5bXSA9IG5ldyBBcnJheShzaXplICsgMSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBzaXplOyBpKyspIHtcbiAgICAgIHJlZnNbaV0gPSBVTkRFRklORURfUkVGRVJFTkNFO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUGFydGlhbFNjb3BlSW1wbChyZWZzLCBvd25lciwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihcbiAgICAvLyB0aGUgMHRoIHNsb3QgaXMgYHNlbGZgXG4gICAgcmVhZG9ubHkgc2xvdHM6IEFycmF5PFNjb3BlU2xvdD4sXG4gICAgcmVhZG9ubHkgb3duZXI6IE93bmVyLFxuICAgIHByaXZhdGUgY2FsbGVyU2NvcGU6IFNjb3BlIHwgbnVsbCxcbiAgICAvLyBuYW1lZCBhcmd1bWVudHMgYW5kIGJsb2NrcyBwYXNzZWQgdG8gYSBsYXlvdXQgdGhhdCB1c2VzIGV2YWxcbiAgICBwcml2YXRlIGV2YWxTY29wZTogRGljdDxTY29wZVNsb3Q+IHwgbnVsbCxcbiAgICAvLyBsb2NhbHMgaW4gc2NvcGUgd2hlbiB0aGUgcGFydGlhbCB3YXMgaW52b2tlZFxuICAgIHByaXZhdGUgcGFydGlhbE1hcDogRGljdDxSZWZlcmVuY2U8dW5rbm93bj4+IHwgbnVsbFxuICApIHt9XG5cbiAgaW5pdCh7IHNlbGYgfTogeyBzZWxmOiBSZWZlcmVuY2U8dW5rbm93bj4gfSk6IHRoaXMge1xuICAgIHRoaXMuc2xvdHNbMF0gPSBzZWxmO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0U2VsZigpOiBSZWZlcmVuY2U8dW5rbm93bj4ge1xuICAgIHJldHVybiB0aGlzLmdldDxSZWZlcmVuY2U8dW5rbm93bj4+KDApO1xuICB9XG5cbiAgZ2V0U3ltYm9sKHN5bWJvbDogbnVtYmVyKTogUmVmZXJlbmNlPHVua25vd24+IHtcbiAgICByZXR1cm4gdGhpcy5nZXQ8UmVmZXJlbmNlPHVua25vd24+PihzeW1ib2wpO1xuICB9XG5cbiAgZ2V0QmxvY2soc3ltYm9sOiBudW1iZXIpOiBPcHRpb248U2NvcGVCbG9jaz4ge1xuICAgIGxldCBibG9jayA9IHRoaXMuZ2V0KHN5bWJvbCk7XG4gICAgcmV0dXJuIGJsb2NrID09PSBVTkRFRklORURfUkVGRVJFTkNFID8gbnVsbCA6IChibG9jayBhcyBTY29wZUJsb2NrKTtcbiAgfVxuXG4gIGdldEV2YWxTY29wZSgpOiBPcHRpb248RGljdDxTY29wZVNsb3Q+PiB7XG4gICAgcmV0dXJuIHRoaXMuZXZhbFNjb3BlO1xuICB9XG5cbiAgZ2V0UGFydGlhbE1hcCgpOiBPcHRpb248RGljdDxSZWZlcmVuY2U8dW5rbm93bj4+PiB7XG4gICAgcmV0dXJuIHRoaXMucGFydGlhbE1hcDtcbiAgfVxuXG4gIGJpbmQoc3ltYm9sOiBudW1iZXIsIHZhbHVlOiBTY29wZVNsb3QpIHtcbiAgICB0aGlzLnNldChzeW1ib2wsIHZhbHVlKTtcbiAgfVxuXG4gIGJpbmRTZWxmKHNlbGY6IFJlZmVyZW5jZTx1bmtub3duPikge1xuICAgIHRoaXMuc2V0PFJlZmVyZW5jZTx1bmtub3duPj4oMCwgc2VsZik7XG4gIH1cblxuICBiaW5kU3ltYm9sKHN5bWJvbDogbnVtYmVyLCB2YWx1ZTogUmVmZXJlbmNlPHVua25vd24+KSB7XG4gICAgdGhpcy5zZXQoc3ltYm9sLCB2YWx1ZSk7XG4gIH1cblxuICBiaW5kQmxvY2soc3ltYm9sOiBudW1iZXIsIHZhbHVlOiBPcHRpb248U2NvcGVCbG9jaz4pIHtcbiAgICB0aGlzLnNldDxPcHRpb248U2NvcGVCbG9jaz4+KHN5bWJvbCwgdmFsdWUpO1xuICB9XG5cbiAgYmluZEV2YWxTY29wZShtYXA6IE9wdGlvbjxEaWN0PFNjb3BlU2xvdD4+KSB7XG4gICAgdGhpcy5ldmFsU2NvcGUgPSBtYXA7XG4gIH1cblxuICBiaW5kUGFydGlhbE1hcChtYXA6IERpY3Q8UmVmZXJlbmNlPHVua25vd24+Pikge1xuICAgIHRoaXMucGFydGlhbE1hcCA9IG1hcDtcbiAgfVxuXG4gIGJpbmRDYWxsZXJTY29wZShzY29wZTogT3B0aW9uPFNjb3BlPik6IHZvaWQge1xuICAgIHRoaXMuY2FsbGVyU2NvcGUgPSBzY29wZTtcbiAgfVxuXG4gIGdldENhbGxlclNjb3BlKCk6IE9wdGlvbjxTY29wZT4ge1xuICAgIHJldHVybiB0aGlzLmNhbGxlclNjb3BlO1xuICB9XG5cbiAgY2hpbGQoKTogU2NvcGUge1xuICAgIHJldHVybiBuZXcgUGFydGlhbFNjb3BlSW1wbChcbiAgICAgIHRoaXMuc2xvdHMuc2xpY2UoKSxcbiAgICAgIHRoaXMub3duZXIsXG4gICAgICB0aGlzLmNhbGxlclNjb3BlLFxuICAgICAgdGhpcy5ldmFsU2NvcGUsXG4gICAgICB0aGlzLnBhcnRpYWxNYXBcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQ8VCBleHRlbmRzIFNjb3BlU2xvdD4oaW5kZXg6IG51bWJlcik6IFQge1xuICAgIGlmIChpbmRleCA+PSB0aGlzLnNsb3RzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEJVRzogY2Fubm90IGdldCAkJHtpbmRleH0gZnJvbSBzY29wZTsgbGVuZ3RoPSR7dGhpcy5zbG90cy5sZW5ndGh9YCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2xvdHNbaW5kZXhdIGFzIFQ7XG4gIH1cblxuICBwcml2YXRlIHNldDxUIGV4dGVuZHMgU2NvcGVTbG90PihpbmRleDogbnVtYmVyLCB2YWx1ZTogVCk6IHZvaWQge1xuICAgIGlmIChpbmRleCA+PSB0aGlzLnNsb3RzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEJVRzogY2Fubm90IGdldCAkJHtpbmRleH0gZnJvbSBzY29wZTsgbGVuZ3RoPSR7dGhpcy5zbG90cy5sZW5ndGh9YCk7XG4gICAgfVxuXG4gICAgdGhpcy5zbG90c1tpbmRleF0gPSB2YWx1ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgc3ltYm9sIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbi8vIFRoZXNlIHN5bWJvbHMgcmVwcmVzZW50IFwiZnJpZW5kXCIgcHJvcGVydGllcyB0aGF0IGFyZSB1c2VkIGluc2lkZSBvZlxuLy8gdGhlIFZNIGluIG90aGVyIGNsYXNzZXMsIGJ1dCBhcmUgbm90IGludGVuZGVkIHRvIGJlIGEgcGFydCBvZlxuLy8gR2xpbW1lcidzIEFQSS5cblxuZXhwb3J0IGNvbnN0IElOTkVSX1ZNOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdJTk5FUl9WTScpO1xuZXhwb3J0IGNvbnN0IERFU1RST1lBQkxFX1NUQUNLOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdERVNUUk9ZQUJMRV9TVEFDSycpO1xuZXhwb3J0IGNvbnN0IFNUQUNLUzogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnU1RBQ0tTJyk7XG5leHBvcnQgY29uc3QgUkVHSVNURVJTOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdSRUdJU1RFUlMnKTtcbmV4cG9ydCBjb25zdCBIRUFQOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdIRUFQJyk7XG5leHBvcnQgY29uc3QgQ09OU1RBTlRTOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdDT05TVEFOVFMnKTtcbmV4cG9ydCBjb25zdCBBUkdTOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdBUkdTJyk7XG5leHBvcnQgY29uc3QgUEM6IHVuaXF1ZSBzeW1ib2wgPSBzeW1ib2woJ1BDJyk7XG4iLCJpbXBvcnQgeyBCb3VuZHMsIEN1cnNvciwgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBTaW1wbGVFbGVtZW50LCBTaW1wbGVOb2RlIH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcbmltcG9ydCB7IGV4cGVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5leHBvcnQgY2xhc3MgQ3Vyc29ySW1wbCBpbXBsZW1lbnRzIEN1cnNvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50OiBTaW1wbGVFbGVtZW50LCBwdWJsaWMgbmV4dFNpYmxpbmc6IE9wdGlvbjxTaW1wbGVOb2RlPikge31cbn1cblxuZXhwb3J0IHR5cGUgRGVzdHJveWFibGVCb3VuZHMgPSBCb3VuZHM7XG5cbmV4cG9ydCBjbGFzcyBDb25jcmV0ZUJvdW5kcyBpbXBsZW1lbnRzIEJvdW5kcyB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBwYXJlbnROb2RlOiBTaW1wbGVFbGVtZW50LFxuICAgIHByaXZhdGUgZmlyc3Q6IFNpbXBsZU5vZGUsXG4gICAgcHJpdmF0ZSBsYXN0OiBTaW1wbGVOb2RlXG4gICkge31cblxuICBwYXJlbnRFbGVtZW50KCk6IFNpbXBsZUVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGU7XG4gIH1cblxuICBmaXJzdE5vZGUoKTogU2ltcGxlTm9kZSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3Q7XG4gIH1cblxuICBsYXN0Tm9kZSgpOiBTaW1wbGVOb2RlIHtcbiAgICByZXR1cm4gdGhpcy5sYXN0O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTaW5nbGVOb2RlQm91bmRzIGltcGxlbWVudHMgQm91bmRzIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwYXJlbnROb2RlOiBTaW1wbGVFbGVtZW50LCBwcml2YXRlIG5vZGU6IFNpbXBsZU5vZGUpIHt9XG5cbiAgcGFyZW50RWxlbWVudCgpOiBTaW1wbGVFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlO1xuICB9XG5cbiAgZmlyc3ROb2RlKCk6IFNpbXBsZU5vZGUge1xuICAgIHJldHVybiB0aGlzLm5vZGU7XG4gIH1cblxuICBsYXN0Tm9kZSgpOiBTaW1wbGVOb2RlIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb3ZlKGJvdW5kczogQm91bmRzLCByZWZlcmVuY2U6IE9wdGlvbjxTaW1wbGVOb2RlPik6IE9wdGlvbjxTaW1wbGVOb2RlPiB7XG4gIGxldCBwYXJlbnQgPSBib3VuZHMucGFyZW50RWxlbWVudCgpO1xuICBsZXQgZmlyc3QgPSBib3VuZHMuZmlyc3ROb2RlKCk7XG4gIGxldCBsYXN0ID0gYm91bmRzLmxhc3ROb2RlKCk7XG5cbiAgbGV0IGN1cnJlbnQ6IFNpbXBsZU5vZGUgPSBmaXJzdDtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxldCBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcblxuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY3VycmVudCwgcmVmZXJlbmNlKTtcblxuICAgIGlmIChjdXJyZW50ID09PSBsYXN0KSB7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG5cbiAgICBjdXJyZW50ID0gZXhwZWN0KG5leHQsICdpbnZhbGlkIGJvdW5kcycpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhcihib3VuZHM6IEJvdW5kcyk6IE9wdGlvbjxTaW1wbGVOb2RlPiB7XG4gIGxldCBwYXJlbnQgPSBib3VuZHMucGFyZW50RWxlbWVudCgpO1xuICBsZXQgZmlyc3QgPSBib3VuZHMuZmlyc3ROb2RlKCk7XG4gIGxldCBsYXN0ID0gYm91bmRzLmxhc3ROb2RlKCk7XG5cbiAgbGV0IGN1cnJlbnQ6IFNpbXBsZU5vZGUgPSBmaXJzdDtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxldCBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcblxuICAgIHBhcmVudC5yZW1vdmVDaGlsZChjdXJyZW50KTtcblxuICAgIGlmIChjdXJyZW50ID09PSBsYXN0KSB7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9XG5cbiAgICBjdXJyZW50ID0gZXhwZWN0KG5leHQsICdpbnZhbGlkIGJvdW5kcycpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBEaWN0IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBTaW1wbGVOb2RlLCBTaW1wbGVEb2N1bWVudEZyYWdtZW50IH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcblxuZXhwb3J0IGludGVyZmFjZSBTYWZlU3RyaW5nIHtcbiAgdG9IVE1MKCk6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgSW5zZXJ0aW9uID0gQ2F1dGlvdXNJbnNlcnRpb24gfCBUcnVzdGluZ0luc2VydGlvbjtcbmV4cG9ydCB0eXBlIENhdXRpb3VzSW5zZXJ0aW9uID0gc3RyaW5nIHwgU2FmZVN0cmluZyB8IFNpbXBsZU5vZGU7XG5leHBvcnQgdHlwZSBUcnVzdGluZ0luc2VydGlvbiA9IHN0cmluZyB8IFNpbXBsZU5vZGU7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTdHJpbmdWYWx1ZSh2YWx1ZTogdW5rbm93bik6IHN0cmluZyB7XG4gIGlmIChpc0VtcHR5KHZhbHVlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVRydXN0ZWRWYWx1ZSh2YWx1ZTogdW5rbm93bik6IFRydXN0aW5nSW5zZXJ0aW9uIHtcbiAgaWYgKGlzRW1wdHkodmFsdWUpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU2FmZVN0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUudG9IVE1MKCk7XG4gIH1cbiAgaWYgKGlzTm9kZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRDb2VyY2UoXG4gIHZhbHVlOiB1bmtub3duXG4pOiB2YWx1ZSBpcyBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiAoXG4gICAgaXNTdHJpbmcodmFsdWUpIHx8IGlzRW1wdHkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkodmFsdWU6IHVua25vd24pOiBib29sZWFuIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mICh2YWx1ZSBhcyBEaWN0KS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2FmZVN0cmluZyh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFNhZmVTdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgKHZhbHVlIGFzIGFueSkudG9IVE1MID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOb2RlKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgU2ltcGxlTm9kZSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiAodmFsdWUgYXMgYW55KS5ub2RlVHlwZSA9PT0gJ251bWJlcic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZyYWdtZW50KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgU2ltcGxlRG9jdW1lbnRGcmFnbWVudCB7XG4gIHJldHVybiBpc05vZGUodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxMTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgc3RyaW5nIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG4iLCJpbXBvcnQgeyBEaWN0IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBTaW1wbGVFbGVtZW50IH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcblxuLypcbiAqIEBtZXRob2Qgbm9ybWFsaXplUHJvcGVydHlcbiAqIEBwYXJhbSBlbGVtZW50IHtIVE1MRWxlbWVudH1cbiAqIEBwYXJhbSBzbG90TmFtZSB7U3RyaW5nfVxuICogQHJldHVybnMge09iamVjdH0geyBuYW1lLCB0eXBlIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BlcnR5KGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsIHNsb3ROYW1lOiBzdHJpbmcpIHtcbiAgbGV0IHR5cGUsIG5vcm1hbGl6ZWQ7XG5cbiAgaWYgKHNsb3ROYW1lIGluIGVsZW1lbnQpIHtcbiAgICBub3JtYWxpemVkID0gc2xvdE5hbWU7XG4gICAgdHlwZSA9ICdwcm9wJztcbiAgfSBlbHNlIHtcbiAgICBsZXQgbG93ZXIgPSBzbG90TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlciBpbiBlbGVtZW50KSB7XG4gICAgICB0eXBlID0gJ3Byb3AnO1xuICAgICAgbm9ybWFsaXplZCA9IGxvd2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gJ2F0dHInO1xuICAgICAgbm9ybWFsaXplZCA9IHNsb3ROYW1lO1xuICAgIH1cbiAgfVxuXG4gIGlmIChcbiAgICB0eXBlID09PSAncHJvcCcgJiZcbiAgICAobm9ybWFsaXplZC50b0xvd2VyQ2FzZSgpID09PSAnc3R5bGUnIHx8IHByZWZlckF0dHIoZWxlbWVudC50YWdOYW1lLCBub3JtYWxpemVkKSlcbiAgKSB7XG4gICAgdHlwZSA9ICdhdHRyJztcbiAgfVxuXG4gIHJldHVybiB7IG5vcm1hbGl6ZWQsIHR5cGUgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BlcnR5VmFsdWUodmFsdWU6IHVua25vd24pOiB1bmtub3duIHtcbiAgaWYgKHZhbHVlID09PSAnJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBwcm9wZXJ0aWVzIHRoYXQgTVVTVCBiZSBzZXQgYXMgYXR0cmlidXRlcywgZHVlIHRvOlxuLy8gKiBicm93c2VyIGJ1Z1xuLy8gKiBzdHJhbmdlIHNwZWMgb3V0bGllclxuY29uc3QgQVRUUl9PVkVSUklERVM6IERpY3Q8RGljdD4gPSB7XG4gIElOUFVUOiB7XG4gICAgZm9ybTogdHJ1ZSxcbiAgICAvLyBDaHJvbWUgNDYuMC4yNDY0LjA6ICdhdXRvY29ycmVjdCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSA9PT0gZmFsc2VcbiAgICAvLyBTYWZhcmkgOC4wLjc6ICdhdXRvY29ycmVjdCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSA9PT0gZmFsc2VcbiAgICAvLyBNb2JpbGUgU2FmYXJpIChpT1MgOC40IHNpbXVsYXRvcik6ICdhdXRvY29ycmVjdCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSA9PT0gdHJ1ZVxuICAgIGF1dG9jb3JyZWN0OiB0cnVlLFxuICAgIC8vIENocm9tZSA1NC4wLjI4NDAuOTg6ICdsaXN0JyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpID09PSB0cnVlXG4gICAgLy8gU2FmYXJpIDkuMS4zOiAnbGlzdCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKSA9PT0gZmFsc2VcbiAgICBsaXN0OiB0cnVlLFxuICB9LFxuXG4gIC8vIGVsZW1lbnQuZm9ybSBpcyBhY3R1YWxseSBhIGxlZ2l0aW1hdGUgcmVhZE9ubHkgcHJvcGVydHksIHRoYXQgaXMgdG8gYmVcbiAgLy8gbXV0YXRlZCwgYnV0IG11c3QgYmUgbXV0YXRlZCBieSBzZXRBdHRyaWJ1dGUuLi5cbiAgU0VMRUNUOiB7IGZvcm06IHRydWUgfSxcbiAgT1BUSU9OOiB7IGZvcm06IHRydWUgfSxcbiAgVEVYVEFSRUE6IHsgZm9ybTogdHJ1ZSB9LFxuICBMQUJFTDogeyBmb3JtOiB0cnVlIH0sXG4gIEZJRUxEU0VUOiB7IGZvcm06IHRydWUgfSxcbiAgTEVHRU5EOiB7IGZvcm06IHRydWUgfSxcbiAgT0JKRUNUOiB7IGZvcm06IHRydWUgfSxcbiAgT1VUUFVUOiB7IGZvcm06IHRydWUgfSxcbiAgQlVUVE9OOiB7IGZvcm06IHRydWUgfSxcbn07XG5cbmZ1bmN0aW9uIHByZWZlckF0dHIodGFnTmFtZTogc3RyaW5nLCBwcm9wTmFtZTogc3RyaW5nKSB7XG4gIGxldCB0YWcgPSBBVFRSX09WRVJSSURFU1t0YWdOYW1lLnRvVXBwZXJDYXNlKCldO1xuICByZXR1cm4gKHRhZyAmJiB0YWdbcHJvcE5hbWUudG9Mb3dlckNhc2UoKV0pIHx8IGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBTaW1wbGVFbGVtZW50IH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcbmltcG9ydCB7IGlzU2FmZVN0cmluZywgbm9ybWFsaXplU3RyaW5nVmFsdWUgfSBmcm9tICcuLi9kb20vbm9ybWFsaXplJztcblxuY29uc3QgYmFkUHJvdG9jb2xzID0gWydqYXZhc2NyaXB0OicsICd2YnNjcmlwdDonXTtcblxuY29uc3QgYmFkVGFncyA9IFsnQScsICdCT0RZJywgJ0xJTksnLCAnSU1HJywgJ0lGUkFNRScsICdCQVNFJywgJ0ZPUk0nXTtcblxuY29uc3QgYmFkVGFnc0ZvckRhdGFVUkkgPSBbJ0VNQkVEJ107XG5cbmNvbnN0IGJhZEF0dHJpYnV0ZXMgPSBbJ2hyZWYnLCAnc3JjJywgJ2JhY2tncm91bmQnLCAnYWN0aW9uJ107XG5cbmNvbnN0IGJhZEF0dHJpYnV0ZXNGb3JEYXRhVVJJID0gWydzcmMnXTtcblxuZnVuY3Rpb24gaGFzKGFycmF5OiBBcnJheTxzdHJpbmc+LCBpdGVtOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBjaGVja1VSSSh0YWdOYW1lOiBPcHRpb248c3RyaW5nPiwgYXR0cmlidXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuICh0YWdOYW1lID09PSBudWxsIHx8IGhhcyhiYWRUYWdzLCB0YWdOYW1lKSkgJiYgaGFzKGJhZEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRGF0YVVSSSh0YWdOYW1lOiBPcHRpb248c3RyaW5nPiwgYXR0cmlidXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKHRhZ05hbWUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGhhcyhiYWRUYWdzRm9yRGF0YVVSSSwgdGFnTmFtZSkgJiYgaGFzKGJhZEF0dHJpYnV0ZXNGb3JEYXRhVVJJLCBhdHRyaWJ1dGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZXNTYW5pdGl6YXRpb24odGFnTmFtZTogc3RyaW5nLCBhdHRyaWJ1dGU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gY2hlY2tVUkkodGFnTmFtZSwgYXR0cmlidXRlKSB8fCBjaGVja0RhdGFVUkkodGFnTmFtZSwgYXR0cmlidXRlKTtcbn1cblxuaW50ZXJmYWNlIE5vZGVVcmxQYXJzZVJlc3VsdCB7XG4gIHByb3RvY29sOiBzdHJpbmcgfCBudWxsO1xufVxuXG5pbnRlcmZhY2UgTm9kZVVybE1vZHVsZSB7XG4gIHBhcnNlKHVybDogc3RyaW5nKTogTm9kZVVybFBhcnNlUmVzdWx0O1xufVxuXG5sZXQgcHJvdG9jb2xGb3JVcmw6ICh1cmw6IHN0cmluZykgPT4gc3RyaW5nO1xuXG5pZiAoXG4gIHR5cGVvZiBVUkwgPT09ICdvYmplY3QnICYmXG4gIFVSTCAhPT0gbnVsbCAmJlxuICAvLyB0aGlzIGlzIHN1cGVyIGFubm95aW5nLCBUUyB0aGlua3MgdGhhdCBVUkwgKiptdXN0KiogYmUgYSBmdW5jdGlvbiBzbyBgVVJMLnBhcnNlYCBjaGVja1xuICAvLyB0aGlua3MgaXQgaXMgYG5ldmVyYCB3aXRob3V0IHRoaXMgYGFzIHVua25vd24gYXMgYW55YFxuICB0eXBlb2YgKChVUkwgYXMgdW5rbm93bikgYXMgYW55KS5wYXJzZSA9PT0gJ2Z1bmN0aW9uJ1xuKSB7XG4gIC8vIEluIEVtYmVyLWxhbmQgdGhlIGBmYXN0Ym9vdGAgcGFja2FnZSBzZXRzIHRoZSBgVVJMYCBnbG9iYWwgdG8gYHJlcXVpcmUoJ3VybCcpYFxuICAvLyB1bHRpbWF0ZWx5LCB0aGlzIHNob3VsZCBiZSBjaGFuZ2VkIChzbyB0aGF0IHdlIGNhbiBlaXRoZXIgcmVseSBvbiB0aGUgbmF0dXJhbCBgVVJMYCBnbG9iYWxcbiAgLy8gdGhhdCBleGlzdHMpIGJ1dCBmb3Igbm93IHdlIGhhdmUgdG8gZGV0ZWN0IHRoZSBzcGVjaWZpYyBgRmFzdEJvb3RgIGNhc2UgZmlyc3RcbiAgLy9cbiAgLy8gYSBmdXR1cmUgdmVyc2lvbiBvZiBgZmFzdGJvb3RgIHdpbGwgZGV0ZWN0IGlmIHRoaXMgbGVnYWN5IFVSTCBzZXR1cCBpcyByZXF1aXJlZCAoYnlcbiAgLy8gaW5zcGVjdGluZyBFbWJlciB2ZXJzaW9uKSBhbmQgaWYgbmV3IGVub3VnaCwgaXQgd2lsbCBhdm9pZCBzaGFkb3dpbmcgdGhlIGBVUkxgIGdsb2JhbFxuICAvLyBjb25zdHJ1Y3RvciB3aXRoIGByZXF1aXJlKCd1cmwnKWAuXG4gIGxldCBub2RlVVJMID0gVVJMIGFzIE5vZGVVcmxNb2R1bGU7XG5cbiAgcHJvdG9jb2xGb3JVcmwgPSAodXJsOiBzdHJpbmcpID0+IHtcbiAgICBsZXQgcHJvdG9jb2wgPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBwcm90b2NvbCA9IG5vZGVVUkwucGFyc2UodXJsKS5wcm90b2NvbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvdG9jb2wgPT09IG51bGwgPyAnOicgOiBwcm90b2NvbDtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIFVSTCA9PT0gJ2Z1bmN0aW9uJykge1xuICBwcm90b2NvbEZvclVybCA9IChfdXJsOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IHVybCA9IG5ldyBVUkwoX3VybCk7XG5cbiAgICAgIHJldHVybiB1cmwucHJvdG9jb2w7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIGFueSBub24tZnVsbHkgcXVhbGlmaWVkIHVybCBzdHJpbmcgd2lsbCB0cmlnZ2VyIGFuIGVycm9yIChiZWNhdXNlIHRoZXJlIGlzIG5vXG4gICAgICAvLyBiYXNlVVJJIHRoYXQgd2UgY2FuIHByb3ZpZGU7IGluIHRoYXQgY2FzZSB3ZSAqKmtub3cqKiB0aGF0IHRoZSBwcm90b2NvbCBpc1xuICAgICAgLy8gXCJzYWZlXCIgYmVjYXVzZSBpdCBpc24ndCBzcGVjaWZpY2FsbHkgb25lIG9mIHRoZSBgYmFkUHJvdG9jb2xzYCBsaXN0ZWQgYWJvdmVcbiAgICAgIC8vIChhbmQgdGhvc2UgcHJvdG9jb2xzIGNhbiBuZXZlciBiZSB0aGUgZGVmYXVsdCBiYXNlVVJJKVxuICAgICAgcmV0dXJuICc6JztcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBmYWxsYmFjayBmb3IgSUUxMSBzdXBwb3J0XG4gIGxldCBwYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcblxuICBwcm90b2NvbEZvclVybCA9ICh1cmw6IHN0cmluZykgPT4ge1xuICAgIHBhcnNpbmdOb2RlLmhyZWYgPSB1cmw7XG4gICAgcmV0dXJuIHBhcnNpbmdOb2RlLnByb3RvY29sO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVBdHRyaWJ1dGVWYWx1ZShcbiAgZWxlbWVudDogU2ltcGxlRWxlbWVudCxcbiAgYXR0cmlidXRlOiBzdHJpbmcsXG4gIHZhbHVlOiB1bmtub3duXG4pOiB1bmtub3duIHtcbiAgbGV0IHRhZ05hbWU6IE9wdGlvbjxzdHJpbmc+ID0gbnVsbDtcblxuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc1NhZmVTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvSFRNTCgpO1xuICB9XG5cbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgdGFnTmFtZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICB9XG5cbiAgbGV0IHN0ciA9IG5vcm1hbGl6ZVN0cmluZ1ZhbHVlKHZhbHVlKTtcblxuICBpZiAoY2hlY2tVUkkodGFnTmFtZSwgYXR0cmlidXRlKSkge1xuICAgIGxldCBwcm90b2NvbCA9IHByb3RvY29sRm9yVXJsKHN0cik7XG4gICAgaWYgKGhhcyhiYWRQcm90b2NvbHMsIHByb3RvY29sKSkge1xuICAgICAgcmV0dXJuIGB1bnNhZmU6JHtzdHJ9YDtcbiAgICB9XG4gIH1cblxuICBpZiAoY2hlY2tEYXRhVVJJKHRhZ05hbWUsIGF0dHJpYnV0ZSkpIHtcbiAgICByZXR1cm4gYHVuc2FmZToke3N0cn1gO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cbiIsImltcG9ydCB7XG4gIERpY3QsXG4gIEVudmlyb25tZW50LFxuICBPcHRpb24sXG4gIEVsZW1lbnRCdWlsZGVyLFxuICBBdHRyaWJ1dGVPcGVyYXRpb24sXG4gIEF0dHJpYnV0ZUN1cnNvcixcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyB3YXJuSWZTdHlsZU5vdFRydXN0ZWQgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5pbXBvcnQgeyBBdHRyTmFtZXNwYWNlLCBOYW1lc3BhY2UsIFNpbXBsZUVsZW1lbnQgfSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgbm9ybWFsaXplU3RyaW5nVmFsdWUgfSBmcm9tICcuLi8uLi9kb20vbm9ybWFsaXplJztcbmltcG9ydCB7IG5vcm1hbGl6ZVByb3BlcnR5IH0gZnJvbSAnLi4vLi4vZG9tL3Byb3BzJztcbmltcG9ydCB7IHJlcXVpcmVzU2FuaXRpemF0aW9uLCBzYW5pdGl6ZUF0dHJpYnV0ZVZhbHVlIH0gZnJvbSAnLi4vLi4vZG9tL3Nhbml0aXplZC12YWx1ZXMnO1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHsgY2FzdFRvQnJvd3NlciB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gZHluYW1pY0F0dHJpYnV0ZShcbiAgZWxlbWVudDogU2ltcGxlRWxlbWVudCxcbiAgYXR0cjogc3RyaW5nLFxuICBuYW1lc3BhY2U6IE9wdGlvbjxBdHRyTmFtZXNwYWNlPixcbiAgaXNUcnVzdGluZyA9IGZhbHNlXG4pOiBEeW5hbWljQXR0cmlidXRlIHtcbiAgbGV0IHsgdGFnTmFtZSwgbmFtZXNwYWNlVVJJIH0gPSBlbGVtZW50O1xuICBsZXQgYXR0cmlidXRlID0geyBlbGVtZW50LCBuYW1lOiBhdHRyLCBuYW1lc3BhY2UgfTtcblxuICBpZiAoREVCVUcgJiYgYXR0ciA9PT0gJ3N0eWxlJyAmJiAhaXNUcnVzdGluZykge1xuICAgIHJldHVybiBuZXcgRGVidWdTdHlsZUF0dHJpYnV0ZU1hbmFnZXIoYXR0cmlidXRlKTtcbiAgfVxuXG4gIGlmIChuYW1lc3BhY2VVUkkgPT09IE5hbWVzcGFjZS5TVkcpIHtcbiAgICByZXR1cm4gYnVpbGREeW5hbWljQXR0cmlidXRlKHRhZ05hbWUsIGF0dHIsIGF0dHJpYnV0ZSk7XG4gIH1cblxuICBsZXQgeyB0eXBlLCBub3JtYWxpemVkIH0gPSBub3JtYWxpemVQcm9wZXJ0eShlbGVtZW50LCBhdHRyKTtcblxuICBpZiAodHlwZSA9PT0gJ2F0dHInKSB7XG4gICAgcmV0dXJuIGJ1aWxkRHluYW1pY0F0dHJpYnV0ZSh0YWdOYW1lLCBub3JtYWxpemVkLCBhdHRyaWJ1dGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBidWlsZER5bmFtaWNQcm9wZXJ0eSh0YWdOYW1lLCBub3JtYWxpemVkLCBhdHRyaWJ1dGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRHluYW1pY0F0dHJpYnV0ZShcbiAgdGFnTmFtZTogc3RyaW5nLFxuICBuYW1lOiBzdHJpbmcsXG4gIGF0dHJpYnV0ZTogQXR0cmlidXRlQ3Vyc29yXG4pOiBEeW5hbWljQXR0cmlidXRlIHtcbiAgaWYgKHJlcXVpcmVzU2FuaXRpemF0aW9uKHRhZ05hbWUsIG5hbWUpKSB7XG4gICAgcmV0dXJuIG5ldyBTYWZlRHluYW1pY0F0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgU2ltcGxlRHluYW1pY0F0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkRHluYW1pY1Byb3BlcnR5KFxuICB0YWdOYW1lOiBzdHJpbmcsXG4gIG5hbWU6IHN0cmluZyxcbiAgYXR0cmlidXRlOiBBdHRyaWJ1dGVDdXJzb3Jcbik6IER5bmFtaWNBdHRyaWJ1dGUge1xuICBpZiAocmVxdWlyZXNTYW5pdGl6YXRpb24odGFnTmFtZSwgbmFtZSkpIHtcbiAgICByZXR1cm4gbmV3IFNhZmVEeW5hbWljUHJvcGVydHkobmFtZSwgYXR0cmlidXRlKTtcbiAgfVxuXG4gIGlmIChpc1VzZXJJbnB1dFZhbHVlKHRhZ05hbWUsIG5hbWUpKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFZhbHVlRHluYW1pY0F0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGUpO1xuICB9XG5cbiAgaWYgKGlzT3B0aW9uU2VsZWN0ZWQodGFnTmFtZSwgbmFtZSkpIHtcbiAgICByZXR1cm4gbmV3IE9wdGlvblNlbGVjdGVkRHluYW1pY0F0dHJpYnV0ZShuYW1lLCBhdHRyaWJ1dGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEZWZhdWx0RHluYW1pY1Byb3BlcnR5KG5hbWUsIGF0dHJpYnV0ZSk7XG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEeW5hbWljQXR0cmlidXRlIGltcGxlbWVudHMgQXR0cmlidXRlT3BlcmF0aW9uIHtcbiAgY29uc3RydWN0b3IocHVibGljIGF0dHJpYnV0ZTogQXR0cmlidXRlQ3Vyc29yKSB7fVxuXG4gIGFic3RyYWN0IHNldChkb206IEVsZW1lbnRCdWlsZGVyLCB2YWx1ZTogdW5rbm93biwgZW52OiBFbnZpcm9ubWVudCk6IHZvaWQ7XG4gIGFic3RyYWN0IHVwZGF0ZSh2YWx1ZTogdW5rbm93biwgZW52OiBFbnZpcm9ubWVudCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBjbGFzcyBTaW1wbGVEeW5hbWljQXR0cmlidXRlIGV4dGVuZHMgRHluYW1pY0F0dHJpYnV0ZSB7XG4gIHNldChkb206IEVsZW1lbnRCdWlsZGVyLCB2YWx1ZTogdW5rbm93biwgX2VudjogRW52aXJvbm1lbnQpOiB2b2lkIHtcbiAgICBsZXQgbm9ybWFsaXplZFZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuXG4gICAgaWYgKG5vcm1hbGl6ZWRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgbGV0IHsgbmFtZSwgbmFtZXNwYWNlIH0gPSB0aGlzLmF0dHJpYnV0ZTtcbiAgICAgIGRvbS5fX3NldEF0dHJpYnV0ZShuYW1lLCBub3JtYWxpemVkVmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKHZhbHVlOiB1bmtub3duLCBfZW52OiBFbnZpcm9ubWVudCk6IHZvaWQge1xuICAgIGxldCBub3JtYWxpemVkVmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgbGV0IHsgZWxlbWVudCwgbmFtZSB9ID0gdGhpcy5hdHRyaWJ1dGU7XG5cbiAgICBpZiAobm9ybWFsaXplZFZhbHVlID09PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgbm9ybWFsaXplZFZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIERlZmF1bHREeW5hbWljUHJvcGVydHkgZXh0ZW5kcyBEeW5hbWljQXR0cmlidXRlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBub3JtYWxpemVkTmFtZTogc3RyaW5nLCBhdHRyaWJ1dGU6IEF0dHJpYnV0ZUN1cnNvcikge1xuICAgIHN1cGVyKGF0dHJpYnV0ZSk7XG4gIH1cblxuICB2YWx1ZTogdW5rbm93bjtcbiAgc2V0KGRvbTogRWxlbWVudEJ1aWxkZXIsIHZhbHVlOiB1bmtub3duLCBfZW52OiBFbnZpcm9ubWVudCk6IHZvaWQge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICBkb20uX19zZXRQcm9wZXJ0eSh0aGlzLm5vcm1hbGl6ZWROYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKHZhbHVlOiB1bmtub3duLCBfZW52OiBFbnZpcm9ubWVudCk6IHZvaWQge1xuICAgIGxldCB7IGVsZW1lbnQgfSA9IHRoaXMuYXR0cmlidXRlO1xuXG4gICAgaWYgKHRoaXMudmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAoZWxlbWVudCBhcyBhbnkpW3RoaXMubm9ybWFsaXplZE5hbWVdID0gdGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCByZW1vdmVBdHRyaWJ1dGUoKSB7XG4gICAgLy8gVE9ETyB0aGlzIHN1Y2tzIGJ1dCB0byBwcmVzZXJ2ZSBwcm9wZXJ0aWVzIGZpcnN0IGFuZCB0byBtZWV0IGN1cnJlbnRcbiAgICAvLyBzZW1hbnRpY3Mgd2UgbXVzdCBkbyB0aGlzLlxuICAgIGxldCB7IGVsZW1lbnQsIG5hbWVzcGFjZSB9ID0gdGhpcy5hdHRyaWJ1dGU7XG5cbiAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgdGhpcy5ub3JtYWxpemVkTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHRoaXMubm9ybWFsaXplZE5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2FmZUR5bmFtaWNQcm9wZXJ0eSBleHRlbmRzIERlZmF1bHREeW5hbWljUHJvcGVydHkge1xuICBzZXQoZG9tOiBFbGVtZW50QnVpbGRlciwgdmFsdWU6IHVua25vd24sIGVudjogRW52aXJvbm1lbnQpOiB2b2lkIHtcbiAgICBsZXQgeyBlbGVtZW50LCBuYW1lIH0gPSB0aGlzLmF0dHJpYnV0ZTtcbiAgICBsZXQgc2FuaXRpemVkID0gc2FuaXRpemVBdHRyaWJ1dGVWYWx1ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgc3VwZXIuc2V0KGRvbSwgc2FuaXRpemVkLCBlbnYpO1xuICB9XG5cbiAgdXBkYXRlKHZhbHVlOiB1bmtub3duLCBlbnY6IEVudmlyb25tZW50KTogdm9pZCB7XG4gICAgbGV0IHsgZWxlbWVudCwgbmFtZSB9ID0gdGhpcy5hdHRyaWJ1dGU7XG4gICAgbGV0IHNhbml0aXplZCA9IHNhbml0aXplQXR0cmlidXRlVmFsdWUoZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuICAgIHN1cGVyLnVwZGF0ZShzYW5pdGl6ZWQsIGVudik7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNhZmVEeW5hbWljQXR0cmlidXRlIGV4dGVuZHMgU2ltcGxlRHluYW1pY0F0dHJpYnV0ZSB7XG4gIHNldChkb206IEVsZW1lbnRCdWlsZGVyLCB2YWx1ZTogdW5rbm93biwgZW52OiBFbnZpcm9ubWVudCk6IHZvaWQge1xuICAgIGxldCB7IGVsZW1lbnQsIG5hbWUgfSA9IHRoaXMuYXR0cmlidXRlO1xuICAgIGxldCBzYW5pdGl6ZWQgPSBzYW5pdGl6ZUF0dHJpYnV0ZVZhbHVlKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgICBzdXBlci5zZXQoZG9tLCBzYW5pdGl6ZWQsIGVudik7XG4gIH1cblxuICB1cGRhdGUodmFsdWU6IHVua25vd24sIGVudjogRW52aXJvbm1lbnQpOiB2b2lkIHtcbiAgICBsZXQgeyBlbGVtZW50LCBuYW1lIH0gPSB0aGlzLmF0dHJpYnV0ZTtcbiAgICBsZXQgc2FuaXRpemVkID0gc2FuaXRpemVBdHRyaWJ1dGVWYWx1ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gICAgc3VwZXIudXBkYXRlKHNhbml0aXplZCwgZW52KTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW5wdXRWYWx1ZUR5bmFtaWNBdHRyaWJ1dGUgZXh0ZW5kcyBEZWZhdWx0RHluYW1pY1Byb3BlcnR5IHtcbiAgc2V0KGRvbTogRWxlbWVudEJ1aWxkZXIsIHZhbHVlOiB1bmtub3duKSB7XG4gICAgZG9tLl9fc2V0UHJvcGVydHkoJ3ZhbHVlJywgbm9ybWFsaXplU3RyaW5nVmFsdWUodmFsdWUpKTtcbiAgfVxuXG4gIHVwZGF0ZSh2YWx1ZTogdW5rbm93bikge1xuICAgIGxldCBpbnB1dCA9IGNhc3RUb0Jyb3dzZXIodGhpcy5hdHRyaWJ1dGUuZWxlbWVudCwgWydpbnB1dCcsICd0ZXh0YXJlYSddKTtcbiAgICBsZXQgY3VycmVudFZhbHVlID0gaW5wdXQudmFsdWU7XG4gICAgbGV0IG5vcm1hbGl6ZWRWYWx1ZSA9IG5vcm1hbGl6ZVN0cmluZ1ZhbHVlKHZhbHVlKTtcbiAgICBpZiAoY3VycmVudFZhbHVlICE9PSBub3JtYWxpemVkVmFsdWUpIHtcbiAgICAgIGlucHV0LnZhbHVlID0gbm9ybWFsaXplZFZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgT3B0aW9uU2VsZWN0ZWREeW5hbWljQXR0cmlidXRlIGV4dGVuZHMgRGVmYXVsdER5bmFtaWNQcm9wZXJ0eSB7XG4gIHNldChkb206IEVsZW1lbnRCdWlsZGVyLCB2YWx1ZTogdW5rbm93bik6IHZvaWQge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZG9tLl9fc2V0UHJvcGVydHkoJ3NlbGVjdGVkJywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKHZhbHVlOiB1bmtub3duKTogdm9pZCB7XG4gICAgbGV0IG9wdGlvbiA9IGNhc3RUb0Jyb3dzZXIodGhpcy5hdHRyaWJ1dGUuZWxlbWVudCwgJ29wdGlvbicpO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb24uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNPcHRpb25TZWxlY3RlZCh0YWdOYW1lOiBzdHJpbmcsIGF0dHJpYnV0ZTogc3RyaW5nKSB7XG4gIHJldHVybiB0YWdOYW1lID09PSAnT1BUSU9OJyAmJiBhdHRyaWJ1dGUgPT09ICdzZWxlY3RlZCc7XG59XG5cbmZ1bmN0aW9uIGlzVXNlcklucHV0VmFsdWUodGFnTmFtZTogc3RyaW5nLCBhdHRyaWJ1dGU6IHN0cmluZykge1xuICByZXR1cm4gKHRhZ05hbWUgPT09ICdJTlBVVCcgfHwgdGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykgJiYgYXR0cmlidXRlID09PSAndmFsdWUnO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZTogdW5rbm93bik6IE9wdGlvbjxzdHJpbmc+IHtcbiAgaWYgKFxuICAgIHZhbHVlID09PSBmYWxzZSB8fFxuICAgIHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICB2YWx1ZSA9PT0gbnVsbCB8fFxuICAgIHR5cGVvZiAodmFsdWUgYXMgRGljdCkudG9TdHJpbmcgPT09ICd1bmRlZmluZWQnXG4gICkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICAvLyBvbmNsaWNrIGZ1bmN0aW9uIGV0YyBpbiBTU1JcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59XG5cbmxldCBEZWJ1Z1N0eWxlQXR0cmlidXRlTWFuYWdlcjoge1xuICBuZXcgKGF0dHJpYnV0ZTogQXR0cmlidXRlQ3Vyc29yKTogQXR0cmlidXRlT3BlcmF0aW9uO1xufTtcblxuaWYgKERFQlVHKSB7XG4gIERlYnVnU3R5bGVBdHRyaWJ1dGVNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBTaW1wbGVEeW5hbWljQXR0cmlidXRlIHtcbiAgICBzZXQoZG9tOiBFbGVtZW50QnVpbGRlciwgdmFsdWU6IHVua25vd24sIGVudjogRW52aXJvbm1lbnQpOiB2b2lkIHtcbiAgICAgIHdhcm5JZlN0eWxlTm90VHJ1c3RlZCh2YWx1ZSk7XG5cbiAgICAgIHN1cGVyLnNldChkb20sIHZhbHVlLCBlbnYpO1xuICAgIH1cbiAgICB1cGRhdGUodmFsdWU6IHVua25vd24sIGVudjogRW52aXJvbm1lbnQpOiB2b2lkIHtcbiAgICAgIHdhcm5JZlN0eWxlTm90VHJ1c3RlZCh2YWx1ZSk7XG5cbiAgICAgIHN1cGVyLnVwZGF0ZSh2YWx1ZSwgZW52KTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBCb3VuZHMsXG4gIEN1cnNvcixcbiAgQ3Vyc29yU3RhY2tTeW1ib2wsXG4gIEVsZW1lbnRCdWlsZGVyLFxuICBFbGVtZW50T3BlcmF0aW9ucyxcbiAgRW52aXJvbm1lbnQsXG4gIEdsaW1tZXJUcmVlQ2hhbmdlcyxcbiAgR2xpbW1lclRyZWVDb25zdHJ1Y3Rpb24sXG4gIExpdmVCbG9jayxcbiAgTWF5YmUsXG4gIE9wdGlvbixcbiAgVXBkYXRhYmxlQmxvY2ssXG4gIE1vZGlmaWVySW5zdGFuY2UsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0LCBleHBlY3QsIFN0YWNrLCBzeW1ib2wgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7XG4gIEF0dHJOYW1lc3BhY2UsXG4gIFNpbXBsZUNvbW1lbnQsXG4gIFNpbXBsZURvY3VtZW50RnJhZ21lbnQsXG4gIFNpbXBsZUVsZW1lbnQsXG4gIFNpbXBsZU5vZGUsXG4gIFNpbXBsZVRleHQsXG59IGZyb20gJ0BzaW1wbGUtZG9tL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBjbGVhciwgQ29uY3JldGVCb3VuZHMsIEN1cnNvckltcGwsIFNpbmdsZU5vZGVCb3VuZHMgfSBmcm9tICcuLi9ib3VuZHMnO1xuaW1wb3J0IHsgZGVzdHJveSwgcmVnaXN0ZXJEZXN0cnVjdG9yIH0gZnJvbSAnQGdsaW1tZXIvZGVzdHJveWFibGUnO1xuaW1wb3J0IHsgRHluYW1pY0F0dHJpYnV0ZSwgZHluYW1pY0F0dHJpYnV0ZSB9IGZyb20gJy4vYXR0cmlidXRlcy9keW5hbWljJztcblxuZXhwb3J0IGludGVyZmFjZSBGaXJzdE5vZGUge1xuICBmaXJzdE5vZGUoKTogU2ltcGxlTm9kZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMYXN0Tm9kZSB7XG4gIGxhc3ROb2RlKCk6IFNpbXBsZU5vZGU7XG59XG5cbmNsYXNzIEZpcnN0IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBub2RlOiBTaW1wbGVOb2RlKSB7fVxuXG4gIGZpcnN0Tm9kZSgpOiBTaW1wbGVOb2RlIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlO1xuICB9XG59XG5cbmNsYXNzIExhc3Qge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5vZGU6IFNpbXBsZU5vZGUpIHt9XG5cbiAgbGFzdE5vZGUoKTogU2ltcGxlTm9kZSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRnJhZ21lbnQgaW1wbGVtZW50cyBCb3VuZHMge1xuICBwcml2YXRlIGJvdW5kczogQm91bmRzO1xuXG4gIGNvbnN0cnVjdG9yKGJvdW5kczogQm91bmRzKSB7XG4gICAgdGhpcy5ib3VuZHMgPSBib3VuZHM7XG4gIH1cblxuICBwYXJlbnRFbGVtZW50KCk6IFNpbXBsZUVsZW1lbnQge1xuICAgIHJldHVybiB0aGlzLmJvdW5kcy5wYXJlbnRFbGVtZW50KCk7XG4gIH1cblxuICBmaXJzdE5vZGUoKTogU2ltcGxlTm9kZSB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLmZpcnN0Tm9kZSgpO1xuICB9XG5cbiAgbGFzdE5vZGUoKTogU2ltcGxlTm9kZSB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLmxhc3ROb2RlKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IENVUlNPUl9TVEFDSzogQ3Vyc29yU3RhY2tTeW1ib2wgPSBzeW1ib2woJ0NVUlNPUl9TVEFDSycpO1xuXG5leHBvcnQgY2xhc3MgTmV3RWxlbWVudEJ1aWxkZXIgaW1wbGVtZW50cyBFbGVtZW50QnVpbGRlciB7XG4gIHB1YmxpYyBkb206IEdsaW1tZXJUcmVlQ29uc3RydWN0aW9uO1xuICBwdWJsaWMgdXBkYXRlT3BlcmF0aW9uczogR2xpbW1lclRyZWVDaGFuZ2VzO1xuICBwdWJsaWMgY29uc3RydWN0aW5nOiBPcHRpb248U2ltcGxlRWxlbWVudD4gPSBudWxsO1xuICBwdWJsaWMgb3BlcmF0aW9uczogT3B0aW9uPEVsZW1lbnRPcGVyYXRpb25zPiA9IG51bGw7XG4gIHByaXZhdGUgZW52OiBFbnZpcm9ubWVudDtcblxuICBbQ1VSU09SX1NUQUNLXSA9IG5ldyBTdGFjazxDdXJzb3I+KCk7XG4gIHByaXZhdGUgbW9kaWZpZXJTdGFjayA9IG5ldyBTdGFjazxPcHRpb248TW9kaWZpZXJJbnN0YW5jZVtdPj4oKTtcbiAgcHJpdmF0ZSBibG9ja1N0YWNrID0gbmV3IFN0YWNrPExpdmVCbG9jaz4oKTtcblxuICBzdGF0aWMgZm9ySW5pdGlhbFJlbmRlcihlbnY6IEVudmlyb25tZW50LCBjdXJzb3I6IEN1cnNvckltcGwpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoZW52LCBjdXJzb3IuZWxlbWVudCwgY3Vyc29yLm5leHRTaWJsaW5nKS5pbml0aWFsaXplKCk7XG4gIH1cblxuICBzdGF0aWMgcmVzdW1lKGVudjogRW52aXJvbm1lbnQsIGJsb2NrOiBVcGRhdGFibGVCbG9jayk6IE5ld0VsZW1lbnRCdWlsZGVyIHtcbiAgICBsZXQgcGFyZW50Tm9kZSA9IGJsb2NrLnBhcmVudEVsZW1lbnQoKTtcbiAgICBsZXQgbmV4dFNpYmxpbmcgPSBibG9jay5yZXNldChlbnYpO1xuXG4gICAgbGV0IHN0YWNrID0gbmV3IHRoaXMoZW52LCBwYXJlbnROb2RlLCBuZXh0U2libGluZykuaW5pdGlhbGl6ZSgpO1xuICAgIHN0YWNrLnB1c2hMaXZlQmxvY2soYmxvY2spO1xuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9XG5cbiAgY29uc3RydWN0b3IoZW52OiBFbnZpcm9ubWVudCwgcGFyZW50Tm9kZTogU2ltcGxlRWxlbWVudCwgbmV4dFNpYmxpbmc6IE9wdGlvbjxTaW1wbGVOb2RlPikge1xuICAgIHRoaXMucHVzaEVsZW1lbnQocGFyZW50Tm9kZSwgbmV4dFNpYmxpbmcpO1xuXG4gICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgdGhpcy5kb20gPSBlbnYuZ2V0QXBwZW5kT3BlcmF0aW9ucygpO1xuICAgIHRoaXMudXBkYXRlT3BlcmF0aW9ucyA9IGVudi5nZXRET00oKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBpbml0aWFsaXplKCk6IHRoaXMge1xuICAgIHRoaXMucHVzaFNpbXBsZUJsb2NrKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZWJ1Z0Jsb2NrcygpOiBMaXZlQmxvY2tbXSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tTdGFjay50b0FycmF5KCk7XG4gIH1cblxuICBnZXQgZWxlbWVudCgpOiBTaW1wbGVFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpc1tDVVJTT1JfU1RBQ0tdLmN1cnJlbnQhLmVsZW1lbnQ7XG4gIH1cblxuICBnZXQgbmV4dFNpYmxpbmcoKTogT3B0aW9uPFNpbXBsZU5vZGU+IHtcbiAgICByZXR1cm4gdGhpc1tDVVJTT1JfU1RBQ0tdLmN1cnJlbnQhLm5leHRTaWJsaW5nO1xuICB9XG5cbiAgZ2V0IGhhc0Jsb2NrcygpIHtcbiAgICByZXR1cm4gdGhpcy5ibG9ja1N0YWNrLnNpemUgPiAwO1xuICB9XG5cbiAgcHJvdGVjdGVkIGJsb2NrKCk6IExpdmVCbG9jayB7XG4gICAgcmV0dXJuIGV4cGVjdCh0aGlzLmJsb2NrU3RhY2suY3VycmVudCwgJ0V4cGVjdGVkIGEgY3VycmVudCBsaXZlIGJsb2NrJyk7XG4gIH1cblxuICBwb3BFbGVtZW50KCkge1xuICAgIHRoaXNbQ1VSU09SX1NUQUNLXS5wb3AoKTtcbiAgICBleHBlY3QodGhpc1tDVVJTT1JfU1RBQ0tdLmN1cnJlbnQsIFwiY2FuJ3QgcG9wIHBhc3QgdGhlIGxhc3QgZWxlbWVudFwiKTtcbiAgfVxuXG4gIHB1c2hTaW1wbGVCbG9jaygpOiBMaXZlQmxvY2sge1xuICAgIHJldHVybiB0aGlzLnB1c2hMaXZlQmxvY2sobmV3IFNpbXBsZUxpdmVCbG9jayh0aGlzLmVsZW1lbnQpKTtcbiAgfVxuXG4gIHB1c2hVcGRhdGFibGVCbG9jaygpOiBVcGRhdGFibGVCbG9ja0ltcGwge1xuICAgIHJldHVybiB0aGlzLnB1c2hMaXZlQmxvY2sobmV3IFVwZGF0YWJsZUJsb2NrSW1wbCh0aGlzLmVsZW1lbnQpKTtcbiAgfVxuXG4gIHB1c2hCbG9ja0xpc3QobGlzdDogTGl2ZUJsb2NrW10pOiBMaXZlQmxvY2tMaXN0IHtcbiAgICByZXR1cm4gdGhpcy5wdXNoTGl2ZUJsb2NrKG5ldyBMaXZlQmxvY2tMaXN0KHRoaXMuZWxlbWVudCwgbGlzdCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHB1c2hMaXZlQmxvY2s8VCBleHRlbmRzIExpdmVCbG9jaz4oYmxvY2s6IFQsIGlzUmVtb3RlID0gZmFsc2UpOiBUIHtcbiAgICBsZXQgY3VycmVudCA9IHRoaXMuYmxvY2tTdGFjay5jdXJyZW50O1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmICghaXNSZW1vdGUpIHtcbiAgICAgICAgY3VycmVudC5kaWRBcHBlbmRCb3VuZHMoYmxvY2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX19vcGVuQmxvY2soKTtcbiAgICB0aGlzLmJsb2NrU3RhY2sucHVzaChibG9jayk7XG4gICAgcmV0dXJuIGJsb2NrO1xuICB9XG5cbiAgcG9wQmxvY2soKTogTGl2ZUJsb2NrIHtcbiAgICB0aGlzLmJsb2NrKCkuZmluYWxpemUodGhpcyk7XG4gICAgdGhpcy5fX2Nsb3NlQmxvY2soKTtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXMuYmxvY2tTdGFjay5wb3AoKSwgJ0V4cGVjdGVkIHBvcEJsb2NrIHRvIHJldHVybiBhIGJsb2NrJyk7XG4gIH1cblxuICBfX29wZW5CbG9jaygpOiB2b2lkIHt9XG4gIF9fY2xvc2VCbG9jaygpOiB2b2lkIHt9XG5cbiAgLy8gdG9kbyByZXR1cm4gc2VlbXMgdW51c2VkXG4gIG9wZW5FbGVtZW50KHRhZzogc3RyaW5nKTogU2ltcGxlRWxlbWVudCB7XG4gICAgbGV0IGVsZW1lbnQgPSB0aGlzLl9fb3BlbkVsZW1lbnQodGFnKTtcbiAgICB0aGlzLmNvbnN0cnVjdGluZyA9IGVsZW1lbnQ7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIF9fb3BlbkVsZW1lbnQodGFnOiBzdHJpbmcpOiBTaW1wbGVFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5kb20uY3JlYXRlRWxlbWVudCh0YWcsIHRoaXMuZWxlbWVudCk7XG4gIH1cblxuICBmbHVzaEVsZW1lbnQobW9kaWZpZXJzOiBPcHRpb248TW9kaWZpZXJJbnN0YW5jZVtdPikge1xuICAgIGxldCBwYXJlbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgbGV0IGVsZW1lbnQgPSBleHBlY3QoXG4gICAgICB0aGlzLmNvbnN0cnVjdGluZyxcbiAgICAgIGBmbHVzaEVsZW1lbnQgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW4gY29uc3RydWN0aW5nIGFuIGVsZW1lbnRgXG4gICAgKTtcblxuICAgIHRoaXMuX19mbHVzaEVsZW1lbnQocGFyZW50LCBlbGVtZW50KTtcblxuICAgIHRoaXMuY29uc3RydWN0aW5nID0gbnVsbDtcbiAgICB0aGlzLm9wZXJhdGlvbnMgPSBudWxsO1xuXG4gICAgdGhpcy5wdXNoTW9kaWZpZXJzKG1vZGlmaWVycyk7XG4gICAgdGhpcy5wdXNoRWxlbWVudChlbGVtZW50LCBudWxsKTtcbiAgICB0aGlzLmRpZE9wZW5FbGVtZW50KGVsZW1lbnQpO1xuICB9XG5cbiAgX19mbHVzaEVsZW1lbnQocGFyZW50OiBTaW1wbGVFbGVtZW50LCBjb25zdHJ1Y3Rpbmc6IFNpbXBsZUVsZW1lbnQpIHtcbiAgICB0aGlzLmRvbS5pbnNlcnRCZWZvcmUocGFyZW50LCBjb25zdHJ1Y3RpbmcsIHRoaXMubmV4dFNpYmxpbmcpO1xuICB9XG5cbiAgY2xvc2VFbGVtZW50KCk6IE9wdGlvbjxNb2RpZmllckluc3RhbmNlW10+IHtcbiAgICB0aGlzLndpbGxDbG9zZUVsZW1lbnQoKTtcbiAgICB0aGlzLnBvcEVsZW1lbnQoKTtcbiAgICByZXR1cm4gdGhpcy5wb3BNb2RpZmllcnMoKTtcbiAgfVxuXG4gIHB1c2hSZW1vdGVFbGVtZW50KFxuICAgIGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsXG4gICAgZ3VpZDogc3RyaW5nLFxuICAgIGluc2VydEJlZm9yZTogTWF5YmU8U2ltcGxlTm9kZT5cbiAgKTogT3B0aW9uPFJlbW90ZUxpdmVCbG9jaz4ge1xuICAgIHJldHVybiB0aGlzLl9fcHVzaFJlbW90ZUVsZW1lbnQoZWxlbWVudCwgZ3VpZCwgaW5zZXJ0QmVmb3JlKTtcbiAgfVxuXG4gIF9fcHVzaFJlbW90ZUVsZW1lbnQoXG4gICAgZWxlbWVudDogU2ltcGxlRWxlbWVudCxcbiAgICBfZ3VpZDogc3RyaW5nLFxuICAgIGluc2VydEJlZm9yZTogTWF5YmU8U2ltcGxlTm9kZT5cbiAgKTogT3B0aW9uPFJlbW90ZUxpdmVCbG9jaz4ge1xuICAgIHRoaXMucHVzaEVsZW1lbnQoZWxlbWVudCwgaW5zZXJ0QmVmb3JlKTtcblxuICAgIGlmIChpbnNlcnRCZWZvcmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgd2hpbGUgKGVsZW1lbnQubGFzdENoaWxkKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudC5sYXN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBibG9jayA9IG5ldyBSZW1vdGVMaXZlQmxvY2soZWxlbWVudCk7XG5cbiAgICByZXR1cm4gdGhpcy5wdXNoTGl2ZUJsb2NrKGJsb2NrLCB0cnVlKTtcbiAgfVxuXG4gIHBvcFJlbW90ZUVsZW1lbnQoKSB7XG4gICAgdGhpcy5wb3BCbG9jaygpO1xuICAgIHRoaXMucG9wRWxlbWVudCgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHB1c2hFbGVtZW50KGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsIG5leHRTaWJsaW5nOiBNYXliZTxTaW1wbGVOb2RlPiA9IG51bGwpIHtcbiAgICB0aGlzW0NVUlNPUl9TVEFDS10ucHVzaChuZXcgQ3Vyc29ySW1wbChlbGVtZW50LCBuZXh0U2libGluZykpO1xuICB9XG5cbiAgcHJpdmF0ZSBwdXNoTW9kaWZpZXJzKG1vZGlmaWVyczogT3B0aW9uPE1vZGlmaWVySW5zdGFuY2VbXT4pOiB2b2lkIHtcbiAgICB0aGlzLm1vZGlmaWVyU3RhY2sucHVzaChtb2RpZmllcnMpO1xuICB9XG5cbiAgcHJpdmF0ZSBwb3BNb2RpZmllcnMoKTogT3B0aW9uPE1vZGlmaWVySW5zdGFuY2VbXT4ge1xuICAgIHJldHVybiB0aGlzLm1vZGlmaWVyU3RhY2sucG9wKCk7XG4gIH1cblxuICBkaWRBcHBlbmRCb3VuZHMoYm91bmRzOiBCb3VuZHMpOiBCb3VuZHMge1xuICAgIHRoaXMuYmxvY2soKS5kaWRBcHBlbmRCb3VuZHMoYm91bmRzKTtcbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG5cbiAgZGlkQXBwZW5kTm9kZTxUIGV4dGVuZHMgU2ltcGxlTm9kZT4obm9kZTogVCk6IFQge1xuICAgIHRoaXMuYmxvY2soKS5kaWRBcHBlbmROb2RlKG5vZGUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZGlkT3BlbkVsZW1lbnQoZWxlbWVudDogU2ltcGxlRWxlbWVudCk6IFNpbXBsZUVsZW1lbnQge1xuICAgIHRoaXMuYmxvY2soKS5vcGVuRWxlbWVudChlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHdpbGxDbG9zZUVsZW1lbnQoKSB7XG4gICAgdGhpcy5ibG9jaygpLmNsb3NlRWxlbWVudCgpO1xuICB9XG5cbiAgYXBwZW5kVGV4dChzdHJpbmc6IHN0cmluZyk6IFNpbXBsZVRleHQge1xuICAgIHJldHVybiB0aGlzLmRpZEFwcGVuZE5vZGUodGhpcy5fX2FwcGVuZFRleHQoc3RyaW5nKSk7XG4gIH1cblxuICBfX2FwcGVuZFRleHQodGV4dDogc3RyaW5nKTogU2ltcGxlVGV4dCB7XG4gICAgbGV0IHsgZG9tLCBlbGVtZW50LCBuZXh0U2libGluZyB9ID0gdGhpcztcbiAgICBsZXQgbm9kZSA9IGRvbS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICBkb20uaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIG5vZGUsIG5leHRTaWJsaW5nKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIF9fYXBwZW5kTm9kZShub2RlOiBTaW1wbGVOb2RlKTogU2ltcGxlTm9kZSB7XG4gICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHRoaXMuZWxlbWVudCwgbm9kZSwgdGhpcy5uZXh0U2libGluZyk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBfX2FwcGVuZEZyYWdtZW50KGZyYWdtZW50OiBTaW1wbGVEb2N1bWVudEZyYWdtZW50KTogQm91bmRzIHtcbiAgICBsZXQgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBsZXQgcmV0ID0gbmV3IENvbmNyZXRlQm91bmRzKHRoaXMuZWxlbWVudCwgZmlyc3QsIGZyYWdtZW50Lmxhc3RDaGlsZCEpO1xuICAgICAgdGhpcy5kb20uaW5zZXJ0QmVmb3JlKHRoaXMuZWxlbWVudCwgZnJhZ21lbnQsIHRoaXMubmV4dFNpYmxpbmcpO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBTaW5nbGVOb2RlQm91bmRzKHRoaXMuZWxlbWVudCwgdGhpcy5fX2FwcGVuZENvbW1lbnQoJycpKTtcbiAgICB9XG4gIH1cblxuICBfX2FwcGVuZEhUTUwoaHRtbDogc3RyaW5nKTogQm91bmRzIHtcbiAgICByZXR1cm4gdGhpcy5kb20uaW5zZXJ0SFRNTEJlZm9yZSh0aGlzLmVsZW1lbnQsIHRoaXMubmV4dFNpYmxpbmcsIGh0bWwpO1xuICB9XG5cbiAgYXBwZW5kRHluYW1pY0hUTUwodmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGxldCBib3VuZHMgPSB0aGlzLnRydXN0ZWRDb250ZW50KHZhbHVlKTtcbiAgICB0aGlzLmRpZEFwcGVuZEJvdW5kcyhib3VuZHMpO1xuICB9XG5cbiAgYXBwZW5kRHluYW1pY1RleHQodmFsdWU6IHN0cmluZyk6IFNpbXBsZVRleHQge1xuICAgIGxldCBub2RlID0gdGhpcy51bnRydXN0ZWRDb250ZW50KHZhbHVlKTtcbiAgICB0aGlzLmRpZEFwcGVuZE5vZGUobm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBhcHBlbmREeW5hbWljRnJhZ21lbnQodmFsdWU6IFNpbXBsZURvY3VtZW50RnJhZ21lbnQpOiB2b2lkIHtcbiAgICBsZXQgYm91bmRzID0gdGhpcy5fX2FwcGVuZEZyYWdtZW50KHZhbHVlKTtcbiAgICB0aGlzLmRpZEFwcGVuZEJvdW5kcyhib3VuZHMpO1xuICB9XG5cbiAgYXBwZW5kRHluYW1pY05vZGUodmFsdWU6IFNpbXBsZU5vZGUpOiB2b2lkIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMuX19hcHBlbmROb2RlKHZhbHVlKTtcbiAgICBsZXQgYm91bmRzID0gbmV3IFNpbmdsZU5vZGVCb3VuZHModGhpcy5lbGVtZW50LCBub2RlKTtcbiAgICB0aGlzLmRpZEFwcGVuZEJvdW5kcyhib3VuZHMpO1xuICB9XG5cbiAgcHJpdmF0ZSB0cnVzdGVkQ29udGVudCh2YWx1ZTogc3RyaW5nKTogQm91bmRzIHtcbiAgICByZXR1cm4gdGhpcy5fX2FwcGVuZEhUTUwodmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSB1bnRydXN0ZWRDb250ZW50KHZhbHVlOiBzdHJpbmcpOiBTaW1wbGVUZXh0IHtcbiAgICByZXR1cm4gdGhpcy5fX2FwcGVuZFRleHQodmFsdWUpO1xuICB9XG5cbiAgYXBwZW5kQ29tbWVudChzdHJpbmc6IHN0cmluZyk6IFNpbXBsZUNvbW1lbnQge1xuICAgIHJldHVybiB0aGlzLmRpZEFwcGVuZE5vZGUodGhpcy5fX2FwcGVuZENvbW1lbnQoc3RyaW5nKSk7XG4gIH1cblxuICBfX2FwcGVuZENvbW1lbnQoc3RyaW5nOiBzdHJpbmcpOiBTaW1wbGVDb21tZW50IHtcbiAgICBsZXQgeyBkb20sIGVsZW1lbnQsIG5leHRTaWJsaW5nIH0gPSB0aGlzO1xuICAgIGxldCBub2RlID0gZG9tLmNyZWF0ZUNvbW1lbnQoc3RyaW5nKTtcbiAgICBkb20uaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIG5vZGUsIG5leHRTaWJsaW5nKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIF9fc2V0QXR0cmlidXRlKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgbmFtZXNwYWNlOiBPcHRpb248QXR0ck5hbWVzcGFjZT4pOiB2b2lkIHtcbiAgICB0aGlzLmRvbS5zZXRBdHRyaWJ1dGUodGhpcy5jb25zdHJ1Y3RpbmchLCBuYW1lLCB2YWx1ZSwgbmFtZXNwYWNlKTtcbiAgfVxuXG4gIF9fc2V0UHJvcGVydHkobmFtZTogc3RyaW5nLCB2YWx1ZTogdW5rbm93bik6IHZvaWQge1xuICAgICh0aGlzLmNvbnN0cnVjdGluZyEgYXMgYW55KVtuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgc2V0U3RhdGljQXR0cmlidXRlKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgbmFtZXNwYWNlOiBPcHRpb248QXR0ck5hbWVzcGFjZT4pOiB2b2lkIHtcbiAgICB0aGlzLl9fc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlLCBuYW1lc3BhY2UpO1xuICB9XG5cbiAgc2V0RHluYW1pY0F0dHJpYnV0ZShcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgdmFsdWU6IHVua25vd24sXG4gICAgdHJ1c3Rpbmc6IGJvb2xlYW4sXG4gICAgbmFtZXNwYWNlOiBPcHRpb248QXR0ck5hbWVzcGFjZT5cbiAgKTogRHluYW1pY0F0dHJpYnV0ZSB7XG4gICAgbGV0IGVsZW1lbnQgPSB0aGlzLmNvbnN0cnVjdGluZyE7XG4gICAgbGV0IGF0dHJpYnV0ZSA9IGR5bmFtaWNBdHRyaWJ1dGUoZWxlbWVudCwgbmFtZSwgbmFtZXNwYWNlLCB0cnVzdGluZyk7XG4gICAgYXR0cmlidXRlLnNldCh0aGlzLCB2YWx1ZSwgdGhpcy5lbnYpO1xuICAgIHJldHVybiBhdHRyaWJ1dGU7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFNpbXBsZUxpdmVCbG9jayBpbXBsZW1lbnRzIExpdmVCbG9jayB7XG4gIHByb3RlY3RlZCBmaXJzdDogT3B0aW9uPEZpcnN0Tm9kZT4gPSBudWxsO1xuICBwcm90ZWN0ZWQgbGFzdDogT3B0aW9uPExhc3ROb2RlPiA9IG51bGw7XG4gIHByb3RlY3RlZCBuZXN0aW5nID0gMDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHBhcmVudDogU2ltcGxlRWxlbWVudCkge31cblxuICBwYXJlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgfVxuXG4gIGZpcnN0Tm9kZSgpOiBTaW1wbGVOb2RlIHtcbiAgICBsZXQgZmlyc3QgPSBleHBlY3QoXG4gICAgICB0aGlzLmZpcnN0LFxuICAgICAgJ2Nhbm5vdCBjYWxsIGBmaXJzdE5vZGUoKWAgd2hpbGUgYFNpbXBsZUxpdmVCbG9ja2AgaXMgc3RpbGwgaW5pdGlhbGl6aW5nJ1xuICAgICk7XG5cbiAgICByZXR1cm4gZmlyc3QuZmlyc3ROb2RlKCk7XG4gIH1cblxuICBsYXN0Tm9kZSgpOiBTaW1wbGVOb2RlIHtcbiAgICBsZXQgbGFzdCA9IGV4cGVjdChcbiAgICAgIHRoaXMubGFzdCxcbiAgICAgICdjYW5ub3QgY2FsbCBgbGFzdE5vZGUoKWAgd2hpbGUgYFNpbXBsZUxpdmVCbG9ja2AgaXMgc3RpbGwgaW5pdGlhbGl6aW5nJ1xuICAgICk7XG5cbiAgICByZXR1cm4gbGFzdC5sYXN0Tm9kZSgpO1xuICB9XG5cbiAgb3BlbkVsZW1lbnQoZWxlbWVudDogU2ltcGxlRWxlbWVudCkge1xuICAgIHRoaXMuZGlkQXBwZW5kTm9kZShlbGVtZW50KTtcbiAgICB0aGlzLm5lc3RpbmcrKztcbiAgfVxuXG4gIGNsb3NlRWxlbWVudCgpIHtcbiAgICB0aGlzLm5lc3RpbmctLTtcbiAgfVxuXG4gIGRpZEFwcGVuZE5vZGUobm9kZTogU2ltcGxlTm9kZSkge1xuICAgIGlmICh0aGlzLm5lc3RpbmcgIT09IDApIHJldHVybjtcblxuICAgIGlmICghdGhpcy5maXJzdCkge1xuICAgICAgdGhpcy5maXJzdCA9IG5ldyBGaXJzdChub2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3QgPSBuZXcgTGFzdChub2RlKTtcbiAgfVxuXG4gIGRpZEFwcGVuZEJvdW5kcyhib3VuZHM6IEJvdW5kcykge1xuICAgIGlmICh0aGlzLm5lc3RpbmcgIT09IDApIHJldHVybjtcblxuICAgIGlmICghdGhpcy5maXJzdCkge1xuICAgICAgdGhpcy5maXJzdCA9IGJvdW5kcztcbiAgICB9XG5cbiAgICB0aGlzLmxhc3QgPSBib3VuZHM7XG4gIH1cblxuICBmaW5hbGl6ZShzdGFjazogRWxlbWVudEJ1aWxkZXIpIHtcbiAgICBpZiAodGhpcy5maXJzdCA9PT0gbnVsbCkge1xuICAgICAgc3RhY2suYXBwZW5kQ29tbWVudCgnJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSZW1vdGVMaXZlQmxvY2sgZXh0ZW5kcyBTaW1wbGVMaXZlQmxvY2sge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQ6IFNpbXBsZUVsZW1lbnQpIHtcbiAgICBzdXBlcihwYXJlbnQpO1xuXG4gICAgcmVnaXN0ZXJEZXN0cnVjdG9yKHRoaXMsICgpID0+IHtcbiAgICAgIC8vIEluIGdlbmVyYWwsIHlvdSBvbmx5IG5lZWQgdG8gY2xlYXIgdGhlIHJvb3Qgb2YgYSBoaWVyYXJjaHksIGFuZCBzaG91bGQgbmV2ZXJcbiAgICAgIC8vIG5lZWQgdG8gY2xlYXIgYW55IGNoaWxkIG5vZGVzLiBUaGlzIGlzIGFuIGltcG9ydGFudCBjb25zdHJhaW50IHRoYXQgZ2l2ZXMgdXNcbiAgICAgIC8vIGEgc3Ryb25nIGd1YXJhbnRlZSB0aGF0IGNsZWFyaW5nIGEgc3VidHJlZSBpcyBhIHNpbmdsZSBET00gb3BlcmF0aW9uLlxuICAgICAgLy9cbiAgICAgIC8vIEJlY2F1c2UgcmVtb3RlIGJsb2NrcyBhcmUgbm90IG5vcm1hbGx5IHBoeXNpY2FsbHkgbmVzdGVkIGluc2lkZSBvZiB0aGUgdHJlZVxuICAgICAgLy8gdGhhdCB0aGV5IGFyZSBsb2dpY2FsbHkgbmVzdGVkIGluc2lkZSwgd2UgbWFudWFsbHkgY2xlYXIgcmVtb3RlIGJsb2NrcyB3aGVuXG4gICAgICAvLyBhIGxvZ2ljYWwgcGFyZW50IGlzIGNsZWFyZWQuXG4gICAgICAvL1xuICAgICAgLy8gSE9XRVZFUiwgaXQgaXMgY3VycmVudGx5IHBvc3NpYmxlIGZvciBhIHJlbW90ZSBibG9jayB0byBiZSBwaHlzaWNhbGx5IG5lc3RlZFxuICAgICAgLy8gaW5zaWRlIG9mIHRoZSBibG9jayBpdCBpcyBsb2dpY2FsbHkgY29udGFpbmVkIGluc2lkZSBvZi4gVGhpcyBoYXBwZW5zIHdoZW5cbiAgICAgIC8vIHRoZSByZW1vdGUgYmxvY2sgaXMgYXBwZW5kZWQgdG8gdGhlIGVuZCBvZiB0aGUgYXBwbGljYXRpb24ncyBlbnRpcmUgZWxlbWVudC5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgcHJvYmxlbSB3aXRoIHRoYXQgc2NlbmFyaW8gaXMgdGhhdCBHbGltbWVyIGJlbGlldmVzIHRoYXQgaXQgb3ducyBtb3JlIG9mXG4gICAgICAvLyB0aGUgRE9NIHRoYW4gaXQgYWN0dWFsbHkgZG9lcy4gVGhlIGNvZGUgaXMgYXR0ZW1wdGluZyB0byB3cml0ZSBwYXN0IHRoZSBlbmRcbiAgICAgIC8vIG9mIHRoZSBHbGltbWVyLW1hbmFnZWQgcm9vdCwgYnV0IEdsaW1tZXIgaXNuJ3QgYXdhcmUgb2YgdGhhdC5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgY29ycmVjdCBzb2x1dGlvbiB0byB0aGF0IHByb2JsZW0gaXMgZm9yIEdsaW1tZXIgdG8gYmUgYXdhcmUgb2YgdGhlIGVuZFxuICAgICAgLy8gb2YgdGhlIGJvdW5kcyB0aGF0IGl0IG93bnMsIGFuZCBvbmNlIHdlIG1ha2UgdGhhdCBjaGFuZ2UsIHRoaXMgY2hlY2sgY291bGRcbiAgICAgIC8vIGJlIHJlbW92ZWQuXG4gICAgICAvL1xuICAgICAgLy8gRm9yIG5vdywgYSBtb3JlIHRhcmdldGVkIGZpeCBpcyB0byBjaGVjayB3aGV0aGVyIHRoZSBub2RlIHdhcyBhbHJlYWR5IHJlbW92ZWRcbiAgICAgIC8vIGFuZCBhdm9pZCBjbGVhcmluZyB0aGUgbm9kZSBpZiBpdCB3YXMuIEluIG1vc3QgY2FzZXMgdGhpcyBzaG91bGRuJ3QgaGFwcGVuLFxuICAgICAgLy8gc28gdGhpcyBtaWdodCBoaWRlIGJ1Z3Mgd2hlcmUgdGhlIGNvZGUgY2xlYXJzIG5lc3RlZCBub2RlcyB1bm5lY2Vzc2FyaWx5LFxuICAgICAgLy8gc28gd2Ugc2hvdWxkIGV2ZW50dWFsbHkgdHJ5IHRvIGRvIHRoZSBjb3JyZWN0IGZpeC5cbiAgICAgIGlmICh0aGlzLnBhcmVudEVsZW1lbnQoKSA9PT0gdGhpcy5maXJzdE5vZGUoKS5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNsZWFyKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVcGRhdGFibGVCbG9ja0ltcGwgZXh0ZW5kcyBTaW1wbGVMaXZlQmxvY2sgaW1wbGVtZW50cyBVcGRhdGFibGVCbG9jayB7XG4gIHJlc2V0KCk6IE9wdGlvbjxTaW1wbGVOb2RlPiB7XG4gICAgZGVzdHJveSh0aGlzKTtcbiAgICBsZXQgbmV4dFNpYmxpbmcgPSBjbGVhcih0aGlzKTtcblxuICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdCA9IG51bGw7XG4gICAgdGhpcy5uZXN0aW5nID0gMDtcblxuICAgIHJldHVybiBuZXh0U2libGluZztcbiAgfVxufVxuXG4vLyBGSVhNRTogQWxsIHRoZSBub29wcyBpbiBoZXJlIGluZGljYXRlIGEgbW9kZWxsaW5nIHByb2JsZW1cbmV4cG9ydCBjbGFzcyBMaXZlQmxvY2tMaXN0IGltcGxlbWVudHMgTGl2ZUJsb2NrIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwYXJlbnQ6IFNpbXBsZUVsZW1lbnQsIHB1YmxpYyBib3VuZExpc3Q6IExpdmVCbG9ja1tdKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5ib3VuZExpc3QgPSBib3VuZExpc3Q7XG4gIH1cblxuICBwYXJlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgfVxuXG4gIGZpcnN0Tm9kZSgpOiBTaW1wbGVOb2RlIHtcbiAgICBsZXQgaGVhZCA9IGV4cGVjdChcbiAgICAgIHRoaXMuYm91bmRMaXN0WzBdLFxuICAgICAgJ2Nhbm5vdCBjYWxsIGBmaXJzdE5vZGUoKWAgd2hpbGUgYExpdmVCbG9ja0xpc3RgIGlzIHN0aWxsIGluaXRpYWxpemluZydcbiAgICApO1xuXG4gICAgcmV0dXJuIGhlYWQuZmlyc3ROb2RlKCk7XG4gIH1cblxuICBsYXN0Tm9kZSgpOiBTaW1wbGVOb2RlIHtcbiAgICBsZXQgYm91bmRMaXN0ID0gdGhpcy5ib3VuZExpc3Q7XG5cbiAgICBsZXQgdGFpbCA9IGV4cGVjdChcbiAgICAgIGJvdW5kTGlzdFtib3VuZExpc3QubGVuZ3RoIC0gMV0sXG4gICAgICAnY2Fubm90IGNhbGwgYGxhc3ROb2RlKClgIHdoaWxlIGBMaXZlQmxvY2tMaXN0YCBpcyBzdGlsbCBpbml0aWFsaXppbmcnXG4gICAgKTtcblxuICAgIHJldHVybiB0YWlsLmxhc3ROb2RlKCk7XG4gIH1cblxuICBvcGVuRWxlbWVudChfZWxlbWVudDogU2ltcGxlRWxlbWVudCkge1xuICAgIGFzc2VydChmYWxzZSwgJ0Nhbm5vdCBvcGVuRWxlbWVudCBkaXJlY3RseSBpbnNpZGUgYSBibG9jayBsaXN0Jyk7XG4gIH1cblxuICBjbG9zZUVsZW1lbnQoKSB7XG4gICAgYXNzZXJ0KGZhbHNlLCAnQ2Fubm90IGNsb3NlRWxlbWVudCBkaXJlY3RseSBpbnNpZGUgYSBibG9jayBsaXN0Jyk7XG4gIH1cblxuICBkaWRBcHBlbmROb2RlKF9ub2RlOiBTaW1wbGVOb2RlKSB7XG4gICAgYXNzZXJ0KGZhbHNlLCAnQ2Fubm90IGNyZWF0ZSBhIG5ldyBub2RlIGRpcmVjdGx5IGluc2lkZSBhIGJsb2NrIGxpc3QnKTtcbiAgfVxuXG4gIGRpZEFwcGVuZEJvdW5kcyhfYm91bmRzOiBCb3VuZHMpIHt9XG5cbiAgZmluYWxpemUoX3N0YWNrOiBFbGVtZW50QnVpbGRlcikge1xuICAgIGFzc2VydCh0aGlzLmJvdW5kTGlzdC5sZW5ndGggPiAwLCAnYm91bmRzTGlzdCBjYW5ub3QgYmUgZW1wdHknKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xpZW50QnVpbGRlcihlbnY6IEVudmlyb25tZW50LCBjdXJzb3I6IEN1cnNvckltcGwpOiBFbGVtZW50QnVpbGRlciB7XG4gIHJldHVybiBOZXdFbGVtZW50QnVpbGRlci5mb3JJbml0aWFsUmVuZGVyKGVudiwgY3Vyc29yKTtcbn1cbiIsImltcG9ydCB7IGRlYnVnLCBsb2dPcGNvZGUsIG9wY29kZU1ldGFkYXRhLCByZWNvcmRTdGFja1NpemUgfSBmcm9tICdAZ2xpbW1lci9kZWJ1Zyc7XG5pbXBvcnQgeyBEaWN0LCBNYXliZSwgT3AsIE9wdGlvbiwgUnVudGltZU9wIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBMT0NBTF9ERUJVRywgTE9DQUxfU0hPVUxEX0xPRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7IHZhbHVlRm9yUmVmIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IGFzc2VydCwgZmlsbE51bGxzLCBMT0NBTF9MT0dHRVIgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7ICRmcCwgJHBjLCAkcmEsICRzcCB9IGZyb20gJ0BnbGltbWVyL3ZtJztcbmltcG9ydCB7IGlzU2NvcGVSZWZlcmVuY2UgfSBmcm9tICcuL3Njb3BlJztcbmltcG9ydCB7IENPTlNUQU5UUywgREVTVFJPWUFCTEVfU1RBQ0ssIElOTkVSX1ZNLCBTVEFDS1MgfSBmcm9tICcuL3N5bWJvbHMnO1xuaW1wb3J0IHsgTG93TGV2ZWxWTSwgVk0gfSBmcm9tICcuL3ZtJztcbmltcG9ydCB7IEludGVybmFsVk0gfSBmcm9tICcuL3ZtL2FwcGVuZCc7XG5pbXBvcnQgeyBDVVJTT1JfU1RBQ0sgfSBmcm9tICcuL3ZtL2VsZW1lbnQtYnVpbGRlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3Bjb2RlSlNPTiB7XG4gIHR5cGU6IG51bWJlciB8IHN0cmluZztcbiAgZ3VpZD86IE9wdGlvbjxudW1iZXI+O1xuICBkZW9wdGVkPzogYm9vbGVhbjtcbiAgYXJncz86IHN0cmluZ1tdO1xuICBkZXRhaWxzPzogRGljdDxPcHRpb248c3RyaW5nPj47XG4gIGNoaWxkcmVuPzogT3Bjb2RlSlNPTltdO1xufVxuXG5leHBvcnQgdHlwZSBPcGVyYW5kMSA9IG51bWJlcjtcbmV4cG9ydCB0eXBlIE9wZXJhbmQyID0gbnVtYmVyO1xuZXhwb3J0IHR5cGUgT3BlcmFuZDMgPSBudW1iZXI7XG5cbmV4cG9ydCB0eXBlIFN5c2NhbGwgPSAodm06IEludGVybmFsVk0sIG9wY29kZTogUnVudGltZU9wKSA9PiB2b2lkO1xuZXhwb3J0IHR5cGUgTWFjaGluZU9wY29kZSA9ICh2bTogTG93TGV2ZWxWTSwgb3Bjb2RlOiBSdW50aW1lT3ApID0+IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIEV2YWx1YXRlID1cbiAgfCB7IHN5c2NhbGw6IHRydWU7IGV2YWx1YXRlOiBTeXNjYWxsIH1cbiAgfCB7IHN5c2NhbGw6IGZhbHNlOyBldmFsdWF0ZTogTWFjaGluZU9wY29kZSB9O1xuXG5leHBvcnQgdHlwZSBEZWJ1Z1N0YXRlID0ge1xuICBwYzogbnVtYmVyO1xuICBzcDogbnVtYmVyO1xuICB0eXBlOiBudW1iZXI7XG4gIGlzTWFjaGluZTogMCB8IDE7XG4gIHNpemU6IG51bWJlcjtcbiAgcGFyYW1zPzogTWF5YmU8RGljdD47XG4gIG5hbWU/OiBzdHJpbmc7XG4gIHN0YXRlOiB1bmtub3duO1xufTtcblxuZXhwb3J0IGNsYXNzIEFwcGVuZE9wY29kZXMge1xuICBwcml2YXRlIGV2YWx1YXRlT3Bjb2RlOiBFdmFsdWF0ZVtdID0gZmlsbE51bGxzPEV2YWx1YXRlPihPcC5TaXplKS5zbGljZSgpO1xuXG4gIGFkZDxOYW1lIGV4dGVuZHMgT3A+KG5hbWU6IE5hbWUsIGV2YWx1YXRlOiBTeXNjYWxsKTogdm9pZDtcbiAgYWRkPE5hbWUgZXh0ZW5kcyBPcD4obmFtZTogTmFtZSwgZXZhbHVhdGU6IE1hY2hpbmVPcGNvZGUsIGtpbmQ6ICdtYWNoaW5lJyk6IHZvaWQ7XG4gIGFkZDxOYW1lIGV4dGVuZHMgT3A+KG5hbWU6IE5hbWUsIGV2YWx1YXRlOiBTeXNjYWxsIHwgTWFjaGluZU9wY29kZSwga2luZCA9ICdzeXNjYWxsJyk6IHZvaWQge1xuICAgIHRoaXMuZXZhbHVhdGVPcGNvZGVbbmFtZSBhcyBudW1iZXJdID0ge1xuICAgICAgc3lzY2FsbDoga2luZCAhPT0gJ21hY2hpbmUnLFxuICAgICAgZXZhbHVhdGUsXG4gICAgfSBhcyBFdmFsdWF0ZTtcbiAgfVxuXG4gIGRlYnVnQmVmb3JlKHZtOiBWTSwgb3Bjb2RlOiBSdW50aW1lT3ApOiBEZWJ1Z1N0YXRlIHtcbiAgICBsZXQgcGFyYW1zOiBNYXliZTxEaWN0PiA9IHVuZGVmaW5lZDtcbiAgICBsZXQgb3BOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoTE9DQUxfU0hPVUxEX0xPRykge1xuICAgICAgbGV0IHBvcyA9IHZtW0lOTkVSX1ZNXS5mZXRjaFJlZ2lzdGVyKCRwYykgLSBvcGNvZGUuc2l6ZTtcblxuICAgICAgW29wTmFtZSwgcGFyYW1zXSA9IGRlYnVnKHZtW0NPTlNUQU5UU10sIG9wY29kZSwgb3Bjb2RlLmlzTWFjaGluZSkhO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZyhgJHt0eXBlUG9zKHZtWydwYyddKX0uYCk7XG4gICAgICBMT0NBTF9MT0dHRVIubG9nKGAke3Bvc30uICR7bG9nT3Bjb2RlKG9wTmFtZSwgcGFyYW1zKX1gKTtcblxuICAgICAgbGV0IGRlYnVnUGFyYW1zID0gW107XG4gICAgICBmb3IgKGxldCBwcm9wIGluIHBhcmFtcykge1xuICAgICAgICBkZWJ1Z1BhcmFtcy5wdXNoKHByb3AsICc9JywgcGFyYW1zW3Byb3BdKTtcbiAgICAgIH1cblxuICAgICAgTE9DQUxfTE9HR0VSLmxvZyguLi5kZWJ1Z1BhcmFtcyk7XG4gICAgfVxuXG4gICAgbGV0IHNwOiBudW1iZXI7XG5cbiAgICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAgIHNwID0gdm0uZmV0Y2hWYWx1ZSgkc3ApO1xuICAgIH1cblxuICAgIHJlY29yZFN0YWNrU2l6ZSh2bS5mZXRjaFZhbHVlKCRzcCkpO1xuICAgIHJldHVybiB7XG4gICAgICBzcDogc3AhLFxuICAgICAgcGM6IHZtLmZldGNoVmFsdWUoJHBjKSxcbiAgICAgIG5hbWU6IG9wTmFtZSxcbiAgICAgIHBhcmFtcyxcbiAgICAgIHR5cGU6IG9wY29kZS50eXBlLFxuICAgICAgaXNNYWNoaW5lOiBvcGNvZGUuaXNNYWNoaW5lLFxuICAgICAgc2l6ZTogb3Bjb2RlLnNpemUsXG4gICAgICBzdGF0ZTogdW5kZWZpbmVkLFxuICAgIH07XG4gIH1cblxuICBkZWJ1Z0FmdGVyKHZtOiBWTSwgcHJlOiBEZWJ1Z1N0YXRlKSB7XG4gICAgbGV0IHsgc3AsIHR5cGUsIGlzTWFjaGluZSwgcGMgfSA9IHByZTtcblxuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgbGV0IG1ldGEgPSBvcGNvZGVNZXRhZGF0YSh0eXBlLCBpc01hY2hpbmUpO1xuICAgICAgbGV0IGFjdHVhbENoYW5nZSA9IHZtLmZldGNoVmFsdWUoJHNwKSAtIHNwITtcbiAgICAgIGlmIChcbiAgICAgICAgbWV0YSAmJlxuICAgICAgICBtZXRhLmNoZWNrICYmXG4gICAgICAgIHR5cGVvZiBtZXRhLnN0YWNrQ2hhbmdlISA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgbWV0YS5zdGFja0NoYW5nZSEgIT09IGFjdHVhbENoYW5nZVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRXJyb3IgaW4gJHtwcmUubmFtZX06XFxuXFxuJHtwY30uICR7bG9nT3Bjb2RlKFxuICAgICAgICAgICAgcHJlLm5hbWUhLFxuICAgICAgICAgICAgcHJlLnBhcmFtcyFcbiAgICAgICAgICApfVxcblxcblN0YWNrIGNoYW5nZWQgYnkgJHthY3R1YWxDaGFuZ2V9LCBleHBlY3RlZCAke21ldGEuc3RhY2tDaGFuZ2UhfWBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKExPQ0FMX1NIT1VMRF9MT0cpIHtcbiAgICAgICAgTE9DQUxfTE9HR0VSLmxvZyhcbiAgICAgICAgICAnJWMgLT4gcGM6ICVkLCByYTogJWQsIGZwOiAlZCwgc3A6ICVkLCBzMDogJU8sIHMxOiAlTywgdDA6ICVPLCB0MTogJU8sIHYwOiAlTycsXG4gICAgICAgICAgJ2NvbG9yOiBvcmFuZ2UnLFxuICAgICAgICAgIHZtW0lOTkVSX1ZNXS5yZWdpc3RlcnNbJHBjXSxcbiAgICAgICAgICB2bVtJTk5FUl9WTV0ucmVnaXN0ZXJzWyRyYV0sXG4gICAgICAgICAgdm1bSU5ORVJfVk1dLnJlZ2lzdGVyc1skZnBdLFxuICAgICAgICAgIHZtW0lOTkVSX1ZNXS5yZWdpc3RlcnNbJHNwXSxcbiAgICAgICAgICB2bVsnczAnXSxcbiAgICAgICAgICB2bVsnczEnXSxcbiAgICAgICAgICB2bVsndDAnXSxcbiAgICAgICAgICB2bVsndDEnXSxcbiAgICAgICAgICB2bVsndjAnXVxuICAgICAgICApO1xuICAgICAgICBMT0NBTF9MT0dHRVIubG9nKCclYyAtPiBldmFsIHN0YWNrJywgJ2NvbG9yOiByZWQnLCB2bS5zdGFjay50b0FycmF5KCkpO1xuICAgICAgICBMT0NBTF9MT0dHRVIubG9nKCclYyAtPiBibG9jayBzdGFjaycsICdjb2xvcjogbWFnZW50YScsIHZtLmVsZW1lbnRzKCkuZGVidWdCbG9ja3MoKSk7XG4gICAgICAgIExPQ0FMX0xPR0dFUi5sb2coXG4gICAgICAgICAgJyVjIC0+IGRlc3RydWN0b3Igc3RhY2snLFxuICAgICAgICAgICdjb2xvcjogdmlvbGV0JyxcbiAgICAgICAgICB2bVtERVNUUk9ZQUJMRV9TVEFDS10udG9BcnJheSgpXG4gICAgICAgICk7XG4gICAgICAgIGlmICh2bVtTVEFDS1NdLnNjb3BlLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBMT0NBTF9MT0dHRVIubG9nKCclYyAtPiBzY29wZScsICdjb2xvcjogZ3JlZW4nLCAnbnVsbCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIExPQ0FMX0xPR0dFUi5sb2coXG4gICAgICAgICAgICAnJWMgLT4gc2NvcGUnLFxuICAgICAgICAgICAgJ2NvbG9yOiBncmVlbicsXG4gICAgICAgICAgICB2bS5zY29wZSgpLnNsb3RzLm1hcCgocykgPT4gKGlzU2NvcGVSZWZlcmVuY2UocykgPyB2YWx1ZUZvclJlZihzKSA6IHMpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBMT0NBTF9MT0dHRVIubG9nKFxuICAgICAgICAgICclYyAtPiBlbGVtZW50cycsXG4gICAgICAgICAgJ2NvbG9yOiBibHVlJyxcbiAgICAgICAgICB2bS5lbGVtZW50cygpW0NVUlNPUl9TVEFDS10uY3VycmVudCEuZWxlbWVudFxuICAgICAgICApO1xuXG4gICAgICAgIExPQ0FMX0xPR0dFUi5sb2coJyVjIC0+IGNvbnN0cnVjdGluZycsICdjb2xvcjogYXF1YScsIHZtLmVsZW1lbnRzKClbJ2NvbnN0cnVjdGluZyddKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBldmFsdWF0ZSh2bTogVk0sIG9wY29kZTogUnVudGltZU9wLCB0eXBlOiBudW1iZXIpIHtcbiAgICBsZXQgb3BlcmF0aW9uID0gdGhpcy5ldmFsdWF0ZU9wY29kZVt0eXBlXTtcblxuICAgIGlmIChvcGVyYXRpb24uc3lzY2FsbCkge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICAhb3Bjb2RlLmlzTWFjaGluZSxcbiAgICAgICAgYEJVRzogTWlzbWF0Y2ggYmV0d2VlbiBvcGVyYXRpb24uc3lzY2FsbCAoJHtvcGVyYXRpb24uc3lzY2FsbH0pIGFuZCBvcGNvZGUuaXNNYWNoaW5lICgke29wY29kZS5pc01hY2hpbmV9KSBmb3IgJHtvcGNvZGUudHlwZX1gXG4gICAgICApO1xuICAgICAgb3BlcmF0aW9uLmV2YWx1YXRlKHZtLCBvcGNvZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIG9wY29kZS5pc01hY2hpbmUsXG4gICAgICAgIGBCVUc6IE1pc21hdGNoIGJldHdlZW4gb3BlcmF0aW9uLnN5c2NhbGwgKCR7b3BlcmF0aW9uLnN5c2NhbGx9KSBhbmQgb3Bjb2RlLmlzTWFjaGluZSAoJHtvcGNvZGUuaXNNYWNoaW5lfSkgZm9yICR7b3Bjb2RlLnR5cGV9YFxuICAgICAgKTtcbiAgICAgIG9wZXJhdGlvbi5ldmFsdWF0ZSh2bVtJTk5FUl9WTV0sIG9wY29kZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBBUFBFTkRfT1BDT0RFUyA9IG5ldyBBcHBlbmRPcGNvZGVzKCk7XG4iLCJpbXBvcnQgeyBEaWN0LCBNYXliZSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgUmVmZXJlbmNlLCB2YWx1ZUZvclJlZiwgY3JlYXRlQ29tcHV0ZVJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb25jYXRSZWYocGFydHNSZWZzOiBSZWZlcmVuY2VbXSkge1xuICByZXR1cm4gY3JlYXRlQ29tcHV0ZVJlZigoKSA9PiB7XG4gICAgbGV0IHBhcnRzID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHNSZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgdmFsdWUgPSB2YWx1ZUZvclJlZihwYXJ0c1JlZnNbaV0pIGFzIE1heWJlPERpY3Q+O1xuXG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJ0c1tpXSA9IGNhc3RUb1N0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhc3RUb1N0cmluZyh2YWx1ZTogRGljdCkge1xuICBpZiAodHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59XG4iLCJpbXBvcnQgeyBDYXB0dXJlZEFyZ3VtZW50cywgQ3VycmllZFR5cGUsIE93bmVyIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBzeW1ib2wsIF9XZWFrU2V0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBSZWZlcmVuY2UgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuXG5jb25zdCBUWVBFOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdUWVBFJyk7XG5jb25zdCBJTk5FUjogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnSU5ORVInKTtcbmNvbnN0IE9XTkVSOiB1bmlxdWUgc3ltYm9sID0gc3ltYm9sKCdPV05FUicpO1xuY29uc3QgQVJHUzogdW5pcXVlIHN5bWJvbCA9IHN5bWJvbCgnQVJHUycpO1xuY29uc3QgUkVTT0xWRUQ6IHVuaXF1ZSBzeW1ib2wgPSBzeW1ib2woJ1JFU09MVkVEJyk7XG5cbmNvbnN0IENVUlJJRURfVkFMVUVTID0gbmV3IF9XZWFrU2V0KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0N1cnJpZWRWYWx1ZSh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEN1cnJpZWRWYWx1ZTxDdXJyaWVkVHlwZT4ge1xuICByZXR1cm4gQ1VSUklFRF9WQUxVRVMuaGFzKHZhbHVlIGFzIG9iamVjdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0N1cnJpZWRUeXBlPFQgZXh0ZW5kcyBDdXJyaWVkVHlwZT4oXG4gIHZhbHVlOiB1bmtub3duLFxuICB0eXBlOiBUXG4pOiB2YWx1ZSBpcyBDdXJyaWVkVmFsdWU8VD4ge1xuICByZXR1cm4gaXNDdXJyaWVkVmFsdWUodmFsdWUpICYmIHZhbHVlW1RZUEVdID09PSB0eXBlO1xufVxuXG5leHBvcnQgY2xhc3MgQ3VycmllZFZhbHVlPFQgZXh0ZW5kcyBDdXJyaWVkVHlwZSA9IEN1cnJpZWRUeXBlPiB7XG4gIFtUWVBFXTogVDtcbiAgW0lOTkVSXTogb2JqZWN0IHwgc3RyaW5nIHwgQ3VycmllZFZhbHVlPFQ+O1xuICBbT1dORVJdOiBPd25lcjtcbiAgW0FSR1NdOiBDYXB0dXJlZEFyZ3VtZW50cyB8IG51bGw7XG4gIFtSRVNPTFZFRF06IGJvb2xlYW47XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICB0eXBlOiBULFxuICAgIGlubmVyOiBvYmplY3QgfCBzdHJpbmcgfCBDdXJyaWVkVmFsdWU8VD4sXG4gICAgb3duZXI6IE93bmVyLFxuICAgIGFyZ3M6IENhcHR1cmVkQXJndW1lbnRzIHwgbnVsbCxcbiAgICByZXNvbHZlZCA9IGZhbHNlXG4gICkge1xuICAgIENVUlJJRURfVkFMVUVTLmFkZCh0aGlzKTtcbiAgICB0aGlzW1RZUEVdID0gdHlwZTtcbiAgICB0aGlzW0lOTkVSXSA9IGlubmVyO1xuICAgIHRoaXNbT1dORVJdID0gb3duZXI7XG4gICAgdGhpc1tBUkdTXSA9IGFyZ3M7XG4gICAgdGhpc1tSRVNPTFZFRF0gPSByZXNvbHZlZDtcbiAgfVxufVxuXG5pbnRlcmZhY2UgUmVzb2x2ZWRDdXJyaWVkVmFsdWU8VD4ge1xuICBkZWZpbml0aW9uOiBUO1xuICBvd25lcjogT3duZXI7XG4gIHJlc29sdmVkOiBib29sZWFuO1xuICBwb3NpdGlvbmFsOiBSZWZlcmVuY2VbXSB8IHVuZGVmaW5lZDtcbiAgbmFtZWQ6IFJlY29yZDxzdHJpbmcsIFJlZmVyZW5jZT5bXSB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVDdXJyaWVkVmFsdWUoXG4gIGN1cnJpZWRWYWx1ZTogQ3VycmllZFZhbHVlPEN1cnJpZWRUeXBlLkNvbXBvbmVudD5cbik6IFJlc29sdmVkQ3VycmllZFZhbHVlPG9iamVjdCB8IHN0cmluZz47XG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUN1cnJpZWRWYWx1ZShcbiAgY3VycmllZFZhbHVlOiBDdXJyaWVkVmFsdWU8Q3VycmllZFR5cGUuSGVscGVyPiB8IEN1cnJpZWRWYWx1ZTxDdXJyaWVkVHlwZS5Nb2RpZmllcj5cbik6IFJlc29sdmVkQ3VycmllZFZhbHVlPG9iamVjdD47XG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUN1cnJpZWRWYWx1ZShcbiAgY3VycmllZFZhbHVlOiBDdXJyaWVkVmFsdWU8Q3VycmllZFR5cGU+XG4pOiBSZXNvbHZlZEN1cnJpZWRWYWx1ZTxvYmplY3QgfCBzdHJpbmc+IHtcbiAgbGV0IGN1cnJlbnRXcmFwcGVyID0gY3VycmllZFZhbHVlO1xuICBsZXQgcG9zaXRpb25hbDogUmVmZXJlbmNlW10gfCB1bmRlZmluZWQ7XG4gIGxldCBuYW1lZDogUmVjb3JkPHN0cmluZywgUmVmZXJlbmNlPltdIHwgdW5kZWZpbmVkO1xuICBsZXQgZGVmaW5pdGlvbiwgb3duZXIsIHJlc29sdmVkO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbGV0IHsgW0FSR1NdOiBjdXJyaWVkQXJncywgW0lOTkVSXTogaW5uZXIgfSA9IGN1cnJlbnRXcmFwcGVyO1xuXG4gICAgaWYgKGN1cnJpZWRBcmdzICE9PSBudWxsKSB7XG4gICAgICBsZXQgeyBuYW1lZDogY3VycmllZE5hbWVkLCBwb3NpdGlvbmFsOiBjdXJyaWVkUG9zaXRpb25hbCB9ID0gY3VycmllZEFyZ3M7XG5cbiAgICAgIGlmIChjdXJyaWVkUG9zaXRpb25hbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBvc2l0aW9uYWwgPVxuICAgICAgICAgIHBvc2l0aW9uYWwgPT09IHVuZGVmaW5lZCA/IGN1cnJpZWRQb3NpdGlvbmFsIDogY3VycmllZFBvc2l0aW9uYWwuY29uY2F0KHBvc2l0aW9uYWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuYW1lZCA9IFtdO1xuICAgICAgfVxuXG4gICAgICBuYW1lZC51bnNoaWZ0KGN1cnJpZWROYW1lZCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0N1cnJpZWRWYWx1ZShpbm5lcikpIHtcbiAgICAgIC8vIFNhdmUgb2ZmIHRoZSBvd25lciB0aGF0IHRoaXMgaGVscGVyIHdhcyBjdXJyaWVkIHdpdGguIExhdGVyIG9uLFxuICAgICAgLy8gd2UnbGwgZmV0Y2ggdGhlIHZhbHVlIG9mIHRoaXMgcmVnaXN0ZXIgYW5kIHNldCBpdCBhcyB0aGUgb3duZXIgb24gdGhlXG4gICAgICAvLyBuZXcgcm9vdCBzY29wZS5cbiAgICAgIGRlZmluaXRpb24gPSBpbm5lcjtcbiAgICAgIG93bmVyID0gY3VycmVudFdyYXBwZXJbT1dORVJdO1xuICAgICAgcmVzb2x2ZWQgPSBjdXJyZW50V3JhcHBlcltSRVNPTFZFRF07XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjdXJyZW50V3JhcHBlciA9IGlubmVyO1xuICB9XG5cbiAgcmV0dXJuIHsgZGVmaW5pdGlvbiwgb3duZXIsIHJlc29sdmVkLCBwb3NpdGlvbmFsLCBuYW1lZCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3Vycnk8VCBleHRlbmRzIEN1cnJpZWRUeXBlPihcbiAgdHlwZTogVCxcbiAgc3BlYzogb2JqZWN0IHwgc3RyaW5nIHwgQ3VycmllZFZhbHVlPFQ+LFxuICBvd25lcjogT3duZXIsXG4gIGFyZ3M6IENhcHR1cmVkQXJndW1lbnRzIHwgbnVsbCxcbiAgcmVzb2x2ZWQgPSBmYWxzZVxuKTogQ3VycmllZFZhbHVlPFQ+IHtcbiAgcmV0dXJuIG5ldyBDdXJyaWVkVmFsdWUodHlwZSwgc3BlYywgb3duZXIsIGFyZ3MsIHJlc29sdmVkKTtcbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7XG4gIENhcHR1cmVkQXJndW1lbnRzLFxuICBDdXJyaWVkVHlwZSxcbiAgRGljdCxcbiAgTWF5YmUsXG4gIE9wdGlvbixcbiAgT3duZXIsXG4gIFJ1bnRpbWVSZXNvbHZlcixcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjcmVhdGVDb21wdXRlUmVmLCBSZWZlcmVuY2UsIHZhbHVlRm9yUmVmIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IGV4cGVjdCwgaXNPYmplY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IGN1cnJ5LCBpc0N1cnJpZWRUeXBlIH0gZnJvbSAnLi4vY3VycmllZC12YWx1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5UmVmKFxuICB0eXBlOiBDdXJyaWVkVHlwZSxcbiAgaW5uZXI6IFJlZmVyZW5jZSxcbiAgb3duZXI6IE93bmVyLFxuICBhcmdzOiBPcHRpb248Q2FwdHVyZWRBcmd1bWVudHM+LFxuICByZXNvbHZlcjogUnVudGltZVJlc29sdmVyLFxuICBpc1N0cmljdDogYm9vbGVhblxuKSB7XG4gIGxldCBsYXN0VmFsdWU6IE1heWJlPERpY3Q+IHwgc3RyaW5nLCBjdXJyaWVkRGVmaW5pdGlvbjogb2JqZWN0IHwgc3RyaW5nIHwgbnVsbDtcblxuICByZXR1cm4gY3JlYXRlQ29tcHV0ZVJlZigoKSA9PiB7XG4gICAgbGV0IHZhbHVlID0gdmFsdWVGb3JSZWYoaW5uZXIpIGFzIE1heWJlPERpY3Q+IHwgc3RyaW5nO1xuXG4gICAgaWYgKHZhbHVlID09PSBsYXN0VmFsdWUpIHtcbiAgICAgIHJldHVybiBjdXJyaWVkRGVmaW5pdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoaXNDdXJyaWVkVHlwZSh2YWx1ZSwgdHlwZSkpIHtcbiAgICAgIGN1cnJpZWREZWZpbml0aW9uID0gYXJncyA/IGN1cnJ5KHR5cGUsIHZhbHVlLCBvd25lciwgYXJncykgOiBhcmdzO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQ3VycmllZFR5cGUuQ29tcG9uZW50ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUpIHtcbiAgICAgIC8vIE9ubHkgY29tcG9uZW50cyBzaG91bGQgZW50ZXIgdGhpcyBwYXRoLCBhcyBoZWxwZXJzIGFuZCBtb2RpZmllcnMgZG8gbm90XG4gICAgICAvLyBzdXBwb3J0IHN0cmluZyBiYXNlZCByZXNvbHV0aW9uXG5cbiAgICAgIGlmIChERUJVRykge1xuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBkeW5hbWljIGNvbXBvbmVudCB3aXRoIGEgc3RyaW5nIGRlZmluaXRpb24sIFxcYCR7dmFsdWV9XFxgIGluIGEgc3RyaWN0IG1vZGUgdGVtcGxhdGUuIEluIHN0cmljdCBtb2RlLCB1c2luZyBzdHJpbmdzIHRvIHJlc29sdmUgY29tcG9uZW50IGRlZmluaXRpb25zIGlzIHByb2hpYml0ZWQuIFlvdSBjYW4gaW5zdGVhZCBpbXBvcnQgdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uIGFuZCB1c2UgaXQgZGlyZWN0bHkuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzb2x2ZWREZWZpbml0aW9uID0gZXhwZWN0KFxuICAgICAgICAgIHJlc29sdmVyLFxuICAgICAgICAgICdCVUc6IGV4cGVjdGVkIHJlc29sdmVyIGZvciBjdXJyaWVkIGNvbXBvbmVudCBkZWZpbml0aW9ucydcbiAgICAgICAgKS5sb29rdXBDb21wb25lbnQodmFsdWUsIG93bmVyKTtcblxuICAgICAgICBpZiAoIXJlc29sdmVkRGVmaW5pdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gcmVzb2x2ZSBcXGAke3ZhbHVlfVxcYCwgd2hpY2ggd2FzIGV4cGVjdGVkIHRvIGJlIGEgY29tcG9uZW50LCBidXQgbm90aGluZyB3YXMgZm91bmQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3VycmllZERlZmluaXRpb24gPSBjdXJyeSh0eXBlLCB2YWx1ZSwgb3duZXIsIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBjdXJyaWVkRGVmaW5pdGlvbiA9IGN1cnJ5KHR5cGUsIHZhbHVlLCBvd25lciwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJpZWREZWZpbml0aW9uID0gbnVsbDtcbiAgICB9XG5cbiAgICBsYXN0VmFsdWUgPSB2YWx1ZTtcblxuICAgIHJldHVybiBjdXJyaWVkRGVmaW5pdGlvbjtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBjaGVjaywgQ2hlY2tCbG9ja1N5bWJvbFRhYmxlLCBDaGVja0hhbmRsZSwgQ2hlY2tPcHRpb24sIENoZWNrT3IgfSBmcm9tICdAZ2xpbW1lci9kZWJ1Zyc7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQge1xuICBCbG9ja0FyZ3VtZW50cyxcbiAgQmxvY2tTeW1ib2xUYWJsZSxcbiAgQmxvY2tWYWx1ZSxcbiAgQ2FwdHVyZWRBcmd1bWVudHMsXG4gIENhcHR1cmVkQmxvY2tBcmd1bWVudHMsXG4gIENhcHR1cmVkTmFtZWRBcmd1bWVudHMsXG4gIENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cyxcbiAgQ29tcGlsYWJsZUJsb2NrLFxuICBEaWN0LFxuICBOYW1lZEFyZ3VtZW50cyxcbiAgT3B0aW9uLFxuICBQb3NpdGlvbmFsQXJndW1lbnRzLFxuICBTY29wZSxcbiAgU2NvcGVCbG9jayxcbiAgVk1Bcmd1bWVudHMsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHtcbiAgY3JlYXRlRGVidWdBbGlhc1JlZixcbiAgUmVmZXJlbmNlLFxuICBVTkRFRklORURfUkVGRVJFTkNFLFxuICB2YWx1ZUZvclJlZixcbn0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IGRpY3QsIGVtcHR5QXJyYXksIEVNUFRZX1NUUklOR19BUlJBWSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQ09OU1RBTlRfVEFHLCBUYWcgfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHsgJHNwIH0gZnJvbSAnQGdsaW1tZXIvdm0nO1xuaW1wb3J0IHsgQ2hlY2tDb21waWxhYmxlQmxvY2ssIENoZWNrUmVmZXJlbmNlLCBDaGVja1Njb3BlIH0gZnJvbSAnLi4vY29tcGlsZWQvb3Bjb2Rlcy8tZGVidWctc3RyaXAnO1xuaW1wb3J0IHsgUkVHSVNURVJTIH0gZnJvbSAnLi4vc3ltYm9scyc7XG5pbXBvcnQgeyBFdmFsdWF0aW9uU3RhY2sgfSBmcm9tICcuL3N0YWNrJztcblxuLypcbiAgVGhlIGNhbGxpbmcgY29udmVudGlvbiBpczpcblxuICAqIDAtTiBibG9jayBhcmd1bWVudHMgYXQgdGhlIGJvdHRvbVxuICAqIDAtTiBwb3NpdGlvbmFsIGFyZ3VtZW50cyBuZXh0IChsZWZ0LXRvLXJpZ2h0KVxuICAqIDAtTiBuYW1lZCBhcmd1bWVudHMgbmV4dFxuKi9cblxuZXhwb3J0IGNsYXNzIFZNQXJndW1lbnRzSW1wbCBpbXBsZW1lbnRzIFZNQXJndW1lbnRzIHtcbiAgcHJpdmF0ZSBzdGFjazogT3B0aW9uPEV2YWx1YXRpb25TdGFjaz4gPSBudWxsO1xuICBwdWJsaWMgcG9zaXRpb25hbCA9IG5ldyBQb3NpdGlvbmFsQXJndW1lbnRzSW1wbCgpO1xuICBwdWJsaWMgbmFtZWQgPSBuZXcgTmFtZWRBcmd1bWVudHNJbXBsKCk7XG4gIHB1YmxpYyBibG9ja3MgPSBuZXcgQmxvY2tBcmd1bWVudHNJbXBsKCk7XG5cbiAgZW1wdHkoc3RhY2s6IEV2YWx1YXRpb25TdGFjayk6IHRoaXMge1xuICAgIGxldCBiYXNlID0gc3RhY2tbUkVHSVNURVJTXVskc3BdICsgMTtcblxuICAgIHRoaXMubmFtZWQuZW1wdHkoc3RhY2ssIGJhc2UpO1xuICAgIHRoaXMucG9zaXRpb25hbC5lbXB0eShzdGFjaywgYmFzZSk7XG4gICAgdGhpcy5ibG9ja3MuZW1wdHkoc3RhY2ssIGJhc2UpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXR1cChcbiAgICBzdGFjazogRXZhbHVhdGlvblN0YWNrLFxuICAgIG5hbWVzOiByZWFkb25seSBzdHJpbmdbXSxcbiAgICBibG9ja05hbWVzOiByZWFkb25seSBzdHJpbmdbXSxcbiAgICBwb3NpdGlvbmFsQ291bnQ6IG51bWJlcixcbiAgICBhdE5hbWVzOiBib29sZWFuXG4gICkge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcblxuICAgIC8qXG4gICAgICAgICAgIHwgLi4uIHwgYmxvY2tzICAgICAgfCBwb3NpdGlvbmFsICB8IG5hbWVkIHxcbiAgICAgICAgICAgfCAuLi4gfCBiMCAgICBiMSAgICB8IHAwIHAxIHAyIHAzIHwgbjAgbjEgfFxuICAgICBpbmRleCB8IC4uLiB8IDQvNS82IDcvOC85IHwgMTAgMTEgMTIgMTMgfCAxNCAxNSB8XG4gICAgICAgICAgICAgICAgICAgXiAgICAgICAgICAgICBeICAgICAgICAgICAgIF4gIF5cbiAgICAgICAgICAgICAgICAgYmJhc2UgICAgICAgICBwYmFzZSAgICAgICBuYmFzZSAgc3BcbiAgICAqL1xuXG4gICAgbGV0IG5hbWVkID0gdGhpcy5uYW1lZDtcbiAgICBsZXQgbmFtZWRDb3VudCA9IG5hbWVzLmxlbmd0aDtcbiAgICBsZXQgbmFtZWRCYXNlID0gc3RhY2tbUkVHSVNURVJTXVskc3BdIC0gbmFtZWRDb3VudCArIDE7XG5cbiAgICBuYW1lZC5zZXR1cChzdGFjaywgbmFtZWRCYXNlLCBuYW1lZENvdW50LCBuYW1lcywgYXROYW1lcyk7XG5cbiAgICBsZXQgcG9zaXRpb25hbCA9IHRoaXMucG9zaXRpb25hbDtcbiAgICBsZXQgcG9zaXRpb25hbEJhc2UgPSBuYW1lZEJhc2UgLSBwb3NpdGlvbmFsQ291bnQ7XG5cbiAgICBwb3NpdGlvbmFsLnNldHVwKHN0YWNrLCBwb3NpdGlvbmFsQmFzZSwgcG9zaXRpb25hbENvdW50KTtcblxuICAgIGxldCBibG9ja3MgPSB0aGlzLmJsb2NrcztcbiAgICBsZXQgYmxvY2tzQ291bnQgPSBibG9ja05hbWVzLmxlbmd0aDtcbiAgICBsZXQgYmxvY2tzQmFzZSA9IHBvc2l0aW9uYWxCYXNlIC0gYmxvY2tzQ291bnQgKiAzO1xuXG4gICAgYmxvY2tzLnNldHVwKHN0YWNrLCBibG9ja3NCYXNlLCBibG9ja3NDb3VudCwgYmxvY2tOYW1lcyk7XG4gIH1cblxuICBnZXQgYmFzZSgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmJsb2Nrcy5iYXNlO1xuICB9XG5cbiAgZ2V0IGxlbmd0aCgpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uYWwubGVuZ3RoICsgdGhpcy5uYW1lZC5sZW5ndGggKyB0aGlzLmJsb2Nrcy5sZW5ndGggKiAzO1xuICB9XG5cbiAgYXQocG9zOiBudW1iZXIpOiBSZWZlcmVuY2Uge1xuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uYWwuYXQocG9zKTtcbiAgfVxuXG4gIHJlYWxsb2Mob2Zmc2V0OiBudW1iZXIpIHtcbiAgICBsZXQgeyBzdGFjayB9ID0gdGhpcztcbiAgICBpZiAob2Zmc2V0ID4gMCAmJiBzdGFjayAhPT0gbnVsbCkge1xuICAgICAgbGV0IHsgcG9zaXRpb25hbCwgbmFtZWQgfSA9IHRoaXM7XG4gICAgICBsZXQgbmV3QmFzZSA9IHBvc2l0aW9uYWwuYmFzZSArIG9mZnNldDtcbiAgICAgIGxldCBsZW5ndGggPSBwb3NpdGlvbmFsLmxlbmd0aCArIG5hbWVkLmxlbmd0aDtcblxuICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0YWNrLmNvcHkoaSArIHBvc2l0aW9uYWwuYmFzZSwgaSArIG5ld0Jhc2UpO1xuICAgICAgfVxuXG4gICAgICBwb3NpdGlvbmFsLmJhc2UgKz0gb2Zmc2V0O1xuICAgICAgbmFtZWQuYmFzZSArPSBvZmZzZXQ7XG4gICAgICBzdGFja1tSRUdJU1RFUlNdWyRzcF0gKz0gb2Zmc2V0O1xuICAgIH1cbiAgfVxuXG4gIGNhcHR1cmUoKTogQ2FwdHVyZWRBcmd1bWVudHMge1xuICAgIGxldCBwb3NpdGlvbmFsID0gdGhpcy5wb3NpdGlvbmFsLmxlbmd0aCA9PT0gMCA/IEVNUFRZX1BPU0lUSU9OQUwgOiB0aGlzLnBvc2l0aW9uYWwuY2FwdHVyZSgpO1xuICAgIGxldCBuYW1lZCA9IHRoaXMubmFtZWQubGVuZ3RoID09PSAwID8gRU1QVFlfTkFNRUQgOiB0aGlzLm5hbWVkLmNhcHR1cmUoKTtcblxuICAgIHJldHVybiB7IG5hbWVkLCBwb3NpdGlvbmFsIH0gYXMgQ2FwdHVyZWRBcmd1bWVudHM7XG4gIH1cblxuICBjbGVhcigpOiB2b2lkIHtcbiAgICBsZXQgeyBzdGFjaywgbGVuZ3RoIH0gPSB0aGlzO1xuICAgIGlmIChsZW5ndGggPiAwICYmIHN0YWNrICE9PSBudWxsKSBzdGFjay5wb3AobGVuZ3RoKTtcbiAgfVxufVxuXG5jb25zdCBFTVBUWV9SRUZFUkVOQ0VTID0gZW1wdHlBcnJheTxSZWZlcmVuY2U+KCk7XG5cbmV4cG9ydCBjbGFzcyBQb3NpdGlvbmFsQXJndW1lbnRzSW1wbCBpbXBsZW1lbnRzIFBvc2l0aW9uYWxBcmd1bWVudHMge1xuICBwdWJsaWMgYmFzZSA9IDA7XG4gIHB1YmxpYyBsZW5ndGggPSAwO1xuXG4gIHByaXZhdGUgc3RhY2s6IEV2YWx1YXRpb25TdGFjayA9IG51bGwgYXMgYW55O1xuXG4gIHByaXZhdGUgX3JlZmVyZW5jZXM6IE9wdGlvbjxyZWFkb25seSBSZWZlcmVuY2VbXT4gPSBudWxsO1xuXG4gIGVtcHR5KHN0YWNrOiBFdmFsdWF0aW9uU3RhY2ssIGJhc2U6IG51bWJlcikge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIHRoaXMuX3JlZmVyZW5jZXMgPSBFTVBUWV9SRUZFUkVOQ0VTO1xuICB9XG5cbiAgc2V0dXAoc3RhY2s6IEV2YWx1YXRpb25TdGFjaywgYmFzZTogbnVtYmVyLCBsZW5ndGg6IG51bWJlcikge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuXG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fcmVmZXJlbmNlcyA9IEVNUFRZX1JFRkVSRU5DRVM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlZmVyZW5jZXMgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGF0KHBvc2l0aW9uOiBudW1iZXIpOiBSZWZlcmVuY2Uge1xuICAgIGxldCB7IGJhc2UsIGxlbmd0aCwgc3RhY2sgfSA9IHRoaXM7XG5cbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIFVOREVGSU5FRF9SRUZFUkVOQ0U7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoZWNrKHN0YWNrLmdldChwb3NpdGlvbiwgYmFzZSksIENoZWNrUmVmZXJlbmNlKTtcbiAgfVxuXG4gIGNhcHR1cmUoKTogQ2FwdHVyZWRQb3NpdGlvbmFsQXJndW1lbnRzIHtcbiAgICByZXR1cm4gdGhpcy5yZWZlcmVuY2VzIGFzIENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cztcbiAgfVxuXG4gIHByZXBlbmQob3RoZXI6IFJlZmVyZW5jZVtdKSB7XG4gICAgbGV0IGFkZGl0aW9ucyA9IG90aGVyLmxlbmd0aDtcblxuICAgIGlmIChhZGRpdGlvbnMgPiAwKSB7XG4gICAgICBsZXQgeyBiYXNlLCBsZW5ndGgsIHN0YWNrIH0gPSB0aGlzO1xuXG4gICAgICB0aGlzLmJhc2UgPSBiYXNlID0gYmFzZSAtIGFkZGl0aW9ucztcbiAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoICsgYWRkaXRpb25zO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZGl0aW9uczsgaSsrKSB7XG4gICAgICAgIHN0YWNrLnNldChvdGhlcltpXSwgaSwgYmFzZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlZmVyZW5jZXMgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0IHJlZmVyZW5jZXMoKTogcmVhZG9ubHkgUmVmZXJlbmNlW10ge1xuICAgIGxldCByZWZlcmVuY2VzID0gdGhpcy5fcmVmZXJlbmNlcztcblxuICAgIGlmICghcmVmZXJlbmNlcykge1xuICAgICAgbGV0IHsgc3RhY2ssIGJhc2UsIGxlbmd0aCB9ID0gdGhpcztcbiAgICAgIHJlZmVyZW5jZXMgPSB0aGlzLl9yZWZlcmVuY2VzID0gc3RhY2suc2xpY2U8UmVmZXJlbmNlPihiYXNlLCBiYXNlICsgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmZXJlbmNlcztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTmFtZWRBcmd1bWVudHNJbXBsIGltcGxlbWVudHMgTmFtZWRBcmd1bWVudHMge1xuICBwdWJsaWMgYmFzZSA9IDA7XG4gIHB1YmxpYyBsZW5ndGggPSAwO1xuXG4gIHByaXZhdGUgc3RhY2shOiBFdmFsdWF0aW9uU3RhY2s7XG5cbiAgcHJpdmF0ZSBfcmVmZXJlbmNlczogT3B0aW9uPHJlYWRvbmx5IFJlZmVyZW5jZVtdPiA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfbmFtZXM6IE9wdGlvbjxyZWFkb25seSBzdHJpbmdbXT4gPSBFTVBUWV9TVFJJTkdfQVJSQVk7XG4gIHByaXZhdGUgX2F0TmFtZXM6IE9wdGlvbjxyZWFkb25seSBzdHJpbmdbXT4gPSBFTVBUWV9TVFJJTkdfQVJSQVk7XG5cbiAgZW1wdHkoc3RhY2s6IEV2YWx1YXRpb25TdGFjaywgYmFzZTogbnVtYmVyKSB7XG4gICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5fcmVmZXJlbmNlcyA9IEVNUFRZX1JFRkVSRU5DRVM7XG4gICAgdGhpcy5fbmFtZXMgPSBFTVBUWV9TVFJJTkdfQVJSQVk7XG4gICAgdGhpcy5fYXROYW1lcyA9IEVNUFRZX1NUUklOR19BUlJBWTtcbiAgfVxuXG4gIHNldHVwKFxuICAgIHN0YWNrOiBFdmFsdWF0aW9uU3RhY2ssXG4gICAgYmFzZTogbnVtYmVyLFxuICAgIGxlbmd0aDogbnVtYmVyLFxuICAgIG5hbWVzOiByZWFkb25seSBzdHJpbmdbXSxcbiAgICBhdE5hbWVzOiBib29sZWFuXG4gICkge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuXG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fcmVmZXJlbmNlcyA9IEVNUFRZX1JFRkVSRU5DRVM7XG4gICAgICB0aGlzLl9uYW1lcyA9IEVNUFRZX1NUUklOR19BUlJBWTtcbiAgICAgIHRoaXMuX2F0TmFtZXMgPSBFTVBUWV9TVFJJTkdfQVJSQVk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlZmVyZW5jZXMgPSBudWxsO1xuXG4gICAgICBpZiAoYXROYW1lcykge1xuICAgICAgICB0aGlzLl9uYW1lcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2F0TmFtZXMgPSBuYW1lcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX25hbWVzID0gbmFtZXM7XG4gICAgICAgIHRoaXMuX2F0TmFtZXMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBuYW1lcygpOiByZWFkb25seSBzdHJpbmdbXSB7XG4gICAgbGV0IG5hbWVzID0gdGhpcy5fbmFtZXM7XG5cbiAgICBpZiAoIW5hbWVzKSB7XG4gICAgICBuYW1lcyA9IHRoaXMuX25hbWVzID0gdGhpcy5fYXROYW1lcyEubWFwKHRoaXMudG9TeW50aGV0aWNOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZXMhO1xuICB9XG5cbiAgZ2V0IGF0TmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIGxldCBhdE5hbWVzID0gdGhpcy5fYXROYW1lcztcblxuICAgIGlmICghYXROYW1lcykge1xuICAgICAgYXROYW1lcyA9IHRoaXMuX2F0TmFtZXMgPSB0aGlzLl9uYW1lcyEubWFwKHRoaXMudG9BdE5hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBhdE5hbWVzITtcbiAgfVxuXG4gIGhhcyhuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lcy5pbmRleE9mKG5hbWUpICE9PSAtMTtcbiAgfVxuXG4gIGdldChuYW1lOiBzdHJpbmcsIGF0TmFtZXMgPSBmYWxzZSk6IFJlZmVyZW5jZSB7XG4gICAgbGV0IHsgYmFzZSwgc3RhY2sgfSA9IHRoaXM7XG5cbiAgICBsZXQgbmFtZXMgPSBhdE5hbWVzID8gdGhpcy5hdE5hbWVzIDogdGhpcy5uYW1lcztcblxuICAgIGxldCBpZHggPSBuYW1lcy5pbmRleE9mKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBVTkRFRklORURfUkVGRVJFTkNFO1xuICAgIH1cblxuICAgIGxldCByZWYgPSBzdGFjay5nZXQ8UmVmZXJlbmNlPihpZHgsIGJhc2UpO1xuXG4gICAgaWYgKERFQlVHKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRGVidWdBbGlhc1JlZiEoYXROYW1lcyA/IG5hbWUgOiBgQCR7bmFtZX1gLCByZWYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH1cbiAgfVxuXG4gIGNhcHR1cmUoKTogQ2FwdHVyZWROYW1lZEFyZ3VtZW50cyB7XG4gICAgbGV0IHsgbmFtZXMsIHJlZmVyZW5jZXMgfSA9IHRoaXM7XG4gICAgbGV0IG1hcCA9IGRpY3Q8UmVmZXJlbmNlPigpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG5hbWUgPSBuYW1lc1tpXTtcblxuICAgICAgaWYgKERFQlVHKSB7XG4gICAgICAgIG1hcFtuYW1lXSA9IGNyZWF0ZURlYnVnQWxpYXNSZWYhKGBAJHtuYW1lfWAsIHJlZmVyZW5jZXNbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFwW25hbWVdID0gcmVmZXJlbmNlc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFwIGFzIENhcHR1cmVkTmFtZWRBcmd1bWVudHM7XG4gIH1cblxuICBtZXJnZShvdGhlcjogUmVjb3JkPHN0cmluZywgUmVmZXJlbmNlPikge1xuICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXMob3RoZXIpO1xuXG4gICAgaWYgKGtleXMubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IHsgbmFtZXMsIGxlbmd0aCwgc3RhY2sgfSA9IHRoaXM7XG4gICAgICBsZXQgbmV3TmFtZXMgPSBuYW1lcy5zbGljZSgpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5hbWUgPSBrZXlzW2ldO1xuICAgICAgICBsZXQgaWR4ID0gbmV3TmFtZXMuaW5kZXhPZihuYW1lKTtcblxuICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgIGxlbmd0aCA9IG5ld05hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChvdGhlcltuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgICB0aGlzLl9yZWZlcmVuY2VzID0gbnVsbDtcbiAgICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG4gICAgICB0aGlzLl9hdE5hbWVzID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldCByZWZlcmVuY2VzKCk6IHJlYWRvbmx5IFJlZmVyZW5jZVtdIHtcbiAgICBsZXQgcmVmZXJlbmNlcyA9IHRoaXMuX3JlZmVyZW5jZXM7XG5cbiAgICBpZiAoIXJlZmVyZW5jZXMpIHtcbiAgICAgIGxldCB7IGJhc2UsIGxlbmd0aCwgc3RhY2sgfSA9IHRoaXM7XG4gICAgICByZWZlcmVuY2VzID0gdGhpcy5fcmVmZXJlbmNlcyA9IHN0YWNrLnNsaWNlPFJlZmVyZW5jZT4oYmFzZSwgYmFzZSArIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZmVyZW5jZXM7XG4gIH1cblxuICBwcml2YXRlIHRvU3ludGhldGljTmFtZSh0aGlzOiB2b2lkLCBuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBuYW1lLnNsaWNlKDEpO1xuICB9XG5cbiAgcHJpdmF0ZSB0b0F0TmFtZSh0aGlzOiB2b2lkLCBuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgQCR7bmFtZX1gO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvU3ltYm9sTmFtZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gYCYke25hbWV9YDtcbn1cblxuY29uc3QgRU1QVFlfQkxPQ0tfVkFMVUVTID0gZW1wdHlBcnJheTxCbG9ja1ZhbHVlPigpO1xuXG5leHBvcnQgY2xhc3MgQmxvY2tBcmd1bWVudHNJbXBsIGltcGxlbWVudHMgQmxvY2tBcmd1bWVudHMge1xuICBwcml2YXRlIHN0YWNrITogRXZhbHVhdGlvblN0YWNrO1xuICBwcml2YXRlIGludGVybmFsVmFsdWVzOiBPcHRpb248cmVhZG9ubHkgQmxvY2tWYWx1ZVtdPiA9IG51bGw7XG4gIHByaXZhdGUgX3N5bWJvbE5hbWVzOiBPcHRpb248cmVhZG9ubHkgc3RyaW5nW10+ID0gbnVsbDtcblxuICBwdWJsaWMgaW50ZXJuYWxUYWc6IE9wdGlvbjxUYWc+ID0gbnVsbDtcbiAgcHVibGljIG5hbWVzOiByZWFkb25seSBzdHJpbmdbXSA9IEVNUFRZX1NUUklOR19BUlJBWTtcblxuICBwdWJsaWMgbGVuZ3RoID0gMDtcbiAgcHVibGljIGJhc2UgPSAwO1xuXG4gIGVtcHR5KHN0YWNrOiBFdmFsdWF0aW9uU3RhY2ssIGJhc2U6IG51bWJlcikge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLm5hbWVzID0gRU1QVFlfU1RSSU5HX0FSUkFZO1xuICAgIHRoaXMuYmFzZSA9IGJhc2U7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3N5bWJvbE5hbWVzID0gbnVsbDtcblxuICAgIHRoaXMuaW50ZXJuYWxUYWcgPSBDT05TVEFOVF9UQUc7XG4gICAgdGhpcy5pbnRlcm5hbFZhbHVlcyA9IEVNUFRZX0JMT0NLX1ZBTFVFUztcbiAgfVxuXG4gIHNldHVwKHN0YWNrOiBFdmFsdWF0aW9uU3RhY2ssIGJhc2U6IG51bWJlciwgbGVuZ3RoOiBudW1iZXIsIG5hbWVzOiByZWFkb25seSBzdHJpbmdbXSkge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLm5hbWVzID0gbmFtZXM7XG4gICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLl9zeW1ib2xOYW1lcyA9IG51bGw7XG5cbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmludGVybmFsVGFnID0gQ09OU1RBTlRfVEFHO1xuICAgICAgdGhpcy5pbnRlcm5hbFZhbHVlcyA9IEVNUFRZX0JMT0NLX1ZBTFVFUztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnRlcm5hbFRhZyA9IG51bGw7XG4gICAgICB0aGlzLmludGVybmFsVmFsdWVzID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBnZXQgdmFsdWVzKCk6IHJlYWRvbmx5IEJsb2NrVmFsdWVbXSB7XG4gICAgbGV0IHZhbHVlcyA9IHRoaXMuaW50ZXJuYWxWYWx1ZXM7XG5cbiAgICBpZiAoIXZhbHVlcykge1xuICAgICAgbGV0IHsgYmFzZSwgbGVuZ3RoLCBzdGFjayB9ID0gdGhpcztcbiAgICAgIHZhbHVlcyA9IHRoaXMuaW50ZXJuYWxWYWx1ZXMgPSBzdGFjay5zbGljZTxCbG9ja1ZhbHVlPihiYXNlLCBiYXNlICsgbGVuZ3RoICogMyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIGhhcyhuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lcyEuaW5kZXhPZihuYW1lKSAhPT0gLTE7XG4gIH1cblxuICBnZXQobmFtZTogc3RyaW5nKTogT3B0aW9uPFNjb3BlQmxvY2s+IHtcbiAgICBsZXQgaWR4ID0gdGhpcy5uYW1lcyEuaW5kZXhPZihuYW1lKTtcblxuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgeyBiYXNlLCBzdGFjayB9ID0gdGhpcztcblxuICAgIGxldCB0YWJsZSA9IGNoZWNrKHN0YWNrLmdldChpZHggKiAzLCBiYXNlKSwgQ2hlY2tPcHRpb24oQ2hlY2tCbG9ja1N5bWJvbFRhYmxlKSk7XG4gICAgbGV0IHNjb3BlID0gY2hlY2soc3RhY2suZ2V0KGlkeCAqIDMgKyAxLCBiYXNlKSwgQ2hlY2tPcHRpb24oQ2hlY2tTY29wZSkpO1xuICAgIGxldCBoYW5kbGUgPSBjaGVjayhcbiAgICAgIHN0YWNrLmdldChpZHggKiAzICsgMiwgYmFzZSksXG4gICAgICBDaGVja09wdGlvbihDaGVja09yKENoZWNrSGFuZGxlLCBDaGVja0NvbXBpbGFibGVCbG9jaykpXG4gICAgKTtcblxuICAgIHJldHVybiBoYW5kbGUgPT09IG51bGwgPyBudWxsIDogKFtoYW5kbGUsIHNjb3BlISwgdGFibGUhXSBhcyBTY29wZUJsb2NrKTtcbiAgfVxuXG4gIGNhcHR1cmUoKTogQ2FwdHVyZWRCbG9ja0FyZ3VtZW50cyB7XG4gICAgcmV0dXJuIG5ldyBDYXB0dXJlZEJsb2NrQXJndW1lbnRzSW1wbCh0aGlzLm5hbWVzLCB0aGlzLnZhbHVlcyk7XG4gIH1cblxuICBnZXQgc3ltYm9sTmFtZXMoKTogcmVhZG9ubHkgc3RyaW5nW10ge1xuICAgIGxldCBzeW1ib2xOYW1lcyA9IHRoaXMuX3N5bWJvbE5hbWVzO1xuXG4gICAgaWYgKHN5bWJvbE5hbWVzID09PSBudWxsKSB7XG4gICAgICBzeW1ib2xOYW1lcyA9IHRoaXMuX3N5bWJvbE5hbWVzID0gdGhpcy5uYW1lcy5tYXAodG9TeW1ib2xOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3ltYm9sTmFtZXM7XG4gIH1cbn1cblxuY2xhc3MgQ2FwdHVyZWRCbG9ja0FyZ3VtZW50c0ltcGwgaW1wbGVtZW50cyBDYXB0dXJlZEJsb2NrQXJndW1lbnRzIHtcbiAgcHVibGljIGxlbmd0aDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBuYW1lczogcmVhZG9ubHkgc3RyaW5nW10sIHB1YmxpYyB2YWx1ZXM6IHJlYWRvbmx5IE9wdGlvbjxCbG9ja1ZhbHVlPltdKSB7XG4gICAgdGhpcy5sZW5ndGggPSBuYW1lcy5sZW5ndGg7XG4gIH1cblxuICBoYXMobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXMuaW5kZXhPZihuYW1lKSAhPT0gLTE7XG4gIH1cblxuICBnZXQobmFtZTogc3RyaW5nKTogT3B0aW9uPFNjb3BlQmxvY2s+IHtcbiAgICBsZXQgaWR4ID0gdGhpcy5uYW1lcy5pbmRleE9mKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA9PT0gLTEpIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIHRoaXMudmFsdWVzW2lkeCAqIDMgKyAyXSBhcyBDb21waWxhYmxlQmxvY2ssXG4gICAgICB0aGlzLnZhbHVlc1tpZHggKiAzICsgMV0gYXMgU2NvcGUsXG4gICAgICB0aGlzLnZhbHVlc1tpZHggKiAzXSBhcyBCbG9ja1N5bWJvbFRhYmxlLFxuICAgIF07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkQXJncyhuYW1lZDogRGljdDxSZWZlcmVuY2U+LCBwb3NpdGlvbmFsOiBSZWZlcmVuY2VbXSkge1xuICByZXR1cm4ge1xuICAgIG5hbWVkLFxuICAgIHBvc2l0aW9uYWwsXG4gIH0gYXMgQ2FwdHVyZWRBcmd1bWVudHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWlmeU5hbWVkKG5hbWVkOiBDYXB0dXJlZE5hbWVkQXJndW1lbnRzKSB7XG4gIGxldCByZWlmaWVkID0gZGljdCgpO1xuXG4gIGZvciAobGV0IGtleSBpbiBuYW1lZCkge1xuICAgIHJlaWZpZWRba2V5XSA9IHZhbHVlRm9yUmVmKG5hbWVkW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlaWZpZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWlmeVBvc2l0aW9uYWwocG9zaXRpb25hbDogQ2FwdHVyZWRQb3NpdGlvbmFsQXJndW1lbnRzKSB7XG4gIHJldHVybiBwb3NpdGlvbmFsLm1hcCh2YWx1ZUZvclJlZik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWlmeUFyZ3MoYXJnczogQ2FwdHVyZWRBcmd1bWVudHMpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lZDogcmVpZnlOYW1lZChhcmdzLm5hbWVkKSxcbiAgICBwb3NpdGlvbmFsOiByZWlmeVBvc2l0aW9uYWwoYXJncy5wb3NpdGlvbmFsKSxcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEVNUFRZX05BTUVEID0gT2JqZWN0LmZyZWV6ZShPYmplY3QuY3JlYXRlKG51bGwpKSBhcyBDYXB0dXJlZE5hbWVkQXJndW1lbnRzO1xuZXhwb3J0IGNvbnN0IEVNUFRZX1BPU0lUSU9OQUwgPSBFTVBUWV9SRUZFUkVOQ0VTIGFzIENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cztcbmV4cG9ydCBjb25zdCBFTVBUWV9BUkdTID0gY3JlYXRlQ2FwdHVyZWRBcmdzKEVNUFRZX05BTUVELCBFTVBUWV9QT1NJVElPTkFMKTtcbiIsImltcG9ydCB7XG4gIENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cyxcbiAgQ3VycmllZFR5cGUsXG4gIEhlbHBlcixcbiAgSGVscGVyRGVmaW5pdGlvblN0YXRlLFxuICBPcCxcbiAgT3duZXIsXG4gIFJlc29sdXRpb25UaW1lQ29uc3RhbnRzLFxuICBSdW50aW1lQ29uc3RhbnRzLFxuICBTY29wZUJsb2NrLFxuICBWTSBhcyBQdWJsaWNWTSxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQge1xuICBSZWZlcmVuY2UsXG4gIGNoaWxkUmVmRm9yLFxuICBVTkRFRklORURfUkVGRVJFTkNFLFxuICBUUlVFX1JFRkVSRU5DRSxcbiAgRkFMU0VfUkVGRVJFTkNFLFxuICB2YWx1ZUZvclJlZixcbiAgY3JlYXRlQ29tcHV0ZVJlZixcbn0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7ICR2MCB9IGZyb20gJ0BnbGltbWVyL3ZtJztcbmltcG9ydCB7IEFQUEVORF9PUENPREVTIH0gZnJvbSAnLi4vLi4vb3Bjb2Rlcyc7XG5pbXBvcnQgeyBjcmVhdGVDb25jYXRSZWYgfSBmcm9tICcuLi9leHByZXNzaW9ucy9jb25jYXQnO1xuaW1wb3J0IHsgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZCwgZGVzdHJveSwgX2hhc0Rlc3Ryb3lhYmxlQ2hpbGRyZW4gfSBmcm9tICdAZ2xpbW1lci9kZXN0cm95YWJsZSc7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2lnbiwgZGVidWdUb1N0cmluZywgZGVjb2RlSGFuZGxlLCBpc09iamVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgdG9Cb29sIH0gZnJvbSAnQGdsaW1tZXIvZ2xvYmFsLWNvbnRleHQnO1xuaW1wb3J0IHtcbiAgY2hlY2ssXG4gIENoZWNrT3B0aW9uLFxuICBDaGVja0hhbmRsZSxcbiAgQ2hlY2tCbG9ja1N5bWJvbFRhYmxlLFxuICBDaGVja09yLFxuICBDaGVja01heWJlLFxufSBmcm9tICdAZ2xpbW1lci9kZWJ1Zyc7XG5pbXBvcnQge1xuICBDaGVja0FyZ3VtZW50cyxcbiAgQ2hlY2tSZWZlcmVuY2UsXG4gIENoZWNrQ29tcGlsYWJsZUJsb2NrLFxuICBDaGVja1Njb3BlLFxuICBDaGVja0hlbHBlcixcbiAgQ2hlY2tVbmRlZmluZWRSZWZlcmVuY2UsXG4gIENoZWNrU2NvcGVCbG9jayxcbiAgQ2hlY2tDYXB0dXJlZEFyZ3VtZW50cyxcbn0gZnJvbSAnLi8tZGVidWctc3RyaXAnO1xuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSAnLi4vLi4vc3ltYm9scyc7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQgY3JlYXRlQ3VycnlSZWYgZnJvbSAnLi4vLi4vcmVmZXJlbmNlcy9jdXJyeS12YWx1ZSc7XG5pbXBvcnQgeyBpc0N1cnJpZWRUeXBlLCByZXNvbHZlQ3VycmllZFZhbHVlIH0gZnJvbSAnLi4vLi4vY3VycmllZC12YWx1ZSc7XG5pbXBvcnQgeyByZWlmeVBvc2l0aW9uYWwgfSBmcm9tICcuLi8uLi92bS9hcmd1bWVudHMnO1xuXG5leHBvcnQgdHlwZSBGdW5jdGlvbkV4cHJlc3Npb248VD4gPSAodm06IFB1YmxpY1ZNKSA9PiBSZWZlcmVuY2U8VD47XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5DdXJyeSwgKHZtLCB7IG9wMTogdHlwZSwgb3AyOiBfaXNTdHJpY3QgfSkgPT4ge1xuICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcblxuICBsZXQgZGVmaW5pdGlvbiA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG4gIGxldCBjYXB0dXJlZEFyZ3MgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tDYXB0dXJlZEFyZ3VtZW50cyk7XG5cbiAgbGV0IG93bmVyID0gdm0uZ2V0T3duZXIoKTtcbiAgbGV0IHJlc29sdmVyID0gdm0ucnVudGltZS5yZXNvbHZlcjtcblxuICBsZXQgaXNTdHJpY3QgPSBmYWxzZTtcblxuICBpZiAoREVCVUcpIHtcbiAgICAvLyBzdHJpY3QgY2hlY2sgb25seSBoYXBwZW5zIGluIERFQlVHIGJ1aWxkcywgbm8gcmVhc29uIHRvIGxvYWQgaXQgb3RoZXJ3aXNlXG4gICAgaXNTdHJpY3QgPSB2bVtDT05TVEFOVFNdLmdldFZhbHVlPGJvb2xlYW4+KGRlY29kZUhhbmRsZShfaXNTdHJpY3QpKTtcbiAgfVxuXG4gIHZtLmxvYWRWYWx1ZShcbiAgICAkdjAsXG4gICAgY3JlYXRlQ3VycnlSZWYodHlwZSBhcyBDdXJyaWVkVHlwZSwgZGVmaW5pdGlvbiwgb3duZXIsIGNhcHR1cmVkQXJncywgcmVzb2x2ZXIsIGlzU3RyaWN0KVxuICApO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5EeW5hbWljSGVscGVyLCAodm0pID0+IHtcbiAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG4gIGxldCByZWYgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuICBsZXQgYXJncyA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja0FyZ3VtZW50cykuY2FwdHVyZSgpO1xuXG4gIGxldCBoZWxwZXJSZWY6IFJlZmVyZW5jZTtcbiAgbGV0IGluaXRpYWxPd25lcjogT3duZXIgPSB2bS5nZXRPd25lcigpO1xuXG4gIGxldCBoZWxwZXJJbnN0YW5jZVJlZiA9IGNyZWF0ZUNvbXB1dGVSZWYoKCkgPT4ge1xuICAgIGlmIChoZWxwZXJSZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdHJveShoZWxwZXJSZWYpO1xuICAgIH1cblxuICAgIGxldCBkZWZpbml0aW9uID0gdmFsdWVGb3JSZWYocmVmKTtcblxuICAgIGlmIChpc0N1cnJpZWRUeXBlKGRlZmluaXRpb24sIEN1cnJpZWRUeXBlLkhlbHBlcikpIHtcbiAgICAgIGxldCB7IGRlZmluaXRpb246IHJlc29sdmVkRGVmLCBvd25lciwgcG9zaXRpb25hbCwgbmFtZWQgfSA9IHJlc29sdmVDdXJyaWVkVmFsdWUoZGVmaW5pdGlvbik7XG5cbiAgICAgIGxldCBoZWxwZXIgPSByZXNvbHZlSGVscGVyKHZtW0NPTlNUQU5UU10sIHJlc29sdmVkRGVmLCByZWYpO1xuXG4gICAgICBpZiAobmFtZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhcmdzLm5hbWVkID0gYXNzaWduKHt9LCAuLi5uYW1lZCwgYXJncy5uYW1lZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NpdGlvbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXJncy5wb3NpdGlvbmFsID0gcG9zaXRpb25hbC5jb25jYXQoYXJncy5wb3NpdGlvbmFsKSBhcyBDYXB0dXJlZFBvc2l0aW9uYWxBcmd1bWVudHM7XG4gICAgICB9XG5cbiAgICAgIGhlbHBlclJlZiA9IGhlbHBlcihhcmdzLCBvd25lcik7XG5cbiAgICAgIGFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQoaGVscGVySW5zdGFuY2VSZWYsIGhlbHBlclJlZik7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgbGV0IGhlbHBlciA9IHJlc29sdmVIZWxwZXIodm1bQ09OU1RBTlRTXSwgZGVmaW5pdGlvbiwgcmVmKTtcbiAgICAgIGhlbHBlclJlZiA9IGhlbHBlcihhcmdzLCBpbml0aWFsT3duZXIpO1xuXG4gICAgICBpZiAoX2hhc0Rlc3Ryb3lhYmxlQ2hpbGRyZW4oaGVscGVyUmVmKSkge1xuICAgICAgICBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkKGhlbHBlckluc3RhbmNlUmVmLCBoZWxwZXJSZWYpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoZWxwZXJSZWYgPSBVTkRFRklORURfUkVGRVJFTkNFO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGhlbHBlclZhbHVlUmVmID0gY3JlYXRlQ29tcHV0ZVJlZigoKSA9PiB7XG4gICAgdmFsdWVGb3JSZWYoaGVscGVySW5zdGFuY2VSZWYpO1xuICAgIHJldHVybiB2YWx1ZUZvclJlZihoZWxwZXJSZWYpO1xuICB9KTtcblxuICB2bS5hc3NvY2lhdGVEZXN0cm95YWJsZShoZWxwZXJJbnN0YW5jZVJlZik7XG4gIHZtLmxvYWRWYWx1ZSgkdjAsIGhlbHBlclZhbHVlUmVmKTtcbn0pO1xuXG5mdW5jdGlvbiByZXNvbHZlSGVscGVyKFxuICBjb25zdGFudHM6IFJ1bnRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgZGVmaW5pdGlvbjogSGVscGVyRGVmaW5pdGlvblN0YXRlLFxuICByZWY6IFJlZmVyZW5jZVxuKTogSGVscGVyIHtcbiAgbGV0IGhhbmRsZSA9IGNvbnN0YW50cy5oZWxwZXIoZGVmaW5pdGlvbiwgbnVsbCwgdHJ1ZSkhO1xuXG4gIGlmIChERUJVRyAmJiBoYW5kbGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBkeW5hbWljIGhlbHBlciBkZWZpbml0aW9uLCBidXQgcmVjZWl2ZWQgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGlkIG5vdCBoYXZlIGEgaGVscGVyIG1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIGl0LiBUaGUgZHluYW1pYyBpbnZvY2F0aW9uIHdhcyBcXGB7eyR7XG4gICAgICAgIHJlZi5kZWJ1Z0xhYmVsXG4gICAgICB9fX1cXGAgb3IgXFxgKCR7cmVmLmRlYnVnTGFiZWx9KVxcYCwgYW5kIHRoZSBpbmNvcnJlY3QgZGVmaW5pdGlvbiBpcyB0aGUgdmFsdWUgYXQgdGhlIHBhdGggXFxgJHtcbiAgICAgICAgcmVmLmRlYnVnTGFiZWxcbiAgICAgIH1cXGAsIHdoaWNoIHdhczogJHtkZWJ1Z1RvU3RyaW5nIShkZWZpbml0aW9uKX1gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjb25zdGFudHMuZ2V0VmFsdWUoaGFuZGxlKTtcbn1cblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkhlbHBlciwgKHZtLCB7IG9wMTogaGFuZGxlIH0pID0+IHtcbiAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG4gIGxldCBoZWxwZXIgPSBjaGVjayh2bVtDT05TVEFOVFNdLmdldFZhbHVlKGhhbmRsZSksIENoZWNrSGVscGVyKTtcbiAgbGV0IGFyZ3MgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tBcmd1bWVudHMpO1xuICBsZXQgdmFsdWUgPSBoZWxwZXIoYXJncy5jYXB0dXJlKCksIHZtLmdldE93bmVyKCksIHZtLmR5bmFtaWNTY29wZSgpKTtcblxuICBpZiAoX2hhc0Rlc3Ryb3lhYmxlQ2hpbGRyZW4odmFsdWUpKSB7XG4gICAgdm0uYXNzb2NpYXRlRGVzdHJveWFibGUodmFsdWUpO1xuICB9XG5cbiAgdm0ubG9hZFZhbHVlKCR2MCwgdmFsdWUpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5HZXRWYXJpYWJsZSwgKHZtLCB7IG9wMTogc3ltYm9sIH0pID0+IHtcbiAgbGV0IGV4cHIgPSB2bS5yZWZlcmVuY2VGb3JTeW1ib2woc3ltYm9sKTtcblxuICB2bS5zdGFjay5wdXNoKGV4cHIpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5TZXRWYXJpYWJsZSwgKHZtLCB7IG9wMTogc3ltYm9sIH0pID0+IHtcbiAgbGV0IGV4cHIgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuICB2bS5zY29wZSgpLmJpbmRTeW1ib2woc3ltYm9sLCBleHByKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuU2V0QmxvY2ssICh2bSwgeyBvcDE6IHN5bWJvbCB9KSA9PiB7XG4gIGxldCBoYW5kbGUgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tDb21waWxhYmxlQmxvY2spO1xuICBsZXQgc2NvcGUgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tTY29wZSk7XG4gIGxldCB0YWJsZSA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja0Jsb2NrU3ltYm9sVGFibGUpO1xuXG4gIHZtLnNjb3BlKCkuYmluZEJsb2NrKHN5bWJvbCwgW2hhbmRsZSwgc2NvcGUsIHRhYmxlXSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlJlc29sdmVNYXliZUxvY2FsLCAodm0sIHsgb3AxOiBfbmFtZSB9KSA9PiB7XG4gIGxldCBuYW1lID0gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxzdHJpbmc+KF9uYW1lKTtcbiAgbGV0IGxvY2FscyA9IHZtLnNjb3BlKCkuZ2V0UGFydGlhbE1hcCgpITtcblxuICBsZXQgcmVmID0gbG9jYWxzW25hbWVdO1xuICBpZiAocmVmID09PSB1bmRlZmluZWQpIHtcbiAgICByZWYgPSBjaGlsZFJlZkZvcih2bS5nZXRTZWxmKCksIG5hbWUpO1xuICB9XG5cbiAgdm0uc3RhY2sucHVzaChyZWYpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Sb290U2NvcGUsICh2bSwgeyBvcDE6IHN5bWJvbHMgfSkgPT4ge1xuICB2bS5wdXNoUm9vdFNjb3BlKHN5bWJvbHMsIHZtLmdldE93bmVyKCkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5HZXRQcm9wZXJ0eSwgKHZtLCB7IG9wMTogX2tleSB9KSA9PiB7XG4gIGxldCBrZXkgPSB2bVtDT05TVEFOVFNdLmdldFZhbHVlPHN0cmluZz4oX2tleSk7XG4gIGxldCBleHByID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcbiAgdm0uc3RhY2sucHVzaChjaGlsZFJlZkZvcihleHByLCBrZXkpKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuR2V0QmxvY2ssICh2bSwgeyBvcDE6IF9ibG9jayB9KSA9PiB7XG4gIGxldCB7IHN0YWNrIH0gPSB2bTtcbiAgbGV0IGJsb2NrID0gdm0uc2NvcGUoKS5nZXRCbG9jayhfYmxvY2spO1xuXG4gIHN0YWNrLnB1c2goYmxvY2spO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5TcHJlYWRCbG9jaywgKHZtKSA9PiB7XG4gIGxldCB7IHN0YWNrIH0gPSB2bTtcbiAgbGV0IGJsb2NrID0gY2hlY2soc3RhY2sucG9wKCksIENoZWNrT3B0aW9uKENoZWNrT3IoQ2hlY2tTY29wZUJsb2NrLCBDaGVja1VuZGVmaW5lZFJlZmVyZW5jZSkpKTtcblxuICBpZiAoYmxvY2sgJiYgIWlzVW5kZWZpbmVkUmVmZXJlbmNlKGJsb2NrKSkge1xuICAgIGxldCBbaGFuZGxlT3JDb21waWxhYmxlLCBzY29wZSwgdGFibGVdID0gYmxvY2s7XG5cbiAgICBzdGFjay5wdXNoKHRhYmxlKTtcbiAgICBzdGFjay5wdXNoKHNjb3BlKTtcbiAgICBzdGFjay5wdXNoKGhhbmRsZU9yQ29tcGlsYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhY2sucHVzaChudWxsKTtcbiAgICBzdGFjay5wdXNoKG51bGwpO1xuICAgIHN0YWNrLnB1c2gobnVsbCk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZFJlZmVyZW5jZShpbnB1dDogU2NvcGVCbG9jayB8IFJlZmVyZW5jZSk6IGlucHV0IGlzIFJlZmVyZW5jZSB7XG4gIGFzc2VydChcbiAgICBBcnJheS5pc0FycmF5KGlucHV0KSB8fCBpbnB1dCA9PT0gVU5ERUZJTkVEX1JFRkVSRU5DRSxcbiAgICAnYSByZWZlcmVuY2Ugb3RoZXIgdGhhbiBVTkRFRklORURfUkVGRVJFTkNFIGlzIGlsbGVnYWwgaGVyZSdcbiAgKTtcbiAgcmV0dXJuIGlucHV0ID09PSBVTkRFRklORURfUkVGRVJFTkNFO1xufVxuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuSGFzQmxvY2ssICh2bSkgPT4ge1xuICBsZXQgeyBzdGFjayB9ID0gdm07XG4gIGxldCBibG9jayA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja09wdGlvbihDaGVja09yKENoZWNrU2NvcGVCbG9jaywgQ2hlY2tVbmRlZmluZWRSZWZlcmVuY2UpKSk7XG5cbiAgaWYgKGJsb2NrICYmICFpc1VuZGVmaW5lZFJlZmVyZW5jZShibG9jaykpIHtcbiAgICBzdGFjay5wdXNoKFRSVUVfUkVGRVJFTkNFKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFjay5wdXNoKEZBTFNFX1JFRkVSRU5DRSk7XG4gIH1cbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuSGFzQmxvY2tQYXJhbXMsICh2bSkgPT4ge1xuICAvLyBGSVhNRShtbXVuKTogc2hvdWxkIG9ubHkgbmVlZCB0byBwdXNoIHRoZSBzeW1ib2wgdGFibGVcbiAgbGV0IGJsb2NrID0gdm0uc3RhY2sucG9wKCk7XG4gIGxldCBzY29wZSA9IHZtLnN0YWNrLnBvcCgpO1xuXG4gIGNoZWNrKGJsb2NrLCBDaGVja01heWJlKENoZWNrT3IoQ2hlY2tIYW5kbGUsIENoZWNrQ29tcGlsYWJsZUJsb2NrKSkpO1xuICBjaGVjayhzY29wZSwgQ2hlY2tNYXliZShDaGVja1Njb3BlKSk7XG4gIGxldCB0YWJsZSA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja01heWJlKENoZWNrQmxvY2tTeW1ib2xUYWJsZSkpO1xuXG4gIGxldCBoYXNCbG9ja1BhcmFtcyA9IHRhYmxlICYmIHRhYmxlLnBhcmFtZXRlcnMubGVuZ3RoO1xuICB2bS5zdGFjay5wdXNoKGhhc0Jsb2NrUGFyYW1zID8gVFJVRV9SRUZFUkVOQ0UgOiBGQUxTRV9SRUZFUkVOQ0UpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Db25jYXQsICh2bSwgeyBvcDE6IGNvdW50IH0pID0+IHtcbiAgbGV0IG91dDogQXJyYXk8UmVmZXJlbmNlPHVua25vd24+PiA9IG5ldyBBcnJheShjb3VudCk7XG5cbiAgZm9yIChsZXQgaSA9IGNvdW50OyBpID4gMDsgaS0tKSB7XG4gICAgbGV0IG9mZnNldCA9IGkgLSAxO1xuICAgIG91dFtvZmZzZXRdID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcbiAgfVxuXG4gIHZtLnN0YWNrLnB1c2goY3JlYXRlQ29uY2F0UmVmKG91dCkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5JZklubGluZSwgKHZtKSA9PiB7XG4gIGxldCBjb25kaXRpb24gPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuICBsZXQgdHJ1dGh5ID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcbiAgbGV0IGZhbHN5ID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcblxuICB2bS5zdGFjay5wdXNoKFxuICAgIGNyZWF0ZUNvbXB1dGVSZWYoKCkgPT4ge1xuICAgICAgaWYgKHRvQm9vbCh2YWx1ZUZvclJlZihjb25kaXRpb24pKSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVGb3JSZWYodHJ1dGh5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUZvclJlZihmYWxzeSk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuTm90LCAodm0pID0+IHtcbiAgbGV0IHJlZiA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG5cbiAgdm0uc3RhY2sucHVzaChcbiAgICBjcmVhdGVDb21wdXRlUmVmKCgpID0+IHtcbiAgICAgIHJldHVybiAhdG9Cb29sKHZhbHVlRm9yUmVmKHJlZikpO1xuICAgIH0pXG4gICk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkdldER5bmFtaWNWYXIsICh2bSkgPT4ge1xuICBsZXQgc2NvcGUgPSB2bS5keW5hbWljU2NvcGUoKTtcbiAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG4gIGxldCBuYW1lUmVmID0gY2hlY2soc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcblxuICBzdGFjay5wdXNoKFxuICAgIGNyZWF0ZUNvbXB1dGVSZWYoKCkgPT4ge1xuICAgICAgbGV0IG5hbWUgPSBTdHJpbmcodmFsdWVGb3JSZWYobmFtZVJlZikpO1xuICAgICAgcmV0dXJuIHZhbHVlRm9yUmVmKHNjb3BlLmdldChuYW1lKSk7XG4gICAgfSlcbiAgKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuTG9nLCAodm0pID0+IHtcbiAgbGV0IHsgcG9zaXRpb25hbCB9ID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrQXJndW1lbnRzKS5jYXB0dXJlKCk7XG5cbiAgdm0ubG9hZFZhbHVlKFxuICAgICR2MCxcbiAgICBjcmVhdGVDb21wdXRlUmVmKCgpID0+IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmxvZyguLi5yZWlmeVBvc2l0aW9uYWwocG9zaXRpb25hbCkpO1xuICAgIH0pXG4gICk7XG59KTtcbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7XG4gIENvbXBvbmVudERlZmluaXRpb24sXG4gIE9wdGlvbixcbiAgT3duZXIsXG4gIFJ1bnRpbWVSZXNvbHZlcixcbiAgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgZXhwZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50KFxuICByZXNvbHZlcjogUnVudGltZVJlc29sdmVyLFxuICBjb25zdGFudHM6IFJlc29sdXRpb25UaW1lQ29uc3RhbnRzLFxuICBuYW1lOiBzdHJpbmcsXG4gIG93bmVyOiBPd25lciB8IG51bGxcbik6IE9wdGlvbjxDb21wb25lbnREZWZpbml0aW9uPiB7XG4gIGxldCBkZWZpbml0aW9uID0gcmVzb2x2ZXIubG9va3VwQ29tcG9uZW50KFxuICAgIG5hbWUsXG4gICAgZXhwZWN0KG93bmVyLCAnQlVHOiBleHBlY3RlZCBvd25lciB3aGVuIGxvb2tpbmcgdXAgY29tcG9uZW50JylcbiAgKTtcblxuICBpZiAoREVCVUcgJiYgIWRlZmluaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQXR0ZW1wdGVkIHRvIHJlc29sdmUgXFxgJHtuYW1lfVxcYCwgd2hpY2ggd2FzIGV4cGVjdGVkIHRvIGJlIGEgY29tcG9uZW50LCBidXQgbm90aGluZyB3YXMgZm91bmQuYFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gY29uc3RhbnRzLnJlc29sdmVkQ29tcG9uZW50KGRlZmluaXRpb24hLCBuYW1lKTtcbn1cbiIsImltcG9ydCB7XG4gIENvbXBvbmVudERlZmluaXRpb25TdGF0ZSxcbiAgQ29tcG9uZW50SW5zdGFuY2VTdGF0ZSxcbiAgSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyLFxuICBXaXRoQ3VzdG9tRGVidWdSZW5kZXJUcmVlLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0N1c3RvbURlYnVnUmVuZGVyVHJlZUxpZmVjeWNsZTxcbiAgRCBleHRlbmRzIENvbXBvbmVudERlZmluaXRpb25TdGF0ZSxcbiAgSSBleHRlbmRzIENvbXBvbmVudEluc3RhbmNlU3RhdGVcbj4obWFuYWdlcjogSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyPEksIEQ+KTogbWFuYWdlciBpcyBXaXRoQ3VzdG9tRGVidWdSZW5kZXJUcmVlPEksIEQ+IHtcbiAgcmV0dXJuICdnZXREZWJ1Z0N1c3RvbVJlbmRlclRyZWUnIGluIG1hbmFnZXI7XG59XG4iLCJpbXBvcnQgeyBSZWZlcmVuY2UsIGNyZWF0ZUNvbXB1dGVSZWYsIHZhbHVlRm9yUmVmIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcblxuaW1wb3J0IHsgbm9ybWFsaXplU3RyaW5nVmFsdWUgfSBmcm9tICcuLi9kb20vbm9ybWFsaXplJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlQ2xhc3NMaXN0UmVmKGxpc3Q6IFJlZmVyZW5jZVtdKSB7XG4gIHJldHVybiBjcmVhdGVDb21wdXRlUmVmKCgpID0+IHtcbiAgICBsZXQgcmV0OiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcmVmID0gbGlzdFtpXTtcbiAgICAgIGxldCB2YWx1ZSA9IG5vcm1hbGl6ZVN0cmluZ1ZhbHVlKHR5cGVvZiByZWYgPT09ICdzdHJpbmcnID8gcmVmIDogdmFsdWVGb3JSZWYobGlzdFtpXSkpO1xuICAgICAgaWYgKHZhbHVlKSByZXQucHVzaCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldC5sZW5ndGggPT09IDAgPyBudWxsIDogcmV0LmpvaW4oJyAnKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyB0b0Jvb2wgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5pbXBvcnQgeyBDb21waWxhYmxlVGVtcGxhdGUsIE9wdGlvbiwgT3AsIFVwZGF0aW5nT3Bjb2RlIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQge1xuICBSZWZlcmVuY2UsXG4gIHZhbHVlRm9yUmVmLFxuICBpc0NvbnN0UmVmLFxuICBjcmVhdGVQcmltaXRpdmVSZWYsXG4gIFVOREVGSU5FRF9SRUZFUkVOQ0UsXG4gIE5VTExfUkVGRVJFTkNFLFxuICBUUlVFX1JFRkVSRU5DRSxcbiAgRkFMU0VfUkVGRVJFTkNFLFxuICBjcmVhdGVDb21wdXRlUmVmLFxuICBjcmVhdGVDb25zdFJlZixcbn0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7XG4gIENPTlNUQU5UX1RBRyxcbiAgUmV2aXNpb24sXG4gIFRhZyxcbiAgdmFsdWVGb3JUYWcsXG4gIHZhbGlkYXRlVGFnLFxuICBJTklUSUFMLFxuICBiZWdpblRyYWNrRnJhbWUsXG4gIGVuZFRyYWNrRnJhbWUsXG4gIGNvbnN1bWVUYWcsXG59IGZyb20gJ0BnbGltbWVyL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBhc3NlcnQsIGRlY29kZUhhbmRsZSwgZGVjb2RlSW1tZWRpYXRlLCBleHBlY3QsIGlzSGFuZGxlIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQge1xuICBDaGVja051bWJlcixcbiAgY2hlY2ssXG4gIENoZWNrSW5zdGFuY2VvZixcbiAgQ2hlY2tPcHRpb24sXG4gIENoZWNrQmxvY2tTeW1ib2xUYWJsZSxcbiAgQ2hlY2tIYW5kbGUsXG4gIENoZWNrUHJpbWl0aXZlLFxufSBmcm9tICdAZ2xpbW1lci9kZWJ1Zyc7XG5pbXBvcnQgeyBzdGFja0Fzc2VydCB9IGZyb20gJy4vYXNzZXJ0JztcbmltcG9ydCB7IEFQUEVORF9PUENPREVTIH0gZnJvbSAnLi4vLi4vb3Bjb2Rlcyc7XG5pbXBvcnQgeyBVcGRhdGluZ1ZNIH0gZnJvbSAnLi4vLi4vdm0nO1xuaW1wb3J0IHsgVk1Bcmd1bWVudHNJbXBsIH0gZnJvbSAnLi4vLi4vdm0vYXJndW1lbnRzJztcbmltcG9ydCB7IENoZWNrUmVmZXJlbmNlLCBDaGVja1Njb3BlIH0gZnJvbSAnLi8tZGVidWctc3RyaXAnO1xuaW1wb3J0IHsgQ09OU1RBTlRTIH0gZnJvbSAnLi4vLi4vc3ltYm9scyc7XG5pbXBvcnQgeyBJbnRlcm5hbFZNIH0gZnJvbSAnLi4vLi4vdm0vYXBwZW5kJztcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkNoaWxkU2NvcGUsICh2bSkgPT4gdm0ucHVzaENoaWxkU2NvcGUoKSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Qb3BTY29wZSwgKHZtKSA9PiB2bS5wb3BTY29wZSgpKTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlB1c2hEeW5hbWljU2NvcGUsICh2bSkgPT4gdm0ucHVzaER5bmFtaWNTY29wZSgpKTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlBvcER5bmFtaWNTY29wZSwgKHZtKSA9PiB2bS5wb3BEeW5hbWljU2NvcGUoKSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Db25zdGFudCwgKHZtLCB7IG9wMTogb3RoZXIgfSkgPT4ge1xuICB2bS5zdGFjay5wdXNoKHZtW0NPTlNUQU5UU10uZ2V0VmFsdWUoZGVjb2RlSGFuZGxlKG90aGVyKSkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Db25zdGFudFJlZmVyZW5jZSwgKHZtLCB7IG9wMTogb3RoZXIgfSkgPT4ge1xuICB2bS5zdGFjay5wdXNoKGNyZWF0ZUNvbnN0UmVmKHZtW0NPTlNUQU5UU10uZ2V0VmFsdWUoZGVjb2RlSGFuZGxlKG90aGVyKSksIGZhbHNlKSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlByaW1pdGl2ZSwgKHZtLCB7IG9wMTogcHJpbWl0aXZlIH0pID0+IHtcbiAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG5cbiAgaWYgKGlzSGFuZGxlKHByaW1pdGl2ZSkpIHtcbiAgICAvLyBpdCBpcyBhIGhhbmRsZSB3aGljaCBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0IG9uIHRoZSBzdGFja1xuICAgIGxldCB2YWx1ZSA9IHZtW0NPTlNUQU5UU10uZ2V0VmFsdWUoZGVjb2RlSGFuZGxlKHByaW1pdGl2ZSkpO1xuICAgIHN0YWNrLnB1c2godmFsdWUgYXMgb2JqZWN0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpcyBhbHJlYWR5IGFuIGVuY29kZWQgaW1tZWRpYXRlIG9yIHByaW1pdGl2ZSBoYW5kbGVcbiAgICBzdGFjay5wdXNoKGRlY29kZUltbWVkaWF0ZShwcmltaXRpdmUpKTtcbiAgfVxufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5QcmltaXRpdmVSZWZlcmVuY2UsICh2bSkgPT4ge1xuICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcbiAgbGV0IHZhbHVlID0gY2hlY2soc3RhY2sucG9wKCksIENoZWNrUHJpbWl0aXZlKTtcbiAgbGV0IHJlZjtcblxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJlZiA9IFVOREVGSU5FRF9SRUZFUkVOQ0U7XG4gIH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZWYgPSBOVUxMX1JFRkVSRU5DRTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgIHJlZiA9IFRSVUVfUkVGRVJFTkNFO1xuICB9IGVsc2UgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgIHJlZiA9IEZBTFNFX1JFRkVSRU5DRTtcbiAgfSBlbHNlIHtcbiAgICByZWYgPSBjcmVhdGVQcmltaXRpdmVSZWYodmFsdWUpO1xuICB9XG5cbiAgc3RhY2sucHVzaChyZWYpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5EdXAsICh2bSwgeyBvcDE6IHJlZ2lzdGVyLCBvcDI6IG9mZnNldCB9KSA9PiB7XG4gIGxldCBwb3NpdGlvbiA9IGNoZWNrKHZtLmZldGNoVmFsdWUocmVnaXN0ZXIpLCBDaGVja051bWJlcikgLSBvZmZzZXQ7XG4gIHZtLnN0YWNrLmR1cChwb3NpdGlvbik7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlBvcCwgKHZtLCB7IG9wMTogY291bnQgfSkgPT4ge1xuICB2bS5zdGFjay5wb3AoY291bnQpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Mb2FkLCAodm0sIHsgb3AxOiByZWdpc3RlciB9KSA9PiB7XG4gIHZtLmxvYWQocmVnaXN0ZXIpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5GZXRjaCwgKHZtLCB7IG9wMTogcmVnaXN0ZXIgfSkgPT4ge1xuICB2bS5mZXRjaChyZWdpc3Rlcik7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkJpbmREeW5hbWljU2NvcGUsICh2bSwgeyBvcDE6IF9uYW1lcyB9KSA9PiB7XG4gIGxldCBuYW1lcyA9IHZtW0NPTlNUQU5UU10uZ2V0QXJyYXk8c3RyaW5nPihfbmFtZXMpO1xuICB2bS5iaW5kRHluYW1pY1Njb3BlKG5hbWVzKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRW50ZXIsICh2bSwgeyBvcDE6IGFyZ3MgfSkgPT4ge1xuICB2bS5lbnRlcihhcmdzKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRXhpdCwgKHZtKSA9PiB7XG4gIHZtLmV4aXQoKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUHVzaFN5bWJvbFRhYmxlLCAodm0sIHsgb3AxOiBfdGFibGUgfSkgPT4ge1xuICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcbiAgc3RhY2sucHVzaCh2bVtDT05TVEFOVFNdLmdldFZhbHVlKF90YWJsZSkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5QdXNoQmxvY2tTY29wZSwgKHZtKSA9PiB7XG4gIGxldCBzdGFjayA9IHZtLnN0YWNrO1xuICBzdGFjay5wdXNoKHZtLnNjb3BlKCkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Db21waWxlQmxvY2ssICh2bTogSW50ZXJuYWxWTSkgPT4ge1xuICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcbiAgbGV0IGJsb2NrID0gc3RhY2sucG9wPE9wdGlvbjxDb21waWxhYmxlVGVtcGxhdGU+IHwgMD4oKTtcblxuICBpZiAoYmxvY2spIHtcbiAgICBzdGFjay5wdXNoKHZtLmNvbXBpbGUoYmxvY2spKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFjay5wdXNoKG51bGwpO1xuICB9XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkludm9rZVlpZWxkLCAodm0pID0+IHtcbiAgbGV0IHsgc3RhY2sgfSA9IHZtO1xuXG4gIGxldCBoYW5kbGUgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tPcHRpb24oQ2hlY2tIYW5kbGUpKTtcbiAgbGV0IHNjb3BlID0gY2hlY2soc3RhY2sucG9wKCksIENoZWNrT3B0aW9uKENoZWNrU2NvcGUpKTtcbiAgbGV0IHRhYmxlID0gY2hlY2soc3RhY2sucG9wKCksIENoZWNrT3B0aW9uKENoZWNrQmxvY2tTeW1ib2xUYWJsZSkpO1xuXG4gIGFzc2VydChcbiAgICB0YWJsZSA9PT0gbnVsbCB8fCAodGFibGUgJiYgdHlwZW9mIHRhYmxlID09PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KHRhYmxlLnBhcmFtZXRlcnMpKSxcbiAgICBzdGFja0Fzc2VydCgnT3B0aW9uPEJsb2NrU3ltYm9sVGFibGU+JywgdGFibGUpXG4gICk7XG5cbiAgbGV0IGFyZ3MgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tJbnN0YW5jZW9mKFZNQXJndW1lbnRzSW1wbCkpO1xuXG4gIGlmICh0YWJsZSA9PT0gbnVsbCkge1xuICAgIC8vIFRvIGJhbGFuY2UgdGhlIHBvcHtGcmFtZSxTY29wZX1cbiAgICB2bS5wdXNoRnJhbWUoKTtcbiAgICB2bS5wdXNoU2NvcGUoc2NvcGUgPz8gdm0uc2NvcGUoKSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgaW52b2tpbmdTY29wZSA9IGV4cGVjdChzY29wZSwgJ0JVRzogZXhwZWN0ZWQgc2NvcGUnKTtcblxuICAvLyBJZiBuZWNlc3NhcnksIGNyZWF0ZSBhIGNoaWxkIHNjb3BlXG4gIHtcbiAgICBsZXQgbG9jYWxzID0gdGFibGUucGFyYW1ldGVycztcbiAgICBsZXQgbG9jYWxzQ291bnQgPSBsb2NhbHMubGVuZ3RoO1xuXG4gICAgaWYgKGxvY2Fsc0NvdW50ID4gMCkge1xuICAgICAgaW52b2tpbmdTY29wZSA9IGludm9raW5nU2NvcGUuY2hpbGQoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbHNDb3VudDsgaSsrKSB7XG4gICAgICAgIGludm9raW5nU2NvcGUuYmluZFN5bWJvbChsb2NhbHMhW2ldLCBhcmdzLmF0KGkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2bS5wdXNoRnJhbWUoKTtcbiAgdm0ucHVzaFNjb3BlKGludm9raW5nU2NvcGUpO1xuICB2bS5jYWxsKGhhbmRsZSEpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5KdW1wSWYsICh2bSwgeyBvcDE6IHRhcmdldCB9KSA9PiB7XG4gIGxldCByZWZlcmVuY2UgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuICBsZXQgdmFsdWUgPSBCb29sZWFuKHZhbHVlRm9yUmVmKHJlZmVyZW5jZSkpO1xuXG4gIGlmIChpc0NvbnN0UmVmKHJlZmVyZW5jZSkpIHtcbiAgICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICAgIHZtLmdvdG8odGFyZ2V0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICB2bS5nb3RvKHRhcmdldCk7XG4gICAgfVxuXG4gICAgdm0udXBkYXRlV2l0aChuZXcgQXNzZXJ0KHJlZmVyZW5jZSkpO1xuICB9XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkp1bXBVbmxlc3MsICh2bSwgeyBvcDE6IHRhcmdldCB9KSA9PiB7XG4gIGxldCByZWZlcmVuY2UgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuICBsZXQgdmFsdWUgPSBCb29sZWFuKHZhbHVlRm9yUmVmKHJlZmVyZW5jZSkpO1xuXG4gIGlmIChpc0NvbnN0UmVmKHJlZmVyZW5jZSkpIHtcbiAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICB2bS5nb3RvKHRhcmdldCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIHZtLmdvdG8odGFyZ2V0KTtcbiAgICB9XG5cbiAgICB2bS51cGRhdGVXaXRoKG5ldyBBc3NlcnQocmVmZXJlbmNlKSk7XG4gIH1cbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuSnVtcEVxLCAodm0sIHsgb3AxOiB0YXJnZXQsIG9wMjogY29tcGFyaXNvbiB9KSA9PiB7XG4gIGxldCBvdGhlciA9IGNoZWNrKHZtLnN0YWNrLnBlZWsoKSwgQ2hlY2tOdW1iZXIpO1xuXG4gIGlmIChvdGhlciA9PT0gY29tcGFyaXNvbikge1xuICAgIHZtLmdvdG8odGFyZ2V0KTtcbiAgfVxufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Bc3NlcnRTYW1lLCAodm0pID0+IHtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBlZWsoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuXG4gIGlmIChpc0NvbnN0UmVmKHJlZmVyZW5jZSkgPT09IGZhbHNlKSB7XG4gICAgdm0udXBkYXRlV2l0aChuZXcgQXNzZXJ0KHJlZmVyZW5jZSkpO1xuICB9XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlRvQm9vbGVhbiwgKHZtKSA9PiB7XG4gIGxldCB7IHN0YWNrIH0gPSB2bTtcbiAgbGV0IHZhbHVlUmVmID0gY2hlY2soc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcblxuICBzdGFjay5wdXNoKGNyZWF0ZUNvbXB1dGVSZWYoKCkgPT4gdG9Cb29sKHZhbHVlRm9yUmVmKHZhbHVlUmVmKSkpKTtcbn0pO1xuXG5leHBvcnQgY2xhc3MgQXNzZXJ0IGltcGxlbWVudHMgVXBkYXRpbmdPcGNvZGUge1xuICBwcml2YXRlIGxhc3Q6IHVua25vd247XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWY6IFJlZmVyZW5jZSkge1xuICAgIHRoaXMubGFzdCA9IHZhbHVlRm9yUmVmKHJlZik7XG4gIH1cblxuICBldmFsdWF0ZSh2bTogVXBkYXRpbmdWTSkge1xuICAgIGxldCB7IGxhc3QsIHJlZiB9ID0gdGhpcztcbiAgICBsZXQgY3VycmVudCA9IHZhbHVlRm9yUmVmKHJlZik7XG5cbiAgICBpZiAobGFzdCAhPT0gY3VycmVudCkge1xuICAgICAgdm0udGhyb3coKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFzc2VydEZpbHRlcjxULCBVPiBpbXBsZW1lbnRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgcHJpdmF0ZSBsYXN0OiBVO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVmOiBSZWZlcmVuY2U8VD4sIHByaXZhdGUgZmlsdGVyOiAoZnJvbTogVCkgPT4gVSkge1xuICAgIHRoaXMubGFzdCA9IGZpbHRlcih2YWx1ZUZvclJlZihyZWYpKTtcbiAgfVxuXG4gIGV2YWx1YXRlKHZtOiBVcGRhdGluZ1ZNKSB7XG4gICAgbGV0IHsgbGFzdCwgcmVmLCBmaWx0ZXIgfSA9IHRoaXM7XG4gICAgbGV0IGN1cnJlbnQgPSBmaWx0ZXIodmFsdWVGb3JSZWYocmVmKSk7XG5cbiAgICBpZiAobGFzdCAhPT0gY3VycmVudCkge1xuICAgICAgdm0udGhyb3coKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEp1bXBJZk5vdE1vZGlmaWVkT3Bjb2RlIGltcGxlbWVudHMgVXBkYXRpbmdPcGNvZGUge1xuICBwcml2YXRlIHRhZzogVGFnID0gQ09OU1RBTlRfVEFHO1xuICBwcml2YXRlIGxhc3RSZXZpc2lvbjogUmV2aXNpb24gPSBJTklUSUFMO1xuICBwcml2YXRlIHRhcmdldD86IG51bWJlcjtcblxuICBmaW5hbGl6ZSh0YWc6IFRhZywgdGFyZ2V0OiBudW1iZXIpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmRpZE1vZGlmeSh0YWcpO1xuICB9XG5cbiAgZXZhbHVhdGUodm06IFVwZGF0aW5nVk0pIHtcbiAgICBsZXQgeyB0YWcsIHRhcmdldCwgbGFzdFJldmlzaW9uIH0gPSB0aGlzO1xuXG4gICAgaWYgKCF2bS5hbHdheXNSZXZhbGlkYXRlICYmIHZhbGlkYXRlVGFnKHRhZywgbGFzdFJldmlzaW9uKSkge1xuICAgICAgY29uc3VtZVRhZyh0YWcpO1xuICAgICAgdm0uZ290byhleHBlY3QodGFyZ2V0LCAnVk0gQlVHOiBUYXJnZXQgbXVzdCBiZSBzZXQgYmVmb3JlIGF0dGVtcHRpbmcgdG8ganVtcCcpKTtcbiAgICB9XG4gIH1cblxuICBkaWRNb2RpZnkodGFnOiBUYWcpIHtcbiAgICB0aGlzLnRhZyA9IHRhZztcbiAgICB0aGlzLmxhc3RSZXZpc2lvbiA9IHZhbHVlRm9yVGFnKHRoaXMudGFnKTtcbiAgICBjb25zdW1lVGFnKHRhZyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEJlZ2luVHJhY2tGcmFtZU9wY29kZSBpbXBsZW1lbnRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkZWJ1Z0xhYmVsPzogc3RyaW5nKSB7fVxuXG4gIGV2YWx1YXRlKCkge1xuICAgIGJlZ2luVHJhY2tGcmFtZSh0aGlzLmRlYnVnTGFiZWwpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBFbmRUcmFja0ZyYW1lT3Bjb2RlIGltcGxlbWVudHMgVXBkYXRpbmdPcGNvZGUge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRhcmdldDogSnVtcElmTm90TW9kaWZpZWRPcGNvZGUpIHt9XG5cbiAgZXZhbHVhdGUoKSB7XG4gICAgbGV0IHRhZyA9IGVuZFRyYWNrRnJhbWUoKTtcbiAgICB0aGlzLnRhcmdldC5kaWRNb2RpZnkodGFnKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgUmVmZXJlbmNlLCB2YWx1ZUZvclJlZiwgaXNDb25zdFJlZiwgY3JlYXRlQ29tcHV0ZVJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQge1xuICBSZXZpc2lvbixcbiAgVGFnLFxuICB2YWx1ZUZvclRhZyxcbiAgdmFsaWRhdGVUYWcsXG4gIGNvbnN1bWVUYWcsXG4gIENVUlJFTlRfVEFHLFxufSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHtcbiAgY2hlY2ssXG4gIENoZWNrU3RyaW5nLFxuICBDaGVja0VsZW1lbnQsXG4gIENoZWNrT3B0aW9uLFxuICBDaGVja05vZGUsXG4gIENoZWNrTWF5YmUsXG59IGZyb20gJ0BnbGltbWVyL2RlYnVnJztcbmltcG9ydCB7XG4gIE9wLFxuICBPcHRpb24sXG4gIE1vZGlmaWVyRGVmaW5pdGlvbixcbiAgTW9kaWZpZXJJbnN0YW5jZSxcbiAgT3duZXIsXG4gIENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cyxcbiAgQ3VycmllZFR5cGUsXG4gIE1vZGlmaWVyRGVmaW5pdGlvblN0YXRlLFxuICBFbnZpcm9ubWVudCxcbiAgVXBkYXRpbmdWTSxcbiAgVXBkYXRpbmdPcGNvZGUsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgJHQwIH0gZnJvbSAnQGdsaW1tZXIvdm0nO1xuaW1wb3J0IHsgQVBQRU5EX09QQ09ERVMgfSBmcm9tICcuLi8uLi9vcGNvZGVzJztcbmltcG9ydCB7IEFzc2VydCB9IGZyb20gJy4vdm0nO1xuaW1wb3J0IHsgRHluYW1pY0F0dHJpYnV0ZSB9IGZyb20gJy4uLy4uL3ZtL2F0dHJpYnV0ZXMvZHluYW1pYyc7XG5pbXBvcnQgeyBDaGVja1JlZmVyZW5jZSwgQ2hlY2tBcmd1bWVudHMsIENoZWNrT3BlcmF0aW9ucyB9IGZyb20gJy4vLWRlYnVnLXN0cmlwJztcbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gJy4uLy4uL3N5bWJvbHMnO1xuaW1wb3J0IHsgYXNzaWduLCBkZWJ1Z1RvU3RyaW5nLCBleHBlY3QsIGlzT2JqZWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBDdXJyaWVkVmFsdWUsIGlzQ3VycmllZFR5cGUsIHJlc29sdmVDdXJyaWVkVmFsdWUgfSBmcm9tICcuLi8uLi9jdXJyaWVkLXZhbHVlJztcbmltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IGFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQsIGRlc3Ryb3kgfSBmcm9tICdAZ2xpbW1lci9kZXN0cm95YWJsZSc7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5UZXh0LCAodm0sIHsgb3AxOiB0ZXh0IH0pID0+IHtcbiAgdm0uZWxlbWVudHMoKS5hcHBlbmRUZXh0KHZtW0NPTlNUQU5UU10uZ2V0VmFsdWUodGV4dCkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Db21tZW50LCAodm0sIHsgb3AxOiB0ZXh0IH0pID0+IHtcbiAgdm0uZWxlbWVudHMoKS5hcHBlbmRDb21tZW50KHZtW0NPTlNUQU5UU10uZ2V0VmFsdWUodGV4dCkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5PcGVuRWxlbWVudCwgKHZtLCB7IG9wMTogdGFnIH0pID0+IHtcbiAgdm0uZWxlbWVudHMoKS5vcGVuRWxlbWVudCh2bVtDT05TVEFOVFNdLmdldFZhbHVlKHRhZykpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5PcGVuRHluYW1pY0VsZW1lbnQsICh2bSkgPT4ge1xuICBsZXQgdGFnTmFtZSA9IGNoZWNrKHZhbHVlRm9yUmVmKGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSkpLCBDaGVja1N0cmluZyk7XG4gIHZtLmVsZW1lbnRzKCkub3BlbkVsZW1lbnQodGFnTmFtZSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlB1c2hSZW1vdGVFbGVtZW50LCAodm0pID0+IHtcbiAgbGV0IGVsZW1lbnRSZWYgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuICBsZXQgaW5zZXJ0QmVmb3JlUmVmID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcbiAgbGV0IGd1aWRSZWYgPSBjaGVjayh2bS5zdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuXG4gIGxldCBlbGVtZW50ID0gY2hlY2sodmFsdWVGb3JSZWYoZWxlbWVudFJlZiksIENoZWNrRWxlbWVudCk7XG4gIGxldCBpbnNlcnRCZWZvcmUgPSBjaGVjayh2YWx1ZUZvclJlZihpbnNlcnRCZWZvcmVSZWYpLCBDaGVja01heWJlKENoZWNrT3B0aW9uKENoZWNrTm9kZSkpKTtcbiAgbGV0IGd1aWQgPSB2YWx1ZUZvclJlZihndWlkUmVmKSBhcyBzdHJpbmc7XG5cbiAgaWYgKCFpc0NvbnN0UmVmKGVsZW1lbnRSZWYpKSB7XG4gICAgdm0udXBkYXRlV2l0aChuZXcgQXNzZXJ0KGVsZW1lbnRSZWYpKTtcbiAgfVxuXG4gIGlmIChpbnNlcnRCZWZvcmUgIT09IHVuZGVmaW5lZCAmJiAhaXNDb25zdFJlZihpbnNlcnRCZWZvcmVSZWYpKSB7XG4gICAgdm0udXBkYXRlV2l0aChuZXcgQXNzZXJ0KGluc2VydEJlZm9yZVJlZikpO1xuICB9XG5cbiAgbGV0IGJsb2NrID0gdm0uZWxlbWVudHMoKS5wdXNoUmVtb3RlRWxlbWVudChlbGVtZW50LCBndWlkLCBpbnNlcnRCZWZvcmUpO1xuICBpZiAoYmxvY2spIHZtLmFzc29jaWF0ZURlc3Ryb3lhYmxlKGJsb2NrKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUG9wUmVtb3RlRWxlbWVudCwgKHZtKSA9PiB7XG4gIHZtLmVsZW1lbnRzKCkucG9wUmVtb3RlRWxlbWVudCgpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5GbHVzaEVsZW1lbnQsICh2bSkgPT4ge1xuICBsZXQgb3BlcmF0aW9ucyA9IGNoZWNrKHZtLmZldGNoVmFsdWUoJHQwKSwgQ2hlY2tPcGVyYXRpb25zKTtcbiAgbGV0IG1vZGlmaWVyczogT3B0aW9uPE1vZGlmaWVySW5zdGFuY2VbXT4gPSBudWxsO1xuXG4gIGlmIChvcGVyYXRpb25zKSB7XG4gICAgbW9kaWZpZXJzID0gb3BlcmF0aW9ucy5mbHVzaCh2bSk7XG4gICAgdm0ubG9hZFZhbHVlKCR0MCwgbnVsbCk7XG4gIH1cblxuICB2bS5lbGVtZW50cygpLmZsdXNoRWxlbWVudChtb2RpZmllcnMpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5DbG9zZUVsZW1lbnQsICh2bSkgPT4ge1xuICBsZXQgbW9kaWZpZXJzID0gdm0uZWxlbWVudHMoKS5jbG9zZUVsZW1lbnQoKTtcblxuICBpZiAobW9kaWZpZXJzKSB7XG4gICAgbW9kaWZpZXJzLmZvckVhY2goKG1vZGlmaWVyKSA9PiB7XG4gICAgICB2bS5lbnYuc2NoZWR1bGVJbnN0YWxsTW9kaWZpZXIobW9kaWZpZXIpO1xuICAgICAgbGV0IHsgbWFuYWdlciwgc3RhdGUgfSA9IG1vZGlmaWVyO1xuICAgICAgbGV0IGQgPSBtYW5hZ2VyLmdldERlc3Ryb3lhYmxlKHN0YXRlKTtcblxuICAgICAgaWYgKGQpIHtcbiAgICAgICAgdm0uYXNzb2NpYXRlRGVzdHJveWFibGUoZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuTW9kaWZpZXIsICh2bSwgeyBvcDE6IGhhbmRsZSB9KSA9PiB7XG4gIGlmICh2bS5lbnYuaXNJbnRlcmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgb3duZXIgPSB2bS5nZXRPd25lcigpO1xuICBsZXQgYXJncyA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja0FyZ3VtZW50cyk7XG4gIGxldCBkZWZpbml0aW9uID0gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxNb2RpZmllckRlZmluaXRpb24+KGhhbmRsZSk7XG5cbiAgbGV0IHsgbWFuYWdlciB9ID0gZGVmaW5pdGlvbjtcblxuICBsZXQgeyBjb25zdHJ1Y3RpbmcgfSA9IHZtLmVsZW1lbnRzKCk7XG5cbiAgbGV0IHN0YXRlID0gbWFuYWdlci5jcmVhdGUoXG4gICAgb3duZXIsXG4gICAgZXhwZWN0KGNvbnN0cnVjdGluZywgJ0JVRzogRWxlbWVudE1vZGlmaWVyIGNvdWxkIG5vdCBmaW5kIHRoZSBlbGVtZW50IGl0IGFwcGxpZXMgdG8nKSxcbiAgICBkZWZpbml0aW9uLnN0YXRlLFxuICAgIGFyZ3MuY2FwdHVyZSgpXG4gICk7XG5cbiAgbGV0IGluc3RhbmNlOiBNb2RpZmllckluc3RhbmNlID0ge1xuICAgIG1hbmFnZXIsXG4gICAgc3RhdGUsXG4gICAgZGVmaW5pdGlvbixcbiAgfTtcblxuICBsZXQgb3BlcmF0aW9ucyA9IGV4cGVjdChcbiAgICBjaGVjayh2bS5mZXRjaFZhbHVlKCR0MCksIENoZWNrT3BlcmF0aW9ucyksXG4gICAgJ0JVRzogRWxlbWVudE1vZGlmaWVyIGNvdWxkIG5vdCBmaW5kIG9wZXJhdGlvbnMgdG8gYXBwZW5kIHRvJ1xuICApO1xuXG4gIG9wZXJhdGlvbnMuYWRkTW9kaWZpZXIoaW5zdGFuY2UpO1xuXG4gIGxldCB0YWcgPSBtYW5hZ2VyLmdldFRhZyhzdGF0ZSk7XG5cbiAgaWYgKHRhZyAhPT0gbnVsbCkge1xuICAgIGNvbnN1bWVUYWcodGFnKTtcbiAgICByZXR1cm4gdm0udXBkYXRlV2l0aChuZXcgVXBkYXRlTW9kaWZpZXJPcGNvZGUodGFnLCBpbnN0YW5jZSkpO1xuICB9XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkR5bmFtaWNNb2RpZmllciwgKHZtKSA9PiB7XG4gIGlmICh2bS5lbnYuaXNJbnRlcmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgeyBzdGFjaywgW0NPTlNUQU5UU106IGNvbnN0YW50cyB9ID0gdm07XG4gIGxldCByZWYgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuICBsZXQgYXJncyA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja0FyZ3VtZW50cykuY2FwdHVyZSgpO1xuICBsZXQgeyBjb25zdHJ1Y3RpbmcgfSA9IHZtLmVsZW1lbnRzKCk7XG4gIGxldCBpbml0aWFsT3duZXIgPSB2bS5nZXRPd25lcigpO1xuXG4gIGxldCBpbnN0YW5jZVJlZiA9IGNyZWF0ZUNvbXB1dGVSZWYoKCkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IHZhbHVlRm9yUmVmKHJlZik7XG4gICAgbGV0IG93bmVyOiBPd25lcjtcblxuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGhvc3REZWZpbml0aW9uOiBDdXJyaWVkVmFsdWUgfCBNb2RpZmllckRlZmluaXRpb25TdGF0ZTtcblxuICAgIGlmIChpc0N1cnJpZWRUeXBlKHZhbHVlLCBDdXJyaWVkVHlwZS5Nb2RpZmllcikpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGRlZmluaXRpb246IHJlc29sdmVkRGVmaW5pdGlvbixcbiAgICAgICAgb3duZXI6IGN1cnJpZWRPd25lcixcbiAgICAgICAgcG9zaXRpb25hbCxcbiAgICAgICAgbmFtZWQsXG4gICAgICB9ID0gcmVzb2x2ZUN1cnJpZWRWYWx1ZSh2YWx1ZSk7XG5cbiAgICAgIGhvc3REZWZpbml0aW9uID0gcmVzb2x2ZWREZWZpbml0aW9uO1xuICAgICAgb3duZXIgPSBjdXJyaWVkT3duZXI7XG5cbiAgICAgIGlmIChwb3NpdGlvbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXJncy5wb3NpdGlvbmFsID0gcG9zaXRpb25hbC5jb25jYXQoYXJncy5wb3NpdGlvbmFsKSBhcyBDYXB0dXJlZFBvc2l0aW9uYWxBcmd1bWVudHM7XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyZ3MubmFtZWQgPSBhc3NpZ24oe30sIC4uLm5hbWVkLCBhcmdzLm5hbWVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaG9zdERlZmluaXRpb24gPSB2YWx1ZTtcbiAgICAgIG93bmVyID0gaW5pdGlhbE93bmVyO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGUgPSBjb25zdGFudHMubW9kaWZpZXIoaG9zdERlZmluaXRpb24sIG51bGwsIHRydWUpO1xuXG4gICAgaWYgKERFQlVHICYmIGhhbmRsZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgYSBkeW5hbWljIG1vZGlmaWVyIGRlZmluaXRpb24sIGJ1dCByZWNlaXZlZCBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkaWQgbm90IGhhdmUgYSBtb2RpZmllciBtYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCBpdC4gVGhlIGR5bmFtaWMgaW52b2NhdGlvbiB3YXMgXFxge3ske1xuICAgICAgICAgIHJlZi5kZWJ1Z0xhYmVsXG4gICAgICAgIH19fVxcYCwgYW5kIHRoZSBpbmNvcnJlY3QgZGVmaW5pdGlvbiBpcyB0aGUgdmFsdWUgYXQgdGhlIHBhdGggXFxgJHtcbiAgICAgICAgICByZWYuZGVidWdMYWJlbFxuICAgICAgICB9XFxgLCB3aGljaCB3YXM6ICR7ZGVidWdUb1N0cmluZyEoaG9zdERlZmluaXRpb24pfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IGRlZmluaXRpb24gPSBjb25zdGFudHMuZ2V0VmFsdWU8TW9kaWZpZXJEZWZpbml0aW9uPihcbiAgICAgIGV4cGVjdChoYW5kbGUsICdCVUc6IG1vZGlmaWVyIGhhbmRsZSBleHBlY3RlZCcpXG4gICAgKTtcblxuICAgIGxldCB7IG1hbmFnZXIgfSA9IGRlZmluaXRpb247XG5cbiAgICBsZXQgc3RhdGUgPSBtYW5hZ2VyLmNyZWF0ZShcbiAgICAgIG93bmVyLFxuICAgICAgZXhwZWN0KGNvbnN0cnVjdGluZywgJ0JVRzogRWxlbWVudE1vZGlmaWVyIGNvdWxkIG5vdCBmaW5kIHRoZSBlbGVtZW50IGl0IGFwcGxpZXMgdG8nKSxcbiAgICAgIGRlZmluaXRpb24uc3RhdGUsXG4gICAgICBhcmdzXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBtYW5hZ2VyLFxuICAgICAgc3RhdGUsXG4gICAgICBkZWZpbml0aW9uLFxuICAgIH07XG4gIH0pO1xuXG4gIGxldCBpbnN0YW5jZSA9IHZhbHVlRm9yUmVmKGluc3RhbmNlUmVmKTtcbiAgbGV0IHRhZyA9IG51bGw7XG5cbiAgaWYgKGluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgb3BlcmF0aW9ucyA9IGV4cGVjdChcbiAgICAgIGNoZWNrKHZtLmZldGNoVmFsdWUoJHQwKSwgQ2hlY2tPcGVyYXRpb25zKSxcbiAgICAgICdCVUc6IEVsZW1lbnRNb2RpZmllciBjb3VsZCBub3QgZmluZCBvcGVyYXRpb25zIHRvIGFwcGVuZCB0bydcbiAgICApO1xuXG4gICAgb3BlcmF0aW9ucy5hZGRNb2RpZmllcihpbnN0YW5jZSk7XG5cbiAgICB0YWcgPSBpbnN0YW5jZS5tYW5hZ2VyLmdldFRhZyhpbnN0YW5jZS5zdGF0ZSk7XG5cbiAgICBpZiAodGFnICE9PSBudWxsKSB7XG4gICAgICBjb25zdW1lVGFnKHRhZyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc0NvbnN0UmVmKHJlZikgfHwgdGFnKSB7XG4gICAgcmV0dXJuIHZtLnVwZGF0ZVdpdGgobmV3IFVwZGF0ZUR5bmFtaWNNb2RpZmllck9wY29kZSh0YWcsIGluc3RhbmNlLCBpbnN0YW5jZVJlZikpO1xuICB9XG59KTtcblxuZXhwb3J0IGNsYXNzIFVwZGF0ZU1vZGlmaWVyT3Bjb2RlIGltcGxlbWVudHMgVXBkYXRpbmdPcGNvZGUge1xuICBwcml2YXRlIGxhc3RVcGRhdGVkOiBSZXZpc2lvbjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRhZzogVGFnLCBwcml2YXRlIG1vZGlmaWVyOiBNb2RpZmllckluc3RhbmNlKSB7XG4gICAgdGhpcy5sYXN0VXBkYXRlZCA9IHZhbHVlRm9yVGFnKHRhZyk7XG4gIH1cblxuICBldmFsdWF0ZSh2bTogVXBkYXRpbmdWTSkge1xuICAgIGxldCB7IG1vZGlmaWVyLCB0YWcsIGxhc3RVcGRhdGVkIH0gPSB0aGlzO1xuXG4gICAgY29uc3VtZVRhZyh0YWcpO1xuXG4gICAgaWYgKCF2YWxpZGF0ZVRhZyh0YWcsIGxhc3RVcGRhdGVkKSkge1xuICAgICAgdm0uZW52LnNjaGVkdWxlVXBkYXRlTW9kaWZpZXIobW9kaWZpZXIpO1xuICAgICAgdGhpcy5sYXN0VXBkYXRlZCA9IHZhbHVlRm9yVGFnKHRhZyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVcGRhdGVEeW5hbWljTW9kaWZpZXJPcGNvZGUgaW1wbGVtZW50cyBVcGRhdGluZ09wY29kZSB7XG4gIHByaXZhdGUgbGFzdFVwZGF0ZWQ6IFJldmlzaW9uO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdGFnOiBUYWcgfCBudWxsLFxuICAgIHByaXZhdGUgaW5zdGFuY2U6IE1vZGlmaWVySW5zdGFuY2UgfCB1bmRlZmluZWQsXG4gICAgcHJpdmF0ZSBpbnN0YW5jZVJlZjogUmVmZXJlbmNlPE1vZGlmaWVySW5zdGFuY2UgfCB1bmRlZmluZWQ+XG4gICkge1xuICAgIHRoaXMubGFzdFVwZGF0ZWQgPSB2YWx1ZUZvclRhZyh0YWcgPz8gQ1VSUkVOVF9UQUcpO1xuICB9XG5cbiAgZXZhbHVhdGUodm06IFVwZGF0aW5nVk0pIHtcbiAgICBsZXQgeyB0YWcsIGxhc3RVcGRhdGVkLCBpbnN0YW5jZSwgaW5zdGFuY2VSZWYgfSA9IHRoaXM7XG5cbiAgICBsZXQgbmV3SW5zdGFuY2UgPSB2YWx1ZUZvclJlZihpbnN0YW5jZVJlZik7XG5cbiAgICBpZiAobmV3SW5zdGFuY2UgIT09IGluc3RhbmNlKSB7XG4gICAgICBpZiAoaW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgZGVzdHJveWFibGUgPSBpbnN0YW5jZS5tYW5hZ2VyLmdldERlc3Ryb3lhYmxlKGluc3RhbmNlLnN0YXRlKTtcblxuICAgICAgICBpZiAoZGVzdHJveWFibGUgIT09IG51bGwpIHtcbiAgICAgICAgICBkZXN0cm95KGRlc3Ryb3lhYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV3SW5zdGFuY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgeyBtYW5hZ2VyLCBzdGF0ZSB9ID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIGxldCBkZXN0cm95YWJsZSA9IG1hbmFnZXIuZ2V0RGVzdHJveWFibGUoc3RhdGUpO1xuXG4gICAgICAgIGlmIChkZXN0cm95YWJsZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQodGhpcywgZGVzdHJveWFibGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFnID0gbWFuYWdlci5nZXRUYWcoc3RhdGUpO1xuXG4gICAgICAgIGlmICh0YWcgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmxhc3RVcGRhdGVkID0gdmFsdWVGb3JUYWcodGFnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB2bS5lbnYuc2NoZWR1bGVJbnN0YWxsTW9kaWZpZXIobmV3SW5zdGFuY2UhKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ld0luc3RhbmNlO1xuICAgIH0gZWxzZSBpZiAodGFnICE9PSBudWxsICYmICF2YWxpZGF0ZVRhZyh0YWcsIGxhc3RVcGRhdGVkKSkge1xuICAgICAgdm0uZW52LnNjaGVkdWxlVXBkYXRlTW9kaWZpZXIoaW5zdGFuY2UhKTtcbiAgICAgIHRoaXMubGFzdFVwZGF0ZWQgPSB2YWx1ZUZvclRhZyh0YWcpO1xuICAgIH1cblxuICAgIGlmICh0YWcgIT09IG51bGwpIHtcbiAgICAgIGNvbnN1bWVUYWcodGFnKTtcbiAgICB9XG4gIH1cbn1cblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlN0YXRpY0F0dHIsICh2bSwgeyBvcDE6IF9uYW1lLCBvcDI6IF92YWx1ZSwgb3AzOiBfbmFtZXNwYWNlIH0pID0+IHtcbiAgbGV0IG5hbWUgPSB2bVtDT05TVEFOVFNdLmdldFZhbHVlPHN0cmluZz4oX25hbWUpO1xuICBsZXQgdmFsdWUgPSB2bVtDT05TVEFOVFNdLmdldFZhbHVlPHN0cmluZz4oX3ZhbHVlKTtcbiAgbGV0IG5hbWVzcGFjZSA9IF9uYW1lc3BhY2UgPyB2bVtDT05TVEFOVFNdLmdldFZhbHVlPHN0cmluZz4oX25hbWVzcGFjZSkgOiBudWxsO1xuXG4gIHZtLmVsZW1lbnRzKCkuc2V0U3RhdGljQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBuYW1lc3BhY2UpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5EeW5hbWljQXR0ciwgKHZtLCB7IG9wMTogX25hbWUsIG9wMjogX3RydXN0aW5nLCBvcDM6IF9uYW1lc3BhY2UgfSkgPT4ge1xuICBsZXQgbmFtZSA9IHZtW0NPTlNUQU5UU10uZ2V0VmFsdWU8c3RyaW5nPihfbmFtZSk7XG4gIGxldCB0cnVzdGluZyA9IHZtW0NPTlNUQU5UU10uZ2V0VmFsdWU8Ym9vbGVhbj4oX3RydXN0aW5nKTtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG4gIGxldCB2YWx1ZSA9IHZhbHVlRm9yUmVmKHJlZmVyZW5jZSk7XG4gIGxldCBuYW1lc3BhY2UgPSBfbmFtZXNwYWNlID8gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxzdHJpbmc+KF9uYW1lc3BhY2UpIDogbnVsbDtcblxuICBsZXQgYXR0cmlidXRlID0gdm0uZWxlbWVudHMoKS5zZXREeW5hbWljQXR0cmlidXRlKG5hbWUsIHZhbHVlLCB0cnVzdGluZywgbmFtZXNwYWNlKTtcblxuICBpZiAoIWlzQ29uc3RSZWYocmVmZXJlbmNlKSkge1xuICAgIHZtLnVwZGF0ZVdpdGgobmV3IFVwZGF0ZUR5bmFtaWNBdHRyaWJ1dGVPcGNvZGUocmVmZXJlbmNlLCBhdHRyaWJ1dGUsIHZtLmVudikpO1xuICB9XG59KTtcblxuZXhwb3J0IGNsYXNzIFVwZGF0ZUR5bmFtaWNBdHRyaWJ1dGVPcGNvZGUgaW1wbGVtZW50cyBVcGRhdGluZ09wY29kZSB7XG4gIHByaXZhdGUgdXBkYXRlUmVmOiBSZWZlcmVuY2U7XG5cbiAgY29uc3RydWN0b3IocmVmZXJlbmNlOiBSZWZlcmVuY2U8dW5rbm93bj4sIGF0dHJpYnV0ZTogRHluYW1pY0F0dHJpYnV0ZSwgZW52OiBFbnZpcm9ubWVudCkge1xuICAgIGxldCBpbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgdGhpcy51cGRhdGVSZWYgPSBjcmVhdGVDb21wdXRlUmVmKCgpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IHZhbHVlRm9yUmVmKHJlZmVyZW5jZSk7XG5cbiAgICAgIGlmIChpbml0aWFsaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICBhdHRyaWJ1dGUudXBkYXRlKHZhbHVlLCBlbnYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFsdWVGb3JSZWYodGhpcy51cGRhdGVSZWYpO1xuICB9XG5cbiAgZXZhbHVhdGUoKSB7XG4gICAgdmFsdWVGb3JSZWYodGhpcy51cGRhdGVSZWYpO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBjaGVjayxcbiAgQ2hlY2tGdW5jdGlvbixcbiAgQ2hlY2tIYW5kbGUsXG4gIENoZWNrSW5zdGFuY2VvZixcbiAgQ2hlY2tJbnRlcmZhY2UsXG4gIENoZWNrUHJvZ3JhbVN5bWJvbFRhYmxlLFxuICBDaGVja1N0cmluZyxcbiAgQ2hlY2tPcixcbn0gZnJvbSAnQGdsaW1tZXIvZGVidWcnO1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHtcbiAgQm91bmRzLFxuICBDb21wb25lbnREZWZpbml0aW9uLFxuICBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHksXG4gIENvbXBvbmVudERlZmluaXRpb25TdGF0ZSxcbiAgQ29tcG9uZW50SW5zdGFuY2VTdGF0ZSxcbiAgSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyLFxuICBEaWN0LFxuICBEeW5hbWljU2NvcGUsXG4gIEVsZW1lbnRPcGVyYXRpb25zLFxuICBPcCxcbiAgT3B0aW9uLFxuICBQcm9ncmFtU3ltYm9sVGFibGUsXG4gIFJlY2FzdCxcbiAgU2NvcGVTbG90LFxuICBWTUFyZ3VtZW50cyxcbiAgV2l0aER5bmFtaWNUYWdOYW1lLFxuICBXaXRoRWxlbWVudEhvb2ssXG4gIFdpdGhVcGRhdGVIb29rLFxuICBDYXB0dXJlZEFyZ3VtZW50cyxcbiAgQ29tcGlsYWJsZVByb2dyYW0sXG4gIENvbXBvbmVudEluc3RhbmNlLFxuICBNb2RpZmllckluc3RhbmNlLFxuICBDb21wb25lbnRJbnN0YW5jZVdpdGhDcmVhdGUsXG4gIE93bmVyLFxuICBDdXJyaWVkVHlwZSxcbiAgVXBkYXRpbmdPcGNvZGUsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgaXNDb25zdFJlZiwgUmVmZXJlbmNlLCB2YWx1ZUZvclJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQge1xuICBhc3NlcnQsXG4gIGFzc2lnbixcbiAgZGVidWdUb1N0cmluZyxcbiAgZGljdCxcbiAgRU1QVFlfU1RSSU5HX0FSUkFZLFxuICBleHBlY3QsXG4gIHVud3JhcFRlbXBsYXRlLFxufSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7ICR0MCwgJHQxIH0gZnJvbSAnQGdsaW1tZXIvdm0nO1xuaW1wb3J0IHsgcmVnaXN0ZXJEZXN0cnVjdG9yIH0gZnJvbSAnQGdsaW1tZXIvZGVzdHJveWFibGUnO1xuaW1wb3J0IHsgbWFuYWdlckhhc0NhcGFiaWxpdHkgfSBmcm9tICdAZ2xpbW1lci9tYW5hZ2VyJztcbmltcG9ydCB7IHJlc29sdmVDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvcmVzb2x2ZSc7XG5pbXBvcnQgeyBoYXNDdXN0b21EZWJ1Z1JlbmRlclRyZWVMaWZlY3ljbGUgfSBmcm9tICcuLi8uLi9jb21wb25lbnQvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBBUFBFTkRfT1BDT0RFUyB9IGZyb20gJy4uLy4uL29wY29kZXMnO1xuaW1wb3J0IGNyZWF0ZUNsYXNzTGlzdFJlZiBmcm9tICcuLi8uLi9yZWZlcmVuY2VzL2NsYXNzLWxpc3QnO1xuaW1wb3J0IHsgQVJHUywgQ09OU1RBTlRTIH0gZnJvbSAnLi4vLi4vc3ltYm9scyc7XG5pbXBvcnQgeyBVcGRhdGluZ1ZNIH0gZnJvbSAnLi4vLi4vdm0nO1xuaW1wb3J0IHsgSW50ZXJuYWxWTSB9IGZyb20gJy4uLy4uL3ZtL2FwcGVuZCc7XG5pbXBvcnQgeyBCbG9ja0FyZ3VtZW50c0ltcGwsIEVNUFRZX0FSR1MsIFZNQXJndW1lbnRzSW1wbCB9IGZyb20gJy4uLy4uL3ZtL2FyZ3VtZW50cyc7XG5pbXBvcnQge1xuICBDaGVja0FyZ3VtZW50cyxcbiAgQ2hlY2tDb21wb25lbnREZWZpbml0aW9uLFxuICBDaGVja0NvbXBvbmVudEluc3RhbmNlLFxuICBDaGVja0ZpbmlzaGVkQ29tcG9uZW50SW5zdGFuY2UsXG4gIENoZWNrSW52b2NhdGlvbixcbiAgQ2hlY2tSZWZlcmVuY2UsXG4gIENoZWNrQ3VycmllZENvbXBvbmVudERlZmluaXRpb24sXG59IGZyb20gJy4vLWRlYnVnLXN0cmlwJztcbmltcG9ydCB7IFVwZGF0ZUR5bmFtaWNBdHRyaWJ1dGVPcGNvZGUgfSBmcm9tICcuL2RvbSc7XG5pbXBvcnQge1xuICBDdXJyaWVkVmFsdWUsXG4gIGlzQ3VycmllZFR5cGUsXG4gIGlzQ3VycmllZFZhbHVlLFxuICByZXNvbHZlQ3VycmllZFZhbHVlLFxufSBmcm9tICcuLi8uLi9jdXJyaWVkLXZhbHVlJztcblxuLyoqXG4gKiBUaGUgVk0gY3JlYXRlcyBhIG5ldyBDb21wb25lbnRJbnN0YW5jZSBkYXRhIHN0cnVjdHVyZSBmb3IgZXZlcnkgY29tcG9uZW50XG4gKiBpbnZvY2F0aW9uIGl0IGVuY291bnRlcnMuXG4gKlxuICogU2ltaWxhciB0byBob3cgYSBDb21wb25lbnREZWZpbml0aW9uIGNvbnRhaW5zIHN0YXRlIGFib3V0IGFsbCBjb21wb25lbnRzIG9mIGFcbiAqIHBhcnRpY3VsYXIgdHlwZSwgYSBDb21wb25lbnRJbnN0YW5jZSBjb250YWlucyBzdGF0ZSBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXJcbiAqIGluc3RhbmNlIG9mIGEgY29tcG9uZW50IHR5cGUuIEl0IGFsc28gY29udGFpbnMgYSBwb2ludGVyIGJhY2sgdG8gaXRzXG4gKiBjb21wb25lbnQgdHlwZSdzIENvbXBvbmVudERlZmluaXRpb24uXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBJbml0aWFsQ29tcG9uZW50SW5zdGFuY2Uge1xuICBkZWZpbml0aW9uOiBDb21wb25lbnREZWZpbml0aW9uO1xuICBtYW5hZ2VyOiBPcHRpb248SW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyPjtcbiAgY2FwYWJpbGl0aWVzOiBPcHRpb248SW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5PjtcbiAgc3RhdGU6IG51bGw7XG4gIGhhbmRsZTogT3B0aW9uPG51bWJlcj47XG4gIHRhYmxlOiBPcHRpb248UHJvZ3JhbVN5bWJvbFRhYmxlPjtcbiAgbG9va3VwOiBPcHRpb248RGljdDxTY29wZVNsb3Q+Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb3B1bGF0ZWRDb21wb25lbnRJbnN0YW5jZSB7XG4gIGRlZmluaXRpb246IENvbXBvbmVudERlZmluaXRpb247XG4gIG1hbmFnZXI6IEludGVybmFsQ29tcG9uZW50TWFuYWdlcjtcbiAgY2FwYWJpbGl0aWVzOiBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHk7XG4gIHN0YXRlOiBudWxsO1xuICBoYW5kbGU6IG51bWJlcjtcbiAgdGFibGU6IE9wdGlvbjxQcm9ncmFtU3ltYm9sVGFibGU+O1xuICBsb29rdXA6IE9wdGlvbjxEaWN0PFNjb3BlU2xvdD4+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhcnRpYWxDb21wb25lbnREZWZpbml0aW9uIHtcbiAgc3RhdGU6IE9wdGlvbjxDb21wb25lbnREZWZpbml0aW9uU3RhdGU+O1xuICBtYW5hZ2VyOiBJbnRlcm5hbENvbXBvbmVudE1hbmFnZXI7XG59XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5QdXNoQ29tcG9uZW50RGVmaW5pdGlvbiwgKHZtLCB7IG9wMTogaGFuZGxlIH0pID0+IHtcbiAgbGV0IGRlZmluaXRpb24gPSB2bVtDT05TVEFOVFNdLmdldFZhbHVlPENvbXBvbmVudERlZmluaXRpb24+KGhhbmRsZSk7XG4gIGFzc2VydCghIWRlZmluaXRpb24sIGBNaXNzaW5nIGNvbXBvbmVudCBmb3IgJHtoYW5kbGV9YCk7XG5cbiAgbGV0IHsgbWFuYWdlciwgY2FwYWJpbGl0aWVzIH0gPSBkZWZpbml0aW9uO1xuXG4gIGxldCBpbnN0YW5jZTogSW5pdGlhbENvbXBvbmVudEluc3RhbmNlID0ge1xuICAgIGRlZmluaXRpb24sXG4gICAgbWFuYWdlcixcbiAgICBjYXBhYmlsaXRpZXMsXG4gICAgc3RhdGU6IG51bGwsXG4gICAgaGFuZGxlOiBudWxsLFxuICAgIHRhYmxlOiBudWxsLFxuICAgIGxvb2t1cDogbnVsbCxcbiAgfTtcblxuICB2bS5zdGFjay5wdXNoKGluc3RhbmNlKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUmVzb2x2ZUR5bmFtaWNDb21wb25lbnQsICh2bSwgeyBvcDE6IF9pc1N0cmljdCB9KSA9PiB7XG4gIGxldCBzdGFjayA9IHZtLnN0YWNrO1xuICBsZXQgY29tcG9uZW50ID0gY2hlY2soXG4gICAgdmFsdWVGb3JSZWYoY2hlY2soc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKSksXG4gICAgQ2hlY2tPcihDaGVja1N0cmluZywgQ2hlY2tDdXJyaWVkQ29tcG9uZW50RGVmaW5pdGlvbilcbiAgKTtcbiAgbGV0IGNvbnN0YW50cyA9IHZtW0NPTlNUQU5UU107XG4gIGxldCBvd25lciA9IHZtLmdldE93bmVyKCk7XG4gIGxldCBpc1N0cmljdCA9IGNvbnN0YW50cy5nZXRWYWx1ZTxib29sZWFuPihfaXNTdHJpY3QpO1xuXG4gIHZtLmxvYWRWYWx1ZSgkdDEsIG51bGwpOyAvLyBDbGVhciB0aGUgdGVtcCByZWdpc3RlclxuXG4gIGxldCBkZWZpbml0aW9uOiBDb21wb25lbnREZWZpbml0aW9uIHwgQ3VycmllZFZhbHVlO1xuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnc3RyaW5nJykge1xuICAgIGlmIChERUJVRyAmJiBpc1N0cmljdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQXR0ZW1wdGVkIHRvIHJlc29sdmUgYSBkeW5hbWljIGNvbXBvbmVudCB3aXRoIGEgc3RyaW5nIGRlZmluaXRpb24sIFxcYCR7Y29tcG9uZW50fVxcYCBpbiBhIHN0cmljdCBtb2RlIHRlbXBsYXRlLiBJbiBzdHJpY3QgbW9kZSwgdXNpbmcgc3RyaW5ncyB0byByZXNvbHZlIGNvbXBvbmVudCBkZWZpbml0aW9ucyBpcyBwcm9oaWJpdGVkLiBZb3UgY2FuIGluc3RlYWQgaW1wb3J0IHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbiBhbmQgdXNlIGl0IGRpcmVjdGx5LmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHJlc29sdmVkRGVmaW5pdGlvbiA9IHJlc29sdmVDb21wb25lbnQodm0ucnVudGltZS5yZXNvbHZlciwgY29uc3RhbnRzLCBjb21wb25lbnQsIG93bmVyKTtcblxuICAgIGRlZmluaXRpb24gPSBleHBlY3QocmVzb2x2ZWREZWZpbml0aW9uLCBgQ291bGQgbm90IGZpbmQgYSBjb21wb25lbnQgbmFtZWQgXCIke2NvbXBvbmVudH1cImApO1xuICB9IGVsc2UgaWYgKGlzQ3VycmllZFZhbHVlKGNvbXBvbmVudCkpIHtcbiAgICBkZWZpbml0aW9uID0gY29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIGRlZmluaXRpb24gPSBjb25zdGFudHMuY29tcG9uZW50KGNvbXBvbmVudCwgb3duZXIpO1xuICB9XG5cbiAgc3RhY2sucHVzaChkZWZpbml0aW9uKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUmVzb2x2ZUN1cnJpZWRDb21wb25lbnQsICh2bSkgPT4ge1xuICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcbiAgbGV0IHJlZiA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG4gIGxldCB2YWx1ZSA9IHZhbHVlRm9yUmVmKHJlZik7XG4gIGxldCBjb25zdGFudHMgPSB2bVtDT05TVEFOVFNdO1xuXG4gIGxldCBkZWZpbml0aW9uOiBDdXJyaWVkVmFsdWUgfCBDb21wb25lbnREZWZpbml0aW9uIHwgbnVsbDtcblxuICBpZiAoREVCVUcgJiYgISh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhIGNvbXBvbmVudCBkZWZpbml0aW9uLCBidXQgcmVjZWl2ZWQgJHt2YWx1ZX0uIFlvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgZG9uZSA8JHtyZWYuZGVidWdMYWJlbH0+LCB3aGVyZSBcIiR7cmVmLmRlYnVnTGFiZWx9XCIgd2FzIGEgc3RyaW5nIGluc3RlYWQgb2YgYSBjdXJyaWVkIGNvbXBvbmVudCBkZWZpbml0aW9uLiBZb3UgbXVzdCBlaXRoZXIgdXNlIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbiBkaXJlY3RseSwgb3IgdXNlIHRoZSB7e2NvbXBvbmVudH19IGhlbHBlciB0byBjcmVhdGUgYSBjdXJyaWVkIGNvbXBvbmVudCBkZWZpbml0aW9uIHdoZW4gaW52b2tpbmcgZHluYW1pY2FsbHkuYFxuICAgICk7XG4gIH1cblxuICBpZiAoaXNDdXJyaWVkVmFsdWUodmFsdWUpKSB7XG4gICAgZGVmaW5pdGlvbiA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGRlZmluaXRpb24gPSBjb25zdGFudHMuY29tcG9uZW50KHZhbHVlIGFzIG9iamVjdCwgdm0uZ2V0T3duZXIoKSwgdHJ1ZSk7XG5cbiAgICBpZiAoREVCVUcgJiYgZGVmaW5pdGlvbiA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRXhwZWN0ZWQgYSBkeW5hbWljIGNvbXBvbmVudCBkZWZpbml0aW9uLCBidXQgcmVjZWl2ZWQgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGlkIG5vdCBoYXZlIGEgY29tcG9uZW50IG1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIGl0LiBUaGUgZHluYW1pYyBpbnZvY2F0aW9uIHdhcyBcXGA8JHtcbiAgICAgICAgICByZWYuZGVidWdMYWJlbFxuICAgICAgICB9PlxcYCBvciBcXGB7eyR7XG4gICAgICAgICAgcmVmLmRlYnVnTGFiZWxcbiAgICAgICAgfX19XFxgLCBhbmQgdGhlIGluY29ycmVjdCBkZWZpbml0aW9uIGlzIHRoZSB2YWx1ZSBhdCB0aGUgcGF0aCBcXGAke1xuICAgICAgICAgIHJlZi5kZWJ1Z0xhYmVsXG4gICAgICAgIH1cXGAsIHdoaWNoIHdhczogJHtkZWJ1Z1RvU3RyaW5nISh2YWx1ZSl9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBzdGFjay5wdXNoKGRlZmluaXRpb24pO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5QdXNoRHluYW1pY0NvbXBvbmVudEluc3RhbmNlLCAodm0pID0+IHtcbiAgbGV0IHsgc3RhY2sgfSA9IHZtO1xuICBsZXQgZGVmaW5pdGlvbiA9IHN0YWNrLnBvcDxDb21wb25lbnREZWZpbml0aW9uPigpO1xuXG4gIGxldCBjYXBhYmlsaXRpZXMsIG1hbmFnZXI7XG5cbiAgaWYgKGlzQ3VycmllZFZhbHVlKGRlZmluaXRpb24pKSB7XG4gICAgbWFuYWdlciA9IGNhcGFiaWxpdGllcyA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbWFuYWdlciA9IGRlZmluaXRpb24ubWFuYWdlcjtcbiAgICBjYXBhYmlsaXRpZXMgPSBkZWZpbml0aW9uLmNhcGFiaWxpdGllcztcbiAgfVxuXG4gIHN0YWNrLnB1c2goeyBkZWZpbml0aW9uLCBjYXBhYmlsaXRpZXMsIG1hbmFnZXIsIHN0YXRlOiBudWxsLCBoYW5kbGU6IG51bGwsIHRhYmxlOiBudWxsIH0pO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5QdXNoQXJncywgKHZtLCB7IG9wMTogX25hbWVzLCBvcDI6IF9ibG9ja05hbWVzLCBvcDM6IGZsYWdzIH0pID0+IHtcbiAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG4gIGxldCBuYW1lcyA9IHZtW0NPTlNUQU5UU10uZ2V0QXJyYXk8c3RyaW5nPihfbmFtZXMpO1xuXG4gIGxldCBwb3NpdGlvbmFsQ291bnQgPSBmbGFncyA+PiA0O1xuICBsZXQgYXROYW1lcyA9IGZsYWdzICYgMGIxMDAwO1xuICBsZXQgYmxvY2tOYW1lcyA9XG4gICAgZmxhZ3MgJiAwYjAxMTEgPyB2bVtDT05TVEFOVFNdLmdldEFycmF5PHN0cmluZz4oX2Jsb2NrTmFtZXMpIDogRU1QVFlfU1RSSU5HX0FSUkFZO1xuXG4gIHZtW0FSR1NdLnNldHVwKHN0YWNrLCBuYW1lcywgYmxvY2tOYW1lcywgcG9zaXRpb25hbENvdW50LCAhIWF0TmFtZXMpO1xuICBzdGFjay5wdXNoKHZtW0FSR1NdKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUHVzaEVtcHR5QXJncywgKHZtKSA9PiB7XG4gIGxldCB7IHN0YWNrIH0gPSB2bTtcblxuICBzdGFjay5wdXNoKHZtW0FSR1NdLmVtcHR5KHN0YWNrKSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkNhcHR1cmVBcmdzLCAodm0pID0+IHtcbiAgbGV0IHN0YWNrID0gdm0uc3RhY2s7XG5cbiAgbGV0IGFyZ3MgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tJbnN0YW5jZW9mKFZNQXJndW1lbnRzSW1wbCkpO1xuICBsZXQgY2FwdHVyZWRBcmdzID0gYXJncy5jYXB0dXJlKCk7XG4gIHN0YWNrLnB1c2goY2FwdHVyZWRBcmdzKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUHJlcGFyZUFyZ3MsICh2bSwgeyBvcDE6IF9zdGF0ZSB9KSA9PiB7XG4gIGxldCBzdGFjayA9IHZtLnN0YWNrO1xuICBsZXQgaW5zdGFuY2UgPSB2bS5mZXRjaFZhbHVlPENvbXBvbmVudEluc3RhbmNlPihfc3RhdGUpO1xuICBsZXQgYXJncyA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja0luc3RhbmNlb2YoVk1Bcmd1bWVudHNJbXBsKSk7XG5cbiAgbGV0IHsgZGVmaW5pdGlvbiB9ID0gaW5zdGFuY2U7XG5cbiAgaWYgKGlzQ3VycmllZFR5cGUoZGVmaW5pdGlvbiwgQ3VycmllZFR5cGUuQ29tcG9uZW50KSkge1xuICAgIGFzc2VydChcbiAgICAgICFkZWZpbml0aW9uLm1hbmFnZXIsXG4gICAgICBcIklmIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbiB3YXMgY3VycmllZCwgd2UgZG9uJ3QgeWV0IGhhdmUgYSBtYW5hZ2VyXCJcbiAgICApO1xuXG4gICAgbGV0IGNvbnN0YW50cyA9IHZtW0NPTlNUQU5UU107XG5cbiAgICBsZXQge1xuICAgICAgZGVmaW5pdGlvbjogcmVzb2x2ZWREZWZpbml0aW9uLFxuICAgICAgb3duZXIsXG4gICAgICByZXNvbHZlZCxcbiAgICAgIHBvc2l0aW9uYWwsXG4gICAgICBuYW1lZCxcbiAgICB9ID0gcmVzb2x2ZUN1cnJpZWRWYWx1ZShkZWZpbml0aW9uKTtcblxuICAgIGlmIChyZXNvbHZlZCA9PT0gdHJ1ZSkge1xuICAgICAgZGVmaW5pdGlvbiA9IHJlc29sdmVkRGVmaW5pdGlvbiBhcyBDb21wb25lbnREZWZpbml0aW9uO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlc29sdmVkRGVmaW5pdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCByZXNvbHZlZFZhbHVlID0gdm0ucnVudGltZS5yZXNvbHZlci5sb29rdXBDb21wb25lbnQocmVzb2x2ZWREZWZpbml0aW9uLCBvd25lcik7XG5cbiAgICAgIGRlZmluaXRpb24gPSBjb25zdGFudHMucmVzb2x2ZWRDb21wb25lbnQoXG4gICAgICAgIGV4cGVjdChyZXNvbHZlZFZhbHVlLCAnQlVHOiBleHBlY3RlZCByZXNvbHZlZCBjb21wb25lbnQnKSxcbiAgICAgICAgcmVzb2x2ZWREZWZpbml0aW9uXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZpbml0aW9uID0gY29uc3RhbnRzLmNvbXBvbmVudChyZXNvbHZlZERlZmluaXRpb24sIG93bmVyKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXJncy5uYW1lZC5tZXJnZShhc3NpZ24oe30sIC4uLm5hbWVkKSk7XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXJncy5yZWFsbG9jKHBvc2l0aW9uYWwubGVuZ3RoKTtcbiAgICAgIGFyZ3MucG9zaXRpb25hbC5wcmVwZW5kKHBvc2l0aW9uYWwpO1xuICAgIH1cblxuICAgIGxldCB7IG1hbmFnZXIgfSA9IGRlZmluaXRpb247XG5cbiAgICBhc3NlcnQoaW5zdGFuY2UubWFuYWdlciA9PT0gbnVsbCwgJ2NvbXBvbmVudCBpbnN0YW5jZSBtYW5hZ2VyIHNob3VsZCBub3QgYmUgcG9wdWxhdGVkIHlldCcpO1xuICAgIGFzc2VydChcbiAgICAgIGluc3RhbmNlLmNhcGFiaWxpdGllcyA9PT0gbnVsbCxcbiAgICAgICdjb21wb25lbnQgaW5zdGFuY2UgbWFuYWdlciBzaG91bGQgbm90IGJlIHBvcHVsYXRlZCB5ZXQnXG4gICAgKTtcblxuICAgIGluc3RhbmNlLmRlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuICAgIGluc3RhbmNlLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIGluc3RhbmNlLmNhcGFiaWxpdGllcyA9IGRlZmluaXRpb24uY2FwYWJpbGl0aWVzO1xuXG4gICAgLy8gU2F2ZSBvZmYgdGhlIG93bmVyIHRoYXQgdGhpcyBjb21wb25lbnQgd2FzIGN1cnJpZWQgd2l0aC4gTGF0ZXIgb24sXG4gICAgLy8gd2UnbGwgZmV0Y2ggdGhlIHZhbHVlIG9mIHRoaXMgcmVnaXN0ZXIgYW5kIHNldCBpdCBhcyB0aGUgb3duZXIgb24gdGhlXG4gICAgLy8gbmV3IHJvb3Qgc2NvcGUuXG4gICAgdm0ubG9hZFZhbHVlKCR0MSwgb3duZXIpO1xuICB9XG5cbiAgbGV0IHsgbWFuYWdlciwgc3RhdGUgfSA9IGRlZmluaXRpb247XG4gIGxldCBjYXBhYmlsaXRpZXMgPSBpbnN0YW5jZS5jYXBhYmlsaXRpZXM7XG5cbiAgaWYgKCFtYW5hZ2VySGFzQ2FwYWJpbGl0eShtYW5hZ2VyLCBjYXBhYmlsaXRpZXMsIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5QcmVwYXJlQXJncykpIHtcbiAgICBzdGFjay5wdXNoKGFyZ3MpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBibG9ja3MgPSBhcmdzLmJsb2Nrcy52YWx1ZXM7XG4gIGxldCBibG9ja05hbWVzID0gYXJncy5ibG9ja3MubmFtZXM7XG4gIGxldCBwcmVwYXJlZEFyZ3MgPSBtYW5hZ2VyLnByZXBhcmVBcmdzKHN0YXRlLCBhcmdzKTtcblxuICBpZiAocHJlcGFyZWRBcmdzKSB7XG4gICAgYXJncy5jbGVhcigpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0YWNrLnB1c2goYmxvY2tzW2ldKTtcbiAgICB9XG5cbiAgICBsZXQgeyBwb3NpdGlvbmFsLCBuYW1lZCB9ID0gcHJlcGFyZWRBcmdzO1xuXG4gICAgbGV0IHBvc2l0aW9uYWxDb3VudCA9IHBvc2l0aW9uYWwubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3NpdGlvbmFsQ291bnQ7IGkrKykge1xuICAgICAgc3RhY2sucHVzaChwb3NpdGlvbmFsW2ldKTtcbiAgICB9XG5cbiAgICBsZXQgbmFtZXMgPSBPYmplY3Qua2V5cyhuYW1lZCk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdGFjay5wdXNoKG5hbWVkW25hbWVzW2ldXSk7XG4gICAgfVxuXG4gICAgYXJncy5zZXR1cChzdGFjaywgbmFtZXMsIGJsb2NrTmFtZXMsIHBvc2l0aW9uYWxDb3VudCwgZmFsc2UpO1xuICB9XG5cbiAgc3RhY2sucHVzaChhcmdzKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuQ3JlYXRlQ29tcG9uZW50LCAodm0sIHsgb3AxOiBmbGFncywgb3AyOiBfc3RhdGUgfSkgPT4ge1xuICBsZXQgaW5zdGFuY2UgPSBjaGVjayh2bS5mZXRjaFZhbHVlKF9zdGF0ZSksIENoZWNrQ29tcG9uZW50SW5zdGFuY2UpO1xuICBsZXQgeyBkZWZpbml0aW9uLCBtYW5hZ2VyLCBjYXBhYmlsaXRpZXMgfSA9IGluc3RhbmNlO1xuXG4gIGlmICghbWFuYWdlckhhc0NhcGFiaWxpdHkobWFuYWdlciwgY2FwYWJpbGl0aWVzLCBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuQ3JlYXRlSW5zdGFuY2UpKSB7XG4gICAgLy8gVE9ETzogQ2xvc3VyZSBhbmQgTWFpbiBjb21wb25lbnRzIGFyZSBhbHdheXMgaW52b2tlZCBkeW5hbWljYWxseSwgc28gdGhpc1xuICAgIC8vIG9wY29kZSBtYXkgcnVuIGV2ZW4gaWYgdGhpcyBjYXBhYmlsaXR5IGlzIG5vdCBlbmFibGVkLiBJbiB0aGUgZnV0dXJlIHdlXG4gICAgLy8gc2hvdWxkIGhhbmRsZSB0aGlzIGluIGEgYmV0dGVyIHdheS5cbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgZHluYW1pY1Njb3BlOiBPcHRpb248RHluYW1pY1Njb3BlPiA9IG51bGw7XG4gIGlmIChtYW5hZ2VySGFzQ2FwYWJpbGl0eShtYW5hZ2VyLCBjYXBhYmlsaXRpZXMsIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5EeW5hbWljU2NvcGUpKSB7XG4gICAgZHluYW1pY1Njb3BlID0gdm0uZHluYW1pY1Njb3BlKCk7XG4gIH1cblxuICBsZXQgaGFzRGVmYXVsdEJsb2NrID0gZmxhZ3MgJiAxO1xuICBsZXQgYXJnczogT3B0aW9uPFZNQXJndW1lbnRzPiA9IG51bGw7XG5cbiAgaWYgKG1hbmFnZXJIYXNDYXBhYmlsaXR5KG1hbmFnZXIsIGNhcGFiaWxpdGllcywgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LkNyZWF0ZUFyZ3MpKSB7XG4gICAgYXJncyA9IGNoZWNrKHZtLnN0YWNrLnBlZWsoKSwgQ2hlY2tBcmd1bWVudHMpO1xuICB9XG5cbiAgbGV0IHNlbGY6IE9wdGlvbjxSZWZlcmVuY2U+ID0gbnVsbDtcbiAgaWYgKG1hbmFnZXJIYXNDYXBhYmlsaXR5KG1hbmFnZXIsIGNhcGFiaWxpdGllcywgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LkNyZWF0ZUNhbGxlcikpIHtcbiAgICBzZWxmID0gdm0uZ2V0U2VsZigpO1xuICB9XG5cbiAgbGV0IHN0YXRlID0gbWFuYWdlci5jcmVhdGUoXG4gICAgdm0uZ2V0T3duZXIoKSxcbiAgICBkZWZpbml0aW9uLnN0YXRlLFxuICAgIGFyZ3MsXG4gICAgdm0uZW52LFxuICAgIGR5bmFtaWNTY29wZSxcbiAgICBzZWxmLFxuICAgICEhaGFzRGVmYXVsdEJsb2NrXG4gICk7XG5cbiAgLy8gV2Ugd2FudCB0byByZXVzZSB0aGUgYHN0YXRlYCBQT0pPIGhlcmUsIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHRoZSBvcGNvZGVzXG4gIC8vIG9ubHkgdHJhbnNpdGlvbiBhdCBleGFjdGx5IG9uZSBwbGFjZS5cbiAgaW5zdGFuY2Uuc3RhdGUgPSBzdGF0ZTtcblxuICBpZiAobWFuYWdlckhhc0NhcGFiaWxpdHkobWFuYWdlciwgY2FwYWJpbGl0aWVzLCBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuVXBkYXRlSG9vaykpIHtcbiAgICB2bS51cGRhdGVXaXRoKG5ldyBVcGRhdGVDb21wb25lbnRPcGNvZGUoc3RhdGUsIG1hbmFnZXIsIGR5bmFtaWNTY29wZSkpO1xuICB9XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlJlZ2lzdGVyQ29tcG9uZW50RGVzdHJ1Y3RvciwgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IHsgbWFuYWdlciwgc3RhdGUsIGNhcGFiaWxpdGllcyB9ID0gY2hlY2sodm0uZmV0Y2hWYWx1ZShfc3RhdGUpLCBDaGVja0NvbXBvbmVudEluc3RhbmNlKTtcblxuICBsZXQgZCA9IG1hbmFnZXIuZ2V0RGVzdHJveWFibGUoc3RhdGUpO1xuXG4gIGlmIChcbiAgICBERUJVRyAmJlxuICAgICFtYW5hZ2VySGFzQ2FwYWJpbGl0eShtYW5hZ2VyLCBjYXBhYmlsaXRpZXMsIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5XaWxsRGVzdHJveSkgJiZcbiAgICBkICE9PSBudWxsICYmXG4gICAgdHlwZW9mICd3aWxsRGVzdHJveScgaW4gZFxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQlVHOiBEZXN0cnVjdG9yIGhhcyB3aWxsRGVzdHJveSwgYnV0IHRoZSB3aWxsRGVzdHJveSBjYXBhYmlsaXR5IHdhcyBub3QgZW5hYmxlZCBmb3IgdGhpcyBjb21wb25lbnQuIFByZS1kZXN0cnVjdGlvbiBob29rcyBtdXN0IGJlIGV4cGxpY2l0bHkgb3B0ZWQgaW50bydcbiAgICApO1xuICB9XG5cbiAgaWYgKGQpIHZtLmFzc29jaWF0ZURlc3Ryb3lhYmxlKGQpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5CZWdpbkNvbXBvbmVudFRyYW5zYWN0aW9uLCAodm0sIHsgb3AxOiBfc3RhdGUgfSkgPT4ge1xuICBsZXQgbmFtZTtcblxuICBpZiAoREVCVUcpIHtcbiAgICBsZXQgeyBkZWZpbml0aW9uLCBtYW5hZ2VyIH0gPSBjaGVjayh2bS5mZXRjaFZhbHVlKF9zdGF0ZSksIENoZWNrQ29tcG9uZW50SW5zdGFuY2UpO1xuXG4gICAgbmFtZSA9IGRlZmluaXRpb24ucmVzb2x2ZWROYW1lID8/IG1hbmFnZXIuZ2V0RGVidWdOYW1lKGRlZmluaXRpb24uc3RhdGUpO1xuICB9XG5cbiAgdm0uYmVnaW5DYWNoZUdyb3VwKG5hbWUpO1xuICB2bS5lbGVtZW50cygpLnB1c2hTaW1wbGVCbG9jaygpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5QdXRDb21wb25lbnRPcGVyYXRpb25zLCAodm0pID0+IHtcbiAgdm0ubG9hZFZhbHVlKCR0MCwgbmV3IENvbXBvbmVudEVsZW1lbnRPcGVyYXRpb25zKCkpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Db21wb25lbnRBdHRyLCAodm0sIHsgb3AxOiBfbmFtZSwgb3AyOiBfdHJ1c3RpbmcsIG9wMzogX25hbWVzcGFjZSB9KSA9PiB7XG4gIGxldCBuYW1lID0gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxzdHJpbmc+KF9uYW1lKTtcbiAgbGV0IHRydXN0aW5nID0gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxib29sZWFuPihfdHJ1c3RpbmcpO1xuICBsZXQgcmVmZXJlbmNlID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcbiAgbGV0IG5hbWVzcGFjZSA9IF9uYW1lc3BhY2UgPyB2bVtDT05TVEFOVFNdLmdldFZhbHVlPHN0cmluZz4oX25hbWVzcGFjZSkgOiBudWxsO1xuXG4gIGNoZWNrKHZtLmZldGNoVmFsdWUoJHQwKSwgQ2hlY2tJbnN0YW5jZW9mKENvbXBvbmVudEVsZW1lbnRPcGVyYXRpb25zKSkuc2V0QXR0cmlidXRlKFxuICAgIG5hbWUsXG4gICAgcmVmZXJlbmNlLFxuICAgIHRydXN0aW5nLFxuICAgIG5hbWVzcGFjZVxuICApO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5TdGF0aWNDb21wb25lbnRBdHRyLCAodm0sIHsgb3AxOiBfbmFtZSwgb3AyOiBfdmFsdWUsIG9wMzogX25hbWVzcGFjZSB9KSA9PiB7XG4gIGxldCBuYW1lID0gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxzdHJpbmc+KF9uYW1lKTtcbiAgbGV0IHZhbHVlID0gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxzdHJpbmc+KF92YWx1ZSk7XG4gIGxldCBuYW1lc3BhY2UgPSBfbmFtZXNwYWNlID8gdm1bQ09OU1RBTlRTXS5nZXRWYWx1ZTxzdHJpbmc+KF9uYW1lc3BhY2UpIDogbnVsbDtcblxuICBjaGVjayh2bS5mZXRjaFZhbHVlKCR0MCksIENoZWNrSW5zdGFuY2VvZihDb21wb25lbnRFbGVtZW50T3BlcmF0aW9ucykpLnNldFN0YXRpY0F0dHJpYnV0ZShcbiAgICBuYW1lLFxuICAgIHZhbHVlLFxuICAgIG5hbWVzcGFjZVxuICApO1xufSk7XG5cbnR5cGUgRGVmZXJyZWRBdHRyaWJ1dGUgPSB7XG4gIHZhbHVlOiBzdHJpbmcgfCBSZWZlcmVuY2U8dW5rbm93bj47XG4gIG5hbWVzcGFjZTogT3B0aW9uPHN0cmluZz47XG4gIHRydXN0aW5nPzogYm9vbGVhbjtcbn07XG5cbmV4cG9ydCBjbGFzcyBDb21wb25lbnRFbGVtZW50T3BlcmF0aW9ucyBpbXBsZW1lbnRzIEVsZW1lbnRPcGVyYXRpb25zIHtcbiAgcHJpdmF0ZSBhdHRyaWJ1dGVzID0gZGljdDxEZWZlcnJlZEF0dHJpYnV0ZT4oKTtcbiAgcHJpdmF0ZSBjbGFzc2VzOiAoc3RyaW5nIHwgUmVmZXJlbmNlPHVua25vd24+KVtdID0gW107XG4gIHByaXZhdGUgbW9kaWZpZXJzOiBNb2RpZmllckluc3RhbmNlW10gPSBbXTtcblxuICBzZXRBdHRyaWJ1dGUoXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHZhbHVlOiBSZWZlcmVuY2U8dW5rbm93bj4sXG4gICAgdHJ1c3Rpbmc6IGJvb2xlYW4sXG4gICAgbmFtZXNwYWNlOiBPcHRpb248c3RyaW5nPlxuICApIHtcbiAgICBsZXQgZGVmZXJyZWQgPSB7IHZhbHVlLCBuYW1lc3BhY2UsIHRydXN0aW5nIH07XG5cbiAgICBpZiAobmFtZSA9PT0gJ2NsYXNzJykge1xuICAgICAgdGhpcy5jbGFzc2VzLnB1c2godmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMuYXR0cmlidXRlc1tuYW1lXSA9IGRlZmVycmVkO1xuICB9XG5cbiAgc2V0U3RhdGljQXR0cmlidXRlKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgbmFtZXNwYWNlOiBPcHRpb248c3RyaW5nPik6IHZvaWQge1xuICAgIGxldCBkZWZlcnJlZCA9IHsgdmFsdWUsIG5hbWVzcGFjZSB9O1xuXG4gICAgaWYgKG5hbWUgPT09ICdjbGFzcycpIHtcbiAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSBkZWZlcnJlZDtcbiAgfVxuXG4gIGFkZE1vZGlmaWVyKG1vZGlmaWVyOiBNb2RpZmllckluc3RhbmNlKTogdm9pZCB7XG4gICAgdGhpcy5tb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBmbHVzaCh2bTogSW50ZXJuYWxWTSk6IE1vZGlmaWVySW5zdGFuY2VbXSB7XG4gICAgbGV0IHR5cGU6IERlZmVycmVkQXR0cmlidXRlIHwgdW5kZWZpbmVkO1xuICAgIGxldCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmIChuYW1lID09PSAndHlwZScpIHtcbiAgICAgICAgdHlwZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgYXR0ciA9IHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgIGlmIChuYW1lID09PSAnY2xhc3MnKSB7XG4gICAgICAgIHNldERlZmVycmVkQXR0cih2bSwgJ2NsYXNzJywgbWVyZ2VDbGFzc2VzKHRoaXMuY2xhc3NlcyksIGF0dHIubmFtZXNwYWNlLCBhdHRyLnRydXN0aW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldERlZmVycmVkQXR0cih2bSwgbmFtZSwgYXR0ci52YWx1ZSwgYXR0ci5uYW1lc3BhY2UsIGF0dHIudHJ1c3RpbmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNldERlZmVycmVkQXR0cih2bSwgJ3R5cGUnLCB0eXBlLnZhbHVlLCB0eXBlLm5hbWVzcGFjZSwgdHlwZS50cnVzdGluZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubW9kaWZpZXJzO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NlcyhjbGFzc2VzOiAoc3RyaW5nIHwgUmVmZXJlbmNlKVtdKTogc3RyaW5nIHwgUmVmZXJlbmNlPHVua25vd24+IHtcbiAgaWYgKGNsYXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmIChjbGFzc2VzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBjbGFzc2VzWzBdO1xuICB9XG4gIGlmIChhbGxTdHJpbmdDbGFzc2VzKGNsYXNzZXMpKSB7XG4gICAgcmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUNsYXNzTGlzdFJlZihjbGFzc2VzIGFzIFJlZmVyZW5jZVtdKTtcbn1cblxuZnVuY3Rpb24gYWxsU3RyaW5nQ2xhc3NlcyhjbGFzc2VzOiAoc3RyaW5nIHwgUmVmZXJlbmNlPHVua25vd24+KVtdKTogY2xhc3NlcyBpcyBzdHJpbmdbXSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0eXBlb2YgY2xhc3Nlc1tpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNldERlZmVycmVkQXR0cihcbiAgdm06IEludGVybmFsVk0sXG4gIG5hbWU6IHN0cmluZyxcbiAgdmFsdWU6IHN0cmluZyB8IFJlZmVyZW5jZTx1bmtub3duPixcbiAgbmFtZXNwYWNlOiBPcHRpb248c3RyaW5nPixcbiAgdHJ1c3RpbmcgPSBmYWxzZVxuKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdm0uZWxlbWVudHMoKS5zZXRTdGF0aWNBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIG5hbWVzcGFjZSk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGF0dHJpYnV0ZSA9IHZtXG4gICAgICAuZWxlbWVudHMoKVxuICAgICAgLnNldER5bmFtaWNBdHRyaWJ1dGUobmFtZSwgdmFsdWVGb3JSZWYodmFsdWUpLCB0cnVzdGluZywgbmFtZXNwYWNlKTtcbiAgICBpZiAoIWlzQ29uc3RSZWYodmFsdWUpKSB7XG4gICAgICB2bS51cGRhdGVXaXRoKG5ldyBVcGRhdGVEeW5hbWljQXR0cmlidXRlT3Bjb2RlKHZhbHVlLCBhdHRyaWJ1dGUsIHZtLmVudikpO1xuICAgIH1cbiAgfVxufVxuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRGlkQ3JlYXRlRWxlbWVudCwgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IHsgZGVmaW5pdGlvbiwgc3RhdGUgfSA9IGNoZWNrKHZtLmZldGNoVmFsdWUoX3N0YXRlKSwgQ2hlY2tDb21wb25lbnRJbnN0YW5jZSk7XG4gIGxldCB7IG1hbmFnZXIgfSA9IGRlZmluaXRpb247XG5cbiAgbGV0IG9wZXJhdGlvbnMgPSBjaGVjayh2bS5mZXRjaFZhbHVlKCR0MCksIENoZWNrSW5zdGFuY2VvZihDb21wb25lbnRFbGVtZW50T3BlcmF0aW9ucykpO1xuXG4gIChtYW5hZ2VyIGFzIFdpdGhFbGVtZW50SG9vazx1bmtub3duPikuZGlkQ3JlYXRlRWxlbWVudChcbiAgICBzdGF0ZSxcbiAgICBleHBlY3Qodm0uZWxlbWVudHMoKS5jb25zdHJ1Y3RpbmcsIGBFeHBlY3RlZCBhIGNvbnN0cnVjdGluZyBlbGVtZW50IGluIERpZENyZWF0ZU9wY29kZWApLFxuICAgIG9wZXJhdGlvbnNcbiAgKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuR2V0Q29tcG9uZW50U2VsZiwgKHZtLCB7IG9wMTogX3N0YXRlLCBvcDI6IF9uYW1lcyB9KSA9PiB7XG4gIGxldCBpbnN0YW5jZSA9IGNoZWNrKHZtLmZldGNoVmFsdWUoX3N0YXRlKSwgQ2hlY2tDb21wb25lbnRJbnN0YW5jZSk7XG4gIGxldCB7IGRlZmluaXRpb24sIHN0YXRlIH0gPSBpbnN0YW5jZTtcbiAgbGV0IHsgbWFuYWdlciB9ID0gZGVmaW5pdGlvbjtcbiAgbGV0IHNlbGZSZWYgPSBtYW5hZ2VyLmdldFNlbGYoc3RhdGUpO1xuXG4gIGlmICh2bS5lbnYuZGVidWdSZW5kZXJUcmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgaW5zdGFuY2UgPSBjaGVjayh2bS5mZXRjaFZhbHVlKF9zdGF0ZSksIENoZWNrQ29tcG9uZW50SW5zdGFuY2UpO1xuICAgIGxldCB7IGRlZmluaXRpb24sIG1hbmFnZXIgfSA9IGluc3RhbmNlO1xuXG4gICAgbGV0IGFyZ3M6IENhcHR1cmVkQXJndW1lbnRzO1xuXG4gICAgaWYgKHZtLnN0YWNrLnBlZWsoKSA9PT0gdm1bQVJHU10pIHtcbiAgICAgIGFyZ3MgPSB2bVtBUkdTXS5jYXB0dXJlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBuYW1lcyA9IHZtW0NPTlNUQU5UU10uZ2V0QXJyYXk8c3RyaW5nPihfbmFtZXMpO1xuICAgICAgdm1bQVJHU10uc2V0dXAodm0uc3RhY2ssIG5hbWVzLCBbXSwgMCwgdHJ1ZSk7XG4gICAgICBhcmdzID0gdm1bQVJHU10uY2FwdHVyZSgpO1xuICAgIH1cblxuICAgIGxldCBtb2R1bGVOYW1lOiBzdHJpbmc7XG4gICAgbGV0IGNvbXBpbGFibGU6IENvbXBpbGFibGVQcm9ncmFtIHwgbnVsbCA9IGRlZmluaXRpb24uY29tcGlsYWJsZTtcblxuICAgIGlmIChjb21waWxhYmxlID09PSBudWxsKSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgIG1hbmFnZXJIYXNDYXBhYmlsaXR5KFxuICAgICAgICAgIG1hbmFnZXIsXG4gICAgICAgICAgaW5zdGFuY2UuY2FwYWJpbGl0aWVzLFxuICAgICAgICAgIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5EeW5hbWljTGF5b3V0XG4gICAgICAgICksXG4gICAgICAgICdCVUc6IE5vIHRlbXBsYXRlIHdhcyBmb3VuZCBmb3IgdGhpcyBjb21wb25lbnQsIGFuZCB0aGUgY29tcG9uZW50IGRpZCBub3QgaGF2ZSB0aGUgZHluYW1pYyBsYXlvdXQgY2FwYWJpbGl0eSdcbiAgICAgICk7XG5cbiAgICAgIGNvbXBpbGFibGUgPSBtYW5hZ2VyLmdldER5bmFtaWNMYXlvdXQoc3RhdGUsIHZtLnJ1bnRpbWUucmVzb2x2ZXIpO1xuXG4gICAgICBpZiAoY29tcGlsYWJsZSAhPT0gbnVsbCkge1xuICAgICAgICBtb2R1bGVOYW1lID0gY29tcGlsYWJsZS5tb2R1bGVOYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kdWxlTmFtZSA9ICdfX2RlZmF1bHRfXy5oYnMnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2R1bGVOYW1lID0gY29tcGlsYWJsZS5tb2R1bGVOYW1lO1xuICAgIH1cblxuICAgIC8vIEZvciB0ZWFyaW5nIGRvd24gdGhlIGRlYnVnUmVuZGVyVHJlZVxuICAgIHZtLmFzc29jaWF0ZURlc3Ryb3lhYmxlKGluc3RhbmNlKTtcblxuICAgIGlmIChoYXNDdXN0b21EZWJ1Z1JlbmRlclRyZWVMaWZlY3ljbGUobWFuYWdlcikpIHtcbiAgICAgIGxldCBub2RlcyA9IG1hbmFnZXIuZ2V0RGVidWdDdXN0b21SZW5kZXJUcmVlKFxuICAgICAgICBpbnN0YW5jZS5kZWZpbml0aW9uLnN0YXRlLFxuICAgICAgICBpbnN0YW5jZS5zdGF0ZSxcbiAgICAgICAgYXJncyxcbiAgICAgICAgbW9kdWxlTmFtZVxuICAgICAgKTtcblxuICAgICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBsZXQgeyBidWNrZXQgfSA9IG5vZGU7XG4gICAgICAgIHZtLmVudi5kZWJ1Z1JlbmRlclRyZWUhLmNyZWF0ZShidWNrZXQsIG5vZGUpO1xuXG4gICAgICAgIHJlZ2lzdGVyRGVzdHJ1Y3RvcihpbnN0YW5jZSwgKCkgPT4ge1xuICAgICAgICAgIHZtLmVudi5kZWJ1Z1JlbmRlclRyZWU/LndpbGxEZXN0cm95KGJ1Y2tldCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZtLnVwZGF0ZVdpdGgobmV3IERlYnVnUmVuZGVyVHJlZVVwZGF0ZU9wY29kZShidWNrZXQpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbmFtZSA9IGRlZmluaXRpb24ucmVzb2x2ZWROYW1lID8/IG1hbmFnZXIuZ2V0RGVidWdOYW1lKGRlZmluaXRpb24uc3RhdGUpO1xuXG4gICAgICB2bS5lbnYuZGVidWdSZW5kZXJUcmVlLmNyZWF0ZShpbnN0YW5jZSwge1xuICAgICAgICB0eXBlOiAnY29tcG9uZW50JyxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgYXJncyxcbiAgICAgICAgdGVtcGxhdGU6IG1vZHVsZU5hbWUsXG4gICAgICAgIGluc3RhbmNlOiB2YWx1ZUZvclJlZihzZWxmUmVmKSxcbiAgICAgIH0pO1xuXG4gICAgICB2bS5hc3NvY2lhdGVEZXN0cm95YWJsZShpbnN0YW5jZSk7XG5cbiAgICAgIHJlZ2lzdGVyRGVzdHJ1Y3RvcihpbnN0YW5jZSwgKCkgPT4ge1xuICAgICAgICB2bS5lbnYuZGVidWdSZW5kZXJUcmVlPy53aWxsRGVzdHJveShpbnN0YW5jZSk7XG4gICAgICB9KTtcblxuICAgICAgdm0udXBkYXRlV2l0aChuZXcgRGVidWdSZW5kZXJUcmVlVXBkYXRlT3Bjb2RlKGluc3RhbmNlKSk7XG4gICAgfVxuICB9XG5cbiAgdm0uc3RhY2sucHVzaChzZWxmUmVmKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuR2V0Q29tcG9uZW50VGFnTmFtZSwgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IHsgZGVmaW5pdGlvbiwgc3RhdGUgfSA9IGNoZWNrKHZtLmZldGNoVmFsdWUoX3N0YXRlKSwgQ2hlY2tDb21wb25lbnRJbnN0YW5jZSk7XG4gIGxldCB7IG1hbmFnZXIgfSA9IGRlZmluaXRpb247XG5cbiAgbGV0IHRhZ05hbWUgPSAobWFuYWdlciBhcyBSZWNhc3Q8XG4gICAgSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyLFxuICAgIFdpdGhEeW5hbWljVGFnTmFtZTx1bmtub3duPlxuICA+KS5nZXRUYWdOYW1lKHN0YXRlKTtcblxuICAvLyBVc2VyIHByb3ZpZGVkIHZhbHVlIGZyb20gSlMsIHNvIHdlIGRvbid0IGJvdGhlciB0byBlbmNvZGVcbiAgdm0uc3RhY2sucHVzaCh0YWdOYW1lKTtcbn0pO1xuXG4vLyBEeW5hbWljIEludm9jYXRpb24gT25seVxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkdldENvbXBvbmVudExheW91dCwgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IGluc3RhbmNlID0gY2hlY2sodm0uZmV0Y2hWYWx1ZShfc3RhdGUpLCBDaGVja0NvbXBvbmVudEluc3RhbmNlKTtcblxuICBsZXQgeyBtYW5hZ2VyLCBkZWZpbml0aW9uIH0gPSBpbnN0YW5jZTtcbiAgbGV0IHsgc3RhY2sgfSA9IHZtO1xuXG4gIGxldCB7IGNvbXBpbGFibGUgfSA9IGRlZmluaXRpb247XG5cbiAgaWYgKGNvbXBpbGFibGUgPT09IG51bGwpIHtcbiAgICBsZXQgeyBjYXBhYmlsaXRpZXMgfSA9IGluc3RhbmNlO1xuXG4gICAgYXNzZXJ0KFxuICAgICAgbWFuYWdlckhhc0NhcGFiaWxpdHkobWFuYWdlciwgY2FwYWJpbGl0aWVzLCBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuRHluYW1pY0xheW91dCksXG4gICAgICAnQlVHOiBObyB0ZW1wbGF0ZSB3YXMgZm91bmQgZm9yIHRoaXMgY29tcG9uZW50LCBhbmQgdGhlIGNvbXBvbmVudCBkaWQgbm90IGhhdmUgdGhlIGR5bmFtaWMgbGF5b3V0IGNhcGFiaWxpdHknXG4gICAgKTtcblxuICAgIGNvbXBpbGFibGUgPSBtYW5hZ2VyLmdldER5bmFtaWNMYXlvdXQoaW5zdGFuY2Uuc3RhdGUsIHZtLnJ1bnRpbWUucmVzb2x2ZXIpO1xuXG4gICAgaWYgKGNvbXBpbGFibGUgPT09IG51bGwpIHtcbiAgICAgIGlmIChtYW5hZ2VySGFzQ2FwYWJpbGl0eShtYW5hZ2VyLCBjYXBhYmlsaXRpZXMsIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5XcmFwcGVkKSkge1xuICAgICAgICBjb21waWxhYmxlID0gdW53cmFwVGVtcGxhdGUodm1bQ09OU1RBTlRTXS5kZWZhdWx0VGVtcGxhdGUpLmFzV3JhcHBlZExheW91dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGlsYWJsZSA9IHVud3JhcFRlbXBsYXRlKHZtW0NPTlNUQU5UU10uZGVmYXVsdFRlbXBsYXRlKS5hc0xheW91dCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBoYW5kbGUgPSBjb21waWxhYmxlLmNvbXBpbGUodm0uY29udGV4dCk7XG5cbiAgc3RhY2sucHVzaChjb21waWxhYmxlLnN5bWJvbFRhYmxlKTtcbiAgc3RhY2sucHVzaChoYW5kbGUpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5NYWluLCAodm0sIHsgb3AxOiByZWdpc3RlciB9KSA9PiB7XG4gIGxldCBkZWZpbml0aW9uID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrQ29tcG9uZW50RGVmaW5pdGlvbik7XG4gIGxldCBpbnZvY2F0aW9uID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrSW52b2NhdGlvbik7XG5cbiAgbGV0IHsgbWFuYWdlciwgY2FwYWJpbGl0aWVzIH0gPSBkZWZpbml0aW9uO1xuXG4gIGxldCBzdGF0ZTogUG9wdWxhdGVkQ29tcG9uZW50SW5zdGFuY2UgPSB7XG4gICAgZGVmaW5pdGlvbixcbiAgICBtYW5hZ2VyLFxuICAgIGNhcGFiaWxpdGllcyxcbiAgICBzdGF0ZTogbnVsbCxcbiAgICBoYW5kbGU6IGludm9jYXRpb24uaGFuZGxlLFxuICAgIHRhYmxlOiBpbnZvY2F0aW9uLnN5bWJvbFRhYmxlLFxuICAgIGxvb2t1cDogbnVsbCxcbiAgfTtcblxuICB2bS5sb2FkVmFsdWUocmVnaXN0ZXIsIHN0YXRlKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuUG9wdWxhdGVMYXlvdXQsICh2bSwgeyBvcDE6IF9zdGF0ZSB9KSA9PiB7XG4gIGxldCB7IHN0YWNrIH0gPSB2bTtcblxuICAvLyBJbiBERUJVRyBoYW5kbGVzIGNvdWxkIGJlIEVyckhhbmRsZSBvYmplY3RzXG4gIGxldCBoYW5kbGUgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tIYW5kbGUpO1xuICBsZXQgdGFibGUgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tQcm9ncmFtU3ltYm9sVGFibGUpO1xuXG4gIGxldCBzdGF0ZSA9IGNoZWNrKHZtLmZldGNoVmFsdWUoX3N0YXRlKSwgQ2hlY2tDb21wb25lbnRJbnN0YW5jZSk7XG5cbiAgc3RhdGUuaGFuZGxlID0gaGFuZGxlO1xuICBzdGF0ZS50YWJsZSA9IHRhYmxlO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5WaXJ0dWFsUm9vdFNjb3BlLCAodm0sIHsgb3AxOiBfc3RhdGUgfSkgPT4ge1xuICBsZXQgeyB0YWJsZSwgbWFuYWdlciwgY2FwYWJpbGl0aWVzLCBzdGF0ZSB9ID0gY2hlY2soXG4gICAgdm0uZmV0Y2hWYWx1ZShfc3RhdGUpLFxuICAgIENoZWNrRmluaXNoZWRDb21wb25lbnRJbnN0YW5jZVxuICApO1xuXG4gIGxldCBvd25lcjtcblxuICBpZiAobWFuYWdlckhhc0NhcGFiaWxpdHkobWFuYWdlciwgY2FwYWJpbGl0aWVzLCBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuSGFzU3ViT3duZXIpKSB7XG4gICAgb3duZXIgPSBtYW5hZ2VyLmdldE93bmVyKHN0YXRlKTtcbiAgICB2bS5sb2FkVmFsdWUoJHQxLCBudWxsKTsgLy8gQ2xlYXIgdGhlIHRlbXAgcmVnaXN0ZXJcbiAgfSBlbHNlIHtcbiAgICAvLyBDaGVjayB0aGUgdGVtcCByZWdpc3RlciB0byBzZWUgaWYgYW4gb3duZXIgd2FzIHJlc29sdmVkIGZyb20gY3VycnlpbmdcbiAgICBvd25lciA9IHZtLmZldGNoVmFsdWU8T3duZXIgfCBudWxsPigkdDEpO1xuXG4gICAgaWYgKG93bmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiBhbiBvd25lciB3YXNuJ3QgZm91bmQsIGRlZmF1bHQgdG8gdXNpbmcgdGhlIGN1cnJlbnQgb3duZXIuIFRoaXNcbiAgICAgIC8vIHdpbGwgaGFwcGVuIGZvciBub3JtYWwgZHluYW1pYyBjb21wb25lbnQgaW52b2NhdGlvbixcbiAgICAgIC8vIGUuZy4gPFNvbWVDbGFzc2ljRW1iZXJDb21wb25lbnQvPlxuICAgICAgb3duZXIgPSB2bS5nZXRPd25lcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbHNlIHRoZSBvd25lciB3YXMgZm91bmQsIHNvIGNsZWFyIHRoZSB0ZW1wIHJlZ2lzdGVyLiBUaGlzIHdpbGwgaGFwcGVuXG4gICAgICAvLyBpZiB3ZSBhcmUgbG9hZGluZyBhIGN1cnJpZWQgY29tcG9uZW50LCBlLmcuIDxAc29tZUN1cnJpZWRDb21wb25lbnQvPlxuICAgICAgdm0ubG9hZFZhbHVlKCR0MSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgdm0ucHVzaFJvb3RTY29wZSh0YWJsZS5zeW1ib2xzLmxlbmd0aCArIDEsIG93bmVyKTtcbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuU2V0dXBGb3JFdmFsLCAodm0sIHsgb3AxOiBfc3RhdGUgfSkgPT4ge1xuICBsZXQgc3RhdGUgPSBjaGVjayh2bS5mZXRjaFZhbHVlKF9zdGF0ZSksIENoZWNrRmluaXNoZWRDb21wb25lbnRJbnN0YW5jZSk7XG5cbiAgaWYgKHN0YXRlLnRhYmxlLmhhc0V2YWwpIHtcbiAgICBsZXQgbG9va3VwID0gKHN0YXRlLmxvb2t1cCA9IGRpY3Q8U2NvcGVTbG90PigpKTtcbiAgICB2bS5zY29wZSgpLmJpbmRFdmFsU2NvcGUobG9va3VwKTtcbiAgfVxufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5TZXROYW1lZFZhcmlhYmxlcywgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IHN0YXRlID0gY2hlY2sodm0uZmV0Y2hWYWx1ZShfc3RhdGUpLCBDaGVja0ZpbmlzaGVkQ29tcG9uZW50SW5zdGFuY2UpO1xuICBsZXQgc2NvcGUgPSB2bS5zY29wZSgpO1xuXG4gIGxldCBhcmdzID0gY2hlY2sodm0uc3RhY2sucGVlaygpLCBDaGVja0FyZ3VtZW50cyk7XG4gIGxldCBjYWxsZXJOYW1lcyA9IGFyZ3MubmFtZWQuYXROYW1lcztcblxuICBmb3IgKGxldCBpID0gY2FsbGVyTmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgYXROYW1lID0gY2FsbGVyTmFtZXNbaV07XG4gICAgbGV0IHN5bWJvbCA9IHN0YXRlLnRhYmxlLnN5bWJvbHMuaW5kZXhPZihjYWxsZXJOYW1lc1tpXSk7XG4gICAgbGV0IHZhbHVlID0gYXJncy5uYW1lZC5nZXQoYXROYW1lLCB0cnVlKTtcblxuICAgIGlmIChzeW1ib2wgIT09IC0xKSBzY29wZS5iaW5kU3ltYm9sKHN5bWJvbCArIDEsIHZhbHVlKTtcbiAgICBpZiAoc3RhdGUubG9va3VwKSBzdGF0ZS5sb29rdXBbYXROYW1lXSA9IHZhbHVlO1xuICB9XG59KTtcblxuZnVuY3Rpb24gYmluZEJsb2NrKFxuICBzeW1ib2xOYW1lOiBzdHJpbmcsXG4gIGJsb2NrTmFtZTogc3RyaW5nLFxuICBzdGF0ZTogQ29tcG9uZW50SW5zdGFuY2UsXG4gIGJsb2NrczogQmxvY2tBcmd1bWVudHNJbXBsLFxuICB2bTogSW50ZXJuYWxWTVxuKSB7XG4gIGxldCBzeW1ib2wgPSBzdGF0ZS50YWJsZS5zeW1ib2xzLmluZGV4T2Yoc3ltYm9sTmFtZSk7XG4gIGxldCBibG9jayA9IGJsb2Nrcy5nZXQoYmxvY2tOYW1lKTtcblxuICBpZiAoc3ltYm9sICE9PSAtMSkgdm0uc2NvcGUoKS5iaW5kQmxvY2soc3ltYm9sICsgMSwgYmxvY2spO1xuICBpZiAoc3RhdGUubG9va3VwKSBzdGF0ZS5sb29rdXBbc3ltYm9sTmFtZV0gPSBibG9jaztcbn1cblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLlNldEJsb2NrcywgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IHN0YXRlID0gY2hlY2sodm0uZmV0Y2hWYWx1ZShfc3RhdGUpLCBDaGVja0ZpbmlzaGVkQ29tcG9uZW50SW5zdGFuY2UpO1xuICBsZXQgeyBibG9ja3MgfSA9IGNoZWNrKHZtLnN0YWNrLnBlZWsoKSwgQ2hlY2tBcmd1bWVudHMpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tzLm5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgYmluZEJsb2NrKGJsb2Nrcy5zeW1ib2xOYW1lc1tpXSwgYmxvY2tzLm5hbWVzW2ldLCBzdGF0ZSwgYmxvY2tzLCB2bSk7XG4gIH1cbn0pO1xuXG4vLyBEeW5hbWljIEludm9jYXRpb24gT25seVxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkludm9rZUNvbXBvbmVudExheW91dCwgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IHN0YXRlID0gY2hlY2sodm0uZmV0Y2hWYWx1ZShfc3RhdGUpLCBDaGVja0ZpbmlzaGVkQ29tcG9uZW50SW5zdGFuY2UpO1xuXG4gIHZtLmNhbGwoc3RhdGUuaGFuZGxlISk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkRpZFJlbmRlckxheW91dCwgKHZtLCB7IG9wMTogX3N0YXRlIH0pID0+IHtcbiAgbGV0IGluc3RhbmNlID0gY2hlY2sodm0uZmV0Y2hWYWx1ZShfc3RhdGUpLCBDaGVja0NvbXBvbmVudEluc3RhbmNlKTtcbiAgbGV0IHsgbWFuYWdlciwgc3RhdGUsIGNhcGFiaWxpdGllcyB9ID0gaW5zdGFuY2U7XG4gIGxldCBib3VuZHMgPSB2bS5lbGVtZW50cygpLnBvcEJsb2NrKCk7XG5cbiAgaWYgKHZtLmVudi5kZWJ1Z1JlbmRlclRyZWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChoYXNDdXN0b21EZWJ1Z1JlbmRlclRyZWVMaWZlY3ljbGUobWFuYWdlcikpIHtcbiAgICAgIGxldCBub2RlcyA9IG1hbmFnZXIuZ2V0RGVidWdDdXN0b21SZW5kZXJUcmVlKGluc3RhbmNlLmRlZmluaXRpb24uc3RhdGUsIHN0YXRlLCBFTVBUWV9BUkdTKTtcblxuICAgICAgbm9kZXMucmV2ZXJzZSgpLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgbGV0IHsgYnVja2V0IH0gPSBub2RlO1xuXG4gICAgICAgIHZtLmVudi5kZWJ1Z1JlbmRlclRyZWUhLmRpZFJlbmRlcihidWNrZXQsIGJvdW5kcyk7XG5cbiAgICAgICAgdm0udXBkYXRlV2l0aChuZXcgRGVidWdSZW5kZXJUcmVlRGlkUmVuZGVyT3Bjb2RlKGJ1Y2tldCwgYm91bmRzKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uZW52LmRlYnVnUmVuZGVyVHJlZS5kaWRSZW5kZXIoaW5zdGFuY2UsIGJvdW5kcyk7XG5cbiAgICAgIHZtLnVwZGF0ZVdpdGgobmV3IERlYnVnUmVuZGVyVHJlZURpZFJlbmRlck9wY29kZShpbnN0YW5jZSwgYm91bmRzKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hbmFnZXJIYXNDYXBhYmlsaXR5KG1hbmFnZXIsIGNhcGFiaWxpdGllcywgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LkNyZWF0ZUluc3RhbmNlKSkge1xuICAgIGxldCBtZ3IgPSBjaGVjayhtYW5hZ2VyLCBDaGVja0ludGVyZmFjZSh7IGRpZFJlbmRlckxheW91dDogQ2hlY2tGdW5jdGlvbiB9KSk7XG4gICAgbWdyLmRpZFJlbmRlckxheW91dChzdGF0ZSwgYm91bmRzKTtcblxuICAgIHZtLmVudi5kaWRDcmVhdGUoaW5zdGFuY2UgYXMgQ29tcG9uZW50SW5zdGFuY2VXaXRoQ3JlYXRlKTtcbiAgICB2bS51cGRhdGVXaXRoKG5ldyBEaWRVcGRhdGVMYXlvdXRPcGNvZGUoaW5zdGFuY2UgYXMgQ29tcG9uZW50SW5zdGFuY2VXaXRoQ3JlYXRlLCBib3VuZHMpKTtcbiAgfVxufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5Db21taXRDb21wb25lbnRUcmFuc2FjdGlvbiwgKHZtKSA9PiB7XG4gIHZtLmNvbW1pdENhY2hlR3JvdXAoKTtcbn0pO1xuXG5leHBvcnQgY2xhc3MgVXBkYXRlQ29tcG9uZW50T3Bjb2RlIGltcGxlbWVudHMgVXBkYXRpbmdPcGNvZGUge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNvbXBvbmVudDogQ29tcG9uZW50SW5zdGFuY2VTdGF0ZSxcbiAgICBwcml2YXRlIG1hbmFnZXI6IFdpdGhVcGRhdGVIb29rLFxuICAgIHByaXZhdGUgZHluYW1pY1Njb3BlOiBPcHRpb248RHluYW1pY1Njb3BlPlxuICApIHt9XG5cbiAgZXZhbHVhdGUoX3ZtOiBVcGRhdGluZ1ZNKSB7XG4gICAgbGV0IHsgY29tcG9uZW50LCBtYW5hZ2VyLCBkeW5hbWljU2NvcGUgfSA9IHRoaXM7XG5cbiAgICBtYW5hZ2VyLnVwZGF0ZShjb21wb25lbnQsIGR5bmFtaWNTY29wZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIERpZFVwZGF0ZUxheW91dE9wY29kZSBpbXBsZW1lbnRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb21wb25lbnQ6IENvbXBvbmVudEluc3RhbmNlV2l0aENyZWF0ZSwgcHJpdmF0ZSBib3VuZHM6IEJvdW5kcykge31cblxuICBldmFsdWF0ZSh2bTogVXBkYXRpbmdWTSkge1xuICAgIGxldCB7IGNvbXBvbmVudCwgYm91bmRzIH0gPSB0aGlzO1xuICAgIGxldCB7IG1hbmFnZXIsIHN0YXRlIH0gPSBjb21wb25lbnQ7XG5cbiAgICBtYW5hZ2VyLmRpZFVwZGF0ZUxheW91dChzdGF0ZSwgYm91bmRzKTtcblxuICAgIHZtLmVudi5kaWRVcGRhdGUoY29tcG9uZW50KTtcbiAgfVxufVxuXG5jbGFzcyBEZWJ1Z1JlbmRlclRyZWVVcGRhdGVPcGNvZGUgaW1wbGVtZW50cyBVcGRhdGluZ09wY29kZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYnVja2V0OiBvYmplY3QpIHt9XG5cbiAgZXZhbHVhdGUodm06IFVwZGF0aW5nVk0pIHtcbiAgICB2bS5lbnYuZGVidWdSZW5kZXJUcmVlPy51cGRhdGUodGhpcy5idWNrZXQpO1xuICB9XG59XG5cbmNsYXNzIERlYnVnUmVuZGVyVHJlZURpZFJlbmRlck9wY29kZSBpbXBsZW1lbnRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBidWNrZXQ6IG9iamVjdCwgcHJpdmF0ZSBib3VuZHM6IEJvdW5kcykge31cblxuICBldmFsdWF0ZSh2bTogVXBkYXRpbmdWTSkge1xuICAgIHZtLmVudi5kZWJ1Z1JlbmRlclRyZWU/LmRpZFJlbmRlcih0aGlzLmJ1Y2tldCwgdGhpcy5ib3VuZHMpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBpc0VtcHR5LCBpc1N0cmluZyB9IGZyb20gJy4uLy4uL2RvbS9ub3JtYWxpemUnO1xuaW1wb3J0IHsgVXBkYXRpbmdPcGNvZGUgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFJlZmVyZW5jZSwgdmFsdWVGb3JSZWYgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgU2ltcGxlVGV4dCB9IGZyb20gJ0BzaW1wbGUtZG9tL2ludGVyZmFjZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIER5bmFtaWNUZXh0Q29udGVudCBpbXBsZW1lbnRzIFVwZGF0aW5nT3Bjb2RlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIG5vZGU6IFNpbXBsZVRleHQsXG4gICAgcHJpdmF0ZSByZWZlcmVuY2U6IFJlZmVyZW5jZTx1bmtub3duPixcbiAgICBwcml2YXRlIGxhc3RWYWx1ZTogc3RyaW5nXG4gICkge31cblxuICBldmFsdWF0ZSgpIHtcbiAgICBsZXQgdmFsdWUgPSB2YWx1ZUZvclJlZih0aGlzLnJlZmVyZW5jZSk7XG5cbiAgICBsZXQgeyBsYXN0VmFsdWUgfSA9IHRoaXM7XG5cbiAgICBpZiAodmFsdWUgPT09IGxhc3RWYWx1ZSkgcmV0dXJuO1xuXG4gICAgbGV0IG5vcm1hbGl6ZWQ6IHN0cmluZztcblxuICAgIGlmIChpc0VtcHR5KHZhbHVlKSkge1xuICAgICAgbm9ybWFsaXplZCA9ICcnO1xuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICBub3JtYWxpemVkID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vcm1hbGl6ZWQgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkICE9PSBsYXN0VmFsdWUpIHtcbiAgICAgIGxldCB0ZXh0Tm9kZSA9IHRoaXMubm9kZTtcbiAgICAgIHRleHROb2RlLm5vZGVWYWx1ZSA9IHRoaXMubGFzdFZhbHVlID0gbm9ybWFsaXplZDtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGlzQ29uc3RSZWYsIHZhbHVlRm9yUmVmIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7XG4gIGNoZWNrLFxuICBDaGVja1N0cmluZyxcbiAgQ2hlY2tTYWZlU3RyaW5nLFxuICBDaGVja05vZGUsXG4gIENoZWNrRG9jdW1lbnRGcmFnbWVudCxcbn0gZnJvbSAnQGdsaW1tZXIvZGVidWcnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcblxuaW1wb3J0IHsgQVBQRU5EX09QQ09ERVMgfSBmcm9tICcuLi8uLi9vcGNvZGVzJztcbmltcG9ydCB7IENoZWNrUmVmZXJlbmNlIH0gZnJvbSAnLi8tZGVidWctc3RyaXAnO1xuaW1wb3J0IHsgaXNFbXB0eSwgaXNTYWZlU3RyaW5nLCBpc0ZyYWdtZW50LCBpc05vZGUsIHNob3VsZENvZXJjZSB9IGZyb20gJy4uLy4uL2RvbS9ub3JtYWxpemUnO1xuaW1wb3J0IER5bmFtaWNUZXh0Q29udGVudCBmcm9tICcuLi8uLi92bS9jb250ZW50L3RleHQnO1xuaW1wb3J0IHsgQ29udGVudFR5cGUsIEN1cnJpZWRUeXBlLCBPcCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgQXNzZXJ0RmlsdGVyIH0gZnJvbSAnLi92bSc7XG5pbXBvcnQgeyBoYXNJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIsIGhhc0ludGVybmFsSGVscGVyTWFuYWdlciB9IGZyb20gJ0BnbGltbWVyL21hbmFnZXInO1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHsgaXNDdXJyaWVkVHlwZSB9IGZyb20gJy4uLy4uL2N1cnJpZWQtdmFsdWUnO1xuXG5mdW5jdGlvbiB0b0NvbnRlbnRUeXBlKHZhbHVlOiB1bmtub3duKSB7XG4gIGlmIChzaG91bGRDb2VyY2UodmFsdWUpKSB7XG4gICAgcmV0dXJuIENvbnRlbnRUeXBlLlN0cmluZztcbiAgfSBlbHNlIGlmIChcbiAgICBpc0N1cnJpZWRUeXBlKHZhbHVlLCBDdXJyaWVkVHlwZS5Db21wb25lbnQpIHx8XG4gICAgaGFzSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyKHZhbHVlIGFzIG9iamVjdClcbiAgKSB7XG4gICAgcmV0dXJuIENvbnRlbnRUeXBlLkNvbXBvbmVudDtcbiAgfSBlbHNlIGlmIChcbiAgICBpc0N1cnJpZWRUeXBlKHZhbHVlLCBDdXJyaWVkVHlwZS5IZWxwZXIpIHx8XG4gICAgaGFzSW50ZXJuYWxIZWxwZXJNYW5hZ2VyKHZhbHVlIGFzIG9iamVjdClcbiAgKSB7XG4gICAgcmV0dXJuIENvbnRlbnRUeXBlLkhlbHBlcjtcbiAgfSBlbHNlIGlmIChpc1NhZmVTdHJpbmcodmFsdWUpKSB7XG4gICAgcmV0dXJuIENvbnRlbnRUeXBlLlNhZmVTdHJpbmc7XG4gIH0gZWxzZSBpZiAoaXNGcmFnbWVudCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gQ29udGVudFR5cGUuRnJhZ21lbnQ7XG4gIH0gZWxzZSBpZiAoaXNOb2RlKHZhbHVlKSkge1xuICAgIHJldHVybiBDb250ZW50VHlwZS5Ob2RlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBDb250ZW50VHlwZS5TdHJpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9EeW5hbWljQ29udGVudFR5cGUodmFsdWU6IHVua25vd24pIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gQ29udGVudFR5cGUuU3RyaW5nO1xuICB9XG5cbiAgaWYgKGlzQ3VycmllZFR5cGUodmFsdWUsIEN1cnJpZWRUeXBlLkNvbXBvbmVudCkgfHwgaGFzSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyKHZhbHVlIGFzIG9iamVjdCkpIHtcbiAgICByZXR1cm4gQ29udGVudFR5cGUuQ29tcG9uZW50O1xuICB9IGVsc2Uge1xuICAgIGlmIChcbiAgICAgIERFQlVHICYmXG4gICAgICAhaXNDdXJyaWVkVHlwZSh2YWx1ZSwgQ3VycmllZFR5cGUuSGVscGVyKSAmJlxuICAgICAgIWhhc0ludGVybmFsSGVscGVyTWFuYWdlcih2YWx1ZSBhcyBvYmplY3QpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBdHRlbXB0ZWQgdXNlIGEgZHluYW1pYyB2YWx1ZSBhcyBhIGNvbXBvbmVudCBvciBoZWxwZXIsIGJ1dCB0aGF0IHZhbHVlIGRpZCBub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIGNvbXBvbmVudCBvciBoZWxwZXIgbWFuYWdlci4gVGhlIHZhbHVlIHdhczogJHt2YWx1ZX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBDb250ZW50VHlwZS5IZWxwZXI7XG4gIH1cbn1cblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkNvbnRlbnRUeXBlLCAodm0pID0+IHtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBlZWsoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuXG4gIHZtLnN0YWNrLnB1c2godG9Db250ZW50VHlwZSh2YWx1ZUZvclJlZihyZWZlcmVuY2UpKSk7XG5cbiAgaWYgKCFpc0NvbnN0UmVmKHJlZmVyZW5jZSkpIHtcbiAgICB2bS51cGRhdGVXaXRoKG5ldyBBc3NlcnRGaWx0ZXIocmVmZXJlbmNlLCB0b0NvbnRlbnRUeXBlKSk7XG4gIH1cbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRHluYW1pY0NvbnRlbnRUeXBlLCAodm0pID0+IHtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBlZWsoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuXG4gIHZtLnN0YWNrLnB1c2godG9EeW5hbWljQ29udGVudFR5cGUodmFsdWVGb3JSZWYocmVmZXJlbmNlKSkpO1xuXG4gIGlmICghaXNDb25zdFJlZihyZWZlcmVuY2UpKSB7XG4gICAgdm0udXBkYXRlV2l0aChuZXcgQXNzZXJ0RmlsdGVyKHJlZmVyZW5jZSwgdG9EeW5hbWljQ29udGVudFR5cGUpKTtcbiAgfVxufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5BcHBlbmRIVE1MLCAodm0pID0+IHtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG5cbiAgbGV0IHJhd1ZhbHVlID0gdmFsdWVGb3JSZWYocmVmZXJlbmNlKTtcbiAgbGV0IHZhbHVlID0gaXNFbXB0eShyYXdWYWx1ZSkgPyAnJyA6IFN0cmluZyhyYXdWYWx1ZSk7XG5cbiAgdm0uZWxlbWVudHMoKS5hcHBlbmREeW5hbWljSFRNTCh2YWx1ZSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkFwcGVuZFNhZmVIVE1MLCAodm0pID0+IHtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG5cbiAgbGV0IHJhd1ZhbHVlID0gY2hlY2sodmFsdWVGb3JSZWYocmVmZXJlbmNlKSwgQ2hlY2tTYWZlU3RyaW5nKS50b0hUTUwoKTtcbiAgbGV0IHZhbHVlID0gaXNFbXB0eShyYXdWYWx1ZSkgPyAnJyA6IGNoZWNrKHJhd1ZhbHVlLCBDaGVja1N0cmluZyk7XG5cbiAgdm0uZWxlbWVudHMoKS5hcHBlbmREeW5hbWljSFRNTCh2YWx1ZSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkFwcGVuZFRleHQsICh2bSkgPT4ge1xuICBsZXQgcmVmZXJlbmNlID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcblxuICBsZXQgcmF3VmFsdWUgPSB2YWx1ZUZvclJlZihyZWZlcmVuY2UpO1xuICBsZXQgdmFsdWUgPSBpc0VtcHR5KHJhd1ZhbHVlKSA/ICcnIDogU3RyaW5nKHJhd1ZhbHVlKTtcblxuICBsZXQgbm9kZSA9IHZtLmVsZW1lbnRzKCkuYXBwZW5kRHluYW1pY1RleHQodmFsdWUpO1xuXG4gIGlmICghaXNDb25zdFJlZihyZWZlcmVuY2UpKSB7XG4gICAgdm0udXBkYXRlV2l0aChuZXcgRHluYW1pY1RleHRDb250ZW50KG5vZGUsIHJlZmVyZW5jZSwgdmFsdWUpKTtcbiAgfVxufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5BcHBlbmREb2N1bWVudEZyYWdtZW50LCAodm0pID0+IHtcbiAgbGV0IHJlZmVyZW5jZSA9IGNoZWNrKHZtLnN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG5cbiAgbGV0IHZhbHVlID0gY2hlY2sodmFsdWVGb3JSZWYocmVmZXJlbmNlKSwgQ2hlY2tEb2N1bWVudEZyYWdtZW50KTtcblxuICB2bS5lbGVtZW50cygpLmFwcGVuZER5bmFtaWNGcmFnbWVudCh2YWx1ZSk7XG59KTtcblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkFwcGVuZE5vZGUsICh2bSkgPT4ge1xuICBsZXQgcmVmZXJlbmNlID0gY2hlY2sodm0uc3RhY2sucG9wKCksIENoZWNrUmVmZXJlbmNlKTtcblxuICBsZXQgdmFsdWUgPSBjaGVjayh2YWx1ZUZvclJlZihyZWZlcmVuY2UpLCBDaGVja05vZGUpO1xuXG4gIHZtLmVsZW1lbnRzKCkuYXBwZW5kRHluYW1pY05vZGUodmFsdWUpO1xufSk7XG4iLCJpbXBvcnQgeyBPcCwgU2NvcGUgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFJlZmVyZW5jZSwgY2hpbGRSZWZGb3IsIHZhbHVlRm9yUmVmIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IGRpY3QsIGRlY29kZUhhbmRsZSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQVBQRU5EX09QQ09ERVMgfSBmcm9tICcuLi8uLi9vcGNvZGVzJztcbmltcG9ydCB7IENPTlNUQU5UUyB9IGZyb20gJy4uLy4uL3N5bWJvbHMnO1xuXG5leHBvcnQgdHlwZSBEZWJ1Z0dldCA9IChwYXRoOiBzdHJpbmcpID0+IHVua25vd247XG5cbmV4cG9ydCB0eXBlIERlYnVnQ2FsbGJhY2sgPSAoY29udGV4dDogdW5rbm93biwgZ2V0OiBEZWJ1Z0dldCkgPT4gdm9pZDtcblxuZnVuY3Rpb24gZGVidWdDYWxsYmFjayhjb250ZXh0OiB1bmtub3duLCBnZXQ6IERlYnVnR2V0KTogdm9pZCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gIGNvbnNvbGUuaW5mbygnVXNlIGBjb250ZXh0YCwgYW5kIGBnZXQoPHBhdGg+KWAgdG8gZGVidWcgdGhpcyB0ZW1wbGF0ZS4nKTtcblxuICAvLyBmb3IgZXhhbXBsZS4uLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gIGNvbnRleHQgPT09IGdldCgndGhpcycpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kZWJ1Z2dlclxuICBkZWJ1Z2dlcjtcbn1cblxubGV0IGNhbGxiYWNrID0gZGVidWdDYWxsYmFjaztcblxuLy8gRm9yIHRlc3RpbmcgcHVycG9zZXNcbmV4cG9ydCBmdW5jdGlvbiBzZXREZWJ1Z2dlckNhbGxiYWNrKGNiOiBEZWJ1Z0NhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gY2I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldERlYnVnZ2VyQ2FsbGJhY2soKSB7XG4gIGNhbGxiYWNrID0gZGVidWdDYWxsYmFjaztcbn1cblxuY2xhc3MgU2NvcGVJbnNwZWN0b3Ige1xuICBwcml2YXRlIGxvY2FscyA9IGRpY3Q8UmVmZXJlbmNlPigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc2NvcGU6IFNjb3BlLCBzeW1ib2xzOiBzdHJpbmdbXSwgZXZhbEluZm86IG51bWJlcltdKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmFsSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHNsb3QgPSBldmFsSW5mb1tpXTtcbiAgICAgIGxldCBuYW1lID0gc3ltYm9sc1tzbG90IC0gMV07XG4gICAgICBsZXQgcmVmID0gc2NvcGUuZ2V0U3ltYm9sKHNsb3QpO1xuICAgICAgdGhpcy5sb2NhbHNbbmFtZV0gPSByZWY7XG4gICAgfVxuICB9XG5cbiAgZ2V0KHBhdGg6IHN0cmluZyk6IFJlZmVyZW5jZSB7XG4gICAgbGV0IHsgc2NvcGUsIGxvY2FscyB9ID0gdGhpcztcbiAgICBsZXQgcGFydHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgbGV0IFtoZWFkLCAuLi50YWlsXSA9IHBhdGguc3BsaXQoJy4nKTtcblxuICAgIGxldCBldmFsU2NvcGUgPSBzY29wZS5nZXRFdmFsU2NvcGUoKSE7XG4gICAgbGV0IHJlZjogUmVmZXJlbmNlO1xuXG4gICAgaWYgKGhlYWQgPT09ICd0aGlzJykge1xuICAgICAgcmVmID0gc2NvcGUuZ2V0U2VsZigpO1xuICAgIH0gZWxzZSBpZiAobG9jYWxzW2hlYWRdKSB7XG4gICAgICByZWYgPSBsb2NhbHNbaGVhZF07XG4gICAgfSBlbHNlIGlmIChoZWFkLmluZGV4T2YoJ0AnKSA9PT0gMCAmJiBldmFsU2NvcGVbaGVhZF0pIHtcbiAgICAgIHJlZiA9IGV2YWxTY29wZVtoZWFkXSBhcyBSZWZlcmVuY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZiA9IHRoaXMuc2NvcGUuZ2V0U2VsZigpO1xuICAgICAgdGFpbCA9IHBhcnRzO1xuICAgIH1cblxuICAgIHJldHVybiB0YWlsLnJlZHVjZSgociwgcGFydCkgPT4gY2hpbGRSZWZGb3IociwgcGFydCksIHJlZik7XG4gIH1cbn1cblxuQVBQRU5EX09QQ09ERVMuYWRkKE9wLkRlYnVnZ2VyLCAodm0sIHsgb3AxOiBfc3ltYm9scywgb3AyOiBfZXZhbEluZm8gfSkgPT4ge1xuICBsZXQgc3ltYm9scyA9IHZtW0NPTlNUQU5UU10uZ2V0QXJyYXk8c3RyaW5nPihfc3ltYm9scyk7XG4gIGxldCBldmFsSW5mbyA9IHZtW0NPTlNUQU5UU10uZ2V0QXJyYXk8bnVtYmVyPihkZWNvZGVIYW5kbGUoX2V2YWxJbmZvKSk7XG4gIGxldCBpbnNwZWN0b3IgPSBuZXcgU2NvcGVJbnNwZWN0b3Iodm0uc2NvcGUoKSwgc3ltYm9scywgZXZhbEluZm8pO1xuICBjYWxsYmFjayh2YWx1ZUZvclJlZih2bS5nZXRTZWxmKCkpLCAocGF0aCkgPT4gdmFsdWVGb3JSZWYoaW5zcGVjdG9yLmdldChwYXRoKSkpO1xufSk7XG4iLCJpbXBvcnQgeyBjcmVhdGVJdGVyYXRvclJlZiwgdmFsdWVGb3JSZWYgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgQVBQRU5EX09QQ09ERVMgfSBmcm9tICcuLi8uLi9vcGNvZGVzJztcbmltcG9ydCB7IENoZWNrUmVmZXJlbmNlLCBDaGVja0l0ZXJhdG9yIH0gZnJvbSAnLi8tZGVidWctc3RyaXAnO1xuaW1wb3J0IHsgY2hlY2sgfSBmcm9tICdAZ2xpbW1lci9kZWJ1Zyc7XG5pbXBvcnQgeyBPcCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgQXNzZXJ0RmlsdGVyIH0gZnJvbSAnLi92bSc7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5FbnRlckxpc3QsICh2bSwgeyBvcDE6IHJlbGF0aXZlU3RhcnQsIG9wMjogZWxzZVRhcmdldCB9KSA9PiB7XG4gIGxldCBzdGFjayA9IHZtLnN0YWNrO1xuICBsZXQgbGlzdFJlZiA9IGNoZWNrKHN0YWNrLnBvcCgpLCBDaGVja1JlZmVyZW5jZSk7XG4gIGxldCBrZXlSZWYgPSBjaGVjayhzdGFjay5wb3AoKSwgQ2hlY2tSZWZlcmVuY2UpO1xuXG4gIGxldCBrZXlWYWx1ZSA9IHZhbHVlRm9yUmVmKGtleVJlZik7XG4gIGxldCBrZXkgPSBrZXlWYWx1ZSA9PT0gbnVsbCA/ICdAaWRlbnRpdHknIDogU3RyaW5nKGtleVZhbHVlKTtcblxuICBsZXQgaXRlcmF0b3JSZWYgPSBjcmVhdGVJdGVyYXRvclJlZihsaXN0UmVmLCBrZXkpO1xuICBsZXQgaXRlcmF0b3IgPSB2YWx1ZUZvclJlZihpdGVyYXRvclJlZik7XG5cbiAgdm0udXBkYXRlV2l0aChuZXcgQXNzZXJ0RmlsdGVyKGl0ZXJhdG9yUmVmLCAoaXRlcmF0b3IpID0+IGl0ZXJhdG9yLmlzRW1wdHkoKSkpO1xuXG4gIGlmIChpdGVyYXRvci5pc0VtcHR5KCkgPT09IHRydWUpIHtcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBvZmZzZXQsIHNob3VsZCBiZSBhY2N1cmF0ZVxuICAgIHZtLmdvdG8oZWxzZVRhcmdldCArIDEpO1xuICB9IGVsc2Uge1xuICAgIHZtLmVudGVyTGlzdChpdGVyYXRvclJlZiwgcmVsYXRpdmVTdGFydCk7XG4gICAgdm0uc3RhY2sucHVzaChpdGVyYXRvcik7XG4gIH1cbn0pO1xuXG5BUFBFTkRfT1BDT0RFUy5hZGQoT3AuRXhpdExpc3QsICh2bSkgPT4ge1xuICB2bS5leGl0TGlzdCgpO1xufSk7XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5JdGVyYXRlLCAodm0sIHsgb3AxOiBicmVha3MgfSkgPT4ge1xuICBsZXQgc3RhY2sgPSB2bS5zdGFjaztcbiAgbGV0IGl0ZXJhdG9yID0gY2hlY2soc3RhY2sucGVlaygpLCBDaGVja0l0ZXJhdG9yKTtcbiAgbGV0IGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICB2bS5yZWdpc3Rlckl0ZW0odm0uZW50ZXJJdGVtKGl0ZW0pKTtcbiAgfSBlbHNlIHtcbiAgICB2bS5nb3RvKGJyZWFrcyk7XG4gIH1cbn0pO1xuIiwiaW1wb3J0IHsgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXRpZXMsIEludGVybmFsQ29tcG9uZW50TWFuYWdlciB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTlVMTF9SRUZFUkVOQ0UsIFJlZmVyZW5jZSB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBzZXRJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIgfSBmcm9tICdAZ2xpbW1lci9tYW5hZ2VyJztcblxuY29uc3QgQ0FQQUJJTElUSUVTOiBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdGllcyA9IHtcbiAgZHluYW1pY0xheW91dDogZmFsc2UsXG4gIGR5bmFtaWNUYWc6IGZhbHNlLFxuICBwcmVwYXJlQXJnczogZmFsc2UsXG4gIGNyZWF0ZUFyZ3M6IGZhbHNlLFxuICBhdHRyaWJ1dGVIb29rOiBmYWxzZSxcbiAgZWxlbWVudEhvb2s6IGZhbHNlLFxuICBjcmVhdGVDYWxsZXI6IGZhbHNlLFxuICBkeW5hbWljU2NvcGU6IGZhbHNlLFxuICB1cGRhdGVIb29rOiBmYWxzZSxcbiAgY3JlYXRlSW5zdGFuY2U6IGZhbHNlLFxuICB3cmFwcGVkOiBmYWxzZSxcbiAgd2lsbERlc3Ryb3k6IGZhbHNlLFxuICBoYXNTdWJPd25lcjogZmFsc2UsXG59O1xuXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVPbmx5Q29tcG9uZW50TWFuYWdlciBpbXBsZW1lbnRzIEludGVybmFsQ29tcG9uZW50TWFuYWdlciB7XG4gIGdldENhcGFiaWxpdGllcygpOiBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdGllcyB7XG4gICAgcmV0dXJuIENBUEFCSUxJVElFUztcbiAgfVxuXG4gIGdldERlYnVnTmFtZSh7IG5hbWUgfTogVGVtcGxhdGVPbmx5Q29tcG9uZW50RGVmaW5pdGlvbik6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cblxuICBnZXRTZWxmKCk6IFJlZmVyZW5jZSB7XG4gICAgcmV0dXJuIE5VTExfUkVGRVJFTkNFO1xuICB9XG5cbiAgZ2V0RGVzdHJveWFibGUoKTogbnVsbCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFRFTVBMQVRFX09OTFlfQ09NUE9ORU5UX01BTkFHRVIgPSBuZXcgVGVtcGxhdGVPbmx5Q29tcG9uZW50TWFuYWdlcigpO1xuXG4vLyBUaGlzIGlzIG9ubHkgZXhwb3J0ZWQgZm9yIHR5cGVzLCBkb24ndCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseVxuZXhwb3J0IGNsYXNzIFRlbXBsYXRlT25seUNvbXBvbmVudERlZmluaXRpb24ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgbW9kdWxlTmFtZSA9ICdAZ2xpbW1lci9jb21wb25lbnQvdGVtcGxhdGUtb25seScsXG4gICAgcHVibGljIG5hbWUgPSAnKHVua25vd24gdGVtcGxhdGUtb25seSBjb21wb25lbnQpJ1xuICApIHt9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTmFtZTtcbiAgfVxufVxuXG5zZXRJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIoXG4gIFRFTVBMQVRFX09OTFlfQ09NUE9ORU5UX01BTkFHRVIsXG4gIFRlbXBsYXRlT25seUNvbXBvbmVudERlZmluaXRpb24ucHJvdG90eXBlXG4pO1xuXG4vKipcbiAgVGhpcyB1dGlsaXR5IGZ1bmN0aW9uIGlzIHVzZWQgdG8gZGVjbGFyZSBhIGdpdmVuIGNvbXBvbmVudCBoYXMgbm8gYmFja2luZyBjbGFzcy4gV2hlbiB0aGUgcmVuZGVyaW5nIGVuZ2luZSBkZXRlY3RzIHRoaXMgaXRcbiAgaXMgYWJsZSB0byBwZXJmb3JtIGEgbnVtYmVyIG9mIG9wdGltaXphdGlvbnMuIFRlbXBsYXRlcyB0aGF0IGFyZSBhc3NvY2lhdGVkIHdpdGggYHRlbXBsYXRlT25seSgpYCB3aWxsIGJlIHJlbmRlcmVkIF9hcyBpc19cbiAgd2l0aG91dCBhZGRpbmcgYSB3cmFwcGluZyBgPGRpdj5gIChvciBhbnkgb2YgdGhlIG90aGVyIGVsZW1lbnQgY3VzdG9taXphdGlvbiBiZWhhdmlvcnMgb2YgW0BlbWJlci9jb21wb25lbnRdKC9lbWJlci9yZWxlYXNlL2NsYXNzZXMvQ29tcG9uZW50KSkuXG4gIFNwZWNpZmljYWxseSwgdGhpcyBtZWFucyB0aGF0IHRoZSB0ZW1wbGF0ZSB3aWxsIGJlIHJlbmRlcmVkIGFzIFwib3V0ZXIgSFRNTFwiLlxuXG4gIEluIGdlbmVyYWwsIHRoaXMgbWV0aG9kIHdpbGwgYmUgdXNlZCBieSBidWlsZCB0aW1lIHRvb2xpbmcgYW5kIHdvdWxkIG5vdCBiZSBkaXJlY3RseSB3cml0dGVuIGluIGFuIGFwcGxpY2F0aW9uLiBIb3dldmVyLFxuICBhdCB0aW1lcyBpdCBtYXkgYmUgdXNlZnVsIHRvIHVzZSBkaXJlY3RseSB0byBsZXZlcmFnZSB0aGUgXCJvdXRlciBIVE1MXCIgc2VtYW50aWNzIG1lbnRpb25lZCBhYm92ZS4gRm9yIGV4YW1wbGUsIGlmIGFuIGFkZG9uIHdvdWxkIGxpa2VcbiAgdG8gdXNlIHRoZXNlIHNlbWFudGljcyBmb3IgaXRzIHRlbXBsYXRlcyBidXQgY2Fubm90IGJlIGNlcnRhaW4gaXQgd2lsbCBvbmx5IGJlIGNvbnN1bWVkIGJ5IGFwcGxpY2F0aW9ucyB0aGF0IGhhdmUgZW5hYmxlZCB0aGVcbiAgYHRlbXBsYXRlLW9ubHktZ2xpbW1lci1jb21wb25lbnRzYCBvcHRpb25hbCBmZWF0dXJlLlxuXG4gIEBleGFtcGxlXG5cbiAgYGBganNcbiAgaW1wb3J0IHsgdGVtcGxhdGVPbmx5Q29tcG9uZW50IH0gZnJvbSAnQGdsaW1tZXIvcnVudGltZSc7XG5cbiAgZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVPbmx5Q29tcG9uZW50KCk7XG4gIGBgYFxuXG4gIEBwdWJsaWNcbiAgQG1ldGhvZCB0ZW1wbGF0ZU9ubHlcbiAgQHBhcmFtIHtTdHJpbmd9IG1vZHVsZU5hbWUgdGhlIG1vZHVsZSBuYW1lIHRoYXQgdGhlIHRlbXBsYXRlIG9ubHkgY29tcG9uZW50IHJlcHJlc2VudHMsIHRoaXMgd2lsbCBiZSB1c2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXNcbiAgQGNhdGVnb3J5IEVNQkVSX0dMSU1NRVJfU0VUX0NPTVBPTkVOVF9URU1QTEFURVxuKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlT25seUNvbXBvbmVudChcbiAgbW9kdWxlTmFtZT86IHN0cmluZyxcbiAgbmFtZT86IHN0cmluZ1xuKTogVGVtcGxhdGVPbmx5Q29tcG9uZW50RGVmaW5pdGlvbiB7XG4gIHJldHVybiBuZXcgVGVtcGxhdGVPbmx5Q29tcG9uZW50RGVmaW5pdGlvbihtb2R1bGVOYW1lLCBuYW1lKTtcbn1cbiIsImltcG9ydCB7XG4gIFNpbXBsZUVsZW1lbnQsXG4gIFNpbXBsZURvY3VtZW50LFxuICBOYW1lc3BhY2UsXG4gIFNpbXBsZU5vZGUsXG4gIEluc2VydFBvc2l0aW9uLFxuICBTaW1wbGVUZXh0LFxuICBTaW1wbGVDb21tZW50LFxufSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRGljdCwgT3B0aW9uLCBCb3VuZHMgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IENvbmNyZXRlQm91bmRzIH0gZnJvbSAnLi4vYm91bmRzJztcbmltcG9ydCB7IGV4cGVjdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbmNvbnN0IFNWR19JTlRFR1JBVElPTl9QT0lOVFMgPSB7IGZvcmVpZ25PYmplY3Q6IDEsIGRlc2M6IDEsIHRpdGxlOiAxIH07XG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwvc3ludGF4Lmh0bWwjYWRqdXN0LXN2Zy1hdHRyaWJ1dGVzXG4vLyBUT0RPOiBBZGp1c3QgU1ZHIGF0dHJpYnV0ZXNcblxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5mb3JlaWduXG4vLyBUT0RPOiBBZGp1c3QgU1ZHIGVsZW1lbnRzXG5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWwvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluZm9yZWlnblxuZXhwb3J0IGNvbnN0IEJMQUNLTElTVF9UQUJMRSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmV4cG9ydCBjbGFzcyBET01PcGVyYXRpb25zIHtcbiAgcHJvdGVjdGVkIHVzZWxlc3NFbGVtZW50ITogU2ltcGxlRWxlbWVudDsgLy8gU2V0IGJ5IHRoaXMuc2V0dXBVc2VsZXNzRWxlbWVudCgpIGluIGNvbnN0cnVjdG9yXG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGRvY3VtZW50OiBTaW1wbGVEb2N1bWVudCkge1xuICAgIHRoaXMuc2V0dXBVc2VsZXNzRWxlbWVudCgpO1xuICB9XG5cbiAgLy8gc3BsaXQgaW50byBzZXBhcmF0ZSBtZXRob2Qgc28gdGhhdCBOb2RlRE9NVHJlZUNvbnN0cnVjdGlvblxuICAvLyBjYW4gb3ZlcnJpZGUgaXQuXG4gIHByb3RlY3RlZCBzZXR1cFVzZWxlc3NFbGVtZW50KCkge1xuICAgIHRoaXMudXNlbGVzc0VsZW1lbnQgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB9XG5cbiAgY3JlYXRlRWxlbWVudCh0YWc6IHN0cmluZywgY29udGV4dD86IFNpbXBsZUVsZW1lbnQpOiBTaW1wbGVFbGVtZW50IHtcbiAgICBsZXQgaXNFbGVtZW50SW5TVkdOYW1lc3BhY2U6IGJvb2xlYW4sIGlzSFRNTEludGVncmF0aW9uUG9pbnQ6IGJvb2xlYW47XG5cbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgaXNFbGVtZW50SW5TVkdOYW1lc3BhY2UgPSBjb250ZXh0Lm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlLlNWRyB8fCB0YWcgPT09ICdzdmcnO1xuICAgICAgaXNIVE1MSW50ZWdyYXRpb25Qb2ludCA9ICEhKFNWR19JTlRFR1JBVElPTl9QT0lOVFMgYXMgRGljdDxudW1iZXI+KVtjb250ZXh0LnRhZ05hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0VsZW1lbnRJblNWR05hbWVzcGFjZSA9IHRhZyA9PT0gJ3N2Zyc7XG4gICAgICBpc0hUTUxJbnRlZ3JhdGlvblBvaW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzRWxlbWVudEluU1ZHTmFtZXNwYWNlICYmICFpc0hUTUxJbnRlZ3JhdGlvblBvaW50KSB7XG4gICAgICAvLyBGSVhNRTogVGhpcyBkb2VzIG5vdCBwcm9wZXJseSBoYW5kbGUgPGZvbnQ+IHdpdGggY29sb3IsIGZhY2UsIG9yXG4gICAgICAvLyBzaXplIGF0dHJpYnV0ZXMsIHdoaWNoIGlzIGFsc28gZGlzYWxsb3dlZCBieSB0aGUgc3BlYy4gV2Ugc2hvdWxkIGZpeFxuICAgICAgLy8gdGhpcy5cbiAgICAgIGlmIChCTEFDS0xJU1RfVEFCTEVbdGFnXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjcmVhdGUgYSAke3RhZ30gaW5zaWRlIGFuIFNWRyBjb250ZXh0YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhOYW1lc3BhY2UuU1ZHLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgfVxuICB9XG5cbiAgaW5zZXJ0QmVmb3JlKHBhcmVudDogU2ltcGxlRWxlbWVudCwgbm9kZTogU2ltcGxlTm9kZSwgcmVmZXJlbmNlOiBPcHRpb248U2ltcGxlTm9kZT4pIHtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZmVyZW5jZSk7XG4gIH1cblxuICBpbnNlcnRIVE1MQmVmb3JlKHBhcmVudDogU2ltcGxlRWxlbWVudCwgbmV4dFNpYmxpbmc6IE9wdGlvbjxTaW1wbGVOb2RlPiwgaHRtbDogc3RyaW5nKTogQm91bmRzIHtcbiAgICBpZiAoaHRtbCA9PT0gJycpIHtcbiAgICAgIGxldCBjb21tZW50ID0gdGhpcy5jcmVhdGVDb21tZW50KCcnKTtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoY29tbWVudCwgbmV4dFNpYmxpbmcpO1xuICAgICAgcmV0dXJuIG5ldyBDb25jcmV0ZUJvdW5kcyhwYXJlbnQsIGNvbW1lbnQsIGNvbW1lbnQpO1xuICAgIH1cblxuICAgIGxldCBwcmV2ID0gbmV4dFNpYmxpbmcgPyBuZXh0U2libGluZy5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuICAgIGxldCBsYXN0OiBTaW1wbGVOb2RlO1xuXG4gICAgaWYgKG5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QWRqYWNlbnRIVE1MKEluc2VydFBvc2l0aW9uLmJlZm9yZWVuZCwgaHRtbCk7XG4gICAgICBsYXN0ID0gZXhwZWN0KHBhcmVudC5sYXN0Q2hpbGQsICdidWcgaW4gaW5zZXJ0QWRqYWNlbnRIVE1MPycpO1xuICAgIH0gZWxzZSBpZiAobmV4dFNpYmxpbmcgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgbmV4dFNpYmxpbmcuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmViZWdpbicsIGh0bWwpO1xuICAgICAgbGFzdCA9IGV4cGVjdChuZXh0U2libGluZy5wcmV2aW91c1NpYmxpbmcsICdidWcgaW4gaW5zZXJ0QWRqYWNlbnRIVE1MPycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb24tZWxlbWVudCBub2RlcyBkbyBub3Qgc3VwcG9ydCBpbnNlcnRBZGphY2VudEhUTUwsIHNvIGFkZCBhblxuICAgICAgLy8gZWxlbWVudCBhbmQgY2FsbCBpdCBvbiB0aGF0IGVsZW1lbnQuIFRoZW4gcmVtb3ZlIHRoZSBlbGVtZW50LlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgYWxzbyBwcm90ZWN0cyBFZGdlLCBJRSBhbmQgRmlyZWZveCB3L28gdGhlIGluc3BlY3RvciBvcGVuXG4gICAgICAvLyBmcm9tIG1lcmdpbmcgYWRqYWNlbnQgdGV4dCBub2Rlcy4gU2VlIC4vY29tcGF0L3RleHQtbm9kZS1tZXJnaW5nLWZpeC50c1xuICAgICAgbGV0IHsgdXNlbGVzc0VsZW1lbnQgfSA9IHRoaXM7XG5cbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUodXNlbGVzc0VsZW1lbnQsIG5leHRTaWJsaW5nKTtcbiAgICAgIHVzZWxlc3NFbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChJbnNlcnRQb3NpdGlvbi5iZWZvcmViZWdpbiwgaHRtbCk7XG4gICAgICBsYXN0ID0gZXhwZWN0KHVzZWxlc3NFbGVtZW50LnByZXZpb3VzU2libGluZywgJ2J1ZyBpbiBpbnNlcnRBZGphY2VudEhUTUw/Jyk7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodXNlbGVzc0VsZW1lbnQpO1xuICAgIH1cblxuICAgIGxldCBmaXJzdCA9IGV4cGVjdChwcmV2ID8gcHJldi5uZXh0U2libGluZyA6IHBhcmVudC5maXJzdENoaWxkLCAnYnVnIGluIGluc2VydEFkamFjZW50SFRNTD8nKTtcbiAgICByZXR1cm4gbmV3IENvbmNyZXRlQm91bmRzKHBhcmVudCwgZmlyc3QsIGxhc3QpO1xuICB9XG5cbiAgY3JlYXRlVGV4dE5vZGUodGV4dDogc3RyaW5nKTogU2ltcGxlVGV4dCB7XG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gIH1cblxuICBjcmVhdGVDb21tZW50KGRhdGE6IHN0cmluZyk6IFNpbXBsZUNvbW1lbnQge1xuICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoZGF0YSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1vdmVOb2Rlc0JlZm9yZShcbiAgc291cmNlOiBTaW1wbGVOb2RlLFxuICB0YXJnZXQ6IFNpbXBsZUVsZW1lbnQsXG4gIG5leHRTaWJsaW5nOiBPcHRpb248U2ltcGxlTm9kZT5cbik6IEJvdW5kcyB7XG4gIGxldCBmaXJzdCA9IGV4cGVjdChzb3VyY2UuZmlyc3RDaGlsZCwgJ3NvdXJjZSBpcyBlbXB0eScpO1xuICBsZXQgbGFzdDogU2ltcGxlTm9kZSA9IGZpcnN0O1xuICBsZXQgY3VycmVudDogT3B0aW9uPFNpbXBsZU5vZGU+ID0gZmlyc3Q7XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBsZXQgbmV4dDogT3B0aW9uPFNpbXBsZU5vZGU+ID0gY3VycmVudC5uZXh0U2libGluZztcblxuICAgIHRhcmdldC5pbnNlcnRCZWZvcmUoY3VycmVudCwgbmV4dFNpYmxpbmcpO1xuXG4gICAgbGFzdCA9IGN1cnJlbnQ7XG4gICAgY3VycmVudCA9IG5leHQ7XG4gIH1cblxuICByZXR1cm4gbmV3IENvbmNyZXRlQm91bmRzKHRhcmdldCwgZmlyc3QsIGxhc3QpO1xufVxuIiwiaW1wb3J0IHsgQm91bmRzLCBPcHRpb24gfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGFzc2VydCwgY2FzdFRvQnJvd3NlciwgY2xlYXJFbGVtZW50LCB1bndyYXAgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7XG4gIEluc2VydFBvc2l0aW9uLFxuICBOYW1lc3BhY2UsXG4gIFNpbXBsZURvY3VtZW50LFxuICBTaW1wbGVFbGVtZW50LFxuICBTaW1wbGVOb2RlLFxufSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRE9NT3BlcmF0aW9ucywgbW92ZU5vZGVzQmVmb3JlIH0gZnJvbSAnLi4vZG9tL29wZXJhdGlvbnMnO1xuXG5leHBvcnQgY29uc3QgU1ZHX05BTUVTUEFDRSA9IE5hbWVzcGFjZS5TVkc7XG5leHBvcnQgdHlwZSBTVkdfTkFNRVNQQUNFID0gdHlwZW9mIFNWR19OQU1FU1BBQ0U7XG5cbi8vIFBhdGNoOiAgICBpbnNlcnRBZGphY2VudEhUTUwgb24gU1ZHIEZpeFxuLy8gQnJvd3NlcnM6IFNhZmFyaSwgSUUsIEVkZ2UsIEZpcmVmb3ggfjMzLTM0XG4vLyBSZWFzb246ICAgaW5zZXJ0QWRqYWNlbnRIVE1MIGRvZXMgbm90IGV4aXN0IG9uIFNWRyBlbGVtZW50cyBpbiBTYWZhcmkuIEl0IGlzXG4vLyAgICAgICAgICAgcHJlc2VudCBidXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBvbiBJRSBhbmQgRWRnZS4gT2xkIHZlcnNpb25zIG9mXG4vLyAgICAgICAgICAgRmlyZWZveCBjcmVhdGUgbm9kZXMgaW4gdGhlIGluY29ycmVjdCBuYW1lc3BhY2UuXG4vLyBGaXg6ICAgICAgU2luY2UgSUUgYW5kIEVkZ2Ugc2lsZW50bHkgZmFpbCB0byBjcmVhdGUgU1ZHIG5vZGVzIHVzaW5nXG4vLyAgICAgICAgICAgaW5uZXJIVE1MLCBhbmQgYmVjYXVzZSBGaXJlZm94IG1heSBjcmVhdGUgbm9kZXMgaW4gdGhlIGluY29ycmVjdFxuLy8gICAgICAgICAgIG5hbWVzcGFjZSB1c2luZyBpbm5lckhUTUwgb24gU1ZHIGVsZW1lbnRzLCBhbiBIVE1MLXN0cmluZyB3cmFwcGluZ1xuLy8gICAgICAgICAgIGFwcHJvYWNoIGlzIHVzZWQuIEEgcHJlL3Bvc3QgU1ZHIHRhZyBpcyBhZGRlZCB0byB0aGUgc3RyaW5nLCB0aGVuXG4vLyAgICAgICAgICAgdGhhdCB3aG9sZSBzdHJpbmcgaXMgYWRkZWQgdG8gYSBkaXYuIFRoZSBjcmVhdGVkIG5vZGVzIGFyZSBwbHVja2VkXG4vLyAgICAgICAgICAgb3V0IGFuZCBhcHBsaWVkIHRvIHRoZSB0YXJnZXQgbG9jYXRpb24gb24gRE9NLlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U1ZHSW5uZXJIVE1MRml4KFxuICBkb2N1bWVudDogT3B0aW9uPFNpbXBsZURvY3VtZW50PixcbiAgRE9NQ2xhc3M6IHR5cGVvZiBET01PcGVyYXRpb25zLFxuICBzdmdOYW1lc3BhY2U6IFNWR19OQU1FU1BBQ0Vcbik6IHR5cGVvZiBET01PcGVyYXRpb25zIHtcbiAgaWYgKCFkb2N1bWVudCkgcmV0dXJuIERPTUNsYXNzO1xuXG4gIGlmICghc2hvdWxkQXBwbHlGaXgoZG9jdW1lbnQsIHN2Z05hbWVzcGFjZSkpIHtcbiAgICByZXR1cm4gRE9NQ2xhc3M7XG4gIH1cblxuICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgYXMgU2ltcGxlRWxlbWVudDtcblxuICByZXR1cm4gY2xhc3MgRE9NQ2hhbmdlc1dpdGhTVkdJbm5lckhUTUxGaXggZXh0ZW5kcyBET01DbGFzcyB7XG4gICAgaW5zZXJ0SFRNTEJlZm9yZShwYXJlbnQ6IFNpbXBsZUVsZW1lbnQsIG5leHRTaWJsaW5nOiBPcHRpb248U2ltcGxlTm9kZT4sIGh0bWw6IHN0cmluZyk6IEJvdW5kcyB7XG4gICAgICBpZiAoaHRtbCA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmluc2VydEhUTUxCZWZvcmUocGFyZW50LCBuZXh0U2libGluZywgaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJICE9PSBzdmdOYW1lc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmluc2VydEhUTUxCZWZvcmUocGFyZW50LCBuZXh0U2libGluZywgaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaXhTVkcocGFyZW50LCBkaXYsIGh0bWwsIG5leHRTaWJsaW5nKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpeFNWRyhcbiAgcGFyZW50OiBTaW1wbGVFbGVtZW50LFxuICBkaXY6IFNpbXBsZUVsZW1lbnQsXG4gIGh0bWw6IHN0cmluZyxcbiAgcmVmZXJlbmNlOiBPcHRpb248U2ltcGxlTm9kZT5cbik6IEJvdW5kcyB7XG4gIGFzc2VydChodG1sICE9PSAnJywgJ2h0bWwgY2Fubm90IGJlIGVtcHR5Jyk7XG5cbiAgbGV0IHNvdXJjZTogU2ltcGxlTm9kZTtcblxuICAvLyBUaGlzIGlzIGltcG9ydGFudCwgYmVjYXVzZSBkZXNjZW5kYW50cyBvZiB0aGUgPGZvcmVpZ25PYmplY3Q+IGludGVncmF0aW9uXG4gIC8vIHBvaW50IGFyZSBwYXJzZWQgaW4gdGhlIEhUTUwgbmFtZXNwYWNlXG4gIGlmIChwYXJlbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnRk9SRUlHTk9CSkVDVCcpIHtcbiAgICAvLyBJRSwgRWRnZTogYWxzbyBkbyBub3QgY29ycmVjdGx5IHN1cHBvcnQgdXNpbmcgYGlubmVySFRNTGAgb24gU1ZHXG4gICAgLy8gbmFtZXNwYWNlZCBlbGVtZW50cy4gU28gaGVyZSBhIHdyYXBwZXIgaXMgdXNlZC5cbiAgICBsZXQgd3JhcHBlZEh0bWwgPSAnPHN2Zz48Zm9yZWlnbk9iamVjdD4nICsgaHRtbCArICc8L2ZvcmVpZ25PYmplY3Q+PC9zdmc+JztcblxuICAgIGNsZWFyRWxlbWVudChkaXYpO1xuICAgIGRpdi5pbnNlcnRBZGphY2VudEhUTUwoSW5zZXJ0UG9zaXRpb24uYWZ0ZXJiZWdpbiwgd3JhcHBlZEh0bWwpO1xuXG4gICAgc291cmNlID0gZGl2LmZpcnN0Q2hpbGQhLmZpcnN0Q2hpbGQhO1xuICB9IGVsc2Uge1xuICAgIC8vIElFLCBFZGdlOiBhbHNvIGRvIG5vdCBjb3JyZWN0bHkgc3VwcG9ydCB1c2luZyBgaW5uZXJIVE1MYCBvbiBTVkdcbiAgICAvLyBuYW1lc3BhY2VkIGVsZW1lbnRzLiBTbyBoZXJlIGEgd3JhcHBlciBpcyB1c2VkLlxuICAgIGxldCB3cmFwcGVkSHRtbCA9ICc8c3ZnPicgKyBodG1sICsgJzwvc3ZnPic7XG5cbiAgICBjbGVhckVsZW1lbnQoZGl2KTtcbiAgICBkaXYuaW5zZXJ0QWRqYWNlbnRIVE1MKEluc2VydFBvc2l0aW9uLmFmdGVyYmVnaW4sIHdyYXBwZWRIdG1sKTtcblxuICAgIHNvdXJjZSA9IGRpdi5maXJzdENoaWxkITtcbiAgfVxuXG4gIHJldHVybiBtb3ZlTm9kZXNCZWZvcmUoc291cmNlLCBwYXJlbnQsIHJlZmVyZW5jZSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEFwcGx5Rml4KGRvY3VtZW50OiBTaW1wbGVEb2N1bWVudCwgc3ZnTmFtZXNwYWNlOiBTVkdfTkFNRVNQQUNFKSB7XG4gIGxldCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTmFtZXNwYWNlLCAnc3ZnJyk7XG5cbiAgdHJ5IHtcbiAgICBzdmcuaW5zZXJ0QWRqYWNlbnRIVE1MKEluc2VydFBvc2l0aW9uLmJlZm9yZWVuZCwgJzxjaXJjbGU+PC9jaXJjbGU+Jyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBJRSwgRWRnZTogV2lsbCB0aHJvdywgaW5zZXJ0QWRqYWNlbnRIVE1MIGlzIHVuc3VwcG9ydGVkIG9uIFNWR1xuICAgIC8vIFNhZmFyaTogV2lsbCB0aHJvdywgaW5zZXJ0QWRqYWNlbnRIVE1MIGlzIG5vdCBwcmVzZW50IG9uIFNWR1xuICB9IGZpbmFsbHkge1xuICAgIC8vIEZGOiBPbGQgdmVyc2lvbnMgd2lsbCBjcmVhdGUgYSBub2RlIGluIHRoZSB3cm9uZyBuYW1lc3BhY2VcbiAgICBpZiAoXG4gICAgICBzdmcuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgIGNhc3RUb0Jyb3dzZXIodW53cmFwKHN2Zy5maXJzdENoaWxkKSwgJ1NWRycpLm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRVxuICAgICkge1xuICAgICAgLy8gVGhlIHRlc3Qgd29ya2VkIGFzIGV4cGVjdGVkLCBubyBmaXggcmVxdWlyZWRcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQm91bmRzLCBPcHRpb24gfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7XG4gIEluc2VydFBvc2l0aW9uLFxuICBTaW1wbGVDb21tZW50LFxuICBTaW1wbGVEb2N1bWVudCxcbiAgU2ltcGxlRWxlbWVudCxcbiAgU2ltcGxlTm9kZSxcbn0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcbmltcG9ydCB7IERPTU9wZXJhdGlvbnMgfSBmcm9tICcuLi9kb20vb3BlcmF0aW9ucyc7XG5cbi8vIFBhdGNoOiAgICBBZGphY2VudCB0ZXh0IG5vZGUgbWVyZ2luZyBmaXhcbi8vIEJyb3dzZXJzOiBJRSwgRWRnZSwgRmlyZWZveCB3L28gaW5zcGVjdG9yIG9wZW5cbi8vIFJlYXNvbjogICBUaGVzZSBicm93c2VycyB3aWxsIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXMuIEZvciBleGFtcGxlIGdpdmVuXG4vLyAgICAgICAgICAgPGRpdj5IZWxsbzwvZGl2PiB3aXRoIGRpdi5pbnNlcnRBZGphY2VudEhUTUwoJyB3b3JsZCcpIGJyb3dzZXJzXG4vLyAgICAgICAgICAgd2l0aCBwcm9wZXIgYmVoYXZpb3Igd2lsbCBwb3B1bGF0ZSBkaXYuY2hpbGROb2RlcyB3aXRoIHR3byBpdGVtcy5cbi8vICAgICAgICAgICBUaGVzZSBicm93c2VycyB3aWxsIHBvcHVsYXRlIGl0IHdpdGggb25lIG1lcmdlZCBub2RlIGluc3RlYWQuXG4vLyBGaXg6ICAgICAgQWRkIHRoZXNlIG5vZGVzIHRvIGEgd3JhcHBlciBlbGVtZW50LCB0aGVuIGl0ZXJhdGUgdGhlIGNoaWxkTm9kZXNcbi8vICAgICAgICAgICBvZiB0aGF0IHdyYXBwZXIgYW5kIG1vdmUgdGhlIG5vZGVzIHRvIHRoZWlyIHRhcmdldCBsb2NhdGlvbi4gTm90ZVxuLy8gICAgICAgICAgIHRoYXQgcG90ZW50aWFsIFNWRyBidWdzIHdpbGwgaGF2ZSBiZWVuIGhhbmRsZWQgYmVmb3JlIHRoaXMgZml4LlxuLy8gICAgICAgICAgIE5vdGUgdGhhdCB0aGlzIGZpeCBtdXN0IG9ubHkgYXBwbHkgdG8gdGhlIHByZXZpb3VzIHRleHQgbm9kZSwgYXNcbi8vICAgICAgICAgICB0aGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgaW5zZXJ0SFRNTEJlZm9yZWAgYWxyZWFkeSBoYW5kbGVzXG4vLyAgICAgICAgICAgZm9sbG93aW5nIHRleHQgbm9kZXMgY29ycmVjdGx5LlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5VGV4dE5vZGVNZXJnaW5nRml4KFxuICBkb2N1bWVudDogT3B0aW9uPFNpbXBsZURvY3VtZW50PixcbiAgRE9NQ2xhc3M6IHR5cGVvZiBET01PcGVyYXRpb25zXG4pOiB0eXBlb2YgRE9NT3BlcmF0aW9ucyB7XG4gIGlmICghZG9jdW1lbnQpIHJldHVybiBET01DbGFzcztcblxuICBpZiAoIXNob3VsZEFwcGx5Rml4KGRvY3VtZW50KSkge1xuICAgIHJldHVybiBET01DbGFzcztcbiAgfVxuXG4gIHJldHVybiBjbGFzcyBET01DaGFuZ2VzV2l0aFRleHROb2RlTWVyZ2luZ0ZpeCBleHRlbmRzIERPTUNsYXNzIHtcbiAgICBwcml2YXRlIHVzZWxlc3NDb21tZW50OiBTaW1wbGVDb21tZW50O1xuXG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQ6IFNpbXBsZURvY3VtZW50KSB7XG4gICAgICBzdXBlcihkb2N1bWVudCk7XG4gICAgICB0aGlzLnVzZWxlc3NDb21tZW50ID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnJyk7XG4gICAgfVxuXG4gICAgaW5zZXJ0SFRNTEJlZm9yZShwYXJlbnQ6IFNpbXBsZUVsZW1lbnQsIG5leHRTaWJsaW5nOiBPcHRpb248U2ltcGxlTm9kZT4sIGh0bWw6IHN0cmluZyk6IEJvdW5kcyB7XG4gICAgICBpZiAoaHRtbCA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmluc2VydEhUTUxCZWZvcmUocGFyZW50LCBuZXh0U2libGluZywgaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBkaWRTZXRVc2VsZXNzQ29tbWVudCA9IGZhbHNlO1xuXG4gICAgICBsZXQgbmV4dFByZXZpb3VzID0gbmV4dFNpYmxpbmcgPyBuZXh0U2libGluZy5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnQubGFzdENoaWxkO1xuXG4gICAgICBpZiAobmV4dFByZXZpb3VzICYmIG5leHRQcmV2aW91cyBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgZGlkU2V0VXNlbGVzc0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMudXNlbGVzc0NvbW1lbnQsIG5leHRTaWJsaW5nKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGJvdW5kcyA9IHN1cGVyLmluc2VydEhUTUxCZWZvcmUocGFyZW50LCBuZXh0U2libGluZywgaHRtbCk7XG5cbiAgICAgIGlmIChkaWRTZXRVc2VsZXNzQ29tbWVudCkge1xuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy51c2VsZXNzQ29tbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBzaG91bGRBcHBseUZpeChkb2N1bWVudDogU2ltcGxlRG9jdW1lbnQpIHtcbiAgbGV0IG1lcmdpbmdUZXh0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgbWVyZ2luZ1RleHREaXYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ2ZpcnN0JykpO1xuICBtZXJnaW5nVGV4dERpdi5pbnNlcnRBZGphY2VudEhUTUwoSW5zZXJ0UG9zaXRpb24uYmVmb3JlZW5kLCAnc2Vjb25kJyk7XG5cbiAgaWYgKG1lcmdpbmdUZXh0RGl2LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gSXQgd29ya2VkIGFzIGV4cGVjdGVkLCBubyBmaXggcmVxdWlyZWRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cbiIsImltcG9ydCB7IEdsaW1tZXJUcmVlQ2hhbmdlcywgR2xpbW1lclRyZWVDb25zdHJ1Y3Rpb24sIE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgY2FzdFRvU2ltcGxlIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQge1xuICBBdHRyTmFtZXNwYWNlLFxuICBFbGVtZW50TmFtZXNwYWNlLFxuICBOYW1lc3BhY2UsXG4gIFNpbXBsZURvY3VtZW50LFxuICBTaW1wbGVFbGVtZW50LFxuICBTaW1wbGVOb2RlLFxufSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgYXBwbHlTVkdJbm5lckhUTUxGaXggfSBmcm9tICcuLi9jb21wYXQvc3ZnLWlubmVyLWh0bWwtZml4JztcbmltcG9ydCB7IGFwcGx5VGV4dE5vZGVNZXJnaW5nRml4IH0gZnJvbSAnLi4vY29tcGF0L3RleHQtbm9kZS1tZXJnaW5nLWZpeCc7XG5pbXBvcnQgeyBCTEFDS0xJU1RfVEFCTEUsIERPTU9wZXJhdGlvbnMgfSBmcm9tICcuL29wZXJhdGlvbnMnO1xuXG5bXG4gICdiJyxcbiAgJ2JpZycsXG4gICdibG9ja3F1b3RlJyxcbiAgJ2JvZHknLFxuICAnYnInLFxuICAnY2VudGVyJyxcbiAgJ2NvZGUnLFxuICAnZGQnLFxuICAnZGl2JyxcbiAgJ2RsJyxcbiAgJ2R0JyxcbiAgJ2VtJyxcbiAgJ2VtYmVkJyxcbiAgJ2gxJyxcbiAgJ2gyJyxcbiAgJ2gzJyxcbiAgJ2g0JyxcbiAgJ2g1JyxcbiAgJ2g2JyxcbiAgJ2hlYWQnLFxuICAnaHInLFxuICAnaScsXG4gICdpbWcnLFxuICAnbGknLFxuICAnbGlzdGluZycsXG4gICdtYWluJyxcbiAgJ21ldGEnLFxuICAnbm9icicsXG4gICdvbCcsXG4gICdwJyxcbiAgJ3ByZScsXG4gICdydWJ5JyxcbiAgJ3MnLFxuICAnc21hbGwnLFxuICAnc3BhbicsXG4gICdzdHJvbmcnLFxuICAnc3RyaWtlJyxcbiAgJ3N1YicsXG4gICdzdXAnLFxuICAndGFibGUnLFxuICAndHQnLFxuICAndScsXG4gICd1bCcsXG4gICd2YXInLFxuXS5mb3JFYWNoKCh0YWcpID0+IChCTEFDS0xJU1RfVEFCTEVbdGFnXSA9IDEpKTtcblxuY29uc3QgV0hJVEVTUEFDRSA9IC9bXFx0LVxcciBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMC1cXHUyMDBBXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHVGRUZGXS87XG5cbmxldCBkb2M6IE9wdGlvbjxTaW1wbGVEb2N1bWVudD4gPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IGNhc3RUb1NpbXBsZShkb2N1bWVudCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1doaXRlc3BhY2Uoc3RyaW5nOiBzdHJpbmcpIHtcbiAgcmV0dXJuIFdISVRFU1BBQ0UudGVzdChzdHJpbmcpO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIERPTSB7XG4gIGV4cG9ydCBjbGFzcyBUcmVlQ29uc3RydWN0aW9uIGV4dGVuZHMgRE9NT3BlcmF0aW9ucyBpbXBsZW1lbnRzIEdsaW1tZXJUcmVlQ29uc3RydWN0aW9uIHtcbiAgICBjcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlOiBFbGVtZW50TmFtZXNwYWNlLCB0YWc6IHN0cmluZyk6IFNpbXBsZUVsZW1lbnQge1xuICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnKTtcbiAgICB9XG5cbiAgICBzZXRBdHRyaWJ1dGUoXG4gICAgICBlbGVtZW50OiBTaW1wbGVFbGVtZW50LFxuICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgdmFsdWU6IHN0cmluZyxcbiAgICAgIG5hbWVzcGFjZTogT3B0aW9uPEF0dHJOYW1lc3BhY2U+ID0gbnVsbFxuICAgICkge1xuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCBhcHBsaWVkVHJlZUNvbnN0cnVjdGlvbiA9IFRyZWVDb25zdHJ1Y3Rpb247XG4gIGFwcGxpZWRUcmVlQ29uc3RydWN0aW9uID0gYXBwbHlUZXh0Tm9kZU1lcmdpbmdGaXgoXG4gICAgZG9jLFxuICAgIGFwcGxpZWRUcmVlQ29uc3RydWN0aW9uXG4gICkgYXMgdHlwZW9mIFRyZWVDb25zdHJ1Y3Rpb247XG4gIGFwcGxpZWRUcmVlQ29uc3RydWN0aW9uID0gYXBwbHlTVkdJbm5lckhUTUxGaXgoXG4gICAgZG9jLFxuICAgIGFwcGxpZWRUcmVlQ29uc3RydWN0aW9uLFxuICAgIE5hbWVzcGFjZS5TVkdcbiAgKSBhcyB0eXBlb2YgVHJlZUNvbnN0cnVjdGlvbjtcblxuICBleHBvcnQgY29uc3QgRE9NVHJlZUNvbnN0cnVjdGlvbiA9IGFwcGxpZWRUcmVlQ29uc3RydWN0aW9uO1xuICBleHBvcnQgdHlwZSBET01UcmVlQ29uc3RydWN0aW9uID0gVHJlZUNvbnN0cnVjdGlvbjtcbn1cblxuZXhwb3J0IGNsYXNzIERPTUNoYW5nZXNJbXBsIGV4dGVuZHMgRE9NT3BlcmF0aW9ucyBpbXBsZW1lbnRzIEdsaW1tZXJUcmVlQ2hhbmdlcyB7XG4gIHByb3RlY3RlZCBuYW1lc3BhY2U6IE9wdGlvbjxzdHJpbmc+O1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBkb2N1bWVudDogU2ltcGxlRG9jdW1lbnQpIHtcbiAgICBzdXBlcihkb2N1bWVudCk7XG4gICAgdGhpcy5uYW1lc3BhY2UgPSBudWxsO1xuICB9XG5cbiAgc2V0QXR0cmlidXRlKGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsIG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIHJlbW92ZUF0dHJpYnV0ZShlbGVtZW50OiBTaW1wbGVFbGVtZW50LCBuYW1lOiBzdHJpbmcpIHtcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxuXG4gIGluc2VydEFmdGVyKGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsIG5vZGU6IFNpbXBsZU5vZGUsIHJlZmVyZW5jZTogU2ltcGxlTm9kZSkge1xuICAgIHRoaXMuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIG5vZGUsIHJlZmVyZW5jZS5uZXh0U2libGluZyk7XG4gIH1cbn1cblxubGV0IGhlbHBlciA9IERPTUNoYW5nZXNJbXBsO1xuXG5oZWxwZXIgPSBhcHBseVRleHROb2RlTWVyZ2luZ0ZpeChkb2MsIGhlbHBlcikgYXMgdHlwZW9mIERPTUNoYW5nZXNJbXBsO1xuaGVscGVyID0gYXBwbHlTVkdJbm5lckhUTUxGaXgoZG9jLCBoZWxwZXIsIE5hbWVzcGFjZS5TVkcpIGFzIHR5cGVvZiBET01DaGFuZ2VzSW1wbDtcblxuZXhwb3J0IGRlZmF1bHQgaGVscGVyO1xuZXhwb3J0IGNvbnN0IERPTVRyZWVDb25zdHJ1Y3Rpb24gPSBET00uRE9NVHJlZUNvbnN0cnVjdGlvbjtcbmV4cG9ydCB0eXBlIERPTVRyZWVDb25zdHJ1Y3Rpb24gPSBET00uRE9NVHJlZUNvbnN0cnVjdGlvbjtcbmV4cG9ydCB0eXBlIERPTU5hbWVzcGFjZSA9IE5hbWVzcGFjZTtcbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7XG4gIEJvdW5kcyxcbiAgQ2FwdHVyZWRSZW5kZXJOb2RlLFxuICBEZWJ1Z1JlbmRlclRyZWUsXG4gIE9wdGlvbixcbiAgUmVuZGVyTm9kZSxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBleHBlY3QsIGFzc2lnbiwgU3RhY2sgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IHJlaWZ5QXJncyB9IGZyb20gJy4vdm0vYXJndW1lbnRzJztcblxuaW50ZXJmYWNlIEludGVybmFsUmVuZGVyTm9kZTxUIGV4dGVuZHMgb2JqZWN0PiBleHRlbmRzIFJlbmRlck5vZGUge1xuICBib3VuZHM6IE9wdGlvbjxCb3VuZHM+O1xuICByZWZzOiBTZXQ8UmVmPFQ+PjtcbiAgcGFyZW50PzogSW50ZXJuYWxSZW5kZXJOb2RlPFQ+O1xufVxuXG5sZXQgR1VJRCA9IDA7XG5cbmV4cG9ydCBjbGFzcyBSZWY8VCBleHRlbmRzIG9iamVjdD4ge1xuICByZWFkb25seSBpZDogbnVtYmVyID0gR1VJRCsrO1xuICBwcml2YXRlIHZhbHVlOiBPcHRpb248VD47XG5cbiAgY29uc3RydWN0b3IodmFsdWU6IFQpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBnZXQoKTogT3B0aW9uPFQ+IHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuXG4gIHJlbGVhc2UoKTogdm9pZCB7XG4gICAgaWYgKERFQlVHICYmIHRoaXMudmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQlVHOiBkb3VibGUgcmVsZWFzZT8nKTtcbiAgICB9XG5cbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgfVxuXG4gIHRvU3RyaW5nKCk6IFN0cmluZyB7XG4gICAgbGV0IGxhYmVsID0gYFJlZiAke3RoaXMuaWR9YDtcblxuICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gYCR7bGFiZWx9IChyZWxlYXNlZClgO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYCR7bGFiZWx9OiAke3RoaXMudmFsdWV9YDtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlYnVnUmVuZGVyVHJlZUltcGw8VEJ1Y2tldCBleHRlbmRzIG9iamVjdD5cbiAgaW1wbGVtZW50cyBEZWJ1Z1JlbmRlclRyZWU8VEJ1Y2tldD4ge1xuICBwcml2YXRlIHN0YWNrID0gbmV3IFN0YWNrPFRCdWNrZXQ+KCk7XG5cbiAgcHJpdmF0ZSByZWZzID0gbmV3IFdlYWtNYXA8VEJ1Y2tldCwgUmVmPFRCdWNrZXQ+PigpO1xuICBwcml2YXRlIHJvb3RzID0gbmV3IFNldDxSZWY8VEJ1Y2tldD4+KCk7XG4gIHByaXZhdGUgbm9kZXMgPSBuZXcgV2Vha01hcDxUQnVja2V0LCBJbnRlcm5hbFJlbmRlck5vZGU8VEJ1Y2tldD4+KCk7XG5cbiAgYmVnaW4oKTogdm9pZCB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgY3JlYXRlKHN0YXRlOiBUQnVja2V0LCBub2RlOiBSZW5kZXJOb2RlKTogdm9pZCB7XG4gICAgbGV0IGludGVybmFsTm9kZTogSW50ZXJuYWxSZW5kZXJOb2RlPFRCdWNrZXQ+ID0gYXNzaWduKHt9LCBub2RlLCB7XG4gICAgICBib3VuZHM6IG51bGwsXG4gICAgICByZWZzOiBuZXcgU2V0PFJlZjxUQnVja2V0Pj4oKSxcbiAgICB9KTtcbiAgICB0aGlzLm5vZGVzLnNldChzdGF0ZSwgaW50ZXJuYWxOb2RlKTtcbiAgICB0aGlzLmFwcGVuZENoaWxkKGludGVybmFsTm9kZSwgc3RhdGUpO1xuICAgIHRoaXMuZW50ZXIoc3RhdGUpO1xuICB9XG5cbiAgdXBkYXRlKHN0YXRlOiBUQnVja2V0KTogdm9pZCB7XG4gICAgdGhpcy5lbnRlcihzdGF0ZSk7XG4gIH1cblxuICBkaWRSZW5kZXIoc3RhdGU6IFRCdWNrZXQsIGJvdW5kczogQm91bmRzKTogdm9pZCB7XG4gICAgaWYgKERFQlVHICYmIHRoaXMuc3RhY2suY3VycmVudCAhPT0gc3RhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQlVHOiBleHBlY3RpbmcgJHt0aGlzLnN0YWNrLmN1cnJlbnR9LCBnb3QgJHtzdGF0ZX1gKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vZGVGb3Ioc3RhdGUpLmJvdW5kcyA9IGJvdW5kcztcbiAgICB0aGlzLmV4aXQoKTtcbiAgfVxuXG4gIHdpbGxEZXN0cm95KHN0YXRlOiBUQnVja2V0KTogdm9pZCB7XG4gICAgZXhwZWN0KHRoaXMucmVmcy5nZXQoc3RhdGUpLCAnQlVHOiBtaXNzaW5nIHJlZicpLnJlbGVhc2UoKTtcbiAgfVxuXG4gIGNvbW1pdCgpOiB2b2lkIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICBjYXB0dXJlKCk6IENhcHR1cmVkUmVuZGVyTm9kZVtdIHtcbiAgICByZXR1cm4gdGhpcy5jYXB0dXJlUmVmcyh0aGlzLnJvb3RzKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc3RhY2suc2l6ZSAhPT0gMCkge1xuICAgICAgLy8gV2UgcHJvYmFibHkgZW5jb3VudGVyZWQgYW4gZXJyb3IgZHVyaW5nIHRoZSByZW5kZXJpbmcgbG9vcC4gVGhpcyB3aWxsXG4gICAgICAvLyBsaWtlbHkgdHJpZ2dlciB1bmRlZmluZWQgYmVoYXZpb3IgYW5kIG1lbW9yeSBsZWFrcyBhcyB0aGUgZXJyb3IgbGVmdFxuICAgICAgLy8gdGhpbmdzIGluIGFuIGluY29uc2lzdGVudCBzdGF0ZS4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB0aGUgdXNlclxuICAgICAgLy8gcmVmcmVzaCB0aGUgcGFnZS5cblxuICAgICAgLy8gVE9ETzogV2UgY291bGQgd2FybiBoZXJlPyBCdXQgdGhpcyBoYXBwZW5zIGFsbCB0aGUgdGltZSBpbiBvdXIgdGVzdHM/XG5cbiAgICAgIC8vIENsZWFuIHVwIHRoZSByb290IHJlZmVyZW5jZSB0byBwcmV2ZW50IGVycm9ycyBmcm9tIGhhcHBlbmluZyBpZiB3ZVxuICAgICAgLy8gYXR0ZW1wdCB0byBjYXB0dXJlIHRoZSByZW5kZXIgdHJlZSAoRW1iZXIgSW5zcGVjdG9yIG1heSBkbyB0aGlzKVxuICAgICAgbGV0IHJvb3QgPSBleHBlY3QodGhpcy5zdGFjay50b0FycmF5KClbMF0sICdleHBlY3RlZCByb290IHN0YXRlIHdoZW4gcmVzZXR0aW5nIHJlbmRlciB0cmVlJyk7XG4gICAgICBsZXQgcmVmID0gdGhpcy5yZWZzLmdldChyb290KTtcblxuICAgICAgaWYgKHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucm9vdHMuZGVsZXRlKHJlZik7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlICghdGhpcy5zdGFjay5pc0VtcHR5KCkpIHtcbiAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGVudGVyKHN0YXRlOiBUQnVja2V0KTogdm9pZCB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHN0YXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgZXhpdCgpOiB2b2lkIHtcbiAgICBpZiAoREVCVUcgJiYgdGhpcy5zdGFjay5zaXplID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JVRzogdW5iYWxhbmNlZCBwb3AnKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBub2RlRm9yKHN0YXRlOiBUQnVja2V0KTogSW50ZXJuYWxSZW5kZXJOb2RlPFRCdWNrZXQ+IHtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXMubm9kZXMuZ2V0KHN0YXRlKSwgJ0JVRzogbWlzc2luZyBub2RlJyk7XG4gIH1cblxuICBwcml2YXRlIGFwcGVuZENoaWxkKG5vZGU6IEludGVybmFsUmVuZGVyTm9kZTxUQnVja2V0Piwgc3RhdGU6IFRCdWNrZXQpOiB2b2lkIHtcbiAgICBpZiAoREVCVUcgJiYgdGhpcy5yZWZzLmhhcyhzdGF0ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQlVHOiBjaGlsZCBhbHJlYWR5IGFwcGVuZGVkJyk7XG4gICAgfVxuXG4gICAgbGV0IHBhcmVudCA9IHRoaXMuc3RhY2suY3VycmVudDtcbiAgICBsZXQgcmVmID0gbmV3IFJlZihzdGF0ZSk7XG5cbiAgICB0aGlzLnJlZnMuc2V0KHN0YXRlLCByZWYpO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgbGV0IHBhcmVudE5vZGUgPSB0aGlzLm5vZGVGb3IocGFyZW50KTtcbiAgICAgIHBhcmVudE5vZGUucmVmcy5hZGQocmVmKTtcbiAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yb290cy5hZGQocmVmKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNhcHR1cmVSZWZzKHJlZnM6IFNldDxSZWY8VEJ1Y2tldD4+KTogQ2FwdHVyZWRSZW5kZXJOb2RlW10ge1xuICAgIGxldCBjYXB0dXJlZDogQ2FwdHVyZWRSZW5kZXJOb2RlW10gPSBbXTtcblxuICAgIHJlZnMuZm9yRWFjaCgocmVmKSA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSByZWYuZ2V0KCk7XG5cbiAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICBjYXB0dXJlZC5wdXNoKHRoaXMuY2FwdHVyZU5vZGUoYHJlbmRlci1ub2RlOiR7cmVmLmlkfWAsIHN0YXRlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNhcHR1cmVkO1xuICB9XG5cbiAgcHJpdmF0ZSBjYXB0dXJlTm9kZShpZDogc3RyaW5nLCBzdGF0ZTogVEJ1Y2tldCk6IENhcHR1cmVkUmVuZGVyTm9kZSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLm5vZGVGb3Ioc3RhdGUpO1xuICAgIGxldCB7IHR5cGUsIG5hbWUsIGFyZ3MsIGluc3RhbmNlLCByZWZzIH0gPSBub2RlO1xuICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMuY2FwdHVyZVRlbXBsYXRlKG5vZGUpO1xuICAgIGxldCBib3VuZHMgPSB0aGlzLmNhcHR1cmVCb3VuZHMobm9kZSk7XG4gICAgbGV0IGNoaWxkcmVuID0gdGhpcy5jYXB0dXJlUmVmcyhyZWZzKTtcbiAgICByZXR1cm4geyBpZCwgdHlwZSwgbmFtZSwgYXJnczogcmVpZnlBcmdzKGFyZ3MpLCBpbnN0YW5jZSwgdGVtcGxhdGUsIGJvdW5kcywgY2hpbGRyZW4gfTtcbiAgfVxuXG4gIHByaXZhdGUgY2FwdHVyZVRlbXBsYXRlKHsgdGVtcGxhdGUgfTogSW50ZXJuYWxSZW5kZXJOb2RlPFRCdWNrZXQ+KTogT3B0aW9uPHN0cmluZz4ge1xuICAgIHJldHVybiB0ZW1wbGF0ZSB8fCBudWxsO1xuICB9XG5cbiAgcHJpdmF0ZSBjYXB0dXJlQm91bmRzKG5vZGU6IEludGVybmFsUmVuZGVyTm9kZTxUQnVja2V0Pik6IENhcHR1cmVkUmVuZGVyTm9kZVsnYm91bmRzJ10ge1xuICAgIGxldCBib3VuZHMgPSBleHBlY3Qobm9kZS5ib3VuZHMsICdCVUc6IG1pc3NpbmcgYm91bmRzJyk7XG4gICAgbGV0IHBhcmVudEVsZW1lbnQgPSBib3VuZHMucGFyZW50RWxlbWVudCgpO1xuICAgIGxldCBmaXJzdE5vZGUgPSBib3VuZHMuZmlyc3ROb2RlKCk7XG4gICAgbGV0IGxhc3ROb2RlID0gYm91bmRzLmxhc3ROb2RlKCk7XG4gICAgcmV0dXJuIHsgcGFyZW50RWxlbWVudCwgZmlyc3ROb2RlLCBsYXN0Tm9kZSB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQge1xuICBFbnZpcm9ubWVudCxcbiAgRW52aXJvbm1lbnRPcHRpb25zLFxuICBHbGltbWVyVHJlZUNoYW5nZXMsXG4gIEdsaW1tZXJUcmVlQ29uc3RydWN0aW9uLFxuICBUcmFuc2FjdGlvbixcbiAgVHJhbnNhY3Rpb25TeW1ib2wsXG4gIFJ1bnRpbWVDb250ZXh0LFxuICBSdW50aW1lUmVzb2x2ZXIsXG4gIE9wdGlvbixcbiAgUnVudGltZUFydGlmYWN0cyxcbiAgQ29tcG9uZW50SW5zdGFuY2VXaXRoQ3JlYXRlLFxuICBNb2RpZmllckluc3RhbmNlLFxuICBJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcixcbiAgTW9kaWZpZXJJbnN0YW5jZVN0YXRlLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGFzc2VydCwgZXhwZWN0LCBzeW1ib2wgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IHRyYWNrLCB1cGRhdGVUYWcgfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHsgRE9NQ2hhbmdlc0ltcGwsIERPTVRyZWVDb25zdHJ1Y3Rpb24gfSBmcm9tICcuL2RvbS9oZWxwZXInO1xuaW1wb3J0IHsgUnVudGltZVByb2dyYW1JbXBsIH0gZnJvbSAnQGdsaW1tZXIvcHJvZ3JhbSc7XG5pbXBvcnQgRGVidWdSZW5kZXJUcmVlIGZyb20gJy4vZGVidWctcmVuZGVyLXRyZWUnO1xuXG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT046IFRyYW5zYWN0aW9uU3ltYm9sID0gc3ltYm9sKCdUUkFOU0FDVElPTicpO1xuXG5jbGFzcyBUcmFuc2FjdGlvbkltcGwgaW1wbGVtZW50cyBUcmFuc2FjdGlvbiB7XG4gIHB1YmxpYyBzY2hlZHVsZWRJbnN0YWxsTW9kaWZpZXJzOiBNb2RpZmllckluc3RhbmNlW10gPSBbXTtcbiAgcHVibGljIHNjaGVkdWxlZFVwZGF0ZU1vZGlmaWVyczogTW9kaWZpZXJJbnN0YW5jZVtdID0gW107XG4gIHB1YmxpYyBjcmVhdGVkQ29tcG9uZW50czogQ29tcG9uZW50SW5zdGFuY2VXaXRoQ3JlYXRlW10gPSBbXTtcbiAgcHVibGljIHVwZGF0ZWRDb21wb25lbnRzOiBDb21wb25lbnRJbnN0YW5jZVdpdGhDcmVhdGVbXSA9IFtdO1xuXG4gIGRpZENyZWF0ZShjb21wb25lbnQ6IENvbXBvbmVudEluc3RhbmNlV2l0aENyZWF0ZSkge1xuICAgIHRoaXMuY3JlYXRlZENvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICB9XG5cbiAgZGlkVXBkYXRlKGNvbXBvbmVudDogQ29tcG9uZW50SW5zdGFuY2VXaXRoQ3JlYXRlKSB7XG4gICAgdGhpcy51cGRhdGVkQ29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gIH1cblxuICBzY2hlZHVsZUluc3RhbGxNb2RpZmllcihtb2RpZmllcjogTW9kaWZpZXJJbnN0YW5jZSkge1xuICAgIHRoaXMuc2NoZWR1bGVkSW5zdGFsbE1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIHNjaGVkdWxlVXBkYXRlTW9kaWZpZXIobW9kaWZpZXI6IE1vZGlmaWVySW5zdGFuY2UpIHtcbiAgICB0aGlzLnNjaGVkdWxlZFVwZGF0ZU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIGNvbW1pdCgpIHtcbiAgICBsZXQgeyBjcmVhdGVkQ29tcG9uZW50cywgdXBkYXRlZENvbXBvbmVudHMgfSA9IHRoaXM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNyZWF0ZWRDb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgeyBtYW5hZ2VyLCBzdGF0ZSB9ID0gY3JlYXRlZENvbXBvbmVudHNbaV07XG4gICAgICBtYW5hZ2VyLmRpZENyZWF0ZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cGRhdGVkQ29tcG9uZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHsgbWFuYWdlciwgc3RhdGUgfSA9IHVwZGF0ZWRDb21wb25lbnRzW2ldO1xuICAgICAgbWFuYWdlci5kaWRVcGRhdGUoc3RhdGUpO1xuICAgIH1cblxuICAgIGxldCB7IHNjaGVkdWxlZEluc3RhbGxNb2RpZmllcnMsIHNjaGVkdWxlZFVwZGF0ZU1vZGlmaWVycyB9ID0gdGhpcztcblxuICAgIC8vIFByZXZlbnQgYSB0cmFuc3BpbGF0aW9uIGlzc3VlIHdlIGd1YXJkIGFnYWluc3QgaW4gRW1iZXIsIHRoZVxuICAgIC8vIHRocm93LWlmLWNsb3N1cmUtcmVxdWlyZWQgaXNzdWVcbiAgICBsZXQgbWFuYWdlcjogSW50ZXJuYWxNb2RpZmllck1hbmFnZXIsIHN0YXRlOiBNb2RpZmllckluc3RhbmNlU3RhdGU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjaGVkdWxlZEluc3RhbGxNb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBtb2RpZmllciA9IHNjaGVkdWxlZEluc3RhbGxNb2RpZmllcnNbaV07XG4gICAgICBtYW5hZ2VyID0gbW9kaWZpZXIubWFuYWdlcjtcbiAgICAgIHN0YXRlID0gbW9kaWZpZXIuc3RhdGU7XG5cbiAgICAgIGxldCBtb2RpZmllclRhZyA9IG1hbmFnZXIuZ2V0VGFnKHN0YXRlKTtcblxuICAgICAgaWYgKG1vZGlmaWVyVGFnICE9PSBudWxsKSB7XG4gICAgICAgIGxldCB0YWcgPSB0cmFjayhcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgICAgKCkgPT4gbWFuYWdlci5pbnN0YWxsKHN0YXRlKSxcbiAgICAgICAgICBERUJVRyAmJlxuICAgICAgICAgICAgYC0gV2hpbGUgcmVuZGVyaW5nOlxcbiAgKGluc3RhbmNlIG9mIGEgXFxgJHtcbiAgICAgICAgICAgICAgbW9kaWZpZXIuZGVmaW5pdGlvbi5yZXNvbHZlZE5hbWUgfHwgbWFuYWdlci5nZXREZWJ1Z05hbWUobW9kaWZpZXIuZGVmaW5pdGlvbi5zdGF0ZSlcbiAgICAgICAgICAgIH1cXGAgbW9kaWZpZXIpYFxuICAgICAgICApO1xuICAgICAgICB1cGRhdGVUYWcobW9kaWZpZXJUYWcsIHRhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYW5hZ2VyLmluc3RhbGwoc3RhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NoZWR1bGVkVXBkYXRlTW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbW9kaWZpZXIgPSBzY2hlZHVsZWRVcGRhdGVNb2RpZmllcnNbaV07XG4gICAgICBtYW5hZ2VyID0gbW9kaWZpZXIubWFuYWdlcjtcbiAgICAgIHN0YXRlID0gbW9kaWZpZXIuc3RhdGU7XG5cbiAgICAgIGxldCBtb2RpZmllclRhZyA9IG1hbmFnZXIuZ2V0VGFnKHN0YXRlKTtcblxuICAgICAgaWYgKG1vZGlmaWVyVGFnICE9PSBudWxsKSB7XG4gICAgICAgIGxldCB0YWcgPSB0cmFjayhcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgICAgKCkgPT4gbWFuYWdlci51cGRhdGUoc3RhdGUpLFxuICAgICAgICAgIERFQlVHICYmXG4gICAgICAgICAgICBgLSBXaGlsZSByZW5kZXJpbmc6XFxuICAoaW5zdGFuY2Ugb2YgYSBcXGAke1xuICAgICAgICAgICAgICBtb2RpZmllci5kZWZpbml0aW9uLnJlc29sdmVkTmFtZSB8fCBtYW5hZ2VyLmdldERlYnVnTmFtZShtb2RpZmllci5kZWZpbml0aW9uLnN0YXRlKVxuICAgICAgICAgICAgfVxcYCBtb2RpZmllcilgXG4gICAgICAgICk7XG4gICAgICAgIHVwZGF0ZVRhZyhtb2RpZmllclRhZywgdGFnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hbmFnZXIudXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEVudmlyb25tZW50SW1wbCBpbXBsZW1lbnRzIEVudmlyb25tZW50IHtcbiAgW1RSQU5TQUNUSU9OXTogT3B0aW9uPFRyYW5zYWN0aW9uSW1wbD4gPSBudWxsO1xuXG4gIHByb3RlY3RlZCBhcHBlbmRPcGVyYXRpb25zITogR2xpbW1lclRyZWVDb25zdHJ1Y3Rpb247XG4gIHByb3RlY3RlZCB1cGRhdGVPcGVyYXRpb25zPzogR2xpbW1lclRyZWVDaGFuZ2VzO1xuXG4gIC8vIERlbGVnYXRlIG1ldGhvZHMgYW5kIHZhbHVlc1xuICBwdWJsaWMgaXNJbnRlcmFjdGl2ZSA9IHRoaXMuZGVsZWdhdGUuaXNJbnRlcmFjdGl2ZTtcblxuICBkZWJ1Z1JlbmRlclRyZWUgPSB0aGlzLmRlbGVnYXRlLmVuYWJsZURlYnVnVG9vbGluZyA/IG5ldyBEZWJ1Z1JlbmRlclRyZWUoKSA6IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zOiBFbnZpcm9ubWVudE9wdGlvbnMsIHByaXZhdGUgZGVsZWdhdGU6IEVudmlyb25tZW50RGVsZWdhdGUpIHtcbiAgICBpZiAob3B0aW9ucy5hcHBlbmRPcGVyYXRpb25zKSB7XG4gICAgICB0aGlzLmFwcGVuZE9wZXJhdGlvbnMgPSBvcHRpb25zLmFwcGVuZE9wZXJhdGlvbnM7XG4gICAgICB0aGlzLnVwZGF0ZU9wZXJhdGlvbnMgPSBvcHRpb25zLnVwZGF0ZU9wZXJhdGlvbnM7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmRvY3VtZW50KSB7XG4gICAgICB0aGlzLmFwcGVuZE9wZXJhdGlvbnMgPSBuZXcgRE9NVHJlZUNvbnN0cnVjdGlvbihvcHRpb25zLmRvY3VtZW50KTtcbiAgICAgIHRoaXMudXBkYXRlT3BlcmF0aW9ucyA9IG5ldyBET01DaGFuZ2VzSW1wbChvcHRpb25zLmRvY3VtZW50KTtcbiAgICB9IGVsc2UgaWYgKERFQlVHKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3lvdSBtdXN0IHBhc3MgZG9jdW1lbnQgb3IgYXBwZW5kT3BlcmF0aW9ucyB0byBhIG5ldyBydW50aW1lJyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0QXBwZW5kT3BlcmF0aW9ucygpOiBHbGltbWVyVHJlZUNvbnN0cnVjdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kT3BlcmF0aW9ucztcbiAgfVxuXG4gIGdldERPTSgpOiBHbGltbWVyVHJlZUNoYW5nZXMge1xuICAgIHJldHVybiBleHBlY3QoXG4gICAgICB0aGlzLnVwZGF0ZU9wZXJhdGlvbnMsXG4gICAgICAnQXR0ZW1wdGVkIHRvIGdldCBET00gdXBkYXRlT3BlcmF0aW9ucywgYnV0IHRoZXkgd2VyZSBub3QgcHJvdmlkZWQgYnkgdGhlIGVudmlyb25tZW50LiBZb3UgbWF5IGJlIGF0dGVtcHRpbmcgdG8gcmVyZW5kZXIgaW4gYW4gZW52aXJvbm1lbnQgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCByZXJlbmRlcmluZywgc3VjaCBhcyBTU1IuJ1xuICAgICk7XG4gIH1cblxuICBiZWdpbigpIHtcbiAgICBhc3NlcnQoXG4gICAgICAhdGhpc1tUUkFOU0FDVElPTl0sXG4gICAgICAnQSBnbGltbWVyIHRyYW5zYWN0aW9uIHdhcyBiZWd1biwgYnV0IG9uZSBhbHJlYWR5IGV4aXN0cy4gWW91IG1heSBoYXZlIGEgbmVzdGVkIHRyYW5zYWN0aW9uLCBwb3NzaWJseSBjYXVzZWQgYnkgYW4gZWFybGllciBydW50aW1lIGV4Y2VwdGlvbiB3aGlsZSByZW5kZXJpbmcuIFBsZWFzZSBjaGVjayB5b3VyIGNvbnNvbGUgZm9yIHRoZSBzdGFjayB0cmFjZSBvZiBhbnkgcHJpb3IgZXhjZXB0aW9ucy4nXG4gICAgKTtcblxuICAgIHRoaXMuZGVidWdSZW5kZXJUcmVlPy5iZWdpbigpO1xuXG4gICAgdGhpc1tUUkFOU0FDVElPTl0gPSBuZXcgVHJhbnNhY3Rpb25JbXBsKCk7XG4gIH1cblxuICBwcml2YXRlIGdldCB0cmFuc2FjdGlvbigpOiBUcmFuc2FjdGlvbkltcGwge1xuICAgIHJldHVybiBleHBlY3QodGhpc1tUUkFOU0FDVElPTl0hLCAnbXVzdCBiZSBpbiBhIHRyYW5zYWN0aW9uJyk7XG4gIH1cblxuICBkaWRDcmVhdGUoY29tcG9uZW50OiBDb21wb25lbnRJbnN0YW5jZVdpdGhDcmVhdGUpIHtcbiAgICB0aGlzLnRyYW5zYWN0aW9uLmRpZENyZWF0ZShjb21wb25lbnQpO1xuICB9XG5cbiAgZGlkVXBkYXRlKGNvbXBvbmVudDogQ29tcG9uZW50SW5zdGFuY2VXaXRoQ3JlYXRlKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbi5kaWRVcGRhdGUoY29tcG9uZW50KTtcbiAgfVxuXG4gIHNjaGVkdWxlSW5zdGFsbE1vZGlmaWVyKG1vZGlmaWVyOiBNb2RpZmllckluc3RhbmNlKSB7XG4gICAgaWYgKHRoaXMuaXNJbnRlcmFjdGl2ZSkge1xuICAgICAgdGhpcy50cmFuc2FjdGlvbi5zY2hlZHVsZUluc3RhbGxNb2RpZmllcihtb2RpZmllcik7XG4gICAgfVxuICB9XG5cbiAgc2NoZWR1bGVVcGRhdGVNb2RpZmllcihtb2RpZmllcjogTW9kaWZpZXJJbnN0YW5jZSkge1xuICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpdmUpIHtcbiAgICAgIHRoaXMudHJhbnNhY3Rpb24uc2NoZWR1bGVVcGRhdGVNb2RpZmllcihtb2RpZmllcik7XG4gICAgfVxuICB9XG5cbiAgY29tbWl0KCkge1xuICAgIGxldCB0cmFuc2FjdGlvbiA9IHRoaXMudHJhbnNhY3Rpb247XG4gICAgdGhpc1tUUkFOU0FDVElPTl0gPSBudWxsO1xuICAgIHRyYW5zYWN0aW9uLmNvbW1pdCgpO1xuXG4gICAgdGhpcy5kZWJ1Z1JlbmRlclRyZWU/LmNvbW1pdCgpO1xuXG4gICAgdGhpcy5kZWxlZ2F0ZS5vblRyYW5zYWN0aW9uQ29tbWl0KCk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbnZpcm9ubWVudERlbGVnYXRlIHtcbiAgLyoqXG4gICAqIFVzZWQgdG8gZGV0ZXJtaW5lIHRoZSB0aGUgZW52aXJvbm1lbnQgaXMgaW50ZXJhY3RpdmUgKGUuZy4gU1NSIGlzIG5vdFxuICAgKiBpbnRlcmFjdGl2ZSkuIEludGVyYWN0aXZlIGVudmlyb25tZW50cyBzY2hlZHVsZSBtb2RpZmllcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cbiAgICovXG4gIGlzSW50ZXJhY3RpdmU6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gZW5hYmxlIGRlYnVnIHRvb2xpbmdcbiAgICovXG4gIGVuYWJsZURlYnVnVG9vbGluZzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gYW4gZW52aXJvbm1lbnQgdHJhbnNhY3Rpb24gY29tbWl0c1xuICAgKi9cbiAgb25UcmFuc2FjdGlvbkNvbW1pdDogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJ1bnRpbWVDb250ZXh0KFxuICBvcHRpb25zOiBFbnZpcm9ubWVudE9wdGlvbnMsXG4gIGRlbGVnYXRlOiBFbnZpcm9ubWVudERlbGVnYXRlLFxuICBhcnRpZmFjdHM6IFJ1bnRpbWVBcnRpZmFjdHMsXG4gIHJlc29sdmVyOiBSdW50aW1lUmVzb2x2ZXJcbik6IFJ1bnRpbWVDb250ZXh0IHtcbiAgcmV0dXJuIHtcbiAgICBlbnY6IG5ldyBFbnZpcm9ubWVudEltcGwob3B0aW9ucywgZGVsZWdhdGUpLFxuICAgIHByb2dyYW06IG5ldyBSdW50aW1lUHJvZ3JhbUltcGwoYXJ0aWZhY3RzLmNvbnN0YW50cywgYXJ0aWZhY3RzLmhlYXApLFxuICAgIHJlc29sdmVyOiByZXNvbHZlcixcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluVHJhbnNhY3Rpb24oZW52OiBFbnZpcm9ubWVudCwgY2I6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgaWYgKCFlbnZbVFJBTlNBQ1RJT05dKSB7XG4gICAgZW52LmJlZ2luKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVudi5jb21taXQoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFbnZpcm9ubWVudEltcGw7XG4iLCJpbXBvcnQgeyBPcHRpb24sIFJ1bnRpbWVIZWFwLCBNYWNoaW5lT3AsIFJ1bnRpbWVQcm9ncmFtLCBSdW50aW1lT3AgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IEFQUEVORF9PUENPREVTIH0gZnJvbSAnLi4vb3Bjb2Rlcyc7XG5pbXBvcnQgVk0gZnJvbSAnLi9hcHBlbmQnO1xuaW1wb3J0IHsgTE9DQUxfREVCVUcgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBNYWNoaW5lUmVnaXN0ZXIsICRwYywgJHJhLCAkZnAsICRzcCB9IGZyb20gJ0BnbGltbWVyL3ZtJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvd0xldmVsUmVnaXN0ZXJzIHtcbiAgW01hY2hpbmVSZWdpc3Rlci5wY106IG51bWJlcjtcbiAgW01hY2hpbmVSZWdpc3Rlci5yYV06IG51bWJlcjtcbiAgW01hY2hpbmVSZWdpc3Rlci5zcF06IG51bWJlcjtcbiAgW01hY2hpbmVSZWdpc3Rlci5mcF06IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVSZWdpc3RlcnMoKTogTG93TGV2ZWxSZWdpc3RlcnMge1xuICByZXR1cm4gWzAsIC0xLCAwLCAwXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVSZWdpc3RlcnNXaXRoU1Aoc3A6IG51bWJlcik6IExvd0xldmVsUmVnaXN0ZXJzIHtcbiAgcmV0dXJuIFswLCAtMSwgc3AsIDBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZVJlZ2lzdGVyc1dpdGhQQyhwYzogbnVtYmVyKTogTG93TGV2ZWxSZWdpc3RlcnMge1xuICByZXR1cm4gW3BjLCAtMSwgMCwgMF07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhY2sge1xuICBwdXNoKHZhbHVlOiB1bmtub3duKTogdm9pZDtcbiAgZ2V0KHBvc2l0aW9uOiBudW1iZXIpOiBudW1iZXI7XG4gIHBvcDxUPigpOiBUO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4dGVybnMge1xuICBkZWJ1Z0JlZm9yZShvcGNvZGU6IFJ1bnRpbWVPcCk6IHVua25vd247XG4gIGRlYnVnQWZ0ZXIoc3RhdGU6IHVua25vd24pOiB2b2lkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMb3dMZXZlbFZNIHtcbiAgcHVibGljIGN1cnJlbnRPcFNpemUgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBzdGFjazogU3RhY2ssXG4gICAgcHVibGljIGhlYXA6IFJ1bnRpbWVIZWFwLFxuICAgIHB1YmxpYyBwcm9ncmFtOiBSdW50aW1lUHJvZ3JhbSxcbiAgICBwdWJsaWMgZXh0ZXJuczogRXh0ZXJucyxcbiAgICByZWFkb25seSByZWdpc3RlcnM6IExvd0xldmVsUmVnaXN0ZXJzXG4gICkge31cblxuICBmZXRjaFJlZ2lzdGVyKHJlZ2lzdGVyOiBNYWNoaW5lUmVnaXN0ZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyc1tyZWdpc3Rlcl07XG4gIH1cblxuICBsb2FkUmVnaXN0ZXIocmVnaXN0ZXI6IE1hY2hpbmVSZWdpc3RlciwgdmFsdWU6IG51bWJlcikge1xuICAgIHRoaXMucmVnaXN0ZXJzW3JlZ2lzdGVyXSA9IHZhbHVlO1xuICB9XG5cbiAgc2V0UGMocGM6IG51bWJlcik6IHZvaWQge1xuICAgIGFzc2VydCh0eXBlb2YgcGMgPT09ICdudW1iZXInICYmICFpc05hTihwYyksICdwYyBpcyBzZXQgdG8gYSBudW1iZXInKTtcbiAgICB0aGlzLnJlZ2lzdGVyc1skcGNdID0gcGM7XG4gIH1cblxuICAvLyBTdGFydCBhIG5ldyBmcmFtZSBhbmQgc2F2ZSAkcmEgYW5kICRmcCBvbiB0aGUgc3RhY2tcbiAgcHVzaEZyYW1lKCkge1xuICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnJlZ2lzdGVyc1skcmFdKTtcbiAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5yZWdpc3RlcnNbJGZwXSk7XG4gICAgdGhpcy5yZWdpc3RlcnNbJGZwXSA9IHRoaXMucmVnaXN0ZXJzWyRzcF0gLSAxO1xuICB9XG5cbiAgLy8gUmVzdG9yZSAkcmEsICRzcCBhbmQgJGZwXG4gIHBvcEZyYW1lKCkge1xuICAgIHRoaXMucmVnaXN0ZXJzWyRzcF0gPSB0aGlzLnJlZ2lzdGVyc1skZnBdIC0gMTtcbiAgICB0aGlzLnJlZ2lzdGVyc1skcmFdID0gdGhpcy5zdGFjay5nZXQoMCk7XG4gICAgdGhpcy5yZWdpc3RlcnNbJGZwXSA9IHRoaXMuc3RhY2suZ2V0KDEpO1xuICB9XG5cbiAgcHVzaFNtYWxsRnJhbWUoKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHRoaXMucmVnaXN0ZXJzWyRyYV0pO1xuICB9XG5cbiAgcG9wU21hbGxGcmFtZSgpIHtcbiAgICB0aGlzLnJlZ2lzdGVyc1skcmFdID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgfVxuXG4gIC8vIEp1bXAgdG8gYW4gYWRkcmVzcyBpbiBgcHJvZ3JhbWBcbiAgZ290byhvZmZzZXQ6IG51bWJlcikge1xuICAgIHRoaXMuc2V0UGModGhpcy50YXJnZXQob2Zmc2V0KSk7XG4gIH1cblxuICB0YXJnZXQob2Zmc2V0OiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlcnNbJHBjXSArIG9mZnNldCAtIHRoaXMuY3VycmVudE9wU2l6ZTtcbiAgfVxuXG4gIC8vIFNhdmUgJHBjIGludG8gJHJhLCB0aGVuIGp1bXAgdG8gYSBuZXcgYWRkcmVzcyBpbiBgcHJvZ3JhbWAgKGphbCBpbiBNSVBTKVxuICBjYWxsKGhhbmRsZTogbnVtYmVyKSB7XG4gICAgYXNzZXJ0KGhhbmRsZSA8IDB4ZmZmZmZmZmYsIGBKdW1waW5nIHRvIHBsYWNlaG9sZGVyIGFkZHJlc3NgKTtcblxuICAgIHRoaXMucmVnaXN0ZXJzWyRyYV0gPSB0aGlzLnJlZ2lzdGVyc1skcGNdO1xuICAgIHRoaXMuc2V0UGModGhpcy5oZWFwLmdldGFkZHIoaGFuZGxlKSk7XG4gIH1cblxuICAvLyBQdXQgYSBzcGVjaWZpYyBgcHJvZ3JhbWAgYWRkcmVzcyBpbiAkcmFcbiAgcmV0dXJuVG8ob2Zmc2V0OiBudW1iZXIpIHtcbiAgICB0aGlzLnJlZ2lzdGVyc1skcmFdID0gdGhpcy50YXJnZXQob2Zmc2V0KTtcbiAgfVxuXG4gIC8vIFJldHVybiB0byB0aGUgYHByb2dyYW1gIGFkZHJlc3Mgc3RvcmVkIGluICRyYVxuICByZXR1cm4oKSB7XG4gICAgdGhpcy5zZXRQYyh0aGlzLnJlZ2lzdGVyc1skcmFdKTtcbiAgfVxuXG4gIG5leHRTdGF0ZW1lbnQoKTogT3B0aW9uPFJ1bnRpbWVPcD4ge1xuICAgIGxldCB7IHJlZ2lzdGVycywgcHJvZ3JhbSB9ID0gdGhpcztcblxuICAgIGxldCBwYyA9IHJlZ2lzdGVyc1skcGNdO1xuXG4gICAgYXNzZXJ0KHR5cGVvZiBwYyA9PT0gJ251bWJlcicsICdwYyBpcyBhIG51bWJlcicpO1xuXG4gICAgaWYgKHBjID09PSAtMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSB0byBzYXZlIG9mZiB0aGUgY3VycmVudCBvcGVyYXRpb25zIHNpemUgc28gdGhhdFxuICAgIC8vIHdoZW4gd2UgZG8gYSBqdW1wIHdlIGNhbiBjYWxjdWxhdGUgdGhlIGNvcnJlY3Qgb2Zmc2V0XG4gICAgLy8gdG8gd2hlcmUgd2UgYXJlIGdvaW5nLiBXZSBjYW4ndCBzaW1wbHkgYXNrIGZvciB0aGUgc2l6ZVxuICAgIC8vIGluIGEganVtcCBiZWNhdXNlIHdlIGhhdmUgaGF2ZSBhbHJlYWR5IGluY3JlbWVudGVkIHRoZVxuICAgIC8vIHByb2dyYW0gY291bnRlciB0byB0aGUgbmV4dCBpbnN0cnVjdGlvbiBwcmlvciB0byBleGVjdXRpbmcuXG4gICAgbGV0IG9wY29kZSA9IHByb2dyYW0ub3Bjb2RlKHBjKTtcbiAgICBsZXQgb3BlcmF0aW9uU2l6ZSA9ICh0aGlzLmN1cnJlbnRPcFNpemUgPSBvcGNvZGUuc2l6ZSk7XG4gICAgdGhpcy5yZWdpc3RlcnNbJHBjXSArPSBvcGVyYXRpb25TaXplO1xuXG4gICAgcmV0dXJuIG9wY29kZTtcbiAgfVxuXG4gIGV2YWx1YXRlT3V0ZXIob3Bjb2RlOiBSdW50aW1lT3AsIHZtOiBWTSkge1xuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgbGV0IHtcbiAgICAgICAgZXh0ZXJuczogeyBkZWJ1Z0JlZm9yZSwgZGVidWdBZnRlciB9LFxuICAgICAgfSA9IHRoaXM7XG4gICAgICBsZXQgc3RhdGUgPSBkZWJ1Z0JlZm9yZShvcGNvZGUpO1xuICAgICAgdGhpcy5ldmFsdWF0ZUlubmVyKG9wY29kZSwgdm0pO1xuICAgICAgZGVidWdBZnRlcihzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXZhbHVhdGVJbm5lcihvcGNvZGUsIHZtKTtcbiAgICB9XG4gIH1cblxuICBldmFsdWF0ZUlubmVyKG9wY29kZTogUnVudGltZU9wLCB2bTogVk0pIHtcbiAgICBpZiAob3Bjb2RlLmlzTWFjaGluZSkge1xuICAgICAgdGhpcy5ldmFsdWF0ZU1hY2hpbmUob3Bjb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ldmFsdWF0ZVN5c2NhbGwob3Bjb2RlLCB2bSk7XG4gICAgfVxuICB9XG5cbiAgZXZhbHVhdGVNYWNoaW5lKG9wY29kZTogUnVudGltZU9wKSB7XG4gICAgc3dpdGNoIChvcGNvZGUudHlwZSkge1xuICAgICAgY2FzZSBNYWNoaW5lT3AuUHVzaEZyYW1lOlxuICAgICAgICByZXR1cm4gdGhpcy5wdXNoRnJhbWUoKTtcbiAgICAgIGNhc2UgTWFjaGluZU9wLlBvcEZyYW1lOlxuICAgICAgICByZXR1cm4gdGhpcy5wb3BGcmFtZSgpO1xuICAgICAgY2FzZSBNYWNoaW5lT3AuSW52b2tlU3RhdGljOlxuICAgICAgICByZXR1cm4gdGhpcy5jYWxsKG9wY29kZS5vcDEpO1xuICAgICAgY2FzZSBNYWNoaW5lT3AuSW52b2tlVmlydHVhbDpcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbCh0aGlzLnN0YWNrLnBvcCgpKTtcbiAgICAgIGNhc2UgTWFjaGluZU9wLkp1bXA6XG4gICAgICAgIHJldHVybiB0aGlzLmdvdG8ob3Bjb2RlLm9wMSk7XG4gICAgICBjYXNlIE1hY2hpbmVPcC5SZXR1cm46XG4gICAgICAgIHJldHVybiB0aGlzLnJldHVybigpO1xuICAgICAgY2FzZSBNYWNoaW5lT3AuUmV0dXJuVG86XG4gICAgICAgIHJldHVybiB0aGlzLnJldHVyblRvKG9wY29kZS5vcDEpO1xuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlU3lzY2FsbChvcGNvZGU6IFJ1bnRpbWVPcCwgdm06IFZNKSB7XG4gICAgQVBQRU5EX09QQ09ERVMuZXZhbHVhdGUodm0sIG9wY29kZSwgb3Bjb2RlLnR5cGUpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQge1xuICBCb3VuZHMsXG4gIER5bmFtaWNTY29wZSxcbiAgRWxlbWVudEJ1aWxkZXIsXG4gIEVudmlyb25tZW50LFxuICBFeGNlcHRpb25IYW5kbGVyLFxuICBHbGltbWVyVHJlZUNoYW5nZXMsXG4gIExpdmVCbG9jayxcbiAgT3B0aW9uLFxuICBSdW50aW1lQ29udGV4dCxcbiAgU2NvcGUsXG4gIFVwZGF0YWJsZUJsb2NrLFxuICBVcGRhdGluZ1ZNLFxuICBVcGRhdGluZ09wY29kZSxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBMT0NBTF9ERUJVRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7XG4gIE9wYXF1ZUl0ZXJhdGlvbkl0ZW0sXG4gIE9wYXF1ZUl0ZXJhdG9yLFxuICBSZWZlcmVuY2UsXG4gIHVwZGF0ZVJlZixcbiAgdmFsdWVGb3JSZWYsXG59IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkLCBkZXN0cm95LCBkZXN0cm95Q2hpbGRyZW4gfSBmcm9tICdAZ2xpbW1lci9kZXN0cm95YWJsZSc7XG5pbXBvcnQgeyBleHBlY3QsIFN0YWNrLCBsb2dTdGVwIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyByZXNldFRyYWNraW5nLCBydW5JblRyYWNraW5nVHJhbnNhY3Rpb24gfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHsgU2ltcGxlQ29tbWVudCB9IGZyb20gJ0BzaW1wbGUtZG9tL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBjbGVhciwgbW92ZSBhcyBtb3ZlQm91bmRzIH0gZnJvbSAnLi4vYm91bmRzJztcbmltcG9ydCB7IEludGVybmFsVk0sIFZtSW5pdENhbGxiYWNrIH0gZnJvbSAnLi9hcHBlbmQnO1xuaW1wb3J0IHsgTGl2ZUJsb2NrTGlzdCwgTmV3RWxlbWVudEJ1aWxkZXIgfSBmcm9tICcuL2VsZW1lbnQtYnVpbGRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVwZGF0aW5nVk1JbXBsIGltcGxlbWVudHMgVXBkYXRpbmdWTSB7XG4gIHB1YmxpYyBlbnY6IEVudmlyb25tZW50O1xuICBwdWJsaWMgZG9tOiBHbGltbWVyVHJlZUNoYW5nZXM7XG4gIHB1YmxpYyBhbHdheXNSZXZhbGlkYXRlOiBib29sZWFuO1xuXG4gIHByaXZhdGUgZnJhbWVTdGFjazogU3RhY2s8VXBkYXRpbmdWTUZyYW1lPiA9IG5ldyBTdGFjazxVcGRhdGluZ1ZNRnJhbWU+KCk7XG5cbiAgY29uc3RydWN0b3IoZW52OiBFbnZpcm9ubWVudCwgeyBhbHdheXNSZXZhbGlkYXRlID0gZmFsc2UgfSkge1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIHRoaXMuZG9tID0gZW52LmdldERPTSgpO1xuICAgIHRoaXMuYWx3YXlzUmV2YWxpZGF0ZSA9IGFsd2F5c1JldmFsaWRhdGU7XG4gIH1cblxuICBleGVjdXRlKG9wY29kZXM6IFVwZGF0aW5nT3Bjb2RlW10sIGhhbmRsZXI6IEV4Y2VwdGlvbkhhbmRsZXIpIHtcbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIGxldCBoYXNFcnJvcmVkID0gdHJ1ZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJ1bkluVHJhY2tpbmdUcmFuc2FjdGlvbiEoKCkgPT4gdGhpcy5fZXhlY3V0ZShvcGNvZGVzLCBoYW5kbGVyKSwgJy0gV2hpbGUgcmVuZGVyaW5nOicpO1xuXG4gICAgICAgIC8vIHVzaW5nIGEgYm9vbGVhbiBoZXJlIHRvIGF2b2lkIGJyZWFraW5nIGVyZ29ub21pY3Mgb2YgXCJwYXVzZSBvbiB1bmNhdWdodCBleGNlcHRpb25zXCJcbiAgICAgICAgLy8gd2hpY2ggd291bGQgaGFwcGVuIHdpdGggYSBgY2F0Y2hgICsgYHRocm93YFxuICAgICAgICBoYXNFcnJvcmVkID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoaGFzRXJyb3JlZCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgXFxuXFxuRXJyb3Igb2NjdXJyZWQ6XFxuXFxuJHtyZXNldFRyYWNraW5nKCl9XFxuXFxuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZXhlY3V0ZShvcGNvZGVzLCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9leGVjdXRlKG9wY29kZXM6IFVwZGF0aW5nT3Bjb2RlW10sIGhhbmRsZXI6IEV4Y2VwdGlvbkhhbmRsZXIpIHtcbiAgICBsZXQgeyBmcmFtZVN0YWNrIH0gPSB0aGlzO1xuXG4gICAgdGhpcy50cnkob3Bjb2RlcywgaGFuZGxlcik7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGZyYW1lU3RhY2suaXNFbXB0eSgpKSBicmVhaztcblxuICAgICAgbGV0IG9wY29kZSA9IHRoaXMuZnJhbWUubmV4dFN0YXRlbWVudCgpO1xuXG4gICAgICBpZiAob3Bjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZnJhbWVTdGFjay5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG9wY29kZS5ldmFsdWF0ZSh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldCBmcmFtZSgpIHtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXMuZnJhbWVTdGFjay5jdXJyZW50LCAnYnVnOiBleHBlY3RlZCBhIGZyYW1lJyk7XG4gIH1cblxuICBnb3RvKGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLmZyYW1lLmdvdG8oaW5kZXgpO1xuICB9XG5cbiAgdHJ5KG9wczogVXBkYXRpbmdPcGNvZGVbXSwgaGFuZGxlcjogT3B0aW9uPEV4Y2VwdGlvbkhhbmRsZXI+KSB7XG4gICAgdGhpcy5mcmFtZVN0YWNrLnB1c2gobmV3IFVwZGF0aW5nVk1GcmFtZShvcHMsIGhhbmRsZXIpKTtcbiAgfVxuXG4gIHRocm93KCkge1xuICAgIHRoaXMuZnJhbWUuaGFuZGxlRXhjZXB0aW9uKCk7XG4gICAgdGhpcy5mcmFtZVN0YWNrLnBvcCgpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVk1TdGF0ZSB7XG4gIHJlYWRvbmx5IHBjOiBudW1iZXI7XG4gIHJlYWRvbmx5IHNjb3BlOiBTY29wZTtcbiAgcmVhZG9ubHkgZHluYW1pY1Njb3BlOiBEeW5hbWljU2NvcGU7XG4gIHJlYWRvbmx5IHN0YWNrOiB1bmtub3duW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzdW1hYmxlVk1TdGF0ZSB7XG4gIHJlc3VtZShydW50aW1lOiBSdW50aW1lQ29udGV4dCwgYnVpbGRlcjogRWxlbWVudEJ1aWxkZXIpOiBJbnRlcm5hbFZNO1xufVxuXG5leHBvcnQgY2xhc3MgUmVzdW1hYmxlVk1TdGF0ZUltcGwgaW1wbGVtZW50cyBSZXN1bWFibGVWTVN0YXRlIHtcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgc3RhdGU6IFZNU3RhdGUsIHByaXZhdGUgcmVzdW1lQ2FsbGJhY2s6IFZtSW5pdENhbGxiYWNrKSB7fVxuXG4gIHJlc3VtZShydW50aW1lOiBSdW50aW1lQ29udGV4dCwgYnVpbGRlcjogRWxlbWVudEJ1aWxkZXIpOiBJbnRlcm5hbFZNIHtcbiAgICByZXR1cm4gdGhpcy5yZXN1bWVDYWxsYmFjayhydW50aW1lLCB0aGlzLnN0YXRlLCBidWlsZGVyKTtcbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmxvY2tPcGNvZGUgaW1wbGVtZW50cyBVcGRhdGluZ09wY29kZSwgQm91bmRzIHtcbiAgcHVibGljIGNoaWxkcmVuOiBVcGRhdGluZ09wY29kZVtdO1xuXG4gIHByb3RlY3RlZCByZWFkb25seSBib3VuZHM6IExpdmVCbG9jaztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgc3RhdGU6IFJlc3VtYWJsZVZNU3RhdGUsXG4gICAgcHJvdGVjdGVkIHJ1bnRpbWU6IFJ1bnRpbWVDb250ZXh0LFxuICAgIGJvdW5kczogTGl2ZUJsb2NrLFxuICAgIGNoaWxkcmVuOiBVcGRhdGluZ09wY29kZVtdXG4gICkge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLmJvdW5kcyA9IGJvdW5kcztcbiAgfVxuXG4gIHBhcmVudEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLnBhcmVudEVsZW1lbnQoKTtcbiAgfVxuXG4gIGZpcnN0Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZHMuZmlyc3ROb2RlKCk7XG4gIH1cblxuICBsYXN0Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZHMubGFzdE5vZGUoKTtcbiAgfVxuXG4gIGV2YWx1YXRlKHZtOiBVcGRhdGluZ1ZNSW1wbCkge1xuICAgIHZtLnRyeSh0aGlzLmNoaWxkcmVuLCBudWxsKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVHJ5T3Bjb2RlIGV4dGVuZHMgQmxvY2tPcGNvZGUgaW1wbGVtZW50cyBFeGNlcHRpb25IYW5kbGVyIHtcbiAgcHVibGljIHR5cGUgPSAndHJ5JztcblxuICBwcm90ZWN0ZWQgYm91bmRzITogVXBkYXRhYmxlQmxvY2s7IC8vIEhpZGVzIHByb3BlcnR5IG9uIGJhc2UgY2xhc3NcblxuICBldmFsdWF0ZSh2bTogVXBkYXRpbmdWTUltcGwpIHtcbiAgICB2bS50cnkodGhpcy5jaGlsZHJlbiwgdGhpcyk7XG4gIH1cblxuICBoYW5kbGVFeGNlcHRpb24oKSB7XG4gICAgbGV0IHsgc3RhdGUsIGJvdW5kcywgcnVudGltZSB9ID0gdGhpcztcblxuICAgIGRlc3Ryb3lDaGlsZHJlbih0aGlzKTtcblxuICAgIGxldCBlbGVtZW50U3RhY2sgPSBOZXdFbGVtZW50QnVpbGRlci5yZXN1bWUocnVudGltZS5lbnYsIGJvdW5kcyk7XG4gICAgbGV0IHZtID0gc3RhdGUucmVzdW1lKHJ1bnRpbWUsIGVsZW1lbnRTdGFjayk7XG5cbiAgICBsZXQgdXBkYXRpbmc6IFVwZGF0aW5nT3Bjb2RlW10gPSBbXTtcbiAgICBsZXQgY2hpbGRyZW4gPSAodGhpcy5jaGlsZHJlbiA9IFtdKTtcblxuICAgIGxldCByZXN1bHQgPSB2bS5leGVjdXRlKCh2bSkgPT4ge1xuICAgICAgdm0ucHVzaFVwZGF0aW5nKHVwZGF0aW5nKTtcbiAgICAgIHZtLnVwZGF0ZVdpdGgodGhpcyk7XG4gICAgICB2bS5wdXNoVXBkYXRpbmcoY2hpbGRyZW4pO1xuICAgIH0pO1xuXG4gICAgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZCh0aGlzLCByZXN1bHQuZHJvcCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIExpc3RJdGVtT3Bjb2RlIGV4dGVuZHMgVHJ5T3Bjb2RlIHtcbiAgcHVibGljIHJldGFpbmVkID0gZmFsc2U7XG4gIHB1YmxpYyBpbmRleCA9IC0xO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHN0YXRlOiBSZXN1bWFibGVWTVN0YXRlLFxuICAgIHJ1bnRpbWU6IFJ1bnRpbWVDb250ZXh0LFxuICAgIGJvdW5kczogVXBkYXRhYmxlQmxvY2ssXG4gICAgcHVibGljIGtleTogdW5rbm93bixcbiAgICBwdWJsaWMgbWVtbzogUmVmZXJlbmNlLFxuICAgIHB1YmxpYyB2YWx1ZTogUmVmZXJlbmNlXG4gICkge1xuICAgIHN1cGVyKHN0YXRlLCBydW50aW1lLCBib3VuZHMsIFtdKTtcbiAgfVxuXG4gIHVwZGF0ZVJlZmVyZW5jZXMoaXRlbTogT3BhcXVlSXRlcmF0aW9uSXRlbSkge1xuICAgIHRoaXMucmV0YWluZWQgPSB0cnVlO1xuICAgIHVwZGF0ZVJlZih0aGlzLnZhbHVlLCBpdGVtLnZhbHVlKTtcbiAgICB1cGRhdGVSZWYodGhpcy5tZW1vLCBpdGVtLm1lbW8pO1xuICB9XG5cbiAgc2hvdWxkUmVtb3ZlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAhdGhpcy5yZXRhaW5lZDtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMucmV0YWluZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTGlzdEJsb2NrT3Bjb2RlIGV4dGVuZHMgQmxvY2tPcGNvZGUge1xuICBwdWJsaWMgdHlwZSA9ICdsaXN0LWJsb2NrJztcbiAgcHVibGljIGNoaWxkcmVuITogTGlzdEl0ZW1PcGNvZGVbXTtcblxuICBwcml2YXRlIG9wY29kZU1hcCA9IG5ldyBNYXA8dW5rbm93biwgTGlzdEl0ZW1PcGNvZGU+KCk7XG4gIHByaXZhdGUgbWFya2VyOiBTaW1wbGVDb21tZW50IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgbGFzdEl0ZXJhdG9yOiBPcGFxdWVJdGVyYXRvcjtcblxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgYm91bmRzITogTGl2ZUJsb2NrTGlzdDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBzdGF0ZTogUmVzdW1hYmxlVk1TdGF0ZSxcbiAgICBydW50aW1lOiBSdW50aW1lQ29udGV4dCxcbiAgICBib3VuZHM6IExpdmVCbG9ja0xpc3QsXG4gICAgY2hpbGRyZW46IExpc3RJdGVtT3Bjb2RlW10sXG4gICAgcHJpdmF0ZSBpdGVyYWJsZVJlZjogUmVmZXJlbmNlPE9wYXF1ZUl0ZXJhdG9yPlxuICApIHtcbiAgICBzdXBlcihzdGF0ZSwgcnVudGltZSwgYm91bmRzLCBjaGlsZHJlbik7XG4gICAgdGhpcy5sYXN0SXRlcmF0b3IgPSB2YWx1ZUZvclJlZihpdGVyYWJsZVJlZik7XG4gIH1cblxuICBpbml0aWFsaXplQ2hpbGQob3Bjb2RlOiBMaXN0SXRlbU9wY29kZSkge1xuICAgIG9wY29kZS5pbmRleCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMTtcbiAgICB0aGlzLm9wY29kZU1hcC5zZXQob3Bjb2RlLmtleSwgb3Bjb2RlKTtcbiAgfVxuXG4gIGV2YWx1YXRlKHZtOiBVcGRhdGluZ1ZNSW1wbCkge1xuICAgIGxldCBpdGVyYXRvciA9IHZhbHVlRm9yUmVmKHRoaXMuaXRlcmFibGVSZWYpO1xuXG4gICAgaWYgKHRoaXMubGFzdEl0ZXJhdG9yICE9PSBpdGVyYXRvcikge1xuICAgICAgbGV0IHsgYm91bmRzIH0gPSB0aGlzO1xuICAgICAgbGV0IHsgZG9tIH0gPSB2bTtcblxuICAgICAgbGV0IG1hcmtlciA9ICh0aGlzLm1hcmtlciA9IGRvbS5jcmVhdGVDb21tZW50KCcnKSk7XG4gICAgICBkb20uaW5zZXJ0QWZ0ZXIoXG4gICAgICAgIGJvdW5kcy5wYXJlbnRFbGVtZW50KCksXG4gICAgICAgIG1hcmtlcixcbiAgICAgICAgZXhwZWN0KGJvdW5kcy5sYXN0Tm9kZSgpLCBcImNhbid0IGluc2VydCBhZnRlciBhbiBlbXB0eSBib3VuZHNcIilcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuc3luYyhpdGVyYXRvcik7XG5cbiAgICAgIHRoaXMucGFyZW50RWxlbWVudCgpLnJlbW92ZUNoaWxkKG1hcmtlcik7XG4gICAgICB0aGlzLm1hcmtlciA9IG51bGw7XG4gICAgICB0aGlzLmxhc3RJdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgIH1cblxuICAgIC8vIFJ1biBub3ctdXBkYXRlZCB1cGRhdGluZyBvcGNvZGVzXG4gICAgc3VwZXIuZXZhbHVhdGUodm0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzeW5jKGl0ZXJhdG9yOiBPcGFxdWVJdGVyYXRvcikge1xuICAgIGxldCB7IG9wY29kZU1hcDogaXRlbU1hcCwgY2hpbGRyZW4gfSA9IHRoaXM7XG5cbiAgICBsZXQgY3VycmVudE9wY29kZUluZGV4ID0gMDtcbiAgICBsZXQgc2VlbkluZGV4ID0gMDtcblxuICAgIHRoaXMuY2hpbGRyZW4gPSB0aGlzLmJvdW5kcy5ib3VuZExpc3QgPSBbXTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgaWYgKGl0ZW0gPT09IG51bGwpIGJyZWFrO1xuXG4gICAgICBsZXQgb3Bjb2RlID0gY2hpbGRyZW5bY3VycmVudE9wY29kZUluZGV4XTtcbiAgICAgIGxldCB7IGtleSB9ID0gaXRlbTtcblxuICAgICAgLy8gSXRlbXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBmb3VuZCBhbmQgbW92ZWQgd2lsbCBhbHJlYWR5IGJlIHJldGFpbmVkLFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHVudGlsIHdlIGZpbmQgdGhlIG5leHQgdW5yZXRhaW5lZCBpdGVtXG4gICAgICB3aGlsZSAob3Bjb2RlICE9PSB1bmRlZmluZWQgJiYgb3Bjb2RlLnJldGFpbmVkID09PSB0cnVlKSB7XG4gICAgICAgIG9wY29kZSA9IGNoaWxkcmVuWysrY3VycmVudE9wY29kZUluZGV4XTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wY29kZSAhPT0gdW5kZWZpbmVkICYmIG9wY29kZS5rZXkgPT09IGtleSkge1xuICAgICAgICB0aGlzLnJldGFpbkl0ZW0ob3Bjb2RlLCBpdGVtKTtcbiAgICAgICAgY3VycmVudE9wY29kZUluZGV4Kys7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1NYXAuaGFzKGtleSkpIHtcbiAgICAgICAgbGV0IGl0ZW1PcGNvZGUgPSBpdGVtTWFwLmdldChrZXkpITtcblxuICAgICAgICAvLyBUaGUgaXRlbSBvcGNvZGUgd2FzIHNlZW4gYWxyZWFkeSwgc28gd2Ugc2hvdWxkIG1vdmUgaXQuXG4gICAgICAgIGlmIChpdGVtT3Bjb2RlLmluZGV4IDwgc2VlbkluZGV4KSB7XG4gICAgICAgICAgdGhpcy5tb3ZlSXRlbShpdGVtT3Bjb2RlLCBpdGVtLCBvcGNvZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2VlbiBpbmRleCwgd2UgYXJlIGdvaW5nIHRvIGJlIG1vdmluZyB0aGlzIGl0ZW0gYXJvdW5kXG4gICAgICAgICAgLy8gc28gYW55IG90aGVyIGl0ZW1zIHRoYXQgY29tZSBiZWZvcmUgaXQgd2lsbCBsaWtlbHkgbmVlZCB0byBtb3ZlIGFzXG4gICAgICAgICAgLy8gd2VsbC5cbiAgICAgICAgICBzZWVuSW5kZXggPSBpdGVtT3Bjb2RlLmluZGV4O1xuXG4gICAgICAgICAgbGV0IHNlZW5VbnJldGFpbmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAvLyBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBvcGNvZGVzIGJldHdlZW4gdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kXG4gICAgICAgICAgLy8gdGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtJ3Mgb3Bjb2RlLCBhbmQgZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGFsbFxuICAgICAgICAgIC8vIHJldGFpbmVkLlxuICAgICAgICAgIGZvciAobGV0IGkgPSBjdXJyZW50T3Bjb2RlSW5kZXggKyAxOyBpIDwgc2VlbkluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXS5yZXRhaW5lZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgc2VlblVucmV0YWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHNlZW4gb25seSByZXRhaW5lZCBvcGNvZGVzIGJldHdlZW4gdGhpcyBhbmQgdGhlIG1hdGNoaW5nXG4gICAgICAgICAgLy8gb3Bjb2RlLCBpdCBtZWFucyB0aGF0IGFsbCB0aGUgb3Bjb2RlcyBpbiBiZXR3ZWVuIGhhdmUgYmVlbiBtb3ZlZFxuICAgICAgICAgIC8vIGFscmVhZHksIGFuZCB3ZSBjYW4gc2FmZWx5IHJldGFpbiB0aGlzIGl0ZW0ncyBvcGNvZGUuXG4gICAgICAgICAgaWYgKHNlZW5VbnJldGFpbmVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5yZXRhaW5JdGVtKGl0ZW1PcGNvZGUsIGl0ZW0pO1xuICAgICAgICAgICAgY3VycmVudE9wY29kZUluZGV4ID0gc2VlbkluZGV4ICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb3ZlSXRlbShpdGVtT3Bjb2RlLCBpdGVtLCBvcGNvZGUpO1xuICAgICAgICAgICAgY3VycmVudE9wY29kZUluZGV4Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmluc2VydEl0ZW0oaXRlbSwgb3Bjb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgb3Bjb2RlID0gY2hpbGRyZW5baV07XG5cbiAgICAgIGlmIChvcGNvZGUucmV0YWluZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlSXRlbShvcGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3Bjb2RlLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZXRhaW5JdGVtKG9wY29kZTogTGlzdEl0ZW1PcGNvZGUsIGl0ZW06IE9wYXF1ZUl0ZXJhdGlvbkl0ZW0pIHtcbiAgICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAgIGxvZ1N0ZXAhKCdsaXN0LXVwZGF0ZXMnLCBbJ3JldGFpbicsIGl0ZW0ua2V5XSk7XG4gICAgfVxuXG4gICAgbGV0IHsgY2hpbGRyZW4gfSA9IHRoaXM7XG5cbiAgICB1cGRhdGVSZWYob3Bjb2RlLm1lbW8sIGl0ZW0ubWVtbyk7XG4gICAgdXBkYXRlUmVmKG9wY29kZS52YWx1ZSwgaXRlbS52YWx1ZSk7XG4gICAgb3Bjb2RlLnJldGFpbmVkID0gdHJ1ZTtcblxuICAgIG9wY29kZS5pbmRleCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBjaGlsZHJlbi5wdXNoKG9wY29kZSk7XG4gIH1cblxuICBwcml2YXRlIGluc2VydEl0ZW0oaXRlbTogT3BhcXVlSXRlcmF0aW9uSXRlbSwgYmVmb3JlOiBMaXN0SXRlbU9wY29kZSkge1xuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgbG9nU3RlcCEoJ2xpc3QtdXBkYXRlcycsIFsnaW5zZXJ0JywgaXRlbS5rZXldKTtcbiAgICB9XG5cbiAgICBsZXQgeyBvcGNvZGVNYXAsIGJvdW5kcywgc3RhdGUsIHJ1bnRpbWUsIGNoaWxkcmVuIH0gPSB0aGlzO1xuICAgIGxldCB7IGtleSB9ID0gaXRlbTtcbiAgICBsZXQgbmV4dFNpYmxpbmcgPSBiZWZvcmUgPT09IHVuZGVmaW5lZCA/IHRoaXMubWFya2VyIDogYmVmb3JlLmZpcnN0Tm9kZSgpO1xuXG4gICAgbGV0IGVsZW1lbnRTdGFjayA9IE5ld0VsZW1lbnRCdWlsZGVyLmZvckluaXRpYWxSZW5kZXIocnVudGltZS5lbnYsIHtcbiAgICAgIGVsZW1lbnQ6IGJvdW5kcy5wYXJlbnRFbGVtZW50KCksXG4gICAgICBuZXh0U2libGluZyxcbiAgICB9KTtcblxuICAgIGxldCB2bSA9IHN0YXRlLnJlc3VtZShydW50aW1lLCBlbGVtZW50U3RhY2spO1xuXG4gICAgdm0uZXhlY3V0ZSgodm0pID0+IHtcbiAgICAgIHZtLnB1c2hVcGRhdGluZygpO1xuICAgICAgbGV0IG9wY29kZSA9IHZtLmVudGVySXRlbShpdGVtKTtcblxuICAgICAgb3Bjb2RlLmluZGV4ID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgY2hpbGRyZW4ucHVzaChvcGNvZGUpO1xuICAgICAgb3Bjb2RlTWFwLnNldChrZXksIG9wY29kZSk7XG4gICAgICBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkKHRoaXMsIG9wY29kZSk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIG1vdmVJdGVtKG9wY29kZTogTGlzdEl0ZW1PcGNvZGUsIGl0ZW06IE9wYXF1ZUl0ZXJhdGlvbkl0ZW0sIGJlZm9yZTogTGlzdEl0ZW1PcGNvZGUpIHtcbiAgICBsZXQgeyBjaGlsZHJlbiB9ID0gdGhpcztcblxuICAgIHVwZGF0ZVJlZihvcGNvZGUubWVtbywgaXRlbS5tZW1vKTtcbiAgICB1cGRhdGVSZWYob3Bjb2RlLnZhbHVlLCBpdGVtLnZhbHVlKTtcbiAgICBvcGNvZGUucmV0YWluZWQgPSB0cnVlO1xuXG4gICAgbGV0IGN1cnJlbnRTaWJsaW5nLCBuZXh0U2libGluZztcblxuICAgIGlmIChiZWZvcmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbW92ZUJvdW5kcyhvcGNvZGUsIHRoaXMubWFya2VyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFNpYmxpbmcgPSBvcGNvZGUubGFzdE5vZGUoKS5uZXh0U2libGluZztcbiAgICAgIG5leHRTaWJsaW5nID0gYmVmb3JlLmZpcnN0Tm9kZSgpO1xuXG4gICAgICAvLyBJdGVtcyBhcmUgbW92ZWQgdGhyb3VnaG91dCB0aGUgYWxnb3JpdGhtLCBzbyB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgdGhlXG4gICAgICAvLyB0aGUgaXRlbXMgYWxyZWFkeSBoYXBwZW4gdG8gYmUgc2libGluZ3MgKGUuZy4gYW4gaXRlbSBpbiBiZXR3ZWVuIHdhc1xuICAgICAgLy8gbW92ZWQgYmVmb3JlIHRoaXMgbW92ZSBoYXBwZW5lZCkuIENoZWNrIHRvIHNlZSBpZiB0aGV5IGFyZSBzaWJsaW5nc1xuICAgICAgLy8gZmlyc3QgYmVmb3JlIGRvaW5nIHRoZSBtb3ZlLlxuICAgICAgaWYgKGN1cnJlbnRTaWJsaW5nICE9PSBuZXh0U2libGluZykge1xuICAgICAgICBtb3ZlQm91bmRzKG9wY29kZSwgbmV4dFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9wY29kZS5pbmRleCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBjaGlsZHJlbi5wdXNoKG9wY29kZSk7XG5cbiAgICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAgIGxldCB0eXBlID0gY3VycmVudFNpYmxpbmcgJiYgY3VycmVudFNpYmxpbmcgPT09IG5leHRTaWJsaW5nID8gJ21vdmUtcmV0YWluJyA6ICdtb3ZlJztcbiAgICAgIGxvZ1N0ZXAhKCdsaXN0LXVwZGF0ZXMnLCBbdHlwZSwgaXRlbS5rZXldKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRlbGV0ZUl0ZW0ob3Bjb2RlOiBMaXN0SXRlbU9wY29kZSkge1xuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgbG9nU3RlcCEoJ2xpc3QtdXBkYXRlcycsIFsnZGVsZXRlJywgb3Bjb2RlLmtleV0pO1xuICAgIH1cblxuICAgIGRlc3Ryb3kob3Bjb2RlKTtcbiAgICBjbGVhcihvcGNvZGUpO1xuICAgIHRoaXMub3Bjb2RlTWFwLmRlbGV0ZShvcGNvZGUua2V5KTtcbiAgfVxufVxuXG5jbGFzcyBVcGRhdGluZ1ZNRnJhbWUge1xuICBwcml2YXRlIGN1cnJlbnQgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3BzOiBVcGRhdGluZ09wY29kZVtdLCBwcml2YXRlIGV4Y2VwdGlvbkhhbmRsZXI6IE9wdGlvbjxFeGNlcHRpb25IYW5kbGVyPikge31cblxuICBnb3RvKGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSBpbmRleDtcbiAgfVxuXG4gIG5leHRTdGF0ZW1lbnQoKTogVXBkYXRpbmdPcGNvZGUgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLm9wc1t0aGlzLmN1cnJlbnQrK107XG4gIH1cblxuICBoYW5kbGVFeGNlcHRpb24oKSB7XG4gICAgaWYgKHRoaXMuZXhjZXB0aW9uSGFuZGxlcikge1xuICAgICAgdGhpcy5leGNlcHRpb25IYW5kbGVyLmhhbmRsZUV4Y2VwdGlvbigpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgRW52aXJvbm1lbnQsIFJlbmRlclJlc3VsdCwgTGl2ZUJsb2NrLCBVcGRhdGluZ09wY29kZSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZCwgcmVnaXN0ZXJEZXN0cnVjdG9yIH0gZnJvbSAnQGdsaW1tZXIvZGVzdHJveWFibGUnO1xuaW1wb3J0IHsgU2ltcGxlRWxlbWVudCwgU2ltcGxlTm9kZSB9IGZyb20gJ0BzaW1wbGUtZG9tL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBjbGVhciB9IGZyb20gJy4uL2JvdW5kcyc7XG5pbXBvcnQgVXBkYXRpbmdWTUltcGwgZnJvbSAnLi91cGRhdGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJSZXN1bHRJbXBsIGltcGxlbWVudHMgUmVuZGVyUmVzdWx0IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgcHJpdmF0ZSB1cGRhdGluZzogVXBkYXRpbmdPcGNvZGVbXSxcbiAgICBwcml2YXRlIGJvdW5kczogTGl2ZUJsb2NrLFxuICAgIHJlYWRvbmx5IGRyb3A6IG9iamVjdFxuICApIHtcbiAgICBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkKHRoaXMsIGRyb3ApO1xuICAgIHJlZ2lzdGVyRGVzdHJ1Y3Rvcih0aGlzLCAoKSA9PiBjbGVhcih0aGlzLmJvdW5kcykpO1xuICB9XG5cbiAgcmVyZW5kZXIoeyBhbHdheXNSZXZhbGlkYXRlID0gZmFsc2UgfSA9IHsgYWx3YXlzUmV2YWxpZGF0ZTogZmFsc2UgfSkge1xuICAgIGxldCB7IGVudiwgdXBkYXRpbmcgfSA9IHRoaXM7XG4gICAgbGV0IHZtID0gbmV3IFVwZGF0aW5nVk1JbXBsKGVudiwgeyBhbHdheXNSZXZhbGlkYXRlIH0pO1xuICAgIHZtLmV4ZWN1dGUodXBkYXRpbmcsIHRoaXMpO1xuICB9XG5cbiAgcGFyZW50RWxlbWVudCgpOiBTaW1wbGVFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5ib3VuZHMucGFyZW50RWxlbWVudCgpO1xuICB9XG5cbiAgZmlyc3ROb2RlKCk6IFNpbXBsZU5vZGUge1xuICAgIHJldHVybiB0aGlzLmJvdW5kcy5maXJzdE5vZGUoKTtcbiAgfVxuXG4gIGxhc3ROb2RlKCk6IFNpbXBsZU5vZGUge1xuICAgIHJldHVybiB0aGlzLmJvdW5kcy5sYXN0Tm9kZSgpO1xuICB9XG5cbiAgaGFuZGxlRXhjZXB0aW9uKCkge1xuICAgIHRocm93ICd0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4nO1xuICB9XG59XG4iLCJpbXBvcnQgeyBMT0NBTF9ERUJVRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7ICRmcCwgJHNwLCBNYWNoaW5lUmVnaXN0ZXIgfSBmcm9tICdAZ2xpbW1lci92bSc7XG5pbXBvcnQgeyBSRUdJU1RFUlMgfSBmcm9tICcuLi9zeW1ib2xzJztcbmltcG9ydCB7IGluaXRpYWxpemVSZWdpc3RlcnNXaXRoU1AsIExvd0xldmVsUmVnaXN0ZXJzIH0gZnJvbSAnLi9sb3ctbGV2ZWwnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEV2YWx1YXRpb25TdGFjayB7XG4gIFtSRUdJU1RFUlNdOiBMb3dMZXZlbFJlZ2lzdGVycztcblxuICBwdXNoKHZhbHVlOiB1bmtub3duKTogdm9pZDtcbiAgZHVwKHBvc2l0aW9uPzogTWFjaGluZVJlZ2lzdGVyKTogdm9pZDtcbiAgY29weShmcm9tOiBudW1iZXIsIHRvOiBudW1iZXIpOiB2b2lkO1xuICBwb3A8VD4obj86IG51bWJlcik6IFQ7XG4gIHBlZWs8VD4ob2Zmc2V0PzogbnVtYmVyKTogVDtcbiAgZ2V0PFQ+KG9mZnNldDogbnVtYmVyLCBiYXNlPzogbnVtYmVyKTogVDtcbiAgc2V0KHZhbHVlOiB1bmtub3duLCBvZmZzZXQ6IG51bWJlciwgYmFzZT86IG51bWJlcik6IHZvaWQ7XG4gIHNsaWNlPFQgPSB1bmtub3duPihzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcik6IFRbXTtcbiAgY2FwdHVyZShpdGVtczogbnVtYmVyKTogdW5rbm93bltdO1xuICByZXNldCgpOiB2b2lkO1xuICB0b0FycmF5KCk6IHVua25vd25bXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZhbHVhdGlvblN0YWNrSW1wbCBpbXBsZW1lbnRzIEV2YWx1YXRpb25TdGFjayB7XG4gIHN0YXRpYyByZXN0b3JlKHNuYXBzaG90OiB1bmtub3duW10pOiBFdmFsdWF0aW9uU3RhY2tJbXBsIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoc25hcHNob3Quc2xpY2UoKSwgaW5pdGlhbGl6ZVJlZ2lzdGVyc1dpdGhTUChzbmFwc2hvdC5sZW5ndGggLSAxKSk7XG4gIH1cblxuICByZWFkb25seSBbUkVHSVNURVJTXTogTG93TGV2ZWxSZWdpc3RlcnM7XG5cbiAgLy8gZnAgLT4gc3BcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzdGFjazogdW5rbm93bltdID0gW10sIHJlZ2lzdGVyczogTG93TGV2ZWxSZWdpc3RlcnMpIHtcbiAgICB0aGlzW1JFR0lTVEVSU10gPSByZWdpc3RlcnM7XG5cbiAgICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2godmFsdWU6IHVua25vd24pOiB2b2lkIHtcbiAgICB0aGlzLnN0YWNrWysrdGhpc1tSRUdJU1RFUlNdWyRzcF1dID0gdmFsdWU7XG4gIH1cblxuICBkdXAocG9zaXRpb24gPSB0aGlzW1JFR0lTVEVSU11bJHNwXSk6IHZvaWQge1xuICAgIHRoaXMuc3RhY2tbKyt0aGlzW1JFR0lTVEVSU11bJHNwXV0gPSB0aGlzLnN0YWNrW3Bvc2l0aW9uXTtcbiAgfVxuXG4gIGNvcHkoZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zdGFja1t0b10gPSB0aGlzLnN0YWNrW2Zyb21dO1xuICB9XG5cbiAgcG9wPFQ+KG4gPSAxKTogVCB7XG4gICAgbGV0IHRvcCA9IHRoaXMuc3RhY2tbdGhpc1tSRUdJU1RFUlNdWyRzcF1dIGFzIFQ7XG4gICAgdGhpc1tSRUdJU1RFUlNdWyRzcF0gLT0gbjtcbiAgICByZXR1cm4gdG9wO1xuICB9XG5cbiAgcGVlazxUPihvZmZzZXQgPSAwKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpc1tSRUdJU1RFUlNdWyRzcF0gLSBvZmZzZXRdIGFzIFQ7XG4gIH1cblxuICBnZXQ8VD4ob2Zmc2V0OiBudW1iZXIsIGJhc2UgPSB0aGlzW1JFR0lTVEVSU11bJGZwXSk6IFQge1xuICAgIHJldHVybiB0aGlzLnN0YWNrW2Jhc2UgKyBvZmZzZXRdIGFzIFQ7XG4gIH1cblxuICBzZXQodmFsdWU6IHVua25vd24sIG9mZnNldDogbnVtYmVyLCBiYXNlID0gdGhpc1tSRUdJU1RFUlNdWyRmcF0pIHtcbiAgICB0aGlzLnN0YWNrW2Jhc2UgKyBvZmZzZXRdID0gdmFsdWU7XG4gIH1cblxuICBzbGljZTxUID0gdW5rbm93bj4oc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpOiBUW10ge1xuICAgIHJldHVybiB0aGlzLnN0YWNrLnNsaWNlKHN0YXJ0LCBlbmQpIGFzIFRbXTtcbiAgfVxuXG4gIGNhcHR1cmUoaXRlbXM6IG51bWJlcik6IHVua25vd25bXSB7XG4gICAgbGV0IGVuZCA9IHRoaXNbUkVHSVNURVJTXVskc3BdICsgMTtcbiAgICBsZXQgc3RhcnQgPSBlbmQgLSBpdGVtcztcbiAgICByZXR1cm4gdGhpcy5zdGFjay5zbGljZShzdGFydCwgZW5kKTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2suc2xpY2UodGhpc1tSRUdJU1RFUlNdWyRmcF0sIHRoaXNbUkVHSVNURVJTXVskc3BdICsgMSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IGFzc2VydEdsb2JhbENvbnRleHRXYXNTZXQgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5pbXBvcnQge1xuICBDb21waWxhYmxlVGVtcGxhdGUsXG4gIERlc3Ryb3lhYmxlLFxuICBEeW5hbWljU2NvcGUsXG4gIEVsZW1lbnRCdWlsZGVyLFxuICBFbnZpcm9ubWVudCxcbiAgT3B0aW9uLFxuICBQYXJ0aWFsU2NvcGUsXG4gIFJlbmRlclJlc3VsdCxcbiAgUmljaEl0ZXJhdG9yUmVzdWx0LFxuICBSdW50aW1lQ29uc3RhbnRzLFxuICBSdW50aW1lQ29udGV4dCxcbiAgUnVudGltZUhlYXAsXG4gIFJ1bnRpbWVQcm9ncmFtLFxuICBTY29wZSxcbiAgQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIFZNIGFzIFB1YmxpY1ZNLFxuICBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgT3duZXIsXG4gIFVwZGF0aW5nT3Bjb2RlLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IExPQ0FMX1NIT1VMRF9MT0cgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBSdW50aW1lT3BJbXBsIH0gZnJvbSAnQGdsaW1tZXIvcHJvZ3JhbSc7XG5pbXBvcnQge1xuICBjcmVhdGVJdGVyYXRvckl0ZW1SZWYsXG4gIE9wYXF1ZUl0ZXJhdGlvbkl0ZW0sXG4gIE9wYXF1ZUl0ZXJhdG9yLFxuICBSZWZlcmVuY2UsXG4gIFVOREVGSU5FRF9SRUZFUkVOQ0UsXG59IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBhc3NlcnQsIGV4cGVjdCwgTE9DQUxfTE9HR0VSLCBTdGFjaywgdW53cmFwSGFuZGxlIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBiZWdpblRyYWNrRnJhbWUsIGVuZFRyYWNrRnJhbWUsIHJlc2V0VHJhY2tpbmcgfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHtcbiAgJGZwLFxuICAkcGMsXG4gICRzMCxcbiAgJHMxLFxuICAkc3AsXG4gICR0MCxcbiAgJHQxLFxuICAkdjAsXG4gIGlzTG93TGV2ZWxSZWdpc3RlcixcbiAgTWFjaGluZVJlZ2lzdGVyLFxuICBSZWdpc3RlcixcbiAgU3lzY2FsbFJlZ2lzdGVyLFxufSBmcm9tICdAZ2xpbW1lci92bSc7XG5pbXBvcnQgeyBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkIH0gZnJvbSAnQGdsaW1tZXIvZGVzdHJveWFibGUnO1xuaW1wb3J0IHtcbiAgQmVnaW5UcmFja0ZyYW1lT3Bjb2RlLFxuICBFbmRUcmFja0ZyYW1lT3Bjb2RlLFxuICBKdW1wSWZOb3RNb2RpZmllZE9wY29kZSxcbn0gZnJvbSAnLi4vY29tcGlsZWQvb3Bjb2Rlcy92bSc7XG5pbXBvcnQgeyBBUFBFTkRfT1BDT0RFUywgRGVidWdTdGF0ZSB9IGZyb20gJy4uL29wY29kZXMnO1xuaW1wb3J0IHsgUGFydGlhbFNjb3BlSW1wbCB9IGZyb20gJy4uL3Njb3BlJztcbmltcG9ydCB7IEFSR1MsIENPTlNUQU5UUywgREVTVFJPWUFCTEVfU1RBQ0ssIEhFQVAsIElOTkVSX1ZNLCBSRUdJU1RFUlMsIFNUQUNLUyB9IGZyb20gJy4uL3N5bWJvbHMnO1xuaW1wb3J0IHsgVk1Bcmd1bWVudHNJbXBsIH0gZnJvbSAnLi9hcmd1bWVudHMnO1xuaW1wb3J0IHsgTGl2ZUJsb2NrTGlzdCB9IGZyb20gJy4vZWxlbWVudC1idWlsZGVyJztcbmltcG9ydCBMb3dMZXZlbFZNIGZyb20gJy4vbG93LWxldmVsJztcbmltcG9ydCBSZW5kZXJSZXN1bHRJbXBsIGZyb20gJy4vcmVuZGVyLXJlc3VsdCc7XG5pbXBvcnQgRXZhbHVhdGlvblN0YWNrSW1wbCwgeyBFdmFsdWF0aW9uU3RhY2sgfSBmcm9tICcuL3N0YWNrJztcbmltcG9ydCB7XG4gIEJsb2NrT3Bjb2RlLFxuICBMaXN0QmxvY2tPcGNvZGUsXG4gIExpc3RJdGVtT3Bjb2RlLFxuICBSZXN1bWFibGVWTVN0YXRlLFxuICBSZXN1bWFibGVWTVN0YXRlSW1wbCxcbiAgVHJ5T3Bjb2RlLFxuICBWTVN0YXRlLFxufSBmcm9tICcuL3VwZGF0ZSc7XG5cbi8qKlxuICogVGhpcyBpbnRlcmZhY2UgaXMgdXNlZCBieSBpbnRlcm5hbCBvcGNvZGVzLCBhbmQgaXMgbW9yZSBzdGFibGUgdGhhblxuICogdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBBcHBlbmQgVk0gaXRzZWxmLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEludGVybmFsVk0ge1xuICByZWFkb25seSBbQ09OU1RBTlRTXTogUnVudGltZUNvbnN0YW50cyAmIFJlc29sdXRpb25UaW1lQ29uc3RhbnRzO1xuICByZWFkb25seSBbQVJHU106IFZNQXJndW1lbnRzSW1wbDtcblxuICByZWFkb25seSBlbnY6IEVudmlyb25tZW50O1xuICByZWFkb25seSBzdGFjazogRXZhbHVhdGlvblN0YWNrO1xuICByZWFkb25seSBydW50aW1lOiBSdW50aW1lQ29udGV4dDtcbiAgcmVhZG9ubHkgY29udGV4dDogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQ7XG5cbiAgbG9hZFZhbHVlKHJlZ2lzdGVyOiBNYWNoaW5lUmVnaXN0ZXIsIHZhbHVlOiBudW1iZXIpOiB2b2lkO1xuICBsb2FkVmFsdWUocmVnaXN0ZXI6IFJlZ2lzdGVyLCB2YWx1ZTogdW5rbm93bik6IHZvaWQ7XG4gIGxvYWRWYWx1ZShyZWdpc3RlcjogUmVnaXN0ZXIgfCBNYWNoaW5lUmVnaXN0ZXIsIHZhbHVlOiB1bmtub3duKTogdm9pZDtcblxuICBmZXRjaFZhbHVlKHJlZ2lzdGVyOiBNYWNoaW5lUmVnaXN0ZXIucmEgfCBNYWNoaW5lUmVnaXN0ZXIucGMpOiBudW1iZXI7XG4gIC8vIFRPRE86IFNvbWV0aGluZyBiZXR0ZXIgdGhhbiBhIHR5cGUgYXNzZXJ0aW9uP1xuICBmZXRjaFZhbHVlPFQ+KHJlZ2lzdGVyOiBSZWdpc3Rlcik6IFQ7XG4gIGZldGNoVmFsdWUocmVnaXN0ZXI6IFJlZ2lzdGVyKTogdW5rbm93bjtcblxuICBsb2FkKHJlZ2lzdGVyOiBSZWdpc3Rlcik6IHZvaWQ7XG4gIGZldGNoKHJlZ2lzdGVyOiBSZWdpc3Rlcik6IHZvaWQ7XG5cbiAgY29tcGlsZShibG9jazogQ29tcGlsYWJsZVRlbXBsYXRlKTogbnVtYmVyO1xuXG4gIHNjb3BlKCk6IFNjb3BlO1xuICBlbGVtZW50cygpOiBFbGVtZW50QnVpbGRlcjtcblxuICBnZXRPd25lcigpOiBPd25lcjtcbiAgZ2V0U2VsZigpOiBSZWZlcmVuY2U7XG5cbiAgdXBkYXRlV2l0aChvcGNvZGU6IFVwZGF0aW5nT3Bjb2RlKTogdm9pZDtcblxuICBhc3NvY2lhdGVEZXN0cm95YWJsZShkOiBEZXN0cm95YWJsZSk6IHZvaWQ7XG5cbiAgYmVnaW5DYWNoZUdyb3VwKG5hbWU/OiBzdHJpbmcpOiB2b2lkO1xuICBjb21taXRDYWNoZUdyb3VwKCk6IHZvaWQ7XG5cbiAgLy8vIEl0ZXJhdGlvbiAvLy9cblxuICBlbnRlckxpc3QoaXRlcmFibGVSZWY6IFJlZmVyZW5jZTxPcGFxdWVJdGVyYXRvcj4sIG9mZnNldDogbnVtYmVyKTogdm9pZDtcbiAgZXhpdExpc3QoKTogdm9pZDtcbiAgZW50ZXJJdGVtKGl0ZW06IE9wYXF1ZUl0ZXJhdGlvbkl0ZW0pOiBMaXN0SXRlbU9wY29kZTtcbiAgcmVnaXN0ZXJJdGVtKGl0ZW06IExpc3RJdGVtT3Bjb2RlKTogdm9pZDtcblxuICBwdXNoUm9vdFNjb3BlKHNpemU6IG51bWJlciwgb3duZXI6IE93bmVyKTogUGFydGlhbFNjb3BlO1xuICBwdXNoQ2hpbGRTY29wZSgpOiB2b2lkO1xuICBwb3BTY29wZSgpOiB2b2lkO1xuICBwdXNoU2NvcGUoc2NvcGU6IFNjb3BlKTogdm9pZDtcblxuICBkeW5hbWljU2NvcGUoKTogRHluYW1pY1Njb3BlO1xuICBiaW5kRHluYW1pY1Njb3BlKG5hbWVzOiBzdHJpbmdbXSk6IHZvaWQ7XG4gIHB1c2hEeW5hbWljU2NvcGUoKTogdm9pZDtcbiAgcG9wRHluYW1pY1Njb3BlKCk6IHZvaWQ7XG5cbiAgZW50ZXIoYXJnczogbnVtYmVyKTogdm9pZDtcbiAgZXhpdCgpOiB2b2lkO1xuXG4gIGdvdG8ocGM6IG51bWJlcik6IHZvaWQ7XG4gIGNhbGwoaGFuZGxlOiBudW1iZXIpOiB2b2lkO1xuICBwdXNoRnJhbWUoKTogdm9pZDtcblxuICByZWZlcmVuY2VGb3JTeW1ib2woc3ltYm9sOiBudW1iZXIpOiBSZWZlcmVuY2U7XG5cbiAgZXhlY3V0ZShpbml0aWFsaXplPzogKHZtOiB0aGlzKSA9PiB2b2lkKTogUmVuZGVyUmVzdWx0O1xuICBwdXNoVXBkYXRpbmcobGlzdD86IFVwZGF0aW5nT3Bjb2RlW10pOiB2b2lkO1xuICBuZXh0KCk6IFJpY2hJdGVyYXRvclJlc3VsdDxudWxsLCBSZW5kZXJSZXN1bHQ+O1xufVxuXG5jbGFzcyBTdGFja3Mge1xuICByZWFkb25seSBzY29wZSA9IG5ldyBTdGFjazxTY29wZT4oKTtcbiAgcmVhZG9ubHkgZHluYW1pY1Njb3BlID0gbmV3IFN0YWNrPER5bmFtaWNTY29wZT4oKTtcbiAgcmVhZG9ubHkgdXBkYXRpbmcgPSBuZXcgU3RhY2s8VXBkYXRpbmdPcGNvZGVbXT4oKTtcbiAgcmVhZG9ubHkgY2FjaGUgPSBuZXcgU3RhY2s8SnVtcElmTm90TW9kaWZpZWRPcGNvZGU+KCk7XG4gIHJlYWRvbmx5IGxpc3QgPSBuZXcgU3RhY2s8TGlzdEJsb2NrT3Bjb2RlPigpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWTSBpbXBsZW1lbnRzIFB1YmxpY1ZNLCBJbnRlcm5hbFZNIHtcbiAgcHJpdmF0ZSByZWFkb25seSBbU1RBQ0tTXSA9IG5ldyBTdGFja3MoKTtcbiAgcHJpdmF0ZSByZWFkb25seSBbSEVBUF06IFJ1bnRpbWVIZWFwO1xuICBwcml2YXRlIHJlYWRvbmx5IGRlc3RydWN0b3I6IG9iamVjdDtcbiAgcHJpdmF0ZSByZWFkb25seSBbREVTVFJPWUFCTEVfU1RBQ0tdID0gbmV3IFN0YWNrPG9iamVjdD4oKTtcbiAgcmVhZG9ubHkgW0NPTlNUQU5UU106IFJ1bnRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cztcbiAgcmVhZG9ubHkgW0FSR1NdOiBWTUFyZ3VtZW50c0ltcGw7XG4gIHJlYWRvbmx5IFtJTk5FUl9WTV06IExvd0xldmVsVk07XG5cbiAgZ2V0IHN0YWNrKCk6IEV2YWx1YXRpb25TdGFjayB7XG4gICAgcmV0dXJuIHRoaXNbSU5ORVJfVk1dLnN0YWNrIGFzIEV2YWx1YXRpb25TdGFjaztcbiAgfVxuXG4gIC8qIFJlZ2lzdGVycyAqL1xuXG4gIGdldCBwYygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzW0lOTkVSX1ZNXS5mZXRjaFJlZ2lzdGVyKCRwYyk7XG4gIH1cblxuICBwdWJsaWMgczA6IHVua25vd24gPSBudWxsO1xuICBwdWJsaWMgczE6IHVua25vd24gPSBudWxsO1xuICBwdWJsaWMgdDA6IHVua25vd24gPSBudWxsO1xuICBwdWJsaWMgdDE6IHVua25vd24gPSBudWxsO1xuICBwdWJsaWMgdjA6IHVua25vd24gPSBudWxsO1xuXG4gIC8vIEZldGNoIGEgdmFsdWUgZnJvbSBhIHJlZ2lzdGVyIG9udG8gdGhlIHN0YWNrXG4gIGZldGNoKHJlZ2lzdGVyOiBTeXNjYWxsUmVnaXN0ZXIpOiB2b2lkIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmZldGNoVmFsdWUocmVnaXN0ZXIpO1xuXG4gICAgdGhpcy5zdGFjay5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIC8vIExvYWQgYSB2YWx1ZSBmcm9tIHRoZSBzdGFjayBpbnRvIGEgcmVnaXN0ZXJcbiAgbG9hZChyZWdpc3RlcjogU3lzY2FsbFJlZ2lzdGVyKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5zdGFjay5wb3AoKTtcblxuICAgIHRoaXMubG9hZFZhbHVlKHJlZ2lzdGVyLCB2YWx1ZSk7XG4gIH1cblxuICAvLyBGZXRjaCBhIHZhbHVlIGZyb20gYSByZWdpc3RlclxuICBmZXRjaFZhbHVlKHJlZ2lzdGVyOiBNYWNoaW5lUmVnaXN0ZXIpOiBudW1iZXI7XG4gIGZldGNoVmFsdWU8VD4ocmVnaXN0ZXI6IFJlZ2lzdGVyKTogVDtcbiAgZmV0Y2hWYWx1ZShyZWdpc3RlcjogUmVnaXN0ZXIgfCBNYWNoaW5lUmVnaXN0ZXIpOiB1bmtub3duIHtcbiAgICBpZiAoaXNMb3dMZXZlbFJlZ2lzdGVyKHJlZ2lzdGVyKSkge1xuICAgICAgcmV0dXJuIHRoaXNbSU5ORVJfVk1dLmZldGNoUmVnaXN0ZXIocmVnaXN0ZXIpO1xuICAgIH1cblxuICAgIHN3aXRjaCAocmVnaXN0ZXIpIHtcbiAgICAgIGNhc2UgJHMwOlxuICAgICAgICByZXR1cm4gdGhpcy5zMDtcbiAgICAgIGNhc2UgJHMxOlxuICAgICAgICByZXR1cm4gdGhpcy5zMTtcbiAgICAgIGNhc2UgJHQwOlxuICAgICAgICByZXR1cm4gdGhpcy50MDtcbiAgICAgIGNhc2UgJHQxOlxuICAgICAgICByZXR1cm4gdGhpcy50MTtcbiAgICAgIGNhc2UgJHYwOlxuICAgICAgICByZXR1cm4gdGhpcy52MDtcbiAgICB9XG4gIH1cblxuICAvLyBMb2FkIGEgdmFsdWUgaW50byBhIHJlZ2lzdGVyXG5cbiAgbG9hZFZhbHVlPFQ+KHJlZ2lzdGVyOiBSZWdpc3RlciB8IE1hY2hpbmVSZWdpc3RlciwgdmFsdWU6IFQpOiB2b2lkIHtcbiAgICBpZiAoaXNMb3dMZXZlbFJlZ2lzdGVyKHJlZ2lzdGVyKSkge1xuICAgICAgdGhpc1tJTk5FUl9WTV0ubG9hZFJlZ2lzdGVyKHJlZ2lzdGVyLCAodmFsdWUgYXMgYW55KSBhcyBudW1iZXIpO1xuICAgIH1cblxuICAgIHN3aXRjaCAocmVnaXN0ZXIpIHtcbiAgICAgIGNhc2UgJHMwOlxuICAgICAgICB0aGlzLnMwID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAkczE6XG4gICAgICAgIHRoaXMuczEgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICR0MDpcbiAgICAgICAgdGhpcy50MCA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJHQxOlxuICAgICAgICB0aGlzLnQxID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAkdjA6XG4gICAgICAgIHRoaXMudjAgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1pZ3JhdGVkIHRvIElubmVyXG4gICAqL1xuXG4gIC8vIFN0YXJ0IGEgbmV3IGZyYW1lIGFuZCBzYXZlICRyYSBhbmQgJGZwIG9uIHRoZSBzdGFja1xuICBwdXNoRnJhbWUoKSB7XG4gICAgdGhpc1tJTk5FUl9WTV0ucHVzaEZyYW1lKCk7XG4gIH1cblxuICAvLyBSZXN0b3JlICRyYSwgJHNwIGFuZCAkZnBcbiAgcG9wRnJhbWUoKSB7XG4gICAgdGhpc1tJTk5FUl9WTV0ucG9wRnJhbWUoKTtcbiAgfVxuXG4gIC8vIEp1bXAgdG8gYW4gYWRkcmVzcyBpbiBgcHJvZ3JhbWBcbiAgZ290byhvZmZzZXQ6IG51bWJlcikge1xuICAgIHRoaXNbSU5ORVJfVk1dLmdvdG8ob2Zmc2V0KTtcbiAgfVxuXG4gIC8vIFNhdmUgJHBjIGludG8gJHJhLCB0aGVuIGp1bXAgdG8gYSBuZXcgYWRkcmVzcyBpbiBgcHJvZ3JhbWAgKGphbCBpbiBNSVBTKVxuICBjYWxsKGhhbmRsZTogbnVtYmVyKSB7XG4gICAgdGhpc1tJTk5FUl9WTV0uY2FsbChoYW5kbGUpO1xuICB9XG5cbiAgLy8gUHV0IGEgc3BlY2lmaWMgYHByb2dyYW1gIGFkZHJlc3MgaW4gJHJhXG4gIHJldHVyblRvKG9mZnNldDogbnVtYmVyKSB7XG4gICAgdGhpc1tJTk5FUl9WTV0ucmV0dXJuVG8ob2Zmc2V0KTtcbiAgfVxuXG4gIC8vIFJldHVybiB0byB0aGUgYHByb2dyYW1gIGFkZHJlc3Mgc3RvcmVkIGluICRyYVxuICByZXR1cm4oKSB7XG4gICAgdGhpc1tJTk5FUl9WTV0ucmV0dXJuKCk7XG4gIH1cblxuICAvKipcbiAgICogRW5kIG9mIG1pZ3JhdGVkLlxuICAgKi9cblxuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBydW50aW1lOiBSdW50aW1lQ29udGV4dCxcbiAgICB7IHBjLCBzY29wZSwgZHluYW1pY1Njb3BlLCBzdGFjayB9OiBWTVN0YXRlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZWxlbWVudFN0YWNrOiBFbGVtZW50QnVpbGRlcixcbiAgICByZWFkb25seSBjb250ZXh0OiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dFxuICApIHtcbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIGFzc2VydEdsb2JhbENvbnRleHRXYXNTZXQhKCk7XG4gICAgfVxuXG4gICAgbGV0IGV2YWxTdGFjayA9IEV2YWx1YXRpb25TdGFja0ltcGwucmVzdG9yZShzdGFjayk7XG5cbiAgICBhc3NlcnQodHlwZW9mIHBjID09PSAnbnVtYmVyJywgJ3BjIGlzIGEgbnVtYmVyJyk7XG5cbiAgICBldmFsU3RhY2tbUkVHSVNURVJTXVskcGNdID0gcGM7XG4gICAgZXZhbFN0YWNrW1JFR0lTVEVSU11bJHNwXSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgZXZhbFN0YWNrW1JFR0lTVEVSU11bJGZwXSA9IC0xO1xuXG4gICAgdGhpc1tIRUFQXSA9IHRoaXMucHJvZ3JhbS5oZWFwO1xuICAgIHRoaXNbQ09OU1RBTlRTXSA9IHRoaXMucHJvZ3JhbS5jb25zdGFudHM7XG4gICAgdGhpcy5lbGVtZW50U3RhY2sgPSBlbGVtZW50U3RhY2s7XG4gICAgdGhpc1tTVEFDS1NdLnNjb3BlLnB1c2goc2NvcGUpO1xuICAgIHRoaXNbU1RBQ0tTXS5keW5hbWljU2NvcGUucHVzaChkeW5hbWljU2NvcGUpO1xuICAgIHRoaXNbQVJHU10gPSBuZXcgVk1Bcmd1bWVudHNJbXBsKCk7XG4gICAgdGhpc1tJTk5FUl9WTV0gPSBuZXcgTG93TGV2ZWxWTShcbiAgICAgIGV2YWxTdGFjayxcbiAgICAgIHRoaXNbSEVBUF0sXG4gICAgICBydW50aW1lLnByb2dyYW0sXG4gICAgICB7XG4gICAgICAgIGRlYnVnQmVmb3JlOiAob3Bjb2RlOiBSdW50aW1lT3BJbXBsKTogRGVidWdTdGF0ZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIEFQUEVORF9PUENPREVTLmRlYnVnQmVmb3JlKHRoaXMsIG9wY29kZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVidWdBZnRlcjogKHN0YXRlOiBEZWJ1Z1N0YXRlKTogdm9pZCA9PiB7XG4gICAgICAgICAgQVBQRU5EX09QQ09ERVMuZGVidWdBZnRlcih0aGlzLCBzdGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgZXZhbFN0YWNrW1JFR0lTVEVSU11cbiAgICApO1xuXG4gICAgdGhpcy5kZXN0cnVjdG9yID0ge307XG4gICAgdGhpc1tERVNUUk9ZQUJMRV9TVEFDS10ucHVzaCh0aGlzLmRlc3RydWN0b3IpO1xuICB9XG5cbiAgc3RhdGljIGluaXRpYWwoXG4gICAgcnVudGltZTogUnVudGltZUNvbnRleHQsXG4gICAgY29udGV4dDogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gICAgeyBoYW5kbGUsIHNlbGYsIGR5bmFtaWNTY29wZSwgdHJlZUJ1aWxkZXIsIG51bVN5bWJvbHMsIG93bmVyIH06IEluaXRPcHRpb25zXG4gICkge1xuICAgIGxldCBzY29wZSA9IFBhcnRpYWxTY29wZUltcGwucm9vdChzZWxmLCBudW1TeW1ib2xzLCBvd25lcik7XG4gICAgbGV0IHN0YXRlID0gdm1TdGF0ZShydW50aW1lLnByb2dyYW0uaGVhcC5nZXRhZGRyKGhhbmRsZSksIHNjb3BlLCBkeW5hbWljU2NvcGUpO1xuICAgIGxldCB2bSA9IGluaXRWTShjb250ZXh0KShydW50aW1lLCBzdGF0ZSwgdHJlZUJ1aWxkZXIpO1xuICAgIHZtLnB1c2hVcGRhdGluZygpO1xuICAgIHJldHVybiB2bTtcbiAgfVxuXG4gIHN0YXRpYyBlbXB0eShcbiAgICBydW50aW1lOiBSdW50aW1lQ29udGV4dCxcbiAgICB7IGhhbmRsZSwgdHJlZUJ1aWxkZXIsIGR5bmFtaWNTY29wZSwgb3duZXIgfTogTWluaW1hbEluaXRPcHRpb25zLFxuICAgIGNvbnRleHQ6IENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0XG4gICkge1xuICAgIGxldCB2bSA9IGluaXRWTShjb250ZXh0KShcbiAgICAgIHJ1bnRpbWUsXG4gICAgICB2bVN0YXRlKFxuICAgICAgICBydW50aW1lLnByb2dyYW0uaGVhcC5nZXRhZGRyKGhhbmRsZSksXG4gICAgICAgIFBhcnRpYWxTY29wZUltcGwucm9vdChVTkRFRklORURfUkVGRVJFTkNFLCAwLCBvd25lciksXG4gICAgICAgIGR5bmFtaWNTY29wZVxuICAgICAgKSxcbiAgICAgIHRyZWVCdWlsZGVyXG4gICAgKTtcbiAgICB2bS5wdXNoVXBkYXRpbmcoKTtcbiAgICByZXR1cm4gdm07XG4gIH1cblxuICBwcml2YXRlIHJlc3VtZTogVm1Jbml0Q2FsbGJhY2sgPSBpbml0Vk0odGhpcy5jb250ZXh0KTtcblxuICBjb21waWxlKGJsb2NrOiBDb21waWxhYmxlVGVtcGxhdGUpOiBudW1iZXIge1xuICAgIGxldCBoYW5kbGUgPSB1bndyYXBIYW5kbGUoYmxvY2suY29tcGlsZSh0aGlzLmNvbnRleHQpKTtcblxuICAgIHJldHVybiBoYW5kbGU7XG4gIH1cblxuICBnZXQgcHJvZ3JhbSgpOiBSdW50aW1lUHJvZ3JhbSB7XG4gICAgcmV0dXJuIHRoaXMucnVudGltZS5wcm9ncmFtO1xuICB9XG5cbiAgZ2V0IGVudigpOiBFbnZpcm9ubWVudCB7XG4gICAgcmV0dXJuIHRoaXMucnVudGltZS5lbnY7XG4gIH1cblxuICBjYXB0dXJlU3RhdGUoYXJnczogbnVtYmVyLCBwYyA9IHRoaXNbSU5ORVJfVk1dLmZldGNoUmVnaXN0ZXIoJHBjKSk6IFZNU3RhdGUge1xuICAgIHJldHVybiB7XG4gICAgICBwYyxcbiAgICAgIHNjb3BlOiB0aGlzLnNjb3BlKCksXG4gICAgICBkeW5hbWljU2NvcGU6IHRoaXMuZHluYW1pY1Njb3BlKCksXG4gICAgICBzdGFjazogdGhpcy5zdGFjay5jYXB0dXJlKGFyZ3MpLFxuICAgIH07XG4gIH1cblxuICBjYXB0dXJlKGFyZ3M6IG51bWJlciwgcGMgPSB0aGlzW0lOTkVSX1ZNXS5mZXRjaFJlZ2lzdGVyKCRwYykpOiBSZXN1bWFibGVWTVN0YXRlIHtcbiAgICByZXR1cm4gbmV3IFJlc3VtYWJsZVZNU3RhdGVJbXBsKHRoaXMuY2FwdHVyZVN0YXRlKGFyZ3MsIHBjKSwgdGhpcy5yZXN1bWUpO1xuICB9XG5cbiAgYmVnaW5DYWNoZUdyb3VwKG5hbWU/OiBzdHJpbmcpIHtcbiAgICBsZXQgb3Bjb2RlcyA9IHRoaXMudXBkYXRpbmcoKTtcbiAgICBsZXQgZ3VhcmQgPSBuZXcgSnVtcElmTm90TW9kaWZpZWRPcGNvZGUoKTtcblxuICAgIG9wY29kZXMucHVzaChndWFyZCk7XG4gICAgb3Bjb2Rlcy5wdXNoKG5ldyBCZWdpblRyYWNrRnJhbWVPcGNvZGUobmFtZSkpO1xuICAgIHRoaXNbU1RBQ0tTXS5jYWNoZS5wdXNoKGd1YXJkKTtcblxuICAgIGJlZ2luVHJhY2tGcmFtZShuYW1lKTtcbiAgfVxuXG4gIGNvbW1pdENhY2hlR3JvdXAoKSB7XG4gICAgbGV0IG9wY29kZXMgPSB0aGlzLnVwZGF0aW5nKCk7XG4gICAgbGV0IGd1YXJkID0gZXhwZWN0KHRoaXNbU1RBQ0tTXS5jYWNoZS5wb3AoKSwgJ1ZNIEJVRzogRXhwZWN0ZWQgYSBjYWNoZSBncm91cCcpO1xuXG4gICAgbGV0IHRhZyA9IGVuZFRyYWNrRnJhbWUoKTtcbiAgICBvcGNvZGVzLnB1c2gobmV3IEVuZFRyYWNrRnJhbWVPcGNvZGUoZ3VhcmQpKTtcblxuICAgIGd1YXJkLmZpbmFsaXplKHRhZywgb3Bjb2Rlcy5sZW5ndGgpO1xuICB9XG5cbiAgZW50ZXIoYXJnczogbnVtYmVyKSB7XG4gICAgbGV0IHVwZGF0aW5nOiBVcGRhdGluZ09wY29kZVtdID0gW107XG5cbiAgICBsZXQgc3RhdGUgPSB0aGlzLmNhcHR1cmUoYXJncyk7XG4gICAgbGV0IGJsb2NrID0gdGhpcy5lbGVtZW50cygpLnB1c2hVcGRhdGFibGVCbG9jaygpO1xuXG4gICAgbGV0IHRyeU9wY29kZSA9IG5ldyBUcnlPcGNvZGUoc3RhdGUsIHRoaXMucnVudGltZSwgYmxvY2ssIHVwZGF0aW5nKTtcblxuICAgIHRoaXMuZGlkRW50ZXIodHJ5T3Bjb2RlKTtcbiAgfVxuXG4gIGVudGVySXRlbSh7IGtleSwgdmFsdWUsIG1lbW8gfTogT3BhcXVlSXRlcmF0aW9uSXRlbSk6IExpc3RJdGVtT3Bjb2RlIHtcbiAgICBsZXQgeyBzdGFjayB9ID0gdGhpcztcblxuICAgIGxldCB2YWx1ZVJlZiA9IGNyZWF0ZUl0ZXJhdG9ySXRlbVJlZih2YWx1ZSk7XG4gICAgbGV0IG1lbW9SZWYgPSBjcmVhdGVJdGVyYXRvckl0ZW1SZWYobWVtbyk7XG5cbiAgICBzdGFjay5wdXNoKHZhbHVlUmVmKTtcbiAgICBzdGFjay5wdXNoKG1lbW9SZWYpO1xuXG4gICAgbGV0IHN0YXRlID0gdGhpcy5jYXB0dXJlKDIpO1xuICAgIGxldCBibG9jayA9IHRoaXMuZWxlbWVudHMoKS5wdXNoVXBkYXRhYmxlQmxvY2soKTtcblxuICAgIGxldCBvcGNvZGUgPSBuZXcgTGlzdEl0ZW1PcGNvZGUoc3RhdGUsIHRoaXMucnVudGltZSwgYmxvY2ssIGtleSwgbWVtb1JlZiwgdmFsdWVSZWYpO1xuICAgIHRoaXMuZGlkRW50ZXIob3Bjb2RlKTtcblxuICAgIHJldHVybiBvcGNvZGU7XG4gIH1cblxuICByZWdpc3Rlckl0ZW0ob3Bjb2RlOiBMaXN0SXRlbU9wY29kZSkge1xuICAgIHRoaXMubGlzdEJsb2NrKCkuaW5pdGlhbGl6ZUNoaWxkKG9wY29kZSk7XG4gIH1cblxuICBlbnRlckxpc3QoaXRlcmFibGVSZWY6IFJlZmVyZW5jZTxPcGFxdWVJdGVyYXRvcj4sIG9mZnNldDogbnVtYmVyKSB7XG4gICAgbGV0IHVwZGF0aW5nOiBMaXN0SXRlbU9wY29kZVtdID0gW107XG5cbiAgICBsZXQgYWRkciA9IHRoaXNbSU5ORVJfVk1dLnRhcmdldChvZmZzZXQpO1xuICAgIGxldCBzdGF0ZSA9IHRoaXMuY2FwdHVyZSgwLCBhZGRyKTtcbiAgICBsZXQgbGlzdCA9IHRoaXMuZWxlbWVudHMoKS5wdXNoQmxvY2tMaXN0KHVwZGF0aW5nKSBhcyBMaXZlQmxvY2tMaXN0O1xuXG4gICAgbGV0IG9wY29kZSA9IG5ldyBMaXN0QmxvY2tPcGNvZGUoc3RhdGUsIHRoaXMucnVudGltZSwgbGlzdCwgdXBkYXRpbmcsIGl0ZXJhYmxlUmVmKTtcblxuICAgIHRoaXNbU1RBQ0tTXS5saXN0LnB1c2gob3Bjb2RlKTtcblxuICAgIHRoaXMuZGlkRW50ZXIob3Bjb2RlKTtcbiAgfVxuXG4gIHByaXZhdGUgZGlkRW50ZXIob3Bjb2RlOiBCbG9ja09wY29kZSkge1xuICAgIHRoaXMuYXNzb2NpYXRlRGVzdHJveWFibGUob3Bjb2RlKTtcbiAgICB0aGlzW0RFU1RST1lBQkxFX1NUQUNLXS5wdXNoKG9wY29kZSk7XG4gICAgdGhpcy51cGRhdGVXaXRoKG9wY29kZSk7XG4gICAgdGhpcy5wdXNoVXBkYXRpbmcob3Bjb2RlLmNoaWxkcmVuKTtcbiAgfVxuXG4gIGV4aXQoKSB7XG4gICAgdGhpc1tERVNUUk9ZQUJMRV9TVEFDS10ucG9wKCk7XG4gICAgdGhpcy5lbGVtZW50cygpLnBvcEJsb2NrKCk7XG4gICAgdGhpcy5wb3BVcGRhdGluZygpO1xuICB9XG5cbiAgZXhpdExpc3QoKSB7XG4gICAgdGhpcy5leGl0KCk7XG4gICAgdGhpc1tTVEFDS1NdLmxpc3QucG9wKCk7XG4gIH1cblxuICBwdXNoVXBkYXRpbmcobGlzdDogVXBkYXRpbmdPcGNvZGVbXSA9IFtdKTogdm9pZCB7XG4gICAgdGhpc1tTVEFDS1NdLnVwZGF0aW5nLnB1c2gobGlzdCk7XG4gIH1cblxuICBwb3BVcGRhdGluZygpOiBVcGRhdGluZ09wY29kZVtdIHtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXNbU1RBQ0tTXS51cGRhdGluZy5wb3AoKSwgXCJjYW4ndCBwb3AgYW4gZW1wdHkgc3RhY2tcIik7XG4gIH1cblxuICB1cGRhdGVXaXRoKG9wY29kZTogVXBkYXRpbmdPcGNvZGUpIHtcbiAgICB0aGlzLnVwZGF0aW5nKCkucHVzaChvcGNvZGUpO1xuICB9XG5cbiAgbGlzdEJsb2NrKCk6IExpc3RCbG9ja09wY29kZSB7XG4gICAgcmV0dXJuIGV4cGVjdCh0aGlzW1NUQUNLU10ubGlzdC5jdXJyZW50LCAnZXhwZWN0ZWQgYSBsaXN0IGJsb2NrJyk7XG4gIH1cblxuICBhc3NvY2lhdGVEZXN0cm95YWJsZShjaGlsZDogRGVzdHJveWFibGUpOiB2b2lkIHtcbiAgICBsZXQgcGFyZW50ID0gZXhwZWN0KHRoaXNbREVTVFJPWUFCTEVfU1RBQ0tdLmN1cnJlbnQsICdFeHBlY3RlZCBkZXN0cnVjdG9yIHBhcmVudCcpO1xuICAgIGFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQocGFyZW50LCBjaGlsZCk7XG4gIH1cblxuICB0cnlVcGRhdGluZygpOiBPcHRpb248VXBkYXRpbmdPcGNvZGVbXT4ge1xuICAgIHJldHVybiB0aGlzW1NUQUNLU10udXBkYXRpbmcuY3VycmVudDtcbiAgfVxuXG4gIHVwZGF0aW5nKCk6IFVwZGF0aW5nT3Bjb2RlW10ge1xuICAgIHJldHVybiBleHBlY3QoXG4gICAgICB0aGlzW1NUQUNLU10udXBkYXRpbmcuY3VycmVudCxcbiAgICAgICdleHBlY3RlZCB1cGRhdGluZyBvcGNvZGUgb24gdGhlIHVwZGF0aW5nIG9wY29kZSBzdGFjaydcbiAgICApO1xuICB9XG5cbiAgZWxlbWVudHMoKTogRWxlbWVudEJ1aWxkZXIge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGFjaztcbiAgfVxuXG4gIHNjb3BlKCk6IFNjb3BlIHtcbiAgICByZXR1cm4gZXhwZWN0KHRoaXNbU1RBQ0tTXS5zY29wZS5jdXJyZW50LCAnZXhwZWN0ZWQgc2NvcGUgb24gdGhlIHNjb3BlIHN0YWNrJyk7XG4gIH1cblxuICBkeW5hbWljU2NvcGUoKTogRHluYW1pY1Njb3BlIHtcbiAgICByZXR1cm4gZXhwZWN0KFxuICAgICAgdGhpc1tTVEFDS1NdLmR5bmFtaWNTY29wZS5jdXJyZW50LFxuICAgICAgJ2V4cGVjdGVkIGR5bmFtaWMgc2NvcGUgb24gdGhlIGR5bmFtaWMgc2NvcGUgc3RhY2snXG4gICAgKTtcbiAgfVxuXG4gIHB1c2hDaGlsZFNjb3BlKCkge1xuICAgIHRoaXNbU1RBQ0tTXS5zY29wZS5wdXNoKHRoaXMuc2NvcGUoKS5jaGlsZCgpKTtcbiAgfVxuXG4gIHB1c2hEeW5hbWljU2NvcGUoKTogRHluYW1pY1Njb3BlIHtcbiAgICBsZXQgY2hpbGQgPSB0aGlzLmR5bmFtaWNTY29wZSgpLmNoaWxkKCk7XG4gICAgdGhpc1tTVEFDS1NdLmR5bmFtaWNTY29wZS5wdXNoKGNoaWxkKTtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cblxuICBwdXNoUm9vdFNjb3BlKHNpemU6IG51bWJlciwgb3duZXI6IE93bmVyKTogUGFydGlhbFNjb3BlIHtcbiAgICBsZXQgc2NvcGUgPSBQYXJ0aWFsU2NvcGVJbXBsLnNpemVkKHNpemUsIG93bmVyKTtcbiAgICB0aGlzW1NUQUNLU10uc2NvcGUucHVzaChzY29wZSk7XG4gICAgcmV0dXJuIHNjb3BlO1xuICB9XG5cbiAgcHVzaFNjb3BlKHNjb3BlOiBTY29wZSkge1xuICAgIHRoaXNbU1RBQ0tTXS5zY29wZS5wdXNoKHNjb3BlKTtcbiAgfVxuXG4gIHBvcFNjb3BlKCkge1xuICAgIHRoaXNbU1RBQ0tTXS5zY29wZS5wb3AoKTtcbiAgfVxuXG4gIHBvcER5bmFtaWNTY29wZSgpIHtcbiAgICB0aGlzW1NUQUNLU10uZHluYW1pY1Njb3BlLnBvcCgpO1xuICB9XG5cbiAgLy8vIFNDT1BFIEhFTFBFUlNcblxuICBnZXRPd25lcigpOiBPd25lciB7XG4gICAgcmV0dXJuIHRoaXMuc2NvcGUoKS5vd25lcjtcbiAgfVxuXG4gIGdldFNlbGYoKTogUmVmZXJlbmNlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLnNjb3BlKCkuZ2V0U2VsZigpO1xuICB9XG5cbiAgcmVmZXJlbmNlRm9yU3ltYm9sKHN5bWJvbDogbnVtYmVyKTogUmVmZXJlbmNlIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZSgpLmdldFN5bWJvbChzeW1ib2wpO1xuICB9XG5cbiAgLy8vIEVYRUNVVElPTlxuXG4gIGV4ZWN1dGUoaW5pdGlhbGl6ZT86ICh2bTogdGhpcykgPT4gdm9pZCk6IFJlbmRlclJlc3VsdCB7XG4gICAgaWYgKERFQlVHKSB7XG4gICAgICBsZXQgaGFzRXJyb3JlZCA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLl9leGVjdXRlKGluaXRpYWxpemUpO1xuXG4gICAgICAgIC8vIHVzaW5nIGEgYm9vbGVhbiBoZXJlIHRvIGF2b2lkIGJyZWFraW5nIGVyZ29ub21pY3Mgb2YgXCJwYXVzZSBvbiB1bmNhdWdodCBleGNlcHRpb25zXCJcbiAgICAgICAgLy8gd2hpY2ggd291bGQgaGFwcGVuIHdpdGggYSBgY2F0Y2hgICsgYHRocm93YFxuICAgICAgICBoYXNFcnJvcmVkID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGhhc0Vycm9yZWQpIHtcbiAgICAgICAgICAvLyBJZiBhbnkgZXhpc3RpbmcgYmxvY2tzIGFyZSBvcGVuLCBkdWUgdG8gYW4gZXJyb3Igb3Igc29tZXRoaW5nIGxpa2VcbiAgICAgICAgICAvLyB0aGF0LCB3ZSBuZWVkIHRvIGNsb3NlIHRoZW0gYWxsIGFuZCBjbGVhbiB0aGluZ3MgdXAgcHJvcGVybHkuXG4gICAgICAgICAgbGV0IGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cygpO1xuXG4gICAgICAgICAgd2hpbGUgKGVsZW1lbnRzLmhhc0Jsb2Nrcykge1xuICAgICAgICAgICAgZWxlbWVudHMucG9wQmxvY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFxcblxcbkVycm9yIG9jY3VycmVkOlxcblxcbiR7cmVzZXRUcmFja2luZygpfVxcblxcbmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9leGVjdXRlKGluaXRpYWxpemUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2V4ZWN1dGUoaW5pdGlhbGl6ZT86ICh2bTogdGhpcykgPT4gdm9pZCk6IFJlbmRlclJlc3VsdCB7XG4gICAgaWYgKExPQ0FMX1NIT1VMRF9MT0cpIHtcbiAgICAgIExPQ0FMX0xPR0dFUi5sb2coYEVYRUNVVElORyBGUk9NICR7dGhpc1tJTk5FUl9WTV0uZmV0Y2hSZWdpc3RlcigkcGMpfWApO1xuICAgIH1cblxuICAgIGlmIChpbml0aWFsaXplKSBpbml0aWFsaXplKHRoaXMpO1xuXG4gICAgbGV0IHJlc3VsdDogUmljaEl0ZXJhdG9yUmVzdWx0PG51bGwsIFJlbmRlclJlc3VsdD47XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5uZXh0KCk7XG4gICAgICBpZiAocmVzdWx0LmRvbmUpIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH1cblxuICBuZXh0KCk6IFJpY2hJdGVyYXRvclJlc3VsdDxudWxsLCBSZW5kZXJSZXN1bHQ+IHtcbiAgICBsZXQgeyBlbnYsIGVsZW1lbnRTdGFjayB9ID0gdGhpcztcbiAgICBsZXQgb3Bjb2RlID0gdGhpc1tJTk5FUl9WTV0ubmV4dFN0YXRlbWVudCgpO1xuICAgIGxldCByZXN1bHQ6IFJpY2hJdGVyYXRvclJlc3VsdDxudWxsLCBSZW5kZXJSZXN1bHQ+O1xuICAgIGlmIChvcGNvZGUgIT09IG51bGwpIHtcbiAgICAgIHRoaXNbSU5ORVJfVk1dLmV2YWx1YXRlT3V0ZXIob3Bjb2RlLCB0aGlzKTtcbiAgICAgIHJlc3VsdCA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBudWxsIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVubG9hZCB0aGUgc3RhY2tcbiAgICAgIHRoaXMuc3RhY2sucmVzZXQoKTtcblxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICB2YWx1ZTogbmV3IFJlbmRlclJlc3VsdEltcGwoXG4gICAgICAgICAgZW52LFxuICAgICAgICAgIHRoaXMucG9wVXBkYXRpbmcoKSxcbiAgICAgICAgICBlbGVtZW50U3RhY2sucG9wQmxvY2soKSxcbiAgICAgICAgICB0aGlzLmRlc3RydWN0b3JcbiAgICAgICAgKSxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBiaW5kRHluYW1pY1Njb3BlKG5hbWVzOiBzdHJpbmdbXSkge1xuICAgIGxldCBzY29wZSA9IHRoaXMuZHluYW1pY1Njb3BlKCk7XG5cbiAgICBmb3IgKGxldCBpID0gbmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBuYW1lID0gbmFtZXNbaV07XG4gICAgICBzY29wZS5zZXQobmFtZSwgdGhpcy5zdGFjay5wb3A8UmVmZXJlbmNlPHVua25vd24+PigpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdm1TdGF0ZShwYzogbnVtYmVyLCBzY29wZTogU2NvcGUsIGR5bmFtaWNTY29wZTogRHluYW1pY1Njb3BlKSB7XG4gIHJldHVybiB7XG4gICAgcGMsXG4gICAgc2NvcGUsXG4gICAgZHluYW1pY1Njb3BlLFxuICAgIHN0YWNrOiBbXSxcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNaW5pbWFsSW5pdE9wdGlvbnMge1xuICBoYW5kbGU6IG51bWJlcjtcbiAgdHJlZUJ1aWxkZXI6IEVsZW1lbnRCdWlsZGVyO1xuICBkeW5hbWljU2NvcGU6IER5bmFtaWNTY29wZTtcbiAgb3duZXI6IE93bmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEluaXRPcHRpb25zIGV4dGVuZHMgTWluaW1hbEluaXRPcHRpb25zIHtcbiAgc2VsZjogUmVmZXJlbmNlO1xuICBudW1TeW1ib2xzOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIFZtSW5pdENhbGxiYWNrID0gKFxuICB0aGlzOiB2b2lkLFxuICBydW50aW1lOiBSdW50aW1lQ29udGV4dCxcbiAgc3RhdGU6IFZNU3RhdGUsXG4gIGJ1aWxkZXI6IEVsZW1lbnRCdWlsZGVyXG4pID0+IEludGVybmFsVk07XG5cbmZ1bmN0aW9uIGluaXRWTShjb250ZXh0OiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCk6IFZtSW5pdENhbGxiYWNrIHtcbiAgcmV0dXJuIChydW50aW1lLCBzdGF0ZSwgYnVpbGRlcikgPT4gbmV3IFZNKHJ1bnRpbWUsIHN0YXRlLCBidWlsZGVyLCBjb250ZXh0KTtcbn1cbiIsImltcG9ydCB7XG4gIER5bmFtaWNTY29wZSxcbiAgRW52aXJvbm1lbnQsXG4gIFJlbmRlclJlc3VsdCxcbiAgUmljaEl0ZXJhdG9yUmVzdWx0LFxuICBUZW1wbGF0ZUl0ZXJhdG9yLFxuICBSdW50aW1lQ29udGV4dCxcbiAgRWxlbWVudEJ1aWxkZXIsXG4gIENvbXBpbGFibGVQcm9ncmFtLFxuICBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCxcbiAgQ29tcG9uZW50RGVmaW5pdGlvblN0YXRlLFxuICBPd25lcixcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjaGlsZFJlZkZvciwgY3JlYXRlQ29uc3RSZWYsIFJlZmVyZW5jZSB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBleHBlY3QsIHVud3JhcEhhbmRsZSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQVJHUywgQ09OU1RBTlRTIH0gZnJvbSAnLi9zeW1ib2xzJztcbmltcG9ydCBWTSwgeyBJbnRlcm5hbFZNIH0gZnJvbSAnLi92bS9hcHBlbmQnO1xuaW1wb3J0IHsgRHluYW1pY1Njb3BlSW1wbCB9IGZyb20gJy4vc2NvcGUnO1xuaW1wb3J0IHsgaW5UcmFuc2FjdGlvbiB9IGZyb20gJy4vZW52aXJvbm1lbnQnO1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHsgcnVuSW5UcmFja2luZ1RyYW5zYWN0aW9uIH0gZnJvbSAnQGdsaW1tZXIvdmFsaWRhdG9yJztcblxuY2xhc3MgVGVtcGxhdGVJdGVyYXRvckltcGwgaW1wbGVtZW50cyBUZW1wbGF0ZUl0ZXJhdG9yIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB2bTogSW50ZXJuYWxWTSkge31cbiAgbmV4dCgpOiBSaWNoSXRlcmF0b3JSZXN1bHQ8bnVsbCwgUmVuZGVyUmVzdWx0PiB7XG4gICAgcmV0dXJuIHRoaXMudm0ubmV4dCgpO1xuICB9XG5cbiAgc3luYygpOiBSZW5kZXJSZXN1bHQge1xuICAgIGlmIChERUJVRykge1xuICAgICAgcmV0dXJuIHJ1bkluVHJhY2tpbmdUcmFuc2FjdGlvbiEoKCkgPT4gdGhpcy52bS5leGVjdXRlKCksICctIFdoaWxlIHJlbmRlcmluZzonKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudm0uZXhlY3V0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyU3luYyhlbnY6IEVudmlyb25tZW50LCBpdGVyYXRvcjogVGVtcGxhdGVJdGVyYXRvcik6IFJlbmRlclJlc3VsdCB7XG4gIGxldCByZXN1bHQ6IFJlbmRlclJlc3VsdDtcblxuICBpblRyYW5zYWN0aW9uKGVudiwgKCkgPT4gKHJlc3VsdCA9IGl0ZXJhdG9yLnN5bmMoKSkpO1xuXG4gIHJldHVybiByZXN1bHQhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWFpbihcbiAgcnVudGltZTogUnVudGltZUNvbnRleHQsXG4gIGNvbnRleHQ6IENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0LFxuICBvd25lcjogT3duZXIsXG4gIHNlbGY6IFJlZmVyZW5jZSxcbiAgdHJlZUJ1aWxkZXI6IEVsZW1lbnRCdWlsZGVyLFxuICBsYXlvdXQ6IENvbXBpbGFibGVQcm9ncmFtLFxuICBkeW5hbWljU2NvcGU6IER5bmFtaWNTY29wZSA9IG5ldyBEeW5hbWljU2NvcGVJbXBsKClcbik6IFRlbXBsYXRlSXRlcmF0b3Ige1xuICBsZXQgaGFuZGxlID0gdW53cmFwSGFuZGxlKGxheW91dC5jb21waWxlKGNvbnRleHQpKTtcbiAgbGV0IG51bVN5bWJvbHMgPSBsYXlvdXQuc3ltYm9sVGFibGUuc3ltYm9scy5sZW5ndGg7XG4gIGxldCB2bSA9IFZNLmluaXRpYWwocnVudGltZSwgY29udGV4dCwge1xuICAgIHNlbGYsXG4gICAgZHluYW1pY1Njb3BlLFxuICAgIHRyZWVCdWlsZGVyLFxuICAgIGhhbmRsZSxcbiAgICBudW1TeW1ib2xzLFxuICAgIG93bmVyLFxuICB9KTtcbiAgcmV0dXJuIG5ldyBUZW1wbGF0ZUl0ZXJhdG9ySW1wbCh2bSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckludm9jYXRpb24oXG4gIHZtOiBJbnRlcm5hbFZNLFxuICBjb250ZXh0OiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCxcbiAgb3duZXI6IE93bmVyLFxuICBkZWZpbml0aW9uOiBDb21wb25lbnREZWZpbml0aW9uU3RhdGUsXG4gIGFyZ3M6IFJlY29yZDxzdHJpbmcsIFJlZmVyZW5jZT5cbik6IFRlbXBsYXRlSXRlcmF0b3Ige1xuICAvLyBHZXQgYSBsaXN0IG9mIHR1cGxlcyBvZiBhcmd1bWVudCBuYW1lcyBhbmQgcmVmZXJlbmNlcywgbGlrZVxuICAvLyBbWyd0aXRsZScsIHJlZmVyZW5jZV0sIFsnbmFtZScsIHJlZmVyZW5jZV1dXG4gIGNvbnN0IGFyZ0xpc3QgPSBPYmplY3Qua2V5cyhhcmdzKS5tYXAoKGtleSkgPT4gW2tleSwgYXJnc1trZXldXSk7XG5cbiAgY29uc3QgYmxvY2tOYW1lcyA9IFsnbWFpbicsICdlbHNlJywgJ2F0dHJzJ107XG4gIC8vIFByZWZpeCBhcmd1bWVudCBuYW1lcyB3aXRoIGBAYCBzeW1ib2xcbiAgY29uc3QgYXJnTmFtZXMgPSBhcmdMaXN0Lm1hcCgoW25hbWVdKSA9PiBgQCR7bmFtZX1gKTtcblxuICBsZXQgcmVpZmllZCA9IHZtW0NPTlNUQU5UU10uY29tcG9uZW50KGRlZmluaXRpb24sIG93bmVyKTtcblxuICB2bS5wdXNoRnJhbWUoKTtcblxuICAvLyBQdXNoIGJsb2NrcyBvbiB0byB0aGUgc3RhY2ssIHRocmVlIHN0YWNrIHZhbHVlcyBwZXIgYmxvY2tcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzICogYmxvY2tOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZtLnN0YWNrLnB1c2gobnVsbCk7XG4gIH1cblxuICB2bS5zdGFjay5wdXNoKG51bGwpO1xuXG4gIC8vIEZvciBlYWNoIGFyZ3VtZW50LCBwdXNoIGl0cyBiYWNraW5nIHJlZmVyZW5jZSBvbiB0byB0aGUgc3RhY2tcbiAgYXJnTGlzdC5mb3JFYWNoKChbLCByZWZlcmVuY2VdKSA9PiB7XG4gICAgdm0uc3RhY2sucHVzaChyZWZlcmVuY2UpO1xuICB9KTtcblxuICAvLyBDb25maWd1cmUgVk0gYmFzZWQgb24gYmxvY2tzIGFuZCBhcmdzIGp1c3QgcHVzaGVkIG9uIHRvIHRoZSBzdGFjay5cbiAgdm1bQVJHU10uc2V0dXAodm0uc3RhY2ssIGFyZ05hbWVzLCBibG9ja05hbWVzLCAwLCB0cnVlKTtcblxuICBjb25zdCBjb21waWxhYmxlID0gZXhwZWN0KFxuICAgIHJlaWZpZWQuY29tcGlsYWJsZSxcbiAgICAnQlVHOiBFeHBlY3RlZCB0aGUgcm9vdCBjb21wb25lbnQgcmVuZGVyZWQgd2l0aCByZW5kZXJDb21wb25lbnQgdG8gaGF2ZSBhbiBhc3NvY2lhdGVkIHRlbXBsYXRlLCBzZXQgd2l0aCBzZXRDb21wb25lbnRUZW1wbGF0ZSdcbiAgKTtcbiAgY29uc3QgbGF5b3V0SGFuZGxlID0gdW53cmFwSGFuZGxlKGNvbXBpbGFibGUuY29tcGlsZShjb250ZXh0KSk7XG4gIGNvbnN0IGludm9jYXRpb24gPSB7IGhhbmRsZTogbGF5b3V0SGFuZGxlLCBzeW1ib2xUYWJsZTogY29tcGlsYWJsZS5zeW1ib2xUYWJsZSB9O1xuXG4gIC8vIE5lZWRlZCBmb3IgdGhlIE9wLk1haW4gb3Bjb2RlOiBhcmd1bWVudHMsIGNvbXBvbmVudCBpbnZvY2F0aW9uIG9iamVjdCwgYW5kXG4gIC8vIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICB2bS5zdGFjay5wdXNoKHZtW0FSR1NdKTtcbiAgdm0uc3RhY2sucHVzaChpbnZvY2F0aW9uKTtcbiAgdm0uc3RhY2sucHVzaChyZWlmaWVkKTtcblxuICByZXR1cm4gbmV3IFRlbXBsYXRlSXRlcmF0b3JJbXBsKHZtKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudChcbiAgcnVudGltZTogUnVudGltZUNvbnRleHQsXG4gIHRyZWVCdWlsZGVyOiBFbGVtZW50QnVpbGRlcixcbiAgY29udGV4dDogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIG93bmVyOiBPd25lcixcbiAgZGVmaW5pdGlvbjogQ29tcG9uZW50RGVmaW5pdGlvblN0YXRlLFxuICBhcmdzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9LFxuICBkeW5hbWljU2NvcGU6IER5bmFtaWNTY29wZSA9IG5ldyBEeW5hbWljU2NvcGVJbXBsKClcbik6IFRlbXBsYXRlSXRlcmF0b3Ige1xuICBsZXQgdm0gPSBWTS5lbXB0eShcbiAgICBydW50aW1lLFxuICAgIHsgdHJlZUJ1aWxkZXIsIGhhbmRsZTogY29udGV4dC5zdGRsaWIubWFpbiwgZHluYW1pY1Njb3BlLCBvd25lciB9LFxuICAgIGNvbnRleHRcbiAgKTtcbiAgcmV0dXJuIHJlbmRlckludm9jYXRpb24odm0sIGNvbnRleHQsIG93bmVyLCBkZWZpbml0aW9uLCByZWNvcmRUb1JlZmVyZW5jZShhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIHJlY29yZFRvUmVmZXJlbmNlKHJlY29yZDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBSZWNvcmQ8c3RyaW5nLCBSZWZlcmVuY2U+IHtcbiAgY29uc3Qgcm9vdCA9IGNyZWF0ZUNvbnN0UmVmKHJlY29yZCwgJ2FyZ3MnKTtcblxuICByZXR1cm4gT2JqZWN0LmtleXMocmVjb3JkKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgYWNjW2tleV0gPSBjaGlsZFJlZkZvcihyb290LCBrZXkpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIFJlZmVyZW5jZT4pO1xufVxuIiwiaW1wb3J0IHsgQm91bmRzLCBFbGVtZW50QnVpbGRlciwgRW52aXJvbm1lbnQsIE9wdGlvbiwgTWF5YmUgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGFzc2VydCwgY2FzdFRvQnJvd3NlciwgY2FzdFRvU2ltcGxlLCBleHBlY3QsIFN0YWNrIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQge1xuICBBdHRyTmFtZXNwYWNlLFxuICBOYW1lc3BhY2UsXG4gIE5vZGVUeXBlLFxuICBTaW1wbGVBdHRyLFxuICBTaW1wbGVDb21tZW50LFxuICBTaW1wbGVFbGVtZW50LFxuICBTaW1wbGVOb2RlLFxuICBTaW1wbGVUZXh0LFxufSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ29uY3JldGVCb3VuZHMsIEN1cnNvckltcGwgfSBmcm9tICcuLi9ib3VuZHMnO1xuaW1wb3J0IHsgQ1VSU09SX1NUQUNLLCBOZXdFbGVtZW50QnVpbGRlciwgUmVtb3RlTGl2ZUJsb2NrIH0gZnJvbSAnLi9lbGVtZW50LWJ1aWxkZXInO1xuXG5leHBvcnQgY29uc3QgU0VSSUFMSVpBVElPTl9GSVJTVF9OT0RFX1NUUklORyA9ICclK2I6MCUnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTZXJpYWxpemF0aW9uRmlyc3ROb2RlKG5vZGU6IFNpbXBsZU5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIG5vZGUubm9kZVZhbHVlID09PSBTRVJJQUxJWkFUSU9OX0ZJUlNUX05PREVfU1RSSU5HO1xufVxuXG5leHBvcnQgY2xhc3MgUmVoeWRyYXRpbmdDdXJzb3IgZXh0ZW5kcyBDdXJzb3JJbXBsIHtcbiAgY2FuZGlkYXRlOiBPcHRpb248U2ltcGxlTm9kZT4gPSBudWxsO1xuICBvcGVuQmxvY2tEZXB0aDogbnVtYmVyO1xuICBpbmplY3RlZE9taXR0ZWROb2RlID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsXG4gICAgbmV4dFNpYmxpbmc6IE9wdGlvbjxTaW1wbGVOb2RlPixcbiAgICBwdWJsaWMgcmVhZG9ubHkgc3RhcnRpbmdCbG9ja0RlcHRoOiBudW1iZXJcbiAgKSB7XG4gICAgc3VwZXIoZWxlbWVudCwgbmV4dFNpYmxpbmcpO1xuICAgIHRoaXMub3BlbkJsb2NrRGVwdGggPSBzdGFydGluZ0Jsb2NrRGVwdGggLSAxO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSZWh5ZHJhdGVCdWlsZGVyIGV4dGVuZHMgTmV3RWxlbWVudEJ1aWxkZXIgaW1wbGVtZW50cyBFbGVtZW50QnVpbGRlciB7XG4gIHByaXZhdGUgdW5tYXRjaGVkQXR0cmlidXRlczogT3B0aW9uPFNpbXBsZUF0dHJbXT4gPSBudWxsO1xuICBbQ1VSU09SX1NUQUNLXSE6IFN0YWNrPFJlaHlkcmF0aW5nQ3Vyc29yPjsgLy8gSGlkZXMgcHJvcGVydHkgb24gYmFzZSBjbGFzc1xuICBibG9ja0RlcHRoID0gMDtcbiAgc3RhcnRpbmdCbG9ja09mZnNldDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGVudjogRW52aXJvbm1lbnQsIHBhcmVudE5vZGU6IFNpbXBsZUVsZW1lbnQsIG5leHRTaWJsaW5nOiBPcHRpb248U2ltcGxlTm9kZT4pIHtcbiAgICBzdXBlcihlbnYsIHBhcmVudE5vZGUsIG5leHRTaWJsaW5nKTtcbiAgICBpZiAobmV4dFNpYmxpbmcpIHRocm93IG5ldyBFcnJvcignUmVoeWRyYXRpb24gd2l0aCBuZXh0U2libGluZyBub3Qgc3VwcG9ydGVkJyk7XG5cbiAgICBsZXQgbm9kZSA9IHRoaXMuY3VycmVudEN1cnNvciEuZWxlbWVudC5maXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChpc09wZW5CbG9jayhub2RlKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIGFzc2VydChub2RlLCAnTXVzdCBoYXZlIG9wZW5pbmcgY29tbWVudCBmb3IgcmVoeWRyYXRpb24uJyk7XG4gICAgdGhpcy5jYW5kaWRhdGUgPSBub2RlO1xuICAgIGNvbnN0IHN0YXJ0aW5nQmxvY2tPZmZzZXQgPSBnZXRCbG9ja0RlcHRoKG5vZGUgYXMgU2ltcGxlQ29tbWVudCk7XG4gICAgaWYgKHN0YXJ0aW5nQmxvY2tPZmZzZXQgIT09IDApIHtcbiAgICAgIC8vIFdlIGFyZSByZWh5ZHJhdGluZyBmcm9tIGEgcGFydGlhbCB0cmVlIGFuZCBub3QgdGhlIHJvb3QgY29tcG9uZW50XG4gICAgICAvLyBXZSBuZWVkIHRvIGFkZCBhbiBleHRyYSBibG9jayBiZWZvcmUgdGhlIGZpcnN0IGJsb2NrIHRvIHJlaHlkcmF0ZSBjb3JyZWN0bHlcbiAgICAgIC8vIFRoZSBleHRyYSBibG9jayBpcyBuZWVkZWQgc2luY2UgdGhlIHJlbmRlckNvbXBvbmVudCBBUEkgY3JlYXRlcyBhIHN5bnRoZXRpYyBjb21wb25lbnQgaW52b2NhdGlvbiB3aGljaCBnZW5lcmF0ZXMgdGhlIGV4dHJhIGJsb2NrXG4gICAgICBjb25zdCBuZXdCbG9ja0RlcHRoID0gc3RhcnRpbmdCbG9ja09mZnNldCAtIDE7XG4gICAgICBjb25zdCBuZXdDYW5kaWRhdGUgPSB0aGlzLmRvbS5jcmVhdGVDb21tZW50KGAlK2I6JHtuZXdCbG9ja0RlcHRofSVgKTtcblxuICAgICAgbm9kZSEucGFyZW50Tm9kZSEuaW5zZXJ0QmVmb3JlKG5ld0NhbmRpZGF0ZSwgdGhpcy5jYW5kaWRhdGUpO1xuICAgICAgbGV0IGNsb3NpbmdOb2RlID0gbm9kZSEubmV4dFNpYmxpbmc7XG4gICAgICB3aGlsZSAoY2xvc2luZ05vZGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzQ2xvc2VCbG9jayhjbG9zaW5nTm9kZSkgJiYgZ2V0QmxvY2tEZXB0aChjbG9zaW5nTm9kZSkgPT09IHN0YXJ0aW5nQmxvY2tPZmZzZXQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjbG9zaW5nTm9kZSA9IGNsb3NpbmdOb2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQoY2xvc2luZ05vZGUsICdNdXN0IGhhdmUgY2xvc2luZyBjb21tZW50IGZvciBzdGFydGluZyBibG9jayBjb21tZW50Jyk7XG4gICAgICBjb25zdCBuZXdDbG9zaW5nQmxvY2sgPSB0aGlzLmRvbS5jcmVhdGVDb21tZW50KGAlLWI6JHtuZXdCbG9ja0RlcHRofSVgKTtcbiAgICAgIG5vZGUhLnBhcmVudE5vZGUhLmluc2VydEJlZm9yZShuZXdDbG9zaW5nQmxvY2ssIGNsb3NpbmdOb2RlIS5uZXh0U2libGluZyk7XG4gICAgICB0aGlzLmNhbmRpZGF0ZSA9IG5ld0NhbmRpZGF0ZTtcbiAgICAgIHRoaXMuc3RhcnRpbmdCbG9ja09mZnNldCA9IG5ld0Jsb2NrRGVwdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnRpbmdCbG9ja09mZnNldCA9IDA7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGN1cnJlbnRDdXJzb3IoKTogT3B0aW9uPFJlaHlkcmF0aW5nQ3Vyc29yPiB7XG4gICAgcmV0dXJuIHRoaXNbQ1VSU09SX1NUQUNLXS5jdXJyZW50O1xuICB9XG5cbiAgZ2V0IGNhbmRpZGF0ZSgpOiBPcHRpb248U2ltcGxlTm9kZT4ge1xuICAgIGlmICh0aGlzLmN1cnJlbnRDdXJzb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRDdXJzb3IuY2FuZGlkYXRlITtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHNldCBjYW5kaWRhdGUobm9kZTogT3B0aW9uPFNpbXBsZU5vZGU+KSB7XG4gICAgbGV0IGN1cnJlbnRDdXJzb3IgPSB0aGlzLmN1cnJlbnRDdXJzb3IhO1xuXG4gICAgY3VycmVudEN1cnNvci5jYW5kaWRhdGUgPSBub2RlO1xuICB9XG5cbiAgZGlzYWJsZVJlaHlkcmF0aW9uKG5leHRTaWJsaW5nOiBPcHRpb248U2ltcGxlTm9kZT4pIHtcbiAgICBsZXQgY3VycmVudEN1cnNvciA9IHRoaXMuY3VycmVudEN1cnNvciE7XG5cbiAgICAvLyByZWh5ZHJhdGlvbiB3aWxsIGJlIGRpc2FibGVkIHVudGlsIHdlIGVpdGhlcjpcbiAgICAvLyAqIGhpdCBwb3BFbGVtZW50IChhbmQgcmV0dXJuIHRvIHVzaW5nIHRoZSBwYXJlbnQgZWxlbWVudHMgY3Vyc29yKVxuICAgIC8vICogaGl0IGNsb3NlQmxvY2sgYW5kIHRoZSBuZXh0IHNpYmxpbmcgaXMgYSBjbG9zZSBibG9jayBjb21tZW50XG4gICAgLy8gICBtYXRjaGluZyB0aGUgZXhwZWN0ZWQgb3BlbkJsb2NrRGVwdGhcbiAgICBjdXJyZW50Q3Vyc29yLmNhbmRpZGF0ZSA9IG51bGw7XG4gICAgY3VycmVudEN1cnNvci5uZXh0U2libGluZyA9IG5leHRTaWJsaW5nO1xuICB9XG5cbiAgZW5hYmxlUmVoeWRyYXRpb24oY2FuZGlkYXRlOiBPcHRpb248U2ltcGxlTm9kZT4pIHtcbiAgICBsZXQgY3VycmVudEN1cnNvciA9IHRoaXMuY3VycmVudEN1cnNvciE7XG5cbiAgICBjdXJyZW50Q3Vyc29yLmNhbmRpZGF0ZSA9IGNhbmRpZGF0ZTtcbiAgICBjdXJyZW50Q3Vyc29yLm5leHRTaWJsaW5nID0gbnVsbDtcbiAgfVxuXG4gIHB1c2hFbGVtZW50KFxuICAgIC8qKiBjYWxsZWQgZnJvbSBwYXJlbnQgY29uc3RydWN0b3IgYmVmb3JlIHdlIGluaXRpYWxpemUgdGhpcyAqL1xuICAgIHRoaXM6XG4gICAgICB8IFJlaHlkcmF0ZUJ1aWxkZXJcbiAgICAgIHwgKE5ld0VsZW1lbnRCdWlsZGVyICYgUGFydGlhbDxQaWNrPFJlaHlkcmF0ZUJ1aWxkZXIsICdibG9ja0RlcHRoJyB8ICdjYW5kaWRhdGUnPj4pLFxuICAgIGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsXG4gICAgbmV4dFNpYmxpbmc6IE1heWJlPFNpbXBsZU5vZGU+ID0gbnVsbFxuICApIHtcbiAgICBsZXQgY3Vyc29yID0gbmV3IFJlaHlkcmF0aW5nQ3Vyc29yKGVsZW1lbnQsIG5leHRTaWJsaW5nLCB0aGlzLmJsb2NrRGVwdGggfHwgMCk7XG5cbiAgICAvKipcbiAgICAgKiA8ZGl2PiAgIDwtLS0tLS0tLS0tLS0tLS0gIGN1cnJlbnRDdXJzb3IuZWxlbWVudFxuICAgICAqICAgPCEtLSUrYjoxJS0tPiA8LS0tLS0tLSAgd291bGQgaGF2ZSBiZWVuIHJlbW92ZWQgZHVyaW5nIG9wZW5CbG9ja1xuICAgICAqICAgPGRpdj4gPC0tLS0tLS0tLS0tLS0tLSAgY3VycmVudEN1cnNvci5jYW5kaWRhdGUgLT4gY3Vyc29yLmVsZW1lbnRcbiAgICAgKiAgICAgPCEtLSUrYjoyJS0tPiA8LS0tLS0gIGN1cnJlbnRDdXJzb3IuY2FuZGlkYXRlLmZpcnN0Q2hpbGQgLT4gY3Vyc29yLmNhbmRpZGF0ZVxuICAgICAqICAgICBGb29cbiAgICAgKiAgICAgPCEtLSUtYjoyJS0tPlxuICAgICAqICAgPC9kaXY+XG4gICAgICogICA8IS0tJS1iOjElLS0+ICA8LS0tLS0tICBiZWNvbWVzIGN1cnJlbnRDdXJzb3IuY2FuZGlkYXRlXG4gICAgICovXG4gICAgaWYgKHRoaXMuY2FuZGlkYXRlICE9PSBudWxsKSB7XG4gICAgICBjdXJzb3IuY2FuZGlkYXRlID0gZWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgdGhpcy5jYW5kaWRhdGUgPSBlbGVtZW50Lm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIHRoaXNbQ1VSU09SX1NUQUNLXS5wdXNoKGN1cnNvcik7XG4gIH1cblxuICAvLyBjbGVhcnMgdW50aWwgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBjb250YWluZXJcbiAgLy8gZWl0aGVyIHRoZSBjdXJyZW50IG9wZW4gYmxvY2sgb3IgaGlnaGVyXG4gIHByaXZhdGUgY2xlYXJNaXNtYXRjaChjYW5kaWRhdGU6IFNpbXBsZU5vZGUpIHtcbiAgICBsZXQgY3VycmVudDogT3B0aW9uPFNpbXBsZU5vZGU+ID0gY2FuZGlkYXRlO1xuICAgIGxldCBjdXJyZW50Q3Vyc29yID0gdGhpcy5jdXJyZW50Q3Vyc29yO1xuICAgIGlmIChjdXJyZW50Q3Vyc29yICE9PSBudWxsKSB7XG4gICAgICBsZXQgb3BlbkJsb2NrRGVwdGggPSBjdXJyZW50Q3Vyc29yLm9wZW5CbG9ja0RlcHRoO1xuICAgICAgaWYgKG9wZW5CbG9ja0RlcHRoID49IGN1cnJlbnRDdXJzb3Iuc3RhcnRpbmdCbG9ja0RlcHRoKSB7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgaWYgKGlzQ2xvc2VCbG9jayhjdXJyZW50KSkge1xuICAgICAgICAgICAgbGV0IGNsb3NlQmxvY2tEZXB0aCA9IGdldEJsb2NrRGVwdGhXaXRoT2Zmc2V0KGN1cnJlbnQsIHRoaXMuc3RhcnRpbmdCbG9ja09mZnNldCk7XG4gICAgICAgICAgICBpZiAob3BlbkJsb2NrRGVwdGggPj0gY2xvc2VCbG9ja0RlcHRoKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ID0gdGhpcy5yZW1vdmUoY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudCA9IHRoaXMucmVtb3ZlKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjdXJyZW50IGN1cnNvciBwYXJlbnROb2RlIHNob3VsZCBiZSBvcGVuQ2FuZGlkYXRlIGlmIGVsZW1lbnRcbiAgICAgIC8vIG9yIG9wZW5DYW5kaWRhdGUucGFyZW50Tm9kZSBpZiBjb21tZW50XG4gICAgICB0aGlzLmRpc2FibGVSZWh5ZHJhdGlvbihjdXJyZW50KTtcbiAgICB9XG4gIH1cblxuICBfX29wZW5CbG9jaygpOiB2b2lkIHtcbiAgICBsZXQgeyBjdXJyZW50Q3Vyc29yIH0gPSB0aGlzO1xuICAgIGlmIChjdXJyZW50Q3Vyc29yID09PSBudWxsKSByZXR1cm47XG5cbiAgICBsZXQgYmxvY2tEZXB0aCA9IHRoaXMuYmxvY2tEZXB0aDtcblxuICAgIHRoaXMuYmxvY2tEZXB0aCsrO1xuXG4gICAgbGV0IHsgY2FuZGlkYXRlIH0gPSBjdXJyZW50Q3Vyc29yO1xuICAgIGlmIChjYW5kaWRhdGUgPT09IG51bGwpIHJldHVybjtcblxuICAgIGxldCB7IHRhZ05hbWUgfSA9IGN1cnJlbnRDdXJzb3IuZWxlbWVudDtcblxuICAgIGlmIChcbiAgICAgIGlzT3BlbkJsb2NrKGNhbmRpZGF0ZSkgJiZcbiAgICAgIGdldEJsb2NrRGVwdGhXaXRoT2Zmc2V0KGNhbmRpZGF0ZSwgdGhpcy5zdGFydGluZ0Jsb2NrT2Zmc2V0KSA9PT0gYmxvY2tEZXB0aFxuICAgICkge1xuICAgICAgdGhpcy5jYW5kaWRhdGUgPSB0aGlzLnJlbW92ZShjYW5kaWRhdGUpO1xuICAgICAgY3VycmVudEN1cnNvci5vcGVuQmxvY2tEZXB0aCA9IGJsb2NrRGVwdGg7XG4gICAgfSBlbHNlIGlmICh0YWdOYW1lICE9PSAnVElUTEUnICYmIHRhZ05hbWUgIT09ICdTQ1JJUFQnICYmIHRhZ05hbWUgIT09ICdTVFlMRScpIHtcbiAgICAgIHRoaXMuY2xlYXJNaXNtYXRjaChjYW5kaWRhdGUpO1xuICAgIH1cbiAgfVxuXG4gIF9fY2xvc2VCbG9jaygpOiB2b2lkIHtcbiAgICBsZXQgeyBjdXJyZW50Q3Vyc29yIH0gPSB0aGlzO1xuICAgIGlmIChjdXJyZW50Q3Vyc29yID09PSBudWxsKSByZXR1cm47XG5cbiAgICAvLyBvcGVuQmxvY2sgaXMgdGhlIGxhc3QgcmVoeWRyYXRlZCBvcGVuIGJsb2NrXG4gICAgbGV0IG9wZW5CbG9ja0RlcHRoID0gY3VycmVudEN1cnNvci5vcGVuQmxvY2tEZXB0aDtcblxuICAgIC8vIHRoaXMgY3VycmVudGx5IGlzIHRoZSBleHBlY3RlZCBuZXh0IG9wZW4gYmxvY2sgZGVwdGhcbiAgICB0aGlzLmJsb2NrRGVwdGgtLTtcblxuICAgIGxldCB7IGNhbmRpZGF0ZSB9ID0gY3VycmVudEN1cnNvcjtcblxuICAgIGxldCBpc1JlaHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgICBpZiAoY2FuZGlkYXRlICE9PSBudWxsKSB7XG4gICAgICBpc1JlaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgIC8vYXNzZXJ0KFxuICAgICAgLy8gIG9wZW5CbG9ja0RlcHRoID09PSB0aGlzLmJsb2NrRGVwdGgsXG4gICAgICAvLyAgJ3doZW4gcmVoeWRyYXRpbmcsIG9wZW5CbG9ja0RlcHRoIHNob3VsZCBtYXRjaCB0aGlzLmJsb2NrRGVwdGggaGVyZSdcbiAgICAgIC8vKTtcblxuICAgICAgaWYgKFxuICAgICAgICBpc0Nsb3NlQmxvY2soY2FuZGlkYXRlKSAmJlxuICAgICAgICBnZXRCbG9ja0RlcHRoV2l0aE9mZnNldChjYW5kaWRhdGUsIHRoaXMuc3RhcnRpbmdCbG9ja09mZnNldCkgPT09IG9wZW5CbG9ja0RlcHRoXG4gICAgICApIHtcbiAgICAgICAgbGV0IG5leHRTaWJsaW5nID0gdGhpcy5yZW1vdmUoY2FuZGlkYXRlKTtcbiAgICAgICAgdGhpcy5jYW5kaWRhdGUgPSBuZXh0U2libGluZztcbiAgICAgICAgY3VycmVudEN1cnNvci5vcGVuQmxvY2tEZXB0aC0tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2xvc2UgdGhlIGJsb2NrIGFuZCBjbGVhciBtaXNtYXRjaCBpbiBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgIC8vIHdlIHdpbGwgYmUgZWl0aGVyIGF0IHRoZSBlbmQgb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgLy8gb3IgYXQgdGhlIGVuZCBvZiBvdXIgY29udGFpbmluZyBibG9ja1xuICAgICAgICB0aGlzLmNsZWFyTWlzbWF0Y2goY2FuZGlkYXRlKTtcbiAgICAgICAgaXNSZWh5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1JlaHlkcmF0aW5nID09PSBmYWxzZSkge1xuICAgICAgLy8gY2hlY2sgaWYgbmV4dFNpYmxpbmcgbWF0Y2hlcyBvdXIgZXhwZWN0ZWQgY2xvc2UgYmxvY2tcbiAgICAgIC8vIGlmIHNvLCB3ZSByZW1vdmUgdGhlIGNsb3NlIGJsb2NrIGNvbW1lbnQgYW5kXG4gICAgICAvLyByZXN0b3JlIHJlaHlkcmF0aW9uIGFmdGVyIGNsZWFyTWlzbWF0Y2ggZGlzYWJsZWRcbiAgICAgIGxldCBuZXh0U2libGluZyA9IGN1cnJlbnRDdXJzb3IubmV4dFNpYmxpbmc7XG4gICAgICBpZiAoXG4gICAgICAgIG5leHRTaWJsaW5nICE9PSBudWxsICYmXG4gICAgICAgIGlzQ2xvc2VCbG9jayhuZXh0U2libGluZykgJiZcbiAgICAgICAgZ2V0QmxvY2tEZXB0aFdpdGhPZmZzZXQobmV4dFNpYmxpbmcsIHRoaXMuc3RhcnRpbmdCbG9ja09mZnNldCkgPT09IHRoaXMuYmxvY2tEZXB0aFxuICAgICAgKSB7XG4gICAgICAgIC8vIHJlc3RvcmUgcmVoeWRyYXRpb24gc3RhdGVcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHRoaXMucmVtb3ZlKG5leHRTaWJsaW5nKTtcbiAgICAgICAgdGhpcy5lbmFibGVSZWh5ZHJhdGlvbihjYW5kaWRhdGUpO1xuXG4gICAgICAgIGN1cnJlbnRDdXJzb3Iub3BlbkJsb2NrRGVwdGgtLTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfX2FwcGVuZE5vZGUobm9kZTogU2ltcGxlTm9kZSk6IFNpbXBsZU5vZGUge1xuICAgIGxldCB7IGNhbmRpZGF0ZSB9ID0gdGhpcztcblxuICAgIC8vIFRoaXMgY29kZSBwYXRoIGlzIG9ubHkgdXNlZCB3aGVuIGluc2VydGluZyBwcmVjaXNlbHkgb25lIG5vZGUuIEl0IG5lZWRzIG1vcmVcbiAgICAvLyBjb21wYXJpc29uIGxvZ2ljLCBidXQgd2UgY2FuIHByb2JhYmx5IGxlYW4gb24gdGhlIGNhc2VzIHdoZXJlIHRoaXMgY29kZSBwYXRoXG4gICAgLy8gaXMgYWN0dWFsbHkgdXNlZC5cbiAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICByZXR1cm4gY2FuZGlkYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIuX19hcHBlbmROb2RlKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIF9fYXBwZW5kSFRNTChodG1sOiBzdHJpbmcpOiBCb3VuZHMge1xuICAgIGxldCBjYW5kaWRhdGVCb3VuZHMgPSB0aGlzLm1hcmtlckJvdW5kcygpO1xuXG4gICAgaWYgKGNhbmRpZGF0ZUJvdW5kcykge1xuICAgICAgbGV0IGZpcnN0ID0gY2FuZGlkYXRlQm91bmRzLmZpcnN0Tm9kZSgpITtcbiAgICAgIGxldCBsYXN0ID0gY2FuZGlkYXRlQm91bmRzLmxhc3ROb2RlKCkhO1xuXG4gICAgICBsZXQgbmV3Qm91bmRzID0gbmV3IENvbmNyZXRlQm91bmRzKHRoaXMuZWxlbWVudCwgZmlyc3QubmV4dFNpYmxpbmchLCBsYXN0LnByZXZpb3VzU2libGluZyEpO1xuXG4gICAgICBsZXQgcG9zc2libGVFbXB0eU1hcmtlciA9IHRoaXMucmVtb3ZlKGZpcnN0KTtcbiAgICAgIHRoaXMucmVtb3ZlKGxhc3QpO1xuXG4gICAgICBpZiAocG9zc2libGVFbXB0eU1hcmtlciAhPT0gbnVsbCAmJiBpc0VtcHR5KHBvc3NpYmxlRW1wdHlNYXJrZXIpKSB7XG4gICAgICAgIHRoaXMuY2FuZGlkYXRlID0gdGhpcy5yZW1vdmUocG9zc2libGVFbXB0eU1hcmtlcik7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5jbGVhck1pc21hdGNoKHRoaXMuY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3Qm91bmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIuX19hcHBlbmRIVE1MKGh0bWwpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCByZW1vdmUobm9kZTogU2ltcGxlTm9kZSk6IE9wdGlvbjxTaW1wbGVOb2RlPiB7XG4gICAgbGV0IGVsZW1lbnQgPSBleHBlY3Qobm9kZS5wYXJlbnROb2RlLCBgY2Fubm90IHJlbW92ZSBhIGRldGFjaGVkIG5vZGVgKSBhcyBTaW1wbGVFbGVtZW50O1xuICAgIGxldCBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICBlbGVtZW50LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgcHJpdmF0ZSBtYXJrZXJCb3VuZHMoKTogT3B0aW9uPEJvdW5kcz4ge1xuICAgIGxldCBfY2FuZGlkYXRlID0gdGhpcy5jYW5kaWRhdGU7XG5cbiAgICBpZiAoX2NhbmRpZGF0ZSAmJiBpc01hcmtlcihfY2FuZGlkYXRlKSkge1xuICAgICAgbGV0IGZpcnN0ID0gX2NhbmRpZGF0ZTtcbiAgICAgIGxldCBsYXN0ID0gZXhwZWN0KGZpcnN0Lm5leHRTaWJsaW5nLCBgQlVHOiBzZXJpYWxpemF0aW9uIG1hcmtlcnMgbXVzdCBiZSBwYWlyZWRgKTtcblxuICAgICAgd2hpbGUgKGxhc3QgJiYgIWlzTWFya2VyKGxhc3QpKSB7XG4gICAgICAgIGxhc3QgPSBleHBlY3QobGFzdC5uZXh0U2libGluZywgYEJVRzogc2VyaWFsaXphdGlvbiBtYXJrZXJzIG11c3QgYmUgcGFpcmVkYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQ29uY3JldGVCb3VuZHModGhpcy5lbGVtZW50LCBmaXJzdCwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIF9fYXBwZW5kVGV4dChzdHJpbmc6IHN0cmluZyk6IFNpbXBsZVRleHQge1xuICAgIGxldCB7IGNhbmRpZGF0ZSB9ID0gdGhpcztcblxuICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgIGlmIChpc1RleHROb2RlKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZS5ub2RlVmFsdWUgIT09IHN0cmluZykge1xuICAgICAgICAgIGNhbmRpZGF0ZS5ub2RlVmFsdWUgPSBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5kaWRhdGUgPSBjYW5kaWRhdGUubmV4dFNpYmxpbmc7XG5cbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNTZXBhcmF0b3IoY2FuZGlkYXRlKSkge1xuICAgICAgICB0aGlzLmNhbmRpZGF0ZSA9IHRoaXMucmVtb3ZlKGNhbmRpZGF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19hcHBlbmRUZXh0KHN0cmluZyk7XG4gICAgICB9IGVsc2UgaWYgKGlzRW1wdHkoY2FuZGlkYXRlKSAmJiBzdHJpbmcgPT09ICcnKSB7XG4gICAgICAgIHRoaXMuY2FuZGlkYXRlID0gdGhpcy5yZW1vdmUoY2FuZGlkYXRlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fX2FwcGVuZFRleHQoc3RyaW5nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2xlYXJNaXNtYXRjaChjYW5kaWRhdGUpO1xuXG4gICAgICAgIHJldHVybiBzdXBlci5fX2FwcGVuZFRleHQoc3RyaW5nKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLl9fYXBwZW5kVGV4dChzdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIF9fYXBwZW5kQ29tbWVudChzdHJpbmc6IHN0cmluZyk6IFNpbXBsZUNvbW1lbnQge1xuICAgIGxldCBfY2FuZGlkYXRlID0gdGhpcy5jYW5kaWRhdGU7XG4gICAgaWYgKF9jYW5kaWRhdGUgJiYgaXNDb21tZW50KF9jYW5kaWRhdGUpKSB7XG4gICAgICBpZiAoX2NhbmRpZGF0ZS5ub2RlVmFsdWUgIT09IHN0cmluZykge1xuICAgICAgICBfY2FuZGlkYXRlLm5vZGVWYWx1ZSA9IHN0cmluZztcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYW5kaWRhdGUgPSBfY2FuZGlkYXRlLm5leHRTaWJsaW5nO1xuICAgICAgcmV0dXJuIF9jYW5kaWRhdGU7XG4gICAgfSBlbHNlIGlmIChfY2FuZGlkYXRlKSB7XG4gICAgICB0aGlzLmNsZWFyTWlzbWF0Y2goX2NhbmRpZGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLl9fYXBwZW5kQ29tbWVudChzdHJpbmcpO1xuICB9XG5cbiAgX19vcGVuRWxlbWVudCh0YWc6IHN0cmluZyk6IFNpbXBsZUVsZW1lbnQge1xuICAgIGxldCBfY2FuZGlkYXRlID0gdGhpcy5jYW5kaWRhdGU7XG5cbiAgICBpZiAoX2NhbmRpZGF0ZSAmJiBpc0VsZW1lbnQoX2NhbmRpZGF0ZSkgJiYgaXNTYW1lTm9kZVR5cGUoX2NhbmRpZGF0ZSwgdGFnKSkge1xuICAgICAgdGhpcy51bm1hdGNoZWRBdHRyaWJ1dGVzID0gW10uc2xpY2UuY2FsbChfY2FuZGlkYXRlLmF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIF9jYW5kaWRhdGU7XG4gICAgfSBlbHNlIGlmIChfY2FuZGlkYXRlKSB7XG4gICAgICBpZiAoaXNFbGVtZW50KF9jYW5kaWRhdGUpICYmIF9jYW5kaWRhdGUudGFnTmFtZSA9PT0gJ1RCT0RZJykge1xuICAgICAgICB0aGlzLnB1c2hFbGVtZW50KF9jYW5kaWRhdGUsIG51bGwpO1xuICAgICAgICB0aGlzLmN1cnJlbnRDdXJzb3IhLmluamVjdGVkT21pdHRlZE5vZGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5fX29wZW5FbGVtZW50KHRhZyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFyTWlzbWF0Y2goX2NhbmRpZGF0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLl9fb3BlbkVsZW1lbnQodGFnKTtcbiAgfVxuXG4gIF9fc2V0QXR0cmlidXRlKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgbmFtZXNwYWNlOiBPcHRpb248QXR0ck5hbWVzcGFjZT4pOiB2b2lkIHtcbiAgICBsZXQgdW5tYXRjaGVkID0gdGhpcy51bm1hdGNoZWRBdHRyaWJ1dGVzO1xuXG4gICAgaWYgKHVubWF0Y2hlZCkge1xuICAgICAgbGV0IGF0dHIgPSBmaW5kQnlOYW1lKHVubWF0Y2hlZCwgbmFtZSk7XG4gICAgICBpZiAoYXR0cikge1xuICAgICAgICBpZiAoYXR0ci52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICBhdHRyLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdW5tYXRjaGVkLnNwbGljZSh1bm1hdGNoZWQuaW5kZXhPZihhdHRyKSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuX19zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIG5hbWVzcGFjZSk7XG4gIH1cblxuICBfX3NldFByb3BlcnR5KG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgIGxldCB1bm1hdGNoZWQgPSB0aGlzLnVubWF0Y2hlZEF0dHJpYnV0ZXM7XG5cbiAgICBpZiAodW5tYXRjaGVkKSB7XG4gICAgICBsZXQgYXR0ciA9IGZpbmRCeU5hbWUodW5tYXRjaGVkLCBuYW1lKTtcbiAgICAgIGlmIChhdHRyKSB7XG4gICAgICAgIGlmIChhdHRyLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgIGF0dHIudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB1bm1hdGNoZWQuc3BsaWNlKHVubWF0Y2hlZC5pbmRleE9mKGF0dHIpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5fX3NldFByb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIF9fZmx1c2hFbGVtZW50KHBhcmVudDogU2ltcGxlRWxlbWVudCwgY29uc3RydWN0aW5nOiBTaW1wbGVFbGVtZW50KTogdm9pZCB7XG4gICAgbGV0IHsgdW5tYXRjaGVkQXR0cmlidXRlczogdW5tYXRjaGVkIH0gPSB0aGlzO1xuICAgIGlmICh1bm1hdGNoZWQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5tYXRjaGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuY29uc3RydWN0aW5nIS5yZW1vdmVBdHRyaWJ1dGUodW5tYXRjaGVkW2ldLm5hbWUpO1xuICAgICAgfVxuICAgICAgdGhpcy51bm1hdGNoZWRBdHRyaWJ1dGVzID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuX19mbHVzaEVsZW1lbnQocGFyZW50LCBjb25zdHJ1Y3RpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHdpbGxDbG9zZUVsZW1lbnQoKSB7XG4gICAgbGV0IHsgY2FuZGlkYXRlLCBjdXJyZW50Q3Vyc29yIH0gPSB0aGlzO1xuXG4gICAgaWYgKGNhbmRpZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5jbGVhck1pc21hdGNoKGNhbmRpZGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRDdXJzb3IgJiYgY3VycmVudEN1cnNvci5pbmplY3RlZE9taXR0ZWROb2RlKSB7XG4gICAgICB0aGlzLnBvcEVsZW1lbnQoKTtcbiAgICB9XG5cbiAgICBzdXBlci53aWxsQ2xvc2VFbGVtZW50KCk7XG4gIH1cblxuICBnZXRNYXJrZXIoZWxlbWVudDogSFRNTEVsZW1lbnQsIGd1aWQ6IHN0cmluZyk6IE9wdGlvbjxTaW1wbGVOb2RlPiB7XG4gICAgbGV0IG1hcmtlciA9IGVsZW1lbnQucXVlcnlTZWxlY3Rvcihgc2NyaXB0W2dsbXI9XCIke2d1aWR9XCJdYCk7XG4gICAgaWYgKG1hcmtlcikge1xuICAgICAgcmV0dXJuIGNhc3RUb1NpbXBsZShtYXJrZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIF9fcHVzaFJlbW90ZUVsZW1lbnQoXG4gICAgZWxlbWVudDogU2ltcGxlRWxlbWVudCxcbiAgICBjdXJzb3JJZDogc3RyaW5nLFxuICAgIGluc2VydEJlZm9yZTogTWF5YmU8U2ltcGxlTm9kZT5cbiAgKTogT3B0aW9uPFJlbW90ZUxpdmVCbG9jaz4ge1xuICAgIGxldCBtYXJrZXIgPSB0aGlzLmdldE1hcmtlcihjYXN0VG9Ccm93c2VyKGVsZW1lbnQsICdIVE1MJyksIGN1cnNvcklkKTtcblxuICAgIGFzc2VydChcbiAgICAgICFtYXJrZXIgfHwgbWFya2VyLnBhcmVudE5vZGUgPT09IGVsZW1lbnQsXG4gICAgICBgZXhwZWN0ZWQgcmVtb3RlIGVsZW1lbnQgbWFya2VyJ3MgcGFyZW50IG5vZGUgdG8gbWF0Y2ggcmVtb3RlIGVsZW1lbnRgXG4gICAgKTtcblxuICAgIC8vIHdoZW4gaW5zZXJ0QmVmb3JlIGlzIG5vdCBwcmVzZW50LCB3ZSBjbGVhciB0aGUgZWxlbWVudFxuICAgIGlmIChpbnNlcnRCZWZvcmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgd2hpbGUgKGVsZW1lbnQuZmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBlbGVtZW50LmZpcnN0Q2hpbGQgIT09IG1hcmtlcikge1xuICAgICAgICB0aGlzLnJlbW92ZShlbGVtZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgaW5zZXJ0QmVmb3JlID0gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgY3Vyc29yID0gbmV3IFJlaHlkcmF0aW5nQ3Vyc29yKGVsZW1lbnQsIG51bGwsIHRoaXMuYmxvY2tEZXB0aCk7XG4gICAgdGhpc1tDVVJTT1JfU1RBQ0tdLnB1c2goY3Vyc29yKTtcblxuICAgIGlmIChtYXJrZXIgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuZGlzYWJsZVJlaHlkcmF0aW9uKGluc2VydEJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FuZGlkYXRlID0gdGhpcy5yZW1vdmUobWFya2VyKTtcbiAgICB9XG5cbiAgICBsZXQgYmxvY2sgPSBuZXcgUmVtb3RlTGl2ZUJsb2NrKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLnB1c2hMaXZlQmxvY2soYmxvY2ssIHRydWUpO1xuICB9XG5cbiAgZGlkQXBwZW5kQm91bmRzKGJvdW5kczogQm91bmRzKTogQm91bmRzIHtcbiAgICBzdXBlci5kaWRBcHBlbmRCb3VuZHMoYm91bmRzKTtcbiAgICBpZiAodGhpcy5jYW5kaWRhdGUpIHtcbiAgICAgIGxldCBsYXN0ID0gYm91bmRzLmxhc3ROb2RlKCk7XG4gICAgICB0aGlzLmNhbmRpZGF0ZSA9IGxhc3QgJiYgbGFzdC5uZXh0U2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGU6IFNpbXBsZU5vZGUpOiBub2RlIGlzIFNpbXBsZVRleHQge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gMztcbn1cblxuZnVuY3Rpb24gaXNDb21tZW50KG5vZGU6IFNpbXBsZU5vZGUpOiBub2RlIGlzIFNpbXBsZUNvbW1lbnQge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gODtcbn1cblxuZnVuY3Rpb24gaXNPcGVuQmxvY2sobm9kZTogU2ltcGxlTm9kZSk6IG5vZGUgaXMgU2ltcGxlQ29tbWVudCB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlVHlwZS5DT01NRU5UX05PREUgJiYgbm9kZS5ub2RlVmFsdWUubGFzdEluZGV4T2YoJyUrYjonLCAwKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNDbG9zZUJsb2NrKG5vZGU6IFNpbXBsZU5vZGUpOiBub2RlIGlzIFNpbXBsZUNvbW1lbnQge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZVR5cGUuQ09NTUVOVF9OT0RFICYmIG5vZGUubm9kZVZhbHVlLmxhc3RJbmRleE9mKCclLWI6JywgMCkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGdldEJsb2NrRGVwdGgobm9kZTogU2ltcGxlQ29tbWVudCk6IG51bWJlciB7XG4gIHJldHVybiBwYXJzZUludChub2RlLm5vZGVWYWx1ZS5zbGljZSg0KSwgMTApO1xufVxuXG5mdW5jdGlvbiBnZXRCbG9ja0RlcHRoV2l0aE9mZnNldChub2RlOiBTaW1wbGVDb21tZW50LCBvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gIHJldHVybiBnZXRCbG9ja0RlcHRoKG5vZGUpIC0gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZTogU2ltcGxlTm9kZSk6IG5vZGUgaXMgU2ltcGxlRWxlbWVudCB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxO1xufVxuXG5mdW5jdGlvbiBpc01hcmtlcihub2RlOiBTaW1wbGVOb2RlKTogYm9vbGVhbiB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlID09PSAnJWdsbXIlJztcbn1cblxuZnVuY3Rpb24gaXNTZXBhcmF0b3Iobm9kZTogU2ltcGxlTm9kZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyV8JSc7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkobm9kZTogU2ltcGxlTm9kZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gOCAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyUgJSc7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU5vZGVUeXBlKGNhbmRpZGF0ZTogU2ltcGxlRWxlbWVudCwgdGFnOiBzdHJpbmcpIHtcbiAgaWYgKGNhbmRpZGF0ZS5uYW1lc3BhY2VVUkkgPT09IE5hbWVzcGFjZS5TVkcpIHtcbiAgICByZXR1cm4gY2FuZGlkYXRlLnRhZ05hbWUgPT09IHRhZztcbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlLnRhZ05hbWUgPT09IHRhZy50b1VwcGVyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBmaW5kQnlOYW1lKGFycmF5OiBTaW1wbGVBdHRyW10sIG5hbWU6IHN0cmluZyk6IFNpbXBsZUF0dHIgfCB1bmRlZmluZWQge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGF0dHIgPSBhcnJheVtpXTtcbiAgICBpZiAoYXR0ci5uYW1lID09PSBuYW1lKSByZXR1cm4gYXR0cjtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWh5ZHJhdGlvbkJ1aWxkZXIoZW52OiBFbnZpcm9ubWVudCwgY3Vyc29yOiBDdXJzb3JJbXBsKTogRWxlbWVudEJ1aWxkZXIge1xuICByZXR1cm4gUmVoeWRyYXRlQnVpbGRlci5mb3JJbml0aWFsUmVuZGVyKGVudiwgY3Vyc29yKTtcbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IENhY2hlLCBjcmVhdGVDYWNoZSwgZ2V0VmFsdWUgfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHsgQXJndW1lbnRzLCBJbnRlcm5hbEhlbHBlck1hbmFnZXIgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGRlYnVnVG9TdHJpbmcgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IGdldEludGVybmFsSGVscGVyTWFuYWdlciwgaGFzRGVzdHJveWFibGUsIGhhc1ZhbHVlIH0gZnJvbSAnQGdsaW1tZXIvbWFuYWdlcic7XG5cbmltcG9ydCB7IEVNUFRZX0FSR1MsIEVNUFRZX05BTUVELCBFTVBUWV9QT1NJVElPTkFMIH0gZnJvbSAnLi4vdm0vYXJndW1lbnRzJztcbmltcG9ydCB7IGdldE93bmVyIH0gZnJvbSAnQGdsaW1tZXIvb3duZXInO1xuaW1wb3J0IHsgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZCwgaXNEZXN0cm95ZWQsIGlzRGVzdHJveWluZyB9IGZyb20gJ0BnbGltbWVyL2Rlc3Ryb3lhYmxlJztcblxubGV0IEFSR1NfQ0FDSEVTID0gREVCVUcgPyBuZXcgV2Vha01hcDxTaW1wbGVBcmdzUHJveHksIENhY2hlPFBhcnRpYWw8QXJndW1lbnRzPj4+KCkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGdldEFyZ3MocHJveHk6IFNpbXBsZUFyZ3NQcm94eSk6IFBhcnRpYWw8QXJndW1lbnRzPiB7XG4gIHJldHVybiBnZXRWYWx1ZShERUJVRyA/IEFSR1NfQ0FDSEVTIS5nZXQocHJveHkpISA6IHByb3h5LmFyZ3NDYWNoZSEpITtcbn1cblxuY2xhc3MgU2ltcGxlQXJnc1Byb3h5IHtcbiAgYXJnc0NhY2hlPzogQ2FjaGU8UGFydGlhbDxBcmd1bWVudHM+PjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBjb250ZXh0OiBvYmplY3QsXG4gICAgY29tcHV0ZUFyZ3M6IChjb250ZXh0OiBvYmplY3QpID0+IFBhcnRpYWw8QXJndW1lbnRzPiA9ICgpID0+IEVNUFRZX0FSR1NcbiAgKSB7XG4gICAgbGV0IGFyZ3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCgpID0+IGNvbXB1dGVBcmdzKGNvbnRleHQpKTtcblxuICAgIGlmIChERUJVRykge1xuICAgICAgQVJHU19DQUNIRVMhLnNldCh0aGlzLCBhcmdzQ2FjaGUpO1xuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcmdzQ2FjaGUgPSBhcmdzQ2FjaGU7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG5hbWVkKCkge1xuICAgIHJldHVybiBnZXRBcmdzKHRoaXMpLm5hbWVkIHx8IEVNUFRZX05BTUVEO1xuICB9XG5cbiAgZ2V0IHBvc2l0aW9uYWwoKSB7XG4gICAgcmV0dXJuIGdldEFyZ3ModGhpcykucG9zaXRpb25hbCB8fCBFTVBUWV9QT1NJVElPTkFMO1xuICB9XG59XG5cbi8vLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlSGVscGVyKFxuICBjb250ZXh0OiBvYmplY3QsXG4gIGRlZmluaXRpb246IG9iamVjdCxcbiAgY29tcHV0ZUFyZ3M/OiAoY29udGV4dDogb2JqZWN0KSA9PiBQYXJ0aWFsPEFyZ3VtZW50cz5cbik6IENhY2hlPHVua25vd24+IHtcbiAgaWYgKERFQlVHICYmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcgfHwgY29udGV4dCA9PT0gbnVsbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBjb250ZXh0IG9iamVjdCB0byBiZSBwYXNzZWQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBpbnZva2VIZWxwZXIsIGdvdCAke2NvbnRleHR9YFxuICAgICk7XG4gIH1cblxuICBjb25zdCBvd25lciA9IGdldE93bmVyKGNvbnRleHQpO1xuICBjb25zdCBpbnRlcm5hbE1hbmFnZXIgPSBnZXRJbnRlcm5hbEhlbHBlck1hbmFnZXIoZGVmaW5pdGlvbikhO1xuXG4gIC8vIFRPRE86IGZpZ3VyZSBvdXQgd2h5IGFzc2VydCBpc24ndCB1c2luZyB0aGUgVFMgYXNzZXJ0IHRoaW5nXG4gIGlmIChERUJVRyAmJiAhaW50ZXJuYWxNYW5hZ2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGEgaGVscGVyIGRlZmluaXRpb24gdG8gYmUgcGFzc2VkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGludm9rZUhlbHBlciwgYnV0IG5vIGhlbHBlciBtYW5hZ2VyIHdhcyBmb3VuZC4gVGhlIGRlZmluaXRpb24gdmFsdWUgdGhhdCB3YXMgcGFzc2VkIHdhcyBcXGAke2RlYnVnVG9TdHJpbmchKFxuICAgICAgICBkZWZpbml0aW9uXG4gICAgICApfVxcYC4gRGlkIHlvdSB1c2Ugc2V0SGVscGVyTWFuYWdlciB0byBhc3NvY2lhdGUgYSBoZWxwZXIgbWFuYWdlciB3aXRoIHRoaXMgdmFsdWU/YFxuICAgICk7XG4gIH1cblxuICBpZiAoREVCVUcgJiYgdHlwZW9mIGludGVybmFsTWFuYWdlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdGb3VuZCBhIGhlbHBlciBtYW5hZ2VyLCBidXQgaXQgd2FzIGFuIGludGVybmFsIGJ1aWx0LWluIGhlbHBlciBtYW5hZ2VyLiBgaW52b2tlSGVscGVyYCBkb2VzIG5vdCBzdXBwb3J0IGludGVybmFsIGhlbHBlcnMgeWV0LidcbiAgICApO1xuICB9XG5cbiAgY29uc3QgbWFuYWdlciA9IChpbnRlcm5hbE1hbmFnZXIgYXMgSW50ZXJuYWxIZWxwZXJNYW5hZ2VyPG9iamVjdD4pLmdldERlbGVnYXRlRm9yKG93bmVyKTtcbiAgbGV0IGFyZ3MgPSBuZXcgU2ltcGxlQXJnc1Byb3h5KGNvbnRleHQsIGNvbXB1dGVBcmdzKTtcbiAgbGV0IGJ1Y2tldCA9IG1hbmFnZXIuY3JlYXRlSGVscGVyKGRlZmluaXRpb24sIGFyZ3MpO1xuXG4gIGxldCBjYWNoZTogQ2FjaGU8dW5rbm93bj47XG5cbiAgaWYgKGhhc1ZhbHVlKG1hbmFnZXIpKSB7XG4gICAgY2FjaGUgPSBjcmVhdGVDYWNoZSgoKSA9PiB7XG4gICAgICBpZiAoREVCVUcgJiYgKGlzRGVzdHJveWluZyhjYWNoZSkgfHwgaXNEZXN0cm95ZWQoY2FjaGUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBhdHRlbXB0ZWQgdG8gZ2V0IHRoZSB2YWx1ZSBvZiBhIGhlbHBlciBhZnRlciB0aGUgaGVscGVyIHdhcyBkZXN0cm95ZWQsIHdoaWNoIGlzIG5vdCBhbGxvd2VkYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFuYWdlci5nZXRWYWx1ZShidWNrZXQpO1xuICAgIH0pO1xuXG4gICAgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZChjb250ZXh0LCBjYWNoZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUT0RPOiB1bnJlYWNoYWJsZSwgdG8gYmUgaW1wbGVtZW50ZWQgd2l0aCBoYXNTY2hlZHVsZWRFZmZlY3QnKTtcbiAgfVxuXG4gIGlmIChoYXNEZXN0cm95YWJsZShtYW5hZ2VyKSkge1xuICAgIGxldCBkZXN0cm95YWJsZSA9IG1hbmFnZXIuZ2V0RGVzdHJveWFibGUoYnVja2V0KTtcblxuICAgIGFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQoY2FjaGUsIGRlc3Ryb3lhYmxlKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cbiIsImltcG9ydCB7IEhlbHBlciwgSGVscGVyRGVmaW5pdGlvblN0YXRlIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBzZXRJbnRlcm5hbEhlbHBlck1hbmFnZXIgfSBmcm9tICdAZ2xpbW1lci9tYW5hZ2VyJztcblxuZXhwb3J0IGZ1bmN0aW9uIGludGVybmFsSGVscGVyKGhlbHBlcjogSGVscGVyKTogSGVscGVyRGVmaW5pdGlvblN0YXRlIHtcbiAgcmV0dXJuIHNldEludGVybmFsSGVscGVyTWFuYWdlcihoZWxwZXIsIHt9KTtcbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IENhcHR1cmVkQXJndW1lbnRzIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQge1xuICBjcmVhdGVDb21wdXRlUmVmLFxuICBpc0ludm9rYWJsZVJlZixcbiAgUmVmZXJlbmNlLFxuICB1cGRhdGVSZWYsXG4gIHZhbHVlRm9yUmVmLFxufSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgcmVpZnlQb3NpdGlvbmFsIH0gZnJvbSAnQGdsaW1tZXIvcnVudGltZSc7XG5pbXBvcnQgeyBidWlsZFVudG91Y2hhYmxlVGhpcyB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgaW50ZXJuYWxIZWxwZXIgfSBmcm9tICcuL2ludGVybmFsLWhlbHBlcic7XG5cbmNvbnN0IGNvbnRleHQgPSBidWlsZFVudG91Y2hhYmxlVGhpcygnYGZuYCBoZWxwZXInKTtcblxuLyoqXG4gIFRoZSBgZm5gIGhlbHBlciBhbGxvd3MgeW91IHRvIGVuc3VyZSBhIGZ1bmN0aW9uIHRoYXQgeW91IGFyZSBwYXNzaW5nIG9mZlxuICB0byBhbm90aGVyIGNvbXBvbmVudCwgaGVscGVyLCBvciBtb2RpZmllciBoYXMgYWNjZXNzIHRvIGFyZ3VtZW50cyB0aGF0IGFyZVxuICBhdmFpbGFibGUgaW4gdGhlIHRlbXBsYXRlLlxuXG4gIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSBhbiBgZWFjaGAgaGVscGVyIGxvb3Bpbmcgb3ZlciBhIG51bWJlciBvZiBpdGVtcywgeW91XG4gIG1heSBuZWVkIHRvIHBhc3MgYSBmdW5jdGlvbiB0aGF0IGV4cGVjdHMgdG8gcmVjZWl2ZSB0aGUgaXRlbSBhcyBhbiBhcmd1bWVudFxuICB0byBhIGNvbXBvbmVudCBpbnZva2VkIHdpdGhpbiB0aGUgbG9vcC4gSGVyZSdzIGhvdyB5b3UgY291bGQgdXNlIHRoZSBgZm5gXG4gIGhlbHBlciB0byBwYXNzIGJvdGggdGhlIGZ1bmN0aW9uIGFuZCBpdHMgYXJndW1lbnRzIHRvZ2V0aGVyOlxuXG4gICAgYGBgYXBwL3RlbXBsYXRlcy9jb21wb25lbnRzL2l0ZW1zLWxpc3RpbmcuaGJzXG4gIHt7I2VhY2ggQGl0ZW1zIGFzIHxpdGVtfH19XG4gICAgPERpc3BsYXlJdGVtIEBpdGVtPWl0ZW0gQHNlbGVjdD17e2ZuIHRoaXMuaGFuZGxlU2VsZWN0ZWQgaXRlbX19IC8+XG4gIHt7L2VhY2h9fVxuICBgYGBcblxuICBgYGBhcHAvY29tcG9uZW50cy9pdGVtcy1saXN0LmpzXG4gIGltcG9ydCBDb21wb25lbnQgZnJvbSAnQGdsaW1tZXIvY29tcG9uZW50JztcbiAgaW1wb3J0IHsgYWN0aW9uIH0gZnJvbSAnQGVtYmVyL29iamVjdCc7XG5cbiAgZXhwb3J0IGRlZmF1bHQgY2xhc3MgSXRlbXNMaXN0IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBoYW5kbGVTZWxlY3RlZCA9IChpdGVtKSA9PiB7XG4gICAgICAvLyAuLi5zbmlwLi4uXG4gICAgfVxuICB9XG4gIGBgYFxuXG4gIEluIHRoaXMgY2FzZSB0aGUgYGRpc3BsYXktaXRlbWAgY29tcG9uZW50IHdpbGwgcmVjZWl2ZSBhIG5vcm1hbCBmdW5jdGlvblxuICB0aGF0IGl0IGNhbiBpbnZva2UuIFdoZW4gaXQgaW52b2tlcyB0aGUgZnVuY3Rpb24sIHRoZSBgaGFuZGxlU2VsZWN0ZWRgXG4gIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgYGl0ZW1gIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCwgdGhhbmtzIHRvIHRoZVxuICBgZm5gIGhlbHBlci5cblxuICBMZXQncyB0YWtlIGxvb2sgYXQgd2hhdCB0aGF0IG1lYW5zIGluIGEgY291cGxlIGNpcmN1bXN0YW5jZXM6XG5cbiAgLSBXaGVuIGludm9rZWQgYXMgYHRoaXMuYXJncy5zZWxlY3QoKWAgdGhlIGBoYW5kbGVTZWxlY3RlZGAgZnVuY3Rpb24gd2lsbFxuICAgIHJlY2VpdmUgdGhlIGBpdGVtYCBmcm9tIHRoZSBsb29wIGFzIGl0cyBmaXJzdCBhbmQgb25seSBhcmd1bWVudC5cbiAgLSBXaGVuIGludm9rZWQgYXMgYHRoaXMuYXJncy5zZWxlY3QoJ2ZvbycpYCB0aGUgYGhhbmRsZVNlbGVjdGVkYCBmdW5jdGlvblxuICAgIHdpbGwgcmVjZWl2ZSB0aGUgYGl0ZW1gIGZyb20gdGhlIGxvb3AgYXMgaXRzIGZpcnN0IGFyZ3VtZW50IGFuZCB0aGVcbiAgICBzdHJpbmcgYCdmb28nYCBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50LlxuXG4gIEluIHRoZSBleGFtcGxlIGFib3ZlLCB3ZSB1c2VkIGFuIGFycm93IGZ1bmN0aW9uIHRvIGVuc3VyZSB0aGF0XG4gIGBoYW5kbGVTZWxlY3RlZGAgaXMgcHJvcGVybHkgYm91bmQgdG8gdGhlIGBpdGVtcy1saXN0YCwgYnV0IGxldCdzIGV4cGxvcmUgd2hhdFxuICBoYXBwZW5zIGlmIHdlIGxlZnQgb3V0IHRoZSBhcnJvdyBmdW5jdGlvbjpcblxuICBgYGBhcHAvY29tcG9uZW50cy9pdGVtcy1saXN0LmpzXG4gIGltcG9ydCBDb21wb25lbnQgZnJvbSAnQGdsaW1tZXIvY29tcG9uZW50JztcblxuICBleHBvcnQgZGVmYXVsdCBjbGFzcyBJdGVtc0xpc3QgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGhhbmRsZVNlbGVjdGVkKGl0ZW0pIHtcbiAgICAgIC8vIC4uLnNuaXAuLi5cbiAgICB9XG4gIH1cbiAgYGBgXG5cbiAgSW4gdGhpcyBleGFtcGxlLCB3aGVuIGBoYW5kbGVTZWxlY3RlZGAgaXMgaW52b2tlZCBpbnNpZGUgdGhlIGBkaXNwbGF5LWl0ZW1gXG4gIGNvbXBvbmVudCwgaXQgd2lsbCAqKm5vdCoqIGhhdmUgYWNjZXNzIHRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuIEluIG90aGVyXG4gIHdvcmRzLCBpdCB3aWxsIGhhdmUgbm8gYHRoaXNgIGNvbnRleHQsIHNvIHBsZWFzZSBtYWtlIHN1cmUgeW91ciBmdW5jdGlvbnNcbiAgYXJlIGJvdW5kICh2aWEgYW4gYXJyb3cgZnVuY3Rpb24gb3Igb3RoZXIgbWVhbnMpIGJlZm9yZSBwYXNzaW5nIGludG8gYGZuYCFcblxuICBTZWUgYWxzbyBbcGFydGlhbCBhcHBsaWNhdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFydGlhbF9hcHBsaWNhdGlvbikuXG5cbiAgQG1ldGhvZCBmblxuICBAcHVibGljXG4qL1xuZXhwb3J0IGRlZmF1bHQgaW50ZXJuYWxIZWxwZXIoKHsgcG9zaXRpb25hbCB9OiBDYXB0dXJlZEFyZ3VtZW50cykgPT4ge1xuICBsZXQgY2FsbGJhY2tSZWYgPSBwb3NpdGlvbmFsWzBdO1xuXG4gIGlmIChERUJVRykgYXNzZXJ0Q2FsbGJhY2tJc0ZuKGNhbGxiYWNrUmVmKTtcblxuICByZXR1cm4gY3JlYXRlQ29tcHV0ZVJlZihcbiAgICAoKSA9PiB7XG4gICAgICByZXR1cm4gKC4uLmludm9jYXRpb25BcmdzOiB1bmtub3duW10pID0+IHtcbiAgICAgICAgbGV0IFtmbiwgLi4uYXJnc10gPSByZWlmeVBvc2l0aW9uYWwocG9zaXRpb25hbCk7XG5cbiAgICAgICAgaWYgKERFQlVHKSBhc3NlcnRDYWxsYmFja0lzRm4oY2FsbGJhY2tSZWYpO1xuXG4gICAgICAgIGlmIChpc0ludm9rYWJsZVJlZihjYWxsYmFja1JlZikpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBhcmdzLmxlbmd0aCA+IDAgPyBhcmdzWzBdIDogaW52b2NhdGlvbkFyZ3NbMF07XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZihjYWxsYmFja1JlZiwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAoZm4gYXMgRnVuY3Rpb24pLmNhbGwoY29udGV4dCwgLi4uYXJncywgLi4uaW52b2NhdGlvbkFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgbnVsbCxcbiAgICAnZm4nXG4gICk7XG59KTtcblxuZnVuY3Rpb24gYXNzZXJ0Q2FsbGJhY2tJc0ZuKGNhbGxiYWNrUmVmOiBSZWZlcmVuY2UpIHtcbiAgaWYgKFxuICAgICEoXG4gICAgICBjYWxsYmFja1JlZiAmJlxuICAgICAgKGlzSW52b2thYmxlUmVmKGNhbGxiYWNrUmVmKSB8fCB0eXBlb2YgdmFsdWVGb3JSZWYoY2FsbGJhY2tSZWYpID09PSAnZnVuY3Rpb24nKVxuICAgIClcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFlvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiBhcyB0aGUgXFxgZm5cXGAgaGVscGVyJ3MgZmlyc3QgYXJndW1lbnQsIHlvdSBwYXNzZWQgJHtcbiAgICAgICAgY2FsbGJhY2tSZWYgPyB2YWx1ZUZvclJlZihjYWxsYmFja1JlZikgOiBjYWxsYmFja1JlZlxuICAgICAgfS4gV2hpbGUgcmVuZGVyaW5nOlxcblxcbiR7Y2FsbGJhY2tSZWY/LmRlYnVnTGFiZWx9YFxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCB7IENhcHR1cmVkQXJndW1lbnRzLCBEaWN0IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjcmVhdGVDb21wdXRlUmVmLCBSZWZlcmVuY2UgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgcmVpZnlOYW1lZCB9IGZyb20gJ0BnbGltbWVyL3J1bnRpbWUnO1xuaW1wb3J0IHsgZGVwcmVjYXRlIH0gZnJvbSAnQGdsaW1tZXIvZ2xvYmFsLWNvbnRleHQnO1xuaW1wb3J0IHsgSEFTX05BVElWRV9QUk9YWSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgaW50ZXJuYWxIZWxwZXIgfSBmcm9tICcuL2ludGVybmFsLWhlbHBlcic7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5cbmxldCB3cmFwSGFzaFByb3h5OiAoaGFzaDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pID0+IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuXG5pZiAoREVCVUcpIHtcbiAgd3JhcEhhc2hQcm94eSA9IChoYXNoOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgPT4ge1xuICAgIHJldHVybiBuZXcgUHJveHkoaGFzaCwge1xuICAgICAgc2V0KHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBkZXByZWNhdGUoXG4gICAgICAgICAgYFlvdSBzZXQgdGhlICcke1N0cmluZyhcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9JyBwcm9wZXJ0eSBvbiBhIHt7aGFzaH19IG9iamVjdC4gU2V0dGluZyBwcm9wZXJ0aWVzIG9uIG9iamVjdHMgZ2VuZXJhdGVkIGJ5IHt7aGFzaH19IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1cGRhdGUgdG8gdXNlIGFuIG9iamVjdCBjcmVhdGVkIHdpdGggYSB0cmFja2VkIHByb3BlcnR5IG9yIGdldHRlciwgb3Igd2l0aCBhIGN1c3RvbSBoZWxwZXIuYCxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICB7IGlkOiAnc2V0dGluZy1vbi1oYXNoJyB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGFyZ2V0W2tleSBhcyBzdHJpbmddID0gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAgIFVzZSB0aGUgYHt7aGFzaH19YCBoZWxwZXIgdG8gY3JlYXRlIGEgaGFzaCB0byBwYXNzIGFzIGFuIG9wdGlvbiB0byB5b3VyXG4gICBjb21wb25lbnRzLiBUaGlzIGlzIHNwZWNpYWxseSB1c2VmdWwgZm9yIGNvbnRleHR1YWwgY29tcG9uZW50cyB3aGVyZSB5b3UgY2FuXG4gICBqdXN0IHlpZWxkIGEgaGFzaDpcblxuICAgYGBgaGFuZGxlYmFyc1xuICAge3t5aWVsZCAoaGFzaFxuICAgICAgbmFtZT0nU2FyYWgnXG4gICAgICB0aXRsZT1vZmZpY2VcbiAgICl9fVxuICAgYGBgXG5cbiAgIFdvdWxkIHJlc3VsdCBpbiBhbiBvYmplY3Qgc3VjaCBhczpcblxuICAgYGBganNcbiAgIHsgbmFtZTogJ1NhcmFoJywgdGl0bGU6IHRoaXMuZ2V0KCdvZmZpY2UnKSB9XG4gICBgYGBcblxuICAgV2hlcmUgdGhlIGB0aXRsZWAgaXMgYm91bmQgdG8gdXBkYXRlcyBvZiB0aGUgYG9mZmljZWAgcHJvcGVydHkuXG5cbiAgIE5vdGUgdGhhdCB0aGUgaGFzaCBpcyBhbiBlbXB0eSBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGUgY2hhaW4sIHRoZXJlZm9yZVxuICAgY29tbW9uIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIGFyZSBub3QgYXZhaWxhYmxlIGluIHRoZSByZXN1bHRpbmcgaGFzaC5cbiAgIElmIHlvdSBuZWVkIHRvIHVzZSBzdWNoIGEgbWV0aG9kLCB5b3UgY2FuIHVzZSB0aGUgYGNhbGxgIG9yIGBhcHBseWBcbiAgIGFwcHJvYWNoOlxuXG4gICBgYGBqc1xuICAgZnVuY3Rpb24gdG9TdHJpbmcob2JqKSB7XG4gICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KG9iaik7XG4gICB9XG4gICBgYGBcblxuICAgQG1ldGhvZCBoYXNoXG4gICBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgQHJldHVybiB7T2JqZWN0fSBIYXNoXG4gICBAcHVibGljXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGludGVybmFsSGVscGVyKFxuICAoeyBuYW1lZCB9OiBDYXB0dXJlZEFyZ3VtZW50cyk6IFJlZmVyZW5jZTxEaWN0PHVua25vd24+PiA9PiB7XG4gICAgbGV0IHJlZiA9IGNyZWF0ZUNvbXB1dGVSZWYoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGxldCBoYXNoID0gcmVpZnlOYW1lZChuYW1lZCk7XG5cbiAgICAgICAgaWYgKERFQlVHICYmIEhBU19OQVRJVkVfUFJPWFkpIHtcbiAgICAgICAgICBoYXNoID0gd3JhcEhhc2hQcm94eShoYXNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfSxcbiAgICAgIG51bGwsXG4gICAgICAnaGFzaCdcbiAgICApO1xuXG4gICAgLy8gU2V0dXAgdGhlIGNoaWxkcmVuIHNvIHRoYXQgdGVtcGxhdGVzIGNhbiBieXBhc3MgZ2V0dGluZyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgcmVmZXJlbmNlIGFuZCB0cmVhdCBjaGlsZHJlbiBsYXppbHlcbiAgICBsZXQgY2hpbGRyZW4gPSBuZXcgTWFwKCk7XG5cbiAgICBmb3IgKGxldCBuYW1lIGluIG5hbWVkKSB7XG4gICAgICBjaGlsZHJlbi5zZXQobmFtZSwgbmFtZWRbbmFtZV0pO1xuICAgIH1cblxuICAgIHJlZi5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuKTtcbiIsImltcG9ydCB7IENhcHR1cmVkQXJndW1lbnRzIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjcmVhdGVDb21wdXRlUmVmLCBSZWZlcmVuY2UgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgcmVpZnlQb3NpdGlvbmFsIH0gZnJvbSAnQGdsaW1tZXIvcnVudGltZSc7XG5pbXBvcnQgeyBpbnRlcm5hbEhlbHBlciB9IGZyb20gJy4vaW50ZXJuYWwtaGVscGVyJztcblxuLyoqXG4gICBVc2UgdGhlIGB7e2FycmF5fX1gIGhlbHBlciB0byBjcmVhdGUgYW4gYXJyYXkgdG8gcGFzcyBhcyBhbiBvcHRpb24gdG8geW91clxuICAgY29tcG9uZW50cy5cblxuICAgYGBgaGFuZGxlYmFyc1xuICAgPE15Q29tcG9uZW50IEBwZW9wbGU9e3thcnJheVxuICAgICAnVG9tIERhbGUnXG4gICAgICdZZWh1ZGEgS2F0eidcbiAgICAgdGhpcy5teU90aGVyUGVyc29ufX1cbiAgIC8+XG4gICBgYGBcbiAgICBvclxuICAgYGBgaGFuZGxlYmFyc1xuICAge3tteS1jb21wb25lbnQgcGVvcGxlPShhcnJheVxuICAgICAnVG9tIERhbGUnXG4gICAgICdZZWh1ZGEgS2F0eidcbiAgICAgdGhpcy5teU90aGVyUGVyc29uKVxuICAgfX1cbiAgIGBgYFxuXG4gICBXb3VsZCByZXN1bHQgaW4gYW4gb2JqZWN0IHN1Y2ggYXM6XG5cbiAgIGBgYGpzXG4gICBbJ1RvbSBEYWxlJywgJ1llaHVkYSBLYXR6JywgdGhpcy5nZXQoJ215T3RoZXJQZXJzb24nKV1cbiAgIGBgYFxuXG4gICBXaGVyZSB0aGUgM3JkIGl0ZW0gaW4gdGhlIGFycmF5IGlzIGJvdW5kIHRvIHVwZGF0ZXMgb2YgdGhlIGBteU90aGVyUGVyc29uYCBwcm9wZXJ0eS5cblxuICAgQG1ldGhvZCBhcnJheVxuICAgQHBhcmFtIHtBcnJheX0gb3B0aW9uc1xuICAgQHJldHVybiB7QXJyYXl9IEFycmF5XG4gICBAcHVibGljXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJuYWxIZWxwZXIoXG4gICh7IHBvc2l0aW9uYWwgfTogQ2FwdHVyZWRBcmd1bWVudHMpOiBSZWZlcmVuY2U8dW5rbm93bltdPiA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbXB1dGVSZWYoKCkgPT4gcmVpZnlQb3NpdGlvbmFsKHBvc2l0aW9uYWwpLCBudWxsLCAnYXJyYXknKTtcbiAgfVxuKTtcbiIsImltcG9ydCB7IGdldFBhdGgsIHNldFBhdGggfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5pbXBvcnQgeyBpc0RpY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IENhcHR1cmVkQXJndW1lbnRzIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjcmVhdGVDb21wdXRlUmVmLCBVTkRFRklORURfUkVGRVJFTkNFLCB2YWx1ZUZvclJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBpbnRlcm5hbEhlbHBlciB9IGZyb20gJy4vaW50ZXJuYWwtaGVscGVyJztcblxuLyoqXG4gIER5bmFtaWNhbGx5IGxvb2sgdXAgYSBwcm9wZXJ0eSBvbiBhbiBvYmplY3QuIFRoZSBzZWNvbmQgYXJndW1lbnQgdG8gYHt7Z2V0fX1gXG4gIHNob3VsZCBoYXZlIGEgc3RyaW5nIHZhbHVlLCBhbHRob3VnaCBpdCBjYW4gYmUgYm91bmQuXG5cbiAgRm9yIGV4YW1wbGUsIHRoZXNlIHR3byB1c2FnZXMgYXJlIGVxdWl2YWxlbnQ6XG5cbiAgYGBgYXBwL2NvbXBvbmVudHMvZGV2ZWxvcGVyLWRldGFpbC5qc1xuICBpbXBvcnQgQ29tcG9uZW50IGZyb20gJ0BnbGltbWVyL2NvbXBvbmVudCc7XG4gIGltcG9ydCB7IHRyYWNrZWQgfSBmcm9tICdAZ2xpbW1lci90cmFja2luZyc7XG5cbiAgZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIEB0cmFja2VkIGRldmVsb3BlciA9IHtcbiAgICAgIG5hbWU6IFwiU2FuZGkgTWV0elwiLFxuICAgICAgbGFuZ3VhZ2U6IFwiUnVieVwiXG4gICAgfVxuICB9XG4gIGBgYFxuXG4gIGBgYGhhbmRsZWJhcnNcbiAge3t0aGlzLmRldmVsb3Blci5uYW1lfX1cbiAge3tnZXQgdGhpcy5kZXZlbG9wZXIgXCJuYW1lXCJ9fVxuICBgYGBcblxuICBJZiB0aGVyZSB3ZXJlIHNldmVyYWwgZmFjdHMgYWJvdXQgYSBwZXJzb24sIHRoZSBge3tnZXR9fWAgaGVscGVyIGNhbiBkeW5hbWljYWxseVxuICBwaWNrIG9uZTpcblxuICBgYGBhcHAvdGVtcGxhdGVzL2FwcGxpY2F0aW9uLmhic1xuICA8RGV2ZWxvcGVyRGV0YWlsIEBmYWN0TmFtZT1cImxhbmd1YWdlXCIgLz5cbiAgYGBgXG5cbiAgYGBgaGFuZGxlYmFyc1xuICB7e2dldCB0aGlzLmRldmVsb3BlciBAZmFjdE5hbWV9fVxuICBgYGBcblxuICBGb3IgYSBtb3JlIGNvbXBsZXggZXhhbXBsZSwgdGhpcyB0ZW1wbGF0ZSB3b3VsZCBhbGxvdyB0aGUgdXNlciB0byBzd2l0Y2hcbiAgYmV0d2VlbiBzaG93aW5nIHRoZSB1c2VyJ3MgaGVpZ2h0IGFuZCB3ZWlnaHQgd2l0aCBhIGNsaWNrOlxuXG4gIGBgYGFwcC9jb21wb25lbnRzL2RldmVsb3Blci1kZXRhaWwuanNcbiAgaW1wb3J0IENvbXBvbmVudCBmcm9tICdAZ2xpbW1lci9jb21wb25lbnQnO1xuICBpbXBvcnQgeyB0cmFja2VkIH0gZnJvbSAnQGdsaW1tZXIvdHJhY2tpbmcnO1xuXG4gIGV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBAdHJhY2tlZCBkZXZlbG9wZXIgPSB7XG4gICAgICBuYW1lOiBcIlNhbmRpIE1ldHpcIixcbiAgICAgIGxhbmd1YWdlOiBcIlJ1YnlcIlxuICAgIH1cblxuICAgIEB0cmFja2VkIGN1cnJlbnRGYWN0ID0gJ25hbWUnXG5cbiAgICBzaG93RmFjdCA9IChmYWN0KSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRGYWN0ID0gZmFjdDtcbiAgICB9XG4gIH1cbiAgYGBgXG5cbiAgYGBgYXBwL2NvbXBvbmVudHMvZGV2ZWxvcGVyLWRldGFpbC5qc1xuICB7e2dldCB0aGlzLmRldmVsb3BlciB0aGlzLmN1cnJlbnRGYWN0fX1cblxuICA8YnV0dG9uIHt7b24gJ2NsaWNrJyAoZm4gdGhpcy5zaG93RmFjdCBcIm5hbWVcIil9fT5TaG93IG5hbWU8L2J1dHRvbj5cbiAgPGJ1dHRvbiB7e29uICdjbGljaycgKGZuIHRoaXMuc2hvd0ZhY3QgXCJsYW5ndWFnZVwiKX19PlNob3cgbGFuZ3VhZ2U8L2J1dHRvbj5cbiAgYGBgXG5cbiAgVGhlIGB7e2dldH19YCBoZWxwZXIgY2FuIGFsc28gcmVzcGVjdCBtdXRhYmxlIHZhbHVlcyBpdHNlbGYuIEZvciBleGFtcGxlOlxuXG4gIGBgYGFwcC9jb21wb25lbnRzL2RldmVsb3Blci1kZXRhaWwuanNcbiAgPElucHV0IEB2YWx1ZT17e211dCAoZ2V0IHRoaXMucGVyc29uIHRoaXMuY3VycmVudEZhY3QpfX0gLz5cblxuICA8YnV0dG9uIHt7b24gJ2NsaWNrJyAoZm4gdGhpcy5zaG93RmFjdCBcIm5hbWVcIil9fT5TaG93IG5hbWU8L2J1dHRvbj5cbiAgPGJ1dHRvbiB7e29uICdjbGljaycgKGZuIHRoaXMuc2hvd0ZhY3QgXCJsYW5ndWFnZVwiKX19PlNob3cgbGFuZ3VhZ2U8L2J1dHRvbj5cbiAgYGBgXG5cbiAgV291bGQgYWxsb3cgdGhlIHVzZXIgdG8gc3dhcCB3aGF0IGZhY3QgaXMgYmVpbmcgZGlzcGxheWVkLCBhbmQgYWxzbyBlZGl0XG4gIHRoYXQgZmFjdCB2aWEgYSB0d28td2F5IG11dGFibGUgYmluZGluZy5cblxuICBAcHVibGljXG4gIEBtZXRob2QgZ2V0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGludGVybmFsSGVscGVyKCh7IHBvc2l0aW9uYWwgfTogQ2FwdHVyZWRBcmd1bWVudHMpID0+IHtcbiAgbGV0IHNvdXJjZVJlZiA9IHBvc2l0aW9uYWxbMF0gPz8gVU5ERUZJTkVEX1JFRkVSRU5DRTtcbiAgbGV0IHBhdGhSZWYgPSBwb3NpdGlvbmFsWzFdID8/IFVOREVGSU5FRF9SRUZFUkVOQ0U7XG5cbiAgcmV0dXJuIGNyZWF0ZUNvbXB1dGVSZWYoXG4gICAgKCkgPT4ge1xuICAgICAgbGV0IHNvdXJjZSA9IHZhbHVlRm9yUmVmKHNvdXJjZVJlZik7XG5cbiAgICAgIGlmIChpc0RpY3Qoc291cmNlKSkge1xuICAgICAgICByZXR1cm4gZ2V0UGF0aChzb3VyY2UsIFN0cmluZyh2YWx1ZUZvclJlZihwYXRoUmVmKSkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgKHZhbHVlKSA9PiB7XG4gICAgICBsZXQgc291cmNlID0gdmFsdWVGb3JSZWYoc291cmNlUmVmKTtcblxuICAgICAgaWYgKGlzRGljdChzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiBzZXRQYXRoKHNvdXJjZSwgU3RyaW5nKHZhbHVlRm9yUmVmKHBhdGhSZWYpKSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ2dldCdcbiAgKTtcbn0pO1xuIiwiaW1wb3J0IHsgQ2FwdHVyZWRBcmd1bWVudHMgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGNyZWF0ZUNvbXB1dGVSZWYgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgcmVpZnlQb3NpdGlvbmFsIH0gZnJvbSAnQGdsaW1tZXIvcnVudGltZSc7XG5pbXBvcnQgeyBpbnRlcm5hbEhlbHBlciB9IGZyb20gJy4vaW50ZXJuYWwtaGVscGVyJztcblxuY29uc3QgaXNFbXB0eSA9ICh2YWx1ZTogdW5rbm93bik6IGJvb2xlYW4gPT4ge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgKHZhbHVlIGFzIG9iamVjdCkudG9TdHJpbmcgIT09ICdmdW5jdGlvbic7XG59O1xuXG5jb25zdCBub3JtYWxpemVUZXh0VmFsdWUgPSAodmFsdWU6IHVua25vd24pOiBzdHJpbmcgPT4ge1xuICBpZiAoaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG59O1xuXG4vKipcbiAgQ29uY2F0ZW5hdGVzIHRoZSBnaXZlbiBhcmd1bWVudHMgaW50byBhIHN0cmluZy5cblxuICBFeGFtcGxlOlxuXG4gIGBgYGhhbmRsZWJhcnNcbiAge3tzb21lLWNvbXBvbmVudCBuYW1lPShjb25jYXQgZmlyc3ROYW1lIFwiIFwiIGxhc3ROYW1lKX19XG5cbiAge3shIHdvdWxkIHBhc3MgbmFtZT1cIjxmaXJzdCBuYW1lIHZhbHVlPiA8bGFzdCBuYW1lIHZhbHVlPlwiIHRvIHRoZSBjb21wb25lbnR9fVxuICBgYGBcblxuICBvciBmb3IgYW5nbGUgYnJhY2tldCBpbnZvY2F0aW9uLCB5b3UgYWN0dWFsbHkgZG9uJ3QgbmVlZCBjb25jYXQgYXQgYWxsLlxuXG4gIGBgYGhhbmRsZWJhcnNcbiAgPFNvbWVDb21wb25lbnQgQG5hbWU9XCJ7e2ZpcnN0TmFtZX19IHt7bGFzdE5hbWV9fVwiIC8+XG4gIGBgYFxuXG4gIEBwdWJsaWNcbiAgQG1ldGhvZCBjb25jYXRcbiovXG5leHBvcnQgZGVmYXVsdCBpbnRlcm5hbEhlbHBlcigoeyBwb3NpdGlvbmFsIH06IENhcHR1cmVkQXJndW1lbnRzKSA9PiB7XG4gIHJldHVybiBjcmVhdGVDb21wdXRlUmVmKFxuICAgICgpID0+IHJlaWZ5UG9zaXRpb25hbChwb3NpdGlvbmFsKS5tYXAobm9ybWFsaXplVGV4dFZhbHVlKS5qb2luKCcnKSxcbiAgICBudWxsLFxuICAgICdjb25jYXQnXG4gICk7XG59KTtcbiIsImltcG9ydCB7IHJlZ2lzdGVyRGVzdHJ1Y3RvciB9IGZyb20gJ0BnbGltbWVyL2Rlc3Ryb3lhYmxlJztcbmltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IENhcHR1cmVkQXJndW1lbnRzLCBJbnRlcm5hbE1vZGlmaWVyTWFuYWdlciwgT3duZXIgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IHNldEludGVybmFsTW9kaWZpZXJNYW5hZ2VyIH0gZnJvbSAnQGdsaW1tZXIvbWFuYWdlcic7XG5pbXBvcnQgeyB2YWx1ZUZvclJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyByZWlmeU5hbWVkIH0gZnJvbSAnQGdsaW1tZXIvcnVudGltZSc7XG5pbXBvcnQgeyBjcmVhdGVVcGRhdGFibGVUYWcsIFVwZGF0YWJsZVRhZyB9IGZyb20gJ0BnbGltbWVyL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBTaW1wbGVFbGVtZW50IH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcbmltcG9ydCB7IGJ1aWxkVW50b3VjaGFibGVUaGlzIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmNvbnN0IHVudG91Y2hhYmxlQ29udGV4dCA9IGJ1aWxkVW50b3VjaGFibGVUaGlzKCdgb25gIG1vZGlmaWVyJyk7XG5cbi8qXG4gIEludGVybmV0IEV4cGxvcmVyIDExIGRvZXMgbm90IHN1cHBvcnQgYG9uY2VgIGFuZCBhbHNvIGRvZXMgbm90IHN1cHBvcnRcbiAgcGFzc2luZyBgZXZlbnRPcHRpb25zYC4gSW4gc29tZSBzaXR1YXRpb25zIGl0IHRoZW4gdGhyb3dzIGEgd2VpcmQgc2NyaXB0XG4gIGVycm9yLCBsaWtlOlxuXG4gIGBgYFxuICBDb3VsZCBub3QgY29tcGxldGUgdGhlIG9wZXJhdGlvbiBkdWUgdG8gZXJyb3IgODAwMjAxMDFcbiAgYGBgXG5cbiAgVGhpcyBmbGFnIGRldGVybWluZXMsIHdoZXRoZXIgYHsgb25jZTogdHJ1ZSB9YCBhbmQgdGh1cyBhbHNvIGV2ZW50IG9wdGlvbnMgaW5cbiAgZ2VuZXJhbCBhcmUgc3VwcG9ydGVkLlxuKi9cbmNvbnN0IFNVUFBPUlRTX0VWRU5UX09QVElPTlMgPSAoKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBjb3VudGVyKyssIHsgb25jZTogdHJ1ZSB9KTtcblxuICAgIGxldCBldmVudDtcbiAgICBpZiAodHlwZW9mIEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBldmVudCA9IG5ldyBFdmVudCgnY2xpY2snKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2ZW50LmluaXRFdmVudCgnY2xpY2snLCB0cnVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBkaXYuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgZGl2LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgcmV0dXJuIGNvdW50ZXIgPT09IDE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG5leHBvcnQgY2xhc3MgT25Nb2RpZmllclN0YXRlIHtcbiAgcHVibGljIHRhZyA9IGNyZWF0ZVVwZGF0YWJsZVRhZygpO1xuICBwdWJsaWMgZWxlbWVudDogRWxlbWVudDtcbiAgcHVibGljIGFyZ3M6IENhcHR1cmVkQXJndW1lbnRzO1xuICBwdWJsaWMgZXZlbnROYW1lITogc3RyaW5nO1xuICBwdWJsaWMgY2FsbGJhY2shOiBFdmVudExpc3RlbmVyO1xuICBwcml2YXRlIHVzZXJQcm92aWRlZENhbGxiYWNrITogRXZlbnRMaXN0ZW5lcjtcbiAgcHVibGljIG9uY2U/OiBib29sZWFuO1xuICBwdWJsaWMgcGFzc2l2ZT86IGJvb2xlYW47XG4gIHB1YmxpYyBjYXB0dXJlPzogYm9vbGVhbjtcbiAgcHVibGljIG9wdGlvbnM/OiBBZGRFdmVudExpc3RlbmVyT3B0aW9ucztcbiAgcHVibGljIHNob3VsZFVwZGF0ZSA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudCwgYXJnczogQ2FwdHVyZWRBcmd1bWVudHMpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gIH1cblxuICB1cGRhdGVGcm9tQXJncygpOiB2b2lkIHtcbiAgICBsZXQgeyBhcmdzIH0gPSB0aGlzO1xuXG4gICAgbGV0IHsgb25jZSwgcGFzc2l2ZSwgY2FwdHVyZSB9OiBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyA9IHJlaWZ5TmFtZWQoYXJncy5uYW1lZCk7XG4gICAgaWYgKG9uY2UgIT09IHRoaXMub25jZSkge1xuICAgICAgdGhpcy5vbmNlID0gb25jZTtcbiAgICAgIHRoaXMuc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocGFzc2l2ZSAhPT0gdGhpcy5wYXNzaXZlKSB7XG4gICAgICB0aGlzLnBhc3NpdmUgPSBwYXNzaXZlO1xuICAgICAgdGhpcy5zaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjYXB0dXJlICE9PSB0aGlzLmNhcHR1cmUpIHtcbiAgICAgIHRoaXMuY2FwdHVyZSA9IGNhcHR1cmU7XG4gICAgICB0aGlzLnNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IG9wdGlvbnM6IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zO1xuICAgIGlmIChvbmNlIHx8IHBhc3NpdmUgfHwgY2FwdHVyZSkge1xuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IHsgb25jZSwgcGFzc2l2ZSwgY2FwdHVyZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgREVCVUcgJiZcbiAgICAgIChhcmdzLnBvc2l0aW9uYWxbMF0gPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWVGb3JSZWYoYXJncy5wb3NpdGlvbmFsWzBdKSAhPT0gJ3N0cmluZycpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdZb3UgbXVzdCBwYXNzIGEgdmFsaWQgRE9NIGV2ZW50IG5hbWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBgb25gIG1vZGlmaWVyJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgZXZlbnROYW1lID0gdmFsdWVGb3JSZWYoYXJncy5wb3NpdGlvbmFsWzBdKSBhcyBzdHJpbmc7XG4gICAgaWYgKGV2ZW50TmFtZSAhPT0gdGhpcy5ldmVudE5hbWUpIHtcbiAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgdGhpcy5zaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCB1c2VyUHJvdmlkZWRDYWxsYmFja1JlZmVyZW5jZSA9IGFyZ3MucG9zaXRpb25hbFsxXTtcblxuICAgIGlmIChERUJVRykge1xuICAgICAgaWYgKGFyZ3MucG9zaXRpb25hbFsxXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIFxcYG9uXFxgIG1vZGlmaWVyLmApO1xuICAgICAgfVxuXG4gICAgICBsZXQgdmFsdWUgPSB2YWx1ZUZvclJlZih1c2VyUHJvdmlkZWRDYWxsYmFja1JlZmVyZW5jZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgXFxgb25cXGAgbW9kaWZpZXI7IHlvdSBwYXNzZWQgJHtcbiAgICAgICAgICAgIHZhbHVlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHZhbHVlXG4gICAgICAgICAgfS4gV2hpbGUgcmVuZGVyaW5nOlxcblxcbiR7dXNlclByb3ZpZGVkQ2FsbGJhY2tSZWZlcmVuY2UuZGVidWdMYWJlbH1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHVzZXJQcm92aWRlZENhbGxiYWNrID0gdmFsdWVGb3JSZWYodXNlclByb3ZpZGVkQ2FsbGJhY2tSZWZlcmVuY2UpIGFzIEV2ZW50TGlzdGVuZXI7XG4gICAgaWYgKHVzZXJQcm92aWRlZENhbGxiYWNrICE9PSB0aGlzLnVzZXJQcm92aWRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVzZXJQcm92aWRlZENhbGxiYWNrID0gdXNlclByb3ZpZGVkQ2FsbGJhY2s7XG4gICAgICB0aGlzLnNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKERFQlVHICYmIGFyZ3MucG9zaXRpb25hbC5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBjYW4gb25seSBwYXNzIHR3byBwb3NpdGlvbmFsIGFyZ3VtZW50cyAoZXZlbnQgbmFtZSBhbmQgY2FsbGJhY2spIHRvIHRoZSBcXGBvblxcYCBtb2RpZmllciwgYnV0IHlvdSBwcm92aWRlZCAke2FyZ3MucG9zaXRpb25hbC5sZW5ndGh9LiBDb25zaWRlciB1c2luZyB0aGUgXFxgZm5cXGAgaGVscGVyIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gdGhlIFxcYG9uXFxgIGNhbGxiYWNrLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IG5lZWRzQ3VzdG9tQ2FsbGJhY2sgPVxuICAgICAgKFNVUFBPUlRTX0VWRU5UX09QVElPTlMgPT09IGZhbHNlICYmIG9uY2UpIC8qIG5lZWRzIG1hbnVhbCBvbmNlIGltcGxlbWVudGF0aW9uICovIHx8XG4gICAgICAoREVCVUcgJiYgcGFzc2l2ZSk7IC8qIG5lZWRzIHBhc3NpdmUgZW5mb3JjZW1lbnQgKi9cblxuICAgIGlmICh0aGlzLnNob3VsZFVwZGF0ZSkge1xuICAgICAgaWYgKG5lZWRzQ3VzdG9tQ2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGNhbGxiYWNrID0gKHRoaXMuY2FsbGJhY2sgPSBmdW5jdGlvbiAodGhpczogRWxlbWVudCwgZXZlbnQpIHtcbiAgICAgICAgICBpZiAoREVCVUcgJiYgcGFzc2l2ZSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgWW91IG1hcmtlZCB0aGlzIGxpc3RlbmVyIGFzICdwYXNzaXZlJywgbWVhbmluZyB0aGF0IHlvdSBtdXN0IG5vdCBjYWxsICdldmVudC5wcmV2ZW50RGVmYXVsdCgpJzogXFxuXFxuJHt1c2VyUHJvdmlkZWRDYWxsYmFja31gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghU1VQUE9SVFNfRVZFTlRfT1BUSU9OUyAmJiBvbmNlKSB7XG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdXNlclByb3ZpZGVkQ2FsbGJhY2suY2FsbCh1bnRvdWNoYWJsZUNvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKERFQlVHKSB7XG4gICAgICAgIC8vIHByZXZlbnQgdGhlIGNhbGxiYWNrIGZyb20gYmVpbmcgYm91bmQgdG8gdGhlIGVsZW1lbnRcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IHVzZXJQcm92aWRlZENhbGxiYWNrLmJpbmQodW50b3VjaGFibGVDb250ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSB1c2VyUHJvdmlkZWRDYWxsYmFjaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubGV0IGFkZHMgPSAwO1xubGV0IHJlbW92ZXMgPSAwO1xuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKFxuICBlbGVtZW50OiBFbGVtZW50LFxuICBldmVudE5hbWU6IHN0cmluZyxcbiAgY2FsbGJhY2s6IEV2ZW50TGlzdGVuZXIsXG4gIG9wdGlvbnM/OiBBZGRFdmVudExpc3RlbmVyT3B0aW9uc1xuKTogdm9pZCB7XG4gIHJlbW92ZXMrKztcblxuICBpZiAoU1VQUE9SVFNfRVZFTlRfT1BUSU9OUykge1xuICAgIC8vIHdoZW4gb3B0aW9ucyBhcmUgc3VwcG9ydGVkLCB1c2UgdGhlbSBhY3Jvc3MgdGhlIGJvYXJkXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmNhcHR1cmUpIHtcbiAgICAvLyB1c2VkIG9ubHkgaW4gdGhlIGZvbGxvd2luZyBjYXNlOlxuICAgIC8vXG4gICAgLy8gYHsgb25jZTogdHJ1ZSB8IGZhbHNlLCBwYXNzaXZlOiB0cnVlIHwgZmFsc2UsIGNhcHR1cmU6IHRydWUgfVxuICAgIC8vXG4gICAgLy8gYG9uY2VgIGlzIGhhbmRsZWQgdmlhIGEgY3VzdG9tIGNhbGxiYWNrIHRoYXQgcmVtb3ZlcyBhZnRlciBmaXJzdFxuICAgIC8vIGludm9jYXRpb24gc28gd2Ugb25seSBjYXJlIGFib3V0IGNhcHR1cmUgaGVyZSBhcyBhIGJvb2xlYW5cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlZCBvbmx5IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgLy9cbiAgICAvLyAqIHdoZXJlIHRoZXJlIGlzIG5vIG9wdGlvbnNcbiAgICAvLyAqIGB7IG9uY2U6IHRydWUgfCBmYWxzZSwgcGFzc2l2ZTogdHJ1ZSB8IGZhbHNlLCBjYXB0dXJlOiBmYWxzZSB9XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIGV2ZW50TmFtZTogc3RyaW5nLFxuICBjYWxsYmFjazogRXZlbnRMaXN0ZW5lcixcbiAgb3B0aW9ucz86IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zXG4pOiB2b2lkIHtcbiAgYWRkcysrO1xuXG4gIGlmIChTVVBQT1JUU19FVkVOVF9PUFRJT05TKSB7XG4gICAgLy8gd2hlbiBvcHRpb25zIGFyZSBzdXBwb3J0ZWQsIHVzZSB0aGVtIGFjcm9zcyB0aGUgYm9hcmRcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuY2FwdHVyZSkge1xuICAgIC8vIHVzZWQgb25seSBpbiB0aGUgZm9sbG93aW5nIGNhc2U6XG4gICAgLy9cbiAgICAvLyBgeyBvbmNlOiB0cnVlIHwgZmFsc2UsIHBhc3NpdmU6IHRydWUgfCBmYWxzZSwgY2FwdHVyZTogdHJ1ZSB9XG4gICAgLy9cbiAgICAvLyBgb25jZWAgaXMgaGFuZGxlZCB2aWEgYSBjdXN0b20gY2FsbGJhY2sgdGhhdCByZW1vdmVzIGFmdGVyIGZpcnN0XG4gICAgLy8gaW52b2NhdGlvbiBzbyB3ZSBvbmx5IGNhcmUgYWJvdXQgY2FwdHVyZSBoZXJlIGFzIGEgYm9vbGVhblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2VkIG9ubHkgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAvL1xuICAgIC8vICogd2hlcmUgdGhlcmUgaXMgbm8gb3B0aW9uc1xuICAgIC8vICogYHsgb25jZTogdHJ1ZSB8IGZhbHNlLCBwYXNzaXZlOiB0cnVlIHwgZmFsc2UsIGNhcHR1cmU6IGZhbHNlIH1cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gIH1cbn1cblxuLyoqXG4gIFRoZSBge3tvbn19YCBtb2RpZmllciBsZXRzIHlvdSBlYXNpbHkgYWRkIGV2ZW50IGxpc3RlbmVycyAoaXQgdXNlc1xuICBbRXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIpXG4gIGludGVybmFsbHkpLlxuXG4gIEZvciBleGFtcGxlLCBpZiB5b3UnZCBsaWtlIHRvIHJ1biBhIGZ1bmN0aW9uIG9uIHlvdXIgY29tcG9uZW50IHdoZW4gYSBgPGJ1dHRvbj5gXG4gIGluIHRoZSBjb21wb25lbnRzIHRlbXBsYXRlIGlzIGNsaWNrZWQgeW91IG1pZ2h0IGRvIHNvbWV0aGluZyBsaWtlOlxuXG4gIGBgYGFwcC9jb21wb25lbnRzL2xpa2UtcG9zdC5oYnNcbiAgPGJ1dHRvbiB7e29uICdjbGljaycgdGhpcy5zYXZlTGlrZX19Pkxpa2UgdGhpcyBwb3N0ITwvYnV0dG9uPlxuICBgYGBcblxuICBgYGBhcHAvY29tcG9uZW50cy9saWtlLXBvc3QuanNcbiAgaW1wb3J0IENvbXBvbmVudCBmcm9tICdAZ2xpbW1lci9jb21wb25lbnQnO1xuICBpbXBvcnQgeyBhY3Rpb24gfSBmcm9tICdAZW1iZXIvb2JqZWN0JztcblxuICBleHBvcnQgZGVmYXVsdCBjbGFzcyBMaWtlUG9zdENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc2F2ZUxpa2UgPSAoKSA9PiB7XG4gICAgICAvLyBzb21lb25lIGxpa2VzIHlvdXIgcG9zdCFcbiAgICAgIC8vIGJldHRlciBzZW5kIGEgcmVxdWVzdCBvZmYgdG8geW91ciBzZXJ2ZXIuLi5cbiAgICB9XG4gIH1cbiAgYGBgXG5cbiAgIyMjIEFyZ3VtZW50c1xuXG4gIGB7e29ufX1gIGFjY2VwdHMgdHdvIHBvc2l0aW9uYWwgYXJndW1lbnRzLCBhbmQgYSBmZXcgbmFtZWQgYXJndW1lbnRzLlxuXG4gIFRoZSBwb3NpdGlvbmFsIGFyZ3VtZW50cyBhcmU6XG5cbiAgLSBgZXZlbnRgIC0tIHRoZSBuYW1lIHRvIHVzZSB3aGVuIGNhbGxpbmcgYGFkZEV2ZW50TGlzdGVuZXJgXG4gIC0gYGNhbGxiYWNrYCAtLSB0aGUgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIGBhZGRFdmVudExpc3RlbmVyYFxuXG4gIFRoZSBuYW1lZCBhcmd1bWVudHMgYXJlOlxuXG4gIC0gY2FwdHVyZSAtLSBhIGB0cnVlYCB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCBldmVudHMgb2YgdGhpcyB0eXBlIHdpbGwgYmUgZGlzcGF0Y2hlZFxuICAgIHRvIHRoZSByZWdpc3RlcmVkIGxpc3RlbmVyIGJlZm9yZSBiZWluZyBkaXNwYXRjaGVkIHRvIGFueSBFdmVudFRhcmdldCBiZW5lYXRoIGl0XG4gICAgaW4gdGhlIERPTSB0cmVlLlxuICAtIG9uY2UgLS0gaW5kaWNhdGVzIHRoYXQgdGhlIGxpc3RlbmVyIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZ1xuICAgIGFkZGVkLiBJZiB0cnVlLCB0aGUgbGlzdGVuZXIgd291bGQgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIHdoZW4gaW52b2tlZC5cbiAgLSBwYXNzaXZlIC0tIGlmIGB0cnVlYCwgaW5kaWNhdGVzIHRoYXQgdGhlIGZ1bmN0aW9uIHNwZWNpZmllZCBieSBsaXN0ZW5lciB3aWxsIG5ldmVyXG4gICAgY2FsbCBwcmV2ZW50RGVmYXVsdCgpLiBJZiBhIHBhc3NpdmUgbGlzdGVuZXIgZG9lcyBjYWxsIHByZXZlbnREZWZhdWx0KCksIHRoZSB1c2VyXG4gICAgYWdlbnQgd2lsbCBkbyBub3RoaW5nIG90aGVyIHRoYW4gZ2VuZXJhdGUgYSBjb25zb2xlIHdhcm5pbmcuIFNlZVxuICAgIFtJbXByb3Zpbmcgc2Nyb2xsaW5nIHBlcmZvcm1hbmNlIHdpdGggcGFzc2l2ZSBsaXN0ZW5lcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI0ltcHJvdmluZ19zY3JvbGxpbmdfcGVyZm9ybWFuY2Vfd2l0aF9wYXNzaXZlX2xpc3RlbmVycylcbiAgICB0byBsZWFybiBtb3JlLlxuXG4gIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBwYXNzZWQgdG8gYHt7b259fWAgd2lsbCByZWNlaXZlIGFueSBhcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkXG4gIHRvIHRoZSBldmVudCBoYW5kbGVyLiBNb3N0IGNvbW1vbmx5IHRoaXMgd291bGQgYmUgdGhlIGBldmVudGAgaXRzZWxmLlxuXG4gIElmIHlvdSB3b3VsZCBsaWtlIHRvIHBhc3MgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uIHlvdSBzaG91bGQgdXNlXG4gIHRoZSBge3tmbn19YCBoZWxwZXIuXG5cbiAgRm9yIGV4YW1wbGUsIGluIG91ciBleGFtcGxlIGNhc2UgYWJvdmUgaWYgeW91J2QgbGlrZSB0byBwYXNzIGluIHRoZSBwb3N0IHRoYXRcbiAgd2FzIGJlaW5nIGxpa2VkIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkIHlvdSBjb3VsZCBkbyBzb21ldGhpbmcgbGlrZTpcblxuICBgYGBhcHAvY29tcG9uZW50cy9saWtlLXBvc3QuaGJzXG4gIDxidXR0b24ge3tvbiAnY2xpY2snIChmbiB0aGlzLnNhdmVMaWtlIEBwb3N0KX19Pkxpa2UgdGhpcyBwb3N0ITwvYnV0dG9uPlxuICBgYGBcblxuICBJbiB0aGlzIGNhc2UsIHRoZSBgc2F2ZUxpa2VgIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0d28gYXJndW1lbnRzOiB0aGUgY2xpY2sgZXZlbnRcbiAgYW5kIHRoZSB2YWx1ZSBvZiBgQHBvc3RgLlxuXG4gICMjIyBGdW5jdGlvbiBDb250ZXh0XG5cbiAgSW4gdGhlIGV4YW1wbGUgYWJvdmUsIHdlIHVzZWQgYW4gYXJyb3cgZnVuY3Rpb24gdG8gZW5zdXJlIHRoYXQgYGxpa2VQb3N0YCBpc1xuICBwcm9wZXJseSBib3VuZCB0byB0aGUgYGl0ZW1zLWxpc3RgLCBidXQgbGV0J3MgZXhwbG9yZSB3aGF0IGhhcHBlbnMgaWYgd2VcbiAgbGVmdCBvdXQgdGhlIGFycm93IGZ1bmN0aW9uOlxuXG4gIGBgYGFwcC9jb21wb25lbnRzL2xpa2UtcG9zdC5qc1xuICBpbXBvcnQgQ29tcG9uZW50IGZyb20gJ0BnbGltbWVyL2NvbXBvbmVudCc7XG5cbiAgZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlrZVBvc3RDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHNhdmVMaWtlKCkge1xuICAgICAgLy8gLi4uc25pcC4uLlxuICAgIH1cbiAgfVxuICBgYGBcblxuICBJbiB0aGlzIGV4YW1wbGUsIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkIGBzYXZlTGlrZWAgd2lsbCBiZSBpbnZva2VkLFxuICBpdCB3aWxsICoqbm90KiogaGF2ZSBhY2Nlc3MgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZS4gSW4gb3RoZXJcbiAgd29yZHMsIGl0IHdpbGwgaGF2ZSBubyBgdGhpc2AgY29udGV4dCwgc28gcGxlYXNlIG1ha2Ugc3VyZSB5b3VyIGZ1bmN0aW9uc1xuICBhcmUgYm91bmQgKHZpYSBhbiBhcnJvdyBmdW5jdGlvbiBvciBvdGhlciBtZWFucykgYmVmb3JlIHBhc3NpbmcgaW50byBgb25gIVxuXG4gIEBtZXRob2Qgb25cbiAgQHB1YmxpY1xuKi9cbmNsYXNzIE9uTW9kaWZpZXJNYW5hZ2VyIGltcGxlbWVudHMgSW50ZXJuYWxNb2RpZmllck1hbmFnZXI8T25Nb2RpZmllclN0YXRlIHwgbnVsbCwgb2JqZWN0PiB7XG4gIHB1YmxpYyBTVVBQT1JUU19FVkVOVF9PUFRJT05TOiBib29sZWFuID0gU1VQUE9SVFNfRVZFTlRfT1BUSU9OUztcblxuICBnZXREZWJ1Z05hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ29uJztcbiAgfVxuXG4gIGdldCBjb3VudGVycygpOiB7IGFkZHM6IG51bWJlcjsgcmVtb3ZlczogbnVtYmVyIH0ge1xuICAgIHJldHVybiB7IGFkZHMsIHJlbW92ZXMgfTtcbiAgfVxuXG4gIGNyZWF0ZShcbiAgICBfb3duZXI6IE93bmVyLFxuICAgIGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQgfCBFbGVtZW50LFxuICAgIF9zdGF0ZTogb2JqZWN0LFxuICAgIGFyZ3M6IENhcHR1cmVkQXJndW1lbnRzXG4gICk6IE9uTW9kaWZpZXJTdGF0ZSB8IG51bGwge1xuICAgIHJldHVybiBuZXcgT25Nb2RpZmllclN0YXRlKGVsZW1lbnQgYXMgRWxlbWVudCwgYXJncyk7XG4gIH1cblxuICBnZXRUYWcoc3RhdGU6IE9uTW9kaWZpZXJTdGF0ZSB8IG51bGwpOiBVcGRhdGFibGVUYWcgfCBudWxsIHtcbiAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS50YWc7XG4gIH1cblxuICBpbnN0YWxsKHN0YXRlOiBPbk1vZGlmaWVyU3RhdGUgfCBudWxsKTogdm9pZCB7XG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdGUudXBkYXRlRnJvbUFyZ3MoKTtcblxuICAgIGxldCB7IGVsZW1lbnQsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMgfSA9IHN0YXRlO1xuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKTtcblxuICAgIHJlZ2lzdGVyRGVzdHJ1Y3RvcihzdGF0ZSwgKCkgPT4gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKSk7XG5cbiAgICBzdGF0ZS5zaG91bGRVcGRhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHVwZGF0ZShzdGF0ZTogT25Nb2RpZmllclN0YXRlIHwgbnVsbCk6IHZvaWQge1xuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN0YXNoIHByaW9yIHN0YXRlIGZvciBlbC5yZW1vdmVFdmVudExpc3RlbmVyXG4gICAgbGV0IHsgZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0aW9ucyB9ID0gc3RhdGU7XG5cbiAgICBzdGF0ZS51cGRhdGVGcm9tQXJncygpO1xuXG4gICAgaWYgKCFzdGF0ZS5zaG91bGRVcGRhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1c2UgcHJpb3Igc3RhdGUgdmFsdWVzIGZvciByZW1vdmFsXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKTtcblxuICAgIC8vIHJlYWQgdXBkYXRlZCB2YWx1ZXMgZnJvbSB0aGUgc3RhdGUgb2JqZWN0XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihzdGF0ZS5lbGVtZW50LCBzdGF0ZS5ldmVudE5hbWUsIHN0YXRlLmNhbGxiYWNrLCBzdGF0ZS5vcHRpb25zKTtcblxuICAgIHN0YXRlLnNob3VsZFVwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgZ2V0RGVzdHJveWFibGUoc3RhdGU6IE9uTW9kaWZpZXJTdGF0ZSB8IG51bGwpOiBPbk1vZGlmaWVyU3RhdGUgfCBudWxsIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0SW50ZXJuYWxNb2RpZmllck1hbmFnZXIobmV3IE9uTW9kaWZpZXJNYW5hZ2VyKCksIHt9KTtcbiJdLCJuYW1lcyI6WyJhc3NpZ24iLCJVTkRFRklORURfUkVGRVJFTkNFIiwic3ltYm9sIiwiREVCVUciLCJ3YXJuSWZTdHlsZU5vdFRydXN0ZWQiLCJTdGFjayIsInJlZ2lzdGVyRGVzdHJ1Y3RvciIsImRlc3Ryb3kiLCJmaWxsTnVsbHMiLCJ2bSIsIiRwYyIsImNyZWF0ZUNvbXB1dGVSZWYiLCJ2YWx1ZUZvclJlZiIsIkFSR1MiLCJfV2Vha1NldCIsImlzT2JqZWN0IiwiJHNwIiwiZW1wdHlBcnJheSIsIkVNUFRZX1NUUklOR19BUlJBWSIsImNyZWF0ZURlYnVnQWxpYXNSZWYiLCJkaWN0IiwiQ09OU1RBTlRfVEFHIiwiZGVjb2RlSGFuZGxlIiwiJHYwIiwiYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZCIsIl9oYXNEZXN0cm95YWJsZUNoaWxkcmVuIiwiZGVidWdUb1N0cmluZyIsImNoaWxkUmVmRm9yIiwiVFJVRV9SRUZFUkVOQ0UiLCJGQUxTRV9SRUZFUkVOQ0UiLCJ0b0Jvb2wiLCJjcmVhdGVDb25zdFJlZiIsImlzSGFuZGxlIiwiZGVjb2RlSW1tZWRpYXRlIiwiTlVMTF9SRUZFUkVOQ0UiLCJjcmVhdGVQcmltaXRpdmVSZWYiLCJyZWZlcmVuY2UiLCJpc0NvbnN0UmVmIiwiSU5JVElBTCIsInZhbGlkYXRlVGFnIiwiY29uc3VtZVRhZyIsInZhbHVlRm9yVGFnIiwiYmVnaW5UcmFja0ZyYW1lIiwiZW5kVHJhY2tGcmFtZSIsIiR0MCIsIkNVUlJFTlRfVEFHIiwiZGVzdHJveWFibGUiLCIkdDEiLCJtYW5hZ2VyIiwibWFuYWdlckhhc0NhcGFiaWxpdHkiLCJ1bndyYXBUZW1wbGF0ZSIsImhhc0ludGVybmFsQ29tcG9uZW50TWFuYWdlciIsImhhc0ludGVybmFsSGVscGVyTWFuYWdlciIsImNyZWF0ZUl0ZXJhdG9yUmVmIiwic2V0SW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyIiwiY2xlYXJFbGVtZW50Iiwic2hvdWxkQXBwbHlGaXgiLCJ0cmFjayIsInVwZGF0ZVRhZyIsIl9hIiwiRGVidWdSZW5kZXJUcmVlIiwiUnVudGltZVByb2dyYW1JbXBsIiwiJHJhIiwiJGZwIiwicnVuSW5UcmFja2luZ1RyYW5zYWN0aW9uIiwicmVzZXRUcmFja2luZyIsImRlc3Ryb3lDaGlsZHJlbiIsInVwZGF0ZVJlZiIsIm1vdmVCb3VuZHMiLCJhc3NlcnRHbG9iYWxDb250ZXh0V2FzU2V0IiwiaXNMb3dMZXZlbFJlZ2lzdGVyIiwiJHMwIiwiJHMxIiwidW53cmFwSGFuZGxlIiwiY3JlYXRlSXRlcmF0b3JJdGVtUmVmIiwiaXNFbXB0eSIsImdldFZhbHVlIiwiY3JlYXRlQ2FjaGUiLCJvd25lciIsImdldE93bmVyIiwiZ2V0SW50ZXJuYWxIZWxwZXJNYW5hZ2VyIiwiaGFzVmFsdWUiLCJpc0Rlc3Ryb3lpbmciLCJpc0Rlc3Ryb3llZCIsImhhc0Rlc3Ryb3lhYmxlIiwic2V0SW50ZXJuYWxIZWxwZXJNYW5hZ2VyIiwiYnVpbGRVbnRvdWNoYWJsZVRoaXMiLCJyZWlmeVBvc2l0aW9uYWwiLCJpc0ludm9rYWJsZVJlZiIsImRlcHJlY2F0ZSIsInJlaWZ5TmFtZWQiLCJIQVNfTkFUSVZFX1BST1hZIiwiaXNEaWN0IiwiZ2V0UGF0aCIsInNldFBhdGgiLCJjcmVhdGVVcGRhdGFibGVUYWciLCJzZXRJbnRlcm5hbE1vZGlmaWVyTWFuYWdlciJdLCJtYXBwaW5ncyI6Ijs7TUFhTSxnQkFBTjtFQUdFLDRCQUFBLE1BQUEsRUFBb0M7RUFDbEMsUUFBQSxNQUFBLEVBQVk7RUFDVixXQUFBLE1BQUEsR0FBY0EsV0FBTSxDQUFBLEVBQUEsRUFBcEIsTUFBb0IsQ0FBcEI7RUFERixLQUFBLE1BRU87RUFDTCxXQUFBLE1BQUEsR0FBQSxFQUFBO0VBQ0Q7RUFDRjs7RUFUSDs7RUFBQSxTQVdFLEdBWEYsR0FXRSxhQUFHLEdBQUgsRUFBZTtFQUNiLFdBQU8sS0FBQSxNQUFBLENBQVAsR0FBTyxDQUFQO0VBQ0QsR0FiSDs7RUFBQSxTQWVFLEdBZkYsR0FlRSxhQUFHLEdBQUgsRUFBRyxTQUFILEVBQXFDO0VBQ25DLFdBQVEsS0FBQSxNQUFBLENBQUEsR0FBQSxJ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
