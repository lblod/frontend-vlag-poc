"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderSync = renderSync;
exports.renderMain = renderMain;
exports.renderComponent = renderComponent;

var _reference = require("@glimmer/reference");

var _util = require("@glimmer/util");

var _symbols = require("./symbols");

var _append = _interopRequireDefault(require("./vm/append"));

var _scope = require("./scope");

var _environment = require("./environment");

var _env = require("@glimmer/env");

var _validator = require("@glimmer/validator");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class TemplateIteratorImpl {
  constructor(vm) {
    this.vm = vm;
  }

  next() {
    return this.vm.next();
  }

  sync() {
    if (_env.DEBUG) {
      return (0, _validator.runInTrackingTransaction)(() => this.vm.execute(), '- While rendering:');
    } else {
      return this.vm.execute();
    }
  }

}

function renderSync(env, iterator) {
  let result;
  (0, _environment.inTransaction)(env, () => result = iterator.sync());
  return result;
}

function renderMain(runtime, context, owner, self, treeBuilder, layout, dynamicScope = new _scope.DynamicScopeImpl()) {
  let handle = (0, _util.unwrapHandle)(layout.compile(context));
  let numSymbols = layout.symbolTable.symbols.length;

  let vm = _append.default.initial(runtime, context, {
    self,
    dynamicScope,
    treeBuilder,
    handle,
    numSymbols,
    owner
  });

  return new TemplateIteratorImpl(vm);
}

function renderInvocation(vm, context, owner, definition, args) {
  // Get a list of tuples of argument names and references, like
  // [['title', reference], ['name', reference]]
  const argList = Object.keys(args).map(key => [key, args[key]]);
  const blockNames = ['main', 'else', 'attrs']; // Prefix argument names with `@` symbol

  const argNames = argList.map(([name]) => `@${name}`);

  let reified = vm[_symbols.CONSTANTS].component(definition, owner);

  vm.pushFrame(); // Push blocks on to the stack, three stack values per block

  for (let i = 0; i < 3 * blockNames.length; i++) {
    vm.stack.push(null);
  }

  vm.stack.push(null); // For each argument, push its backing reference on to the stack

  argList.forEach(([, reference]) => {
    vm.stack.push(reference);
  }); // Configure VM based on blocks and args just pushed on to the stack.

  vm[_symbols.ARGS].setup(vm.stack, argNames, blockNames, 0, true);

  const compilable = reified.compilable;
  const layoutHandle = (0, _util.unwrapHandle)(compilable.compile(context));
  const invocation = {
    handle: layoutHandle,
    symbolTable: compilable.symbolTable
  }; // Needed for the Op.Main opcode: arguments, component invocation object, and
  // component definition.

  vm.stack.push(vm[_symbols.ARGS]);
  vm.stack.push(invocation);
  vm.stack.push(reified);
  return new TemplateIteratorImpl(vm);
}

function renderComponent(runtime, treeBuilder, context, owner, definition, args = {}, dynamicScope = new _scope.DynamicScopeImpl()) {
  let vm = _append.default.empty(runtime, {
    treeBuilder,
    handle: context.stdlib.main,
    dynamicScope,
    owner
  }, context);

  return renderInvocation(vm, context, owner, definition, recordToReference(args));
}

function recordToReference(record) {
  const root = (0, _reference.createConstRef)(record, 'args');
  return Object.keys(record).reduce((acc, key) => {
    acc[key] = (0, _reference.childRefFor)(root, key);
    return acc;
  }, {});
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3JlbmRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFhQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUVBLE1BQUEsb0JBQUEsQ0FBMEI7QUFDeEIsRUFBQSxXQUFBLENBQUEsRUFBQSxFQUFrQztBQUFkLFNBQUEsRUFBQSxHQUFBLEVBQUE7QUFBa0I7O0FBQ3RDLEVBQUEsSUFBSSxHQUFBO0FBQ0YsV0FBTyxLQUFBLEVBQUEsQ0FBUCxJQUFPLEVBQVA7QUFDRDs7QUFFRCxFQUFBLElBQUksR0FBQTtBQUNGLFFBQUEsVUFBQSxFQUFXO0FBQ1QsYUFBTyx5Q0FBMEIsTUFBTSxLQUFBLEVBQUEsQ0FBUCxPQUFPLEVBQWhDLEVBQVAsb0JBQU8sQ0FBUDtBQURGLEtBQUEsTUFFTztBQUNMLGFBQU8sS0FBQSxFQUFBLENBQVAsT0FBTyxFQUFQO0FBQ0Q7QUFDRjs7QUFadUI7O0FBZXBCLFNBQUEsVUFBQSxDQUFBLEdBQUEsRUFBQSxRQUFBLEVBQWlFO0FBQ3JFLE1BQUEsTUFBQTtBQUVBLGtDQUFhLEdBQWIsRUFBbUIsTUFBTyxNQUFNLEdBQUcsUUFBUSxDQUEzQyxJQUFtQyxFQUFuQztBQUVBLFNBQUEsTUFBQTtBQUNEOztBQUVLLFNBQUEsVUFBQSxDQUFBLE9BQUEsRUFBQSxPQUFBLEVBQUEsS0FBQSxFQUFBLElBQUEsRUFBQSxXQUFBLEVBQUEsTUFBQSxFQU9KLFlBQUEsR0FBNkIsSUFQekIsdUJBT3lCLEVBUHpCLEVBTytDO0FBRW5ELE1BQUksTUFBTSxHQUFHLHdCQUFhLE1BQU0sQ0FBTixPQUFBLENBQTFCLE9BQTBCLENBQWIsQ0FBYjtBQUNBLE1BQUksVUFBVSxHQUFHLE1BQU0sQ0FBTixXQUFBLENBQUEsT0FBQSxDQUFqQixNQUFBOztBQUNBLE1BQUksRUFBRSxHQUFHLGdCQUFBLE9BQUEsQ0FBQSxPQUFBLEVBQUEsT0FBQSxFQUE2QjtBQUFBLElBQUEsSUFBQTtBQUFBLElBQUEsWUFBQTtBQUFBLElBQUEsV0FBQTtBQUFBLElBQUEsTUFBQTtBQUFBLElBQUEsVUFBQTtBQU1wQyxJQUFBO0FBTm9DLEdBQTdCLENBQVQ7O0FBUUEsU0FBTyxJQUFBLG9CQUFBLENBQVAsRUFBTyxDQUFQO0FBQ0Q7O0FBRUQsU0FBQSxnQkFBQSxDQUFBLEVBQUEsRUFBQSxPQUFBLEVBQUEsS0FBQSxFQUFBLFVBQUEsRUFBQSxJQUFBLEVBS2lDO0FBRS9CO0FBQ0E7QUFDQSxRQUFNLE9BQU8sR0FBRyxNQUFNLENBQU4sSUFBQSxDQUFBLElBQUEsRUFBQSxHQUFBLENBQXVCLEdBQUQsSUFBUyxDQUFBLEdBQUEsRUFBTSxJQUFJLENBQXpELEdBQXlELENBQVYsQ0FBL0IsQ0FBaEI7QUFFQSxRQUFNLFVBQVUsR0FBRyxDQUFBLE1BQUEsRUFBQSxNQUFBLEVBTlksT0FNWixDQUFuQixDQU4rQixDQU8vQjs7QUFDQSxRQUFNLFFBQVEsR0FBRyxPQUFPLENBQVAsR0FBQSxDQUFZLENBQUMsQ0FBRCxJQUFDLENBQUQsS0FBWSxJQUFJLElBQTdDLEVBQWlCLENBQWpCOztBQUVBLE1BQUksT0FBTyxHQUFHLEVBQUUsQ0FBRixrQkFBRSxDQUFGLENBQUEsU0FBQSxDQUFBLFVBQUEsRUFBZCxLQUFjLENBQWQ7O0FBRUEsRUFBQSxFQUFFLENBWjZCLFNBWS9CLEdBWitCLENBYy9COztBQUNBLE9BQUssSUFBSSxDQUFDLEdBQVYsQ0FBQSxFQUFnQixDQUFDLEdBQUcsSUFBSSxVQUFVLENBQWxDLE1BQUEsRUFBMkMsQ0FBM0MsRUFBQSxFQUFnRDtBQUM5QyxJQUFBLEVBQUUsQ0FBRixLQUFBLENBQUEsSUFBQSxDQUFBLElBQUE7QUFDRDs7QUFFRCxFQUFBLEVBQUUsQ0FBRixLQUFBLENBQUEsSUFBQSxDQW5CK0IsSUFtQi9CLEVBbkIrQixDQXFCL0I7O0FBQ0EsRUFBQSxPQUFPLENBQVAsT0FBQSxDQUFnQixDQUFDLEdBQUQsU0FBQyxDQUFELEtBQWtCO0FBQ2hDLElBQUEsRUFBRSxDQUFGLEtBQUEsQ0FBQSxJQUFBLENBQUEsU0FBQTtBQXZCNkIsR0FzQi9CLEVBdEIrQixDQTBCL0I7O0FBQ0EsRUFBQSxFQUFFLENBQUYsYUFBRSxDQUFGLENBQUEsS0FBQSxDQUFlLEVBQUUsQ0FBakIsS0FBQSxFQUFBLFFBQUEsRUFBQSxVQUFBLEVBQUEsQ0FBQSxFQUFBLElBQUE7O0FBRUEsUUFBTSxVQUFVLEdBQ2QsT0FBTyxDQURULFVBQUE7QUFJQSxRQUFNLFlBQVksR0FBRyx3QkFBYSxVQUFVLENBQVYsT0FBQSxDQUFsQyxPQUFrQyxDQUFiLENBQXJCO0FBQ0EsUUFBTSxVQUFVLEdBQUc7QUFBRSxJQUFBLE1BQU0sRUFBUixZQUFBO0FBQXdCLElBQUEsV0FBVyxFQUFFLFVBQVUsQ0FBQztBQUFoRCxHQUFuQixDQWxDK0IsQ0FvQy9CO0FBQ0E7O0FBQ0EsRUFBQSxFQUFFLENBQUYsS0FBQSxDQUFBLElBQUEsQ0FBYyxFQUFFLENBQWhCLGFBQWdCLENBQWhCO0FBQ0EsRUFBQSxFQUFFLENBQUYsS0FBQSxDQUFBLElBQUEsQ0FBQSxVQUFBO0FBQ0EsRUFBQSxFQUFFLENBQUYsS0FBQSxDQUFBLElBQUEsQ0FBQSxPQUFBO0FBRUEsU0FBTyxJQUFBLG9CQUFBLENBQVAsRUFBTyxDQUFQO0FBQ0Q7O0FBRUssU0FBQSxlQUFBLENBQUEsT0FBQSxFQUFBLFdBQUEsRUFBQSxPQUFBLEVBQUEsS0FBQSxFQUFBLFVBQUEsRUFNSixJQUFBLEdBTkksRUFBQSxFQU9KLFlBQUEsR0FBNkIsSUFQekIsdUJBT3lCLEVBUHpCLEVBTytDO0FBRW5ELE1BQUksRUFBRSxHQUFHLGdCQUFBLEtBQUEsQ0FBQSxPQUFBLEVBRVA7QUFBQSxJQUFBLFdBQUE7QUFBZSxJQUFBLE1BQU0sRUFBRSxPQUFPLENBQVAsTUFBQSxDQUF2QixJQUFBO0FBQUEsSUFBQSxZQUFBO0FBQTBELElBQUE7QUFBMUQsR0FGTyxFQUFULE9BQVMsQ0FBVDs7QUFLQSxTQUFPLGdCQUFnQixDQUFBLEVBQUEsRUFBQSxPQUFBLEVBQUEsS0FBQSxFQUFBLFVBQUEsRUFBaUMsaUJBQWlCLENBQXpFLElBQXlFLENBQWxELENBQXZCO0FBQ0Q7O0FBRUQsU0FBQSxpQkFBQSxDQUFBLE1BQUEsRUFBMEQ7QUFDeEQsUUFBTSxJQUFJLEdBQUcsK0JBQWMsTUFBZCxFQUFiLE1BQWEsQ0FBYjtBQUVBLFNBQU8sTUFBTSxDQUFOLElBQUEsQ0FBQSxNQUFBLEVBQUEsTUFBQSxDQUEyQixDQUFBLEdBQUEsRUFBQSxHQUFBLEtBQWE7QUFDN0MsSUFBQSxHQUFHLENBQUgsR0FBRyxDQUFILEdBQVcsNEJBQVcsSUFBWCxFQUFYLEdBQVcsQ0FBWDtBQUNBLFdBQUEsR0FBQTtBQUZLLEdBQUEsRUFBUCxFQUFPLENBQVA7QUFJRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIER5bmFtaWNTY29wZSxcbiAgRW52aXJvbm1lbnQsXG4gIFJlbmRlclJlc3VsdCxcbiAgUmljaEl0ZXJhdG9yUmVzdWx0LFxuICBUZW1wbGF0ZUl0ZXJhdG9yLFxuICBSdW50aW1lQ29udGV4dCxcbiAgRWxlbWVudEJ1aWxkZXIsXG4gIENvbXBpbGFibGVQcm9ncmFtLFxuICBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCxcbiAgQ29tcG9uZW50RGVmaW5pdGlvblN0YXRlLFxuICBPd25lcixcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjaGlsZFJlZkZvciwgY3JlYXRlQ29uc3RSZWYsIFJlZmVyZW5jZSB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBleHBlY3QsIHVud3JhcEhhbmRsZSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgQVJHUywgQ09OU1RBTlRTIH0gZnJvbSAnLi9zeW1ib2xzJztcbmltcG9ydCBWTSwgeyBJbnRlcm5hbFZNIH0gZnJvbSAnLi92bS9hcHBlbmQnO1xuaW1wb3J0IHsgRHluYW1pY1Njb3BlSW1wbCB9IGZyb20gJy4vc2NvcGUnO1xuaW1wb3J0IHsgaW5UcmFuc2FjdGlvbiB9IGZyb20gJy4vZW52aXJvbm1lbnQnO1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHsgcnVuSW5UcmFja2luZ1RyYW5zYWN0aW9uIH0gZnJvbSAnQGdsaW1tZXIvdmFsaWRhdG9yJztcblxuY2xhc3MgVGVtcGxhdGVJdGVyYXRvckltcGwgaW1wbGVtZW50cyBUZW1wbGF0ZUl0ZXJhdG9yIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB2bTogSW50ZXJuYWxWTSkge31cbiAgbmV4dCgpOiBSaWNoSXRlcmF0b3JSZXN1bHQ8bnVsbCwgUmVuZGVyUmVzdWx0PiB7XG4gICAgcmV0dXJuIHRoaXMudm0ubmV4dCgpO1xuICB9XG5cbiAgc3luYygpOiBSZW5kZXJSZXN1bHQge1xuICAgIGlmIChERUJVRykge1xuICAgICAgcmV0dXJuIHJ1bkluVHJhY2tpbmdUcmFuc2FjdGlvbiEoKCkgPT4gdGhpcy52bS5leGVjdXRlKCksICctIFdoaWxlIHJlbmRlcmluZzonKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMudm0uZXhlY3V0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyU3luYyhlbnY6IEVudmlyb25tZW50LCBpdGVyYXRvcjogVGVtcGxhdGVJdGVyYXRvcik6IFJlbmRlclJlc3VsdCB7XG4gIGxldCByZXN1bHQ6IFJlbmRlclJlc3VsdDtcblxuICBpblRyYW5zYWN0aW9uKGVudiwgKCkgPT4gKHJlc3VsdCA9IGl0ZXJhdG9yLnN5bmMoKSkpO1xuXG4gIHJldHVybiByZXN1bHQhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWFpbihcbiAgcnVudGltZTogUnVudGltZUNvbnRleHQsXG4gIGNvbnRleHQ6IENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0LFxuICBvd25lcjogT3duZXIsXG4gIHNlbGY6IFJlZmVyZW5jZSxcbiAgdHJlZUJ1aWxkZXI6IEVsZW1lbnRCdWlsZGVyLFxuICBsYXlvdXQ6IENvbXBpbGFibGVQcm9ncmFtLFxuICBkeW5hbWljU2NvcGU6IER5bmFtaWNTY29wZSA9IG5ldyBEeW5hbWljU2NvcGVJbXBsKClcbik6IFRlbXBsYXRlSXRlcmF0b3Ige1xuICBsZXQgaGFuZGxlID0gdW53cmFwSGFuZGxlKGxheW91dC5jb21waWxlKGNvbnRleHQpKTtcbiAgbGV0IG51bVN5bWJvbHMgPSBsYXlvdXQuc3ltYm9sVGFibGUuc3ltYm9scy5sZW5ndGg7XG4gIGxldCB2bSA9IFZNLmluaXRpYWwocnVudGltZSwgY29udGV4dCwge1xuICAgIHNlbGYsXG4gICAgZHluYW1pY1Njb3BlLFxuICAgIHRyZWVCdWlsZGVyLFxuICAgIGhhbmRsZSxcbiAgICBudW1TeW1ib2xzLFxuICAgIG93bmVyLFxuICB9KTtcbiAgcmV0dXJuIG5ldyBUZW1wbGF0ZUl0ZXJhdG9ySW1wbCh2bSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckludm9jYXRpb24oXG4gIHZtOiBJbnRlcm5hbFZNLFxuICBjb250ZXh0OiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCxcbiAgb3duZXI6IE93bmVyLFxuICBkZWZpbml0aW9uOiBDb21wb25lbnREZWZpbml0aW9uU3RhdGUsXG4gIGFyZ3M6IFJlY29yZDxzdHJpbmcsIFJlZmVyZW5jZT5cbik6IFRlbXBsYXRlSXRlcmF0b3Ige1xuICAvLyBHZXQgYSBsaXN0IG9mIHR1cGxlcyBvZiBhcmd1bWVudCBuYW1lcyBhbmQgcmVmZXJlbmNlcywgbGlrZVxuICAvLyBbWyd0aXRsZScsIHJlZmVyZW5jZV0sIFsnbmFtZScsIHJlZmVyZW5jZV1dXG4gIGNvbnN0IGFyZ0xpc3QgPSBPYmplY3Qua2V5cyhhcmdzKS5tYXAoKGtleSkgPT4gW2tleSwgYXJnc1trZXldXSk7XG5cbiAgY29uc3QgYmxvY2tOYW1lcyA9IFsnbWFpbicsICdlbHNlJywgJ2F0dHJzJ107XG4gIC8vIFByZWZpeCBhcmd1bWVudCBuYW1lcyB3aXRoIGBAYCBzeW1ib2xcbiAgY29uc3QgYXJnTmFtZXMgPSBhcmdMaXN0Lm1hcCgoW25hbWVdKSA9PiBgQCR7bmFtZX1gKTtcblxuICBsZXQgcmVpZmllZCA9IHZtW0NPTlNUQU5UU10uY29tcG9uZW50KGRlZmluaXRpb24sIG93bmVyKTtcblxuICB2bS5wdXNoRnJhbWUoKTtcblxuICAvLyBQdXNoIGJsb2NrcyBvbiB0byB0aGUgc3RhY2ssIHRocmVlIHN0YWNrIHZhbHVlcyBwZXIgYmxvY2tcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzICogYmxvY2tOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZtLnN0YWNrLnB1c2gobnVsbCk7XG4gIH1cblxuICB2bS5zdGFjay5wdXNoKG51bGwpO1xuXG4gIC8vIEZvciBlYWNoIGFyZ3VtZW50LCBwdXNoIGl0cyBiYWNraW5nIHJlZmVyZW5jZSBvbiB0byB0aGUgc3RhY2tcbiAgYXJnTGlzdC5mb3JFYWNoKChbLCByZWZlcmVuY2VdKSA9PiB7XG4gICAgdm0uc3RhY2sucHVzaChyZWZlcmVuY2UpO1xuICB9KTtcblxuICAvLyBDb25maWd1cmUgVk0gYmFzZWQgb24gYmxvY2tzIGFuZCBhcmdzIGp1c3QgcHVzaGVkIG9uIHRvIHRoZSBzdGFjay5cbiAgdm1bQVJHU10uc2V0dXAodm0uc3RhY2ssIGFyZ05hbWVzLCBibG9ja05hbWVzLCAwLCB0cnVlKTtcblxuICBjb25zdCBjb21waWxhYmxlID0gZXhwZWN0KFxuICAgIHJlaWZpZWQuY29tcGlsYWJsZSxcbiAgICAnQlVHOiBFeHBlY3RlZCB0aGUgcm9vdCBjb21wb25lbnQgcmVuZGVyZWQgd2l0aCByZW5kZXJDb21wb25lbnQgdG8gaGF2ZSBhbiBhc3NvY2lhdGVkIHRlbXBsYXRlLCBzZXQgd2l0aCBzZXRDb21wb25lbnRUZW1wbGF0ZSdcbiAgKTtcbiAgY29uc3QgbGF5b3V0SGFuZGxlID0gdW53cmFwSGFuZGxlKGNvbXBpbGFibGUuY29tcGlsZShjb250ZXh0KSk7XG4gIGNvbnN0IGludm9jYXRpb24gPSB7IGhhbmRsZTogbGF5b3V0SGFuZGxlLCBzeW1ib2xUYWJsZTogY29tcGlsYWJsZS5zeW1ib2xUYWJsZSB9O1xuXG4gIC8vIE5lZWRlZCBmb3IgdGhlIE9wLk1haW4gb3Bjb2RlOiBhcmd1bWVudHMsIGNvbXBvbmVudCBpbnZvY2F0aW9uIG9iamVjdCwgYW5kXG4gIC8vIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICB2bS5zdGFjay5wdXNoKHZtW0FSR1NdKTtcbiAgdm0uc3RhY2sucHVzaChpbnZvY2F0aW9uKTtcbiAgdm0uc3RhY2sucHVzaChyZWlmaWVkKTtcblxuICByZXR1cm4gbmV3IFRlbXBsYXRlSXRlcmF0b3JJbXBsKHZtKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudChcbiAgcnVudGltZTogUnVudGltZUNvbnRleHQsXG4gIHRyZWVCdWlsZGVyOiBFbGVtZW50QnVpbGRlcixcbiAgY29udGV4dDogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIG93bmVyOiBPd25lcixcbiAgZGVmaW5pdGlvbjogQ29tcG9uZW50RGVmaW5pdGlvblN0YXRlLFxuICBhcmdzOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9LFxuICBkeW5hbWljU2NvcGU6IER5bmFtaWNTY29wZSA9IG5ldyBEeW5hbWljU2NvcGVJbXBsKClcbik6IFRlbXBsYXRlSXRlcmF0b3Ige1xuICBsZXQgdm0gPSBWTS5lbXB0eShcbiAgICBydW50aW1lLFxuICAgIHsgdHJlZUJ1aWxkZXIsIGhhbmRsZTogY29udGV4dC5zdGRsaWIubWFpbiwgZHluYW1pY1Njb3BlLCBvd25lciB9LFxuICAgIGNvbnRleHRcbiAgKTtcbiAgcmV0dXJuIHJlbmRlckludm9jYXRpb24odm0sIGNvbnRleHQsIG93bmVyLCBkZWZpbml0aW9uLCByZWNvcmRUb1JlZmVyZW5jZShhcmdzKSk7XG59XG5cbmZ1bmN0aW9uIHJlY29yZFRvUmVmZXJlbmNlKHJlY29yZDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiBSZWNvcmQ8c3RyaW5nLCBSZWZlcmVuY2U+IHtcbiAgY29uc3Qgcm9vdCA9IGNyZWF0ZUNvbnN0UmVmKHJlY29yZCwgJ2FyZ3MnKTtcblxuICByZXR1cm4gT2JqZWN0LmtleXMocmVjb3JkKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgYWNjW2tleV0gPSBjaGlsZFJlZkZvcihyb290LCBrZXkpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIFJlZmVyZW5jZT4pO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==