"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setDebuggerCallback = setDebuggerCallback;
exports.resetDebuggerCallback = resetDebuggerCallback;

var _reference = require("@glimmer/reference");

var _util = require("@glimmer/util");

var _opcodes = require("../../opcodes");

var _symbols2 = require("../../symbols");

function debugCallback(context, get) {
  // eslint-disable-next-line no-console
  console.info('Use `context`, and `get(<path>)` to debug this template.'); // for example...
  // eslint-disable-next-line no-unused-expressions

  context === get('this'); // eslint-disable-next-line no-debugger

  debugger;
}

let callback = debugCallback; // For testing purposes

function setDebuggerCallback(cb) {
  callback = cb;
}

function resetDebuggerCallback() {
  callback = debugCallback;
}

class ScopeInspector {
  constructor(scope, symbols, evalInfo) {
    this.scope = scope;
    this.locals = (0, _util.dict)();

    for (let i = 0; i < evalInfo.length; i++) {
      let slot = evalInfo[i];
      let name = symbols[slot - 1];
      let ref = scope.getSymbol(slot);
      this.locals[name] = ref;
    }
  }

  get(path) {
    let {
      scope,
      locals
    } = this;
    let parts = path.split('.');
    let [head, ...tail] = path.split('.');
    let evalScope = scope.getEvalScope();
    let ref;

    if (head === 'this') {
      ref = scope.getSelf();
    } else if (locals[head]) {
      ref = locals[head];
    } else if (head.indexOf('@') === 0 && evalScope[head]) {
      ref = evalScope[head];
    } else {
      ref = this.scope.getSelf();
      tail = parts;
    }

    return tail.reduce((r, part) => (0, _reference.childRefFor)(r, part), ref);
  }

}

_opcodes.APPEND_OPCODES.add(103
/* Debugger */
, (vm, {
  op1: _symbols,
  op2: _evalInfo
}) => {
  let symbols = vm[_symbols2.CONSTANTS].getArray(_symbols);

  let evalInfo = vm[_symbols2.CONSTANTS].getArray((0, _util.decodeHandle)(_evalInfo));

  let inspector = new ScopeInspector(vm.scope(), symbols, evalInfo);
  callback((0, _reference.valueForRef)(vm.getSelf()), path => (0, _reference.valueForRef)(inspector.get(path)));
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBpbGVkL29wY29kZXMvZGVidWdnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFNQSxTQUFBLGFBQUEsQ0FBQSxPQUFBLEVBQUEsR0FBQSxFQUFzRDtBQUNwRDtBQUNBLEVBQUEsT0FBTyxDQUFQLElBQUEsQ0FGb0QsMERBRXBELEVBRm9ELENBSXBEO0FBQ0E7O0FBQ0EsRUFBQSxPQUFPLEtBQUssR0FBRyxDQU5xQyxNQU1yQyxDQUFmLENBTm9ELENBUXBEOztBQUNBO0FBQ0Q7O0FBRUQsSUFBSSxRQUFRLEdBQVosYUFBQSxDLENBRUE7O0FBQ00sU0FBQSxtQkFBQSxDQUFBLEVBQUEsRUFBK0M7QUFDbkQsRUFBQSxRQUFRLEdBQVIsRUFBQTtBQUNEOztBQUVLLFNBQUEscUJBQUEsR0FBK0I7QUFDbkMsRUFBQSxRQUFRLEdBQVIsYUFBQTtBQUNEOztBQUVELE1BQUEsY0FBQSxDQUFvQjtBQUdsQixFQUFBLFdBQUEsQ0FBQSxLQUFBLEVBQUEsT0FBQSxFQUFBLFFBQUEsRUFBdUU7QUFBbkQsU0FBQSxLQUFBLEdBQUEsS0FBQTtBQUZaLFNBQUEsTUFBQSxHQUFBLGlCQUFBOztBQUdOLFNBQUssSUFBSSxDQUFDLEdBQVYsQ0FBQSxFQUFnQixDQUFDLEdBQUcsUUFBUSxDQUE1QixNQUFBLEVBQXFDLENBQXJDLEVBQUEsRUFBMEM7QUFDeEMsVUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFuQixDQUFtQixDQUFuQjtBQUNBLFVBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLEdBQXZCLENBQWtCLENBQWxCO0FBQ0EsVUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFMLFNBQUEsQ0FBVixJQUFVLENBQVY7QUFDQSxXQUFBLE1BQUEsQ0FBQSxJQUFBLElBQUEsR0FBQTtBQUNEO0FBQ0Y7O0FBRUQsRUFBQSxHQUFHLENBQUEsSUFBQSxFQUFhO0FBQ2QsUUFBSTtBQUFBLE1BQUEsS0FBQTtBQUFTLE1BQUE7QUFBVCxRQUFKLElBQUE7QUFDQSxRQUFJLEtBQUssR0FBRyxJQUFJLENBQUosS0FBQSxDQUFaLEdBQVksQ0FBWjtBQUNBLFFBQUksQ0FBQSxJQUFBLEVBQU8sR0FBUCxJQUFBLElBQWtCLElBQUksQ0FBSixLQUFBLENBQXRCLEdBQXNCLENBQXRCO0FBRUEsUUFBSSxTQUFTLEdBQUcsS0FBSyxDQUFyQixZQUFnQixFQUFoQjtBQUNBLFFBQUEsR0FBQTs7QUFFQSxRQUFJLElBQUksS0FBUixNQUFBLEVBQXFCO0FBQ25CLE1BQUEsR0FBRyxHQUFHLEtBQUssQ0FBWCxPQUFNLEVBQU47QUFERixLQUFBLE1BRU8sSUFBSSxNQUFNLENBQVYsSUFBVSxDQUFWLEVBQWtCO0FBQ3ZCLE1BQUEsR0FBRyxHQUFHLE1BQU0sQ0FBWixJQUFZLENBQVo7QUFESyxLQUFBLE1BRUEsSUFBSSxJQUFJLENBQUosT0FBQSxDQUFBLEdBQUEsTUFBQSxDQUFBLElBQTJCLFNBQVMsQ0FBeEMsSUFBd0MsQ0FBeEMsRUFBZ0Q7QUFDckQsTUFBQSxHQUFHLEdBQUcsU0FBUyxDQUFmLElBQWUsQ0FBZjtBQURLLEtBQUEsTUFFQTtBQUNMLE1BQUEsR0FBRyxHQUFHLEtBQUEsS0FBQSxDQUFOLE9BQU0sRUFBTjtBQUNBLE1BQUEsSUFBSSxHQUFKLEtBQUE7QUFDRDs7QUFFRCxXQUFPLElBQUksQ0FBSixNQUFBLENBQVksQ0FBQSxDQUFBLEVBQUEsSUFBQSxLQUFhLDRCQUFXLENBQVgsRUFBekIsSUFBeUIsQ0FBekIsRUFBUCxHQUFPLENBQVA7QUFDRDs7QUFoQ2lCOztBQW1DcEIsd0JBQUEsR0FBQSxDQUFrQjtBQUFBO0FBQWxCLEVBQWdDLENBQUEsRUFBQSxFQUFLO0FBQUUsRUFBQSxHQUFHLEVBQUwsUUFBQTtBQUFpQixFQUFBLEdBQUcsRUFBRTtBQUF0QixDQUFMLEtBQTBDO0FBQ3hFLE1BQUksT0FBTyxHQUFHLEVBQUUsQ0FBRixtQkFBRSxDQUFGLENBQUEsUUFBQSxDQUFkLFFBQWMsQ0FBZDs7QUFDQSxNQUFJLFFBQVEsR0FBRyxFQUFFLENBQUYsbUJBQUUsQ0FBRixDQUFBLFFBQUEsQ0FBK0Isd0JBQTlDLFNBQThDLENBQS9CLENBQWY7O0FBQ0EsTUFBSSxTQUFTLEdBQUcsSUFBQSxjQUFBLENBQW1CLEVBQUUsQ0FBckIsS0FBbUIsRUFBbkIsRUFBQSxPQUFBLEVBQWhCLFFBQWdCLENBQWhCO0FBQ0EsRUFBQSxRQUFRLENBQUMsNEJBQVksRUFBRSxDQUFmLE9BQWEsRUFBWixDQUFELEVBQTZCLElBQUQsSUFBVSw0QkFBWSxTQUFTLENBQVQsR0FBQSxDQUExRCxJQUEwRCxDQUFaLENBQXRDLENBQVI7QUFKRixDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT3AsIFNjb3BlIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBSZWZlcmVuY2UsIGNoaWxkUmVmRm9yLCB2YWx1ZUZvclJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBkaWN0LCBkZWNvZGVIYW5kbGUgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IEFQUEVORF9PUENPREVTIH0gZnJvbSAnLi4vLi4vb3Bjb2Rlcyc7XG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tICcuLi8uLi9zeW1ib2xzJztcblxuZXhwb3J0IHR5cGUgRGVidWdHZXQgPSAocGF0aDogc3RyaW5nKSA9PiB1bmtub3duO1xuXG5leHBvcnQgdHlwZSBEZWJ1Z0NhbGxiYWNrID0gKGNvbnRleHQ6IHVua25vd24sIGdldDogRGVidWdHZXQpID0+IHZvaWQ7XG5cbmZ1bmN0aW9uIGRlYnVnQ2FsbGJhY2soY29udGV4dDogdW5rbm93biwgZ2V0OiBEZWJ1Z0dldCk6IHZvaWQge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLmluZm8oJ1VzZSBgY29udGV4dGAsIGFuZCBgZ2V0KDxwYXRoPilgIHRvIGRlYnVnIHRoaXMgdGVtcGxhdGUuJyk7XG5cbiAgLy8gZm9yIGV4YW1wbGUuLi5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICBjb250ZXh0ID09PSBnZXQoJ3RoaXMnKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZGVidWdnZXJcbiAgZGVidWdnZXI7XG59XG5cbmxldCBjYWxsYmFjayA9IGRlYnVnQ2FsbGJhY2s7XG5cbi8vIEZvciB0ZXN0aW5nIHB1cnBvc2VzXG5leHBvcnQgZnVuY3Rpb24gc2V0RGVidWdnZXJDYWxsYmFjayhjYjogRGVidWdDYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXREZWJ1Z2dlckNhbGxiYWNrKCkge1xuICBjYWxsYmFjayA9IGRlYnVnQ2FsbGJhY2s7XG59XG5cbmNsYXNzIFNjb3BlSW5zcGVjdG9yIHtcbiAgcHJpdmF0ZSBsb2NhbHMgPSBkaWN0PFJlZmVyZW5jZT4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNjb3BlOiBTY29wZSwgc3ltYm9sczogc3RyaW5nW10sIGV2YWxJbmZvOiBudW1iZXJbXSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZhbEluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzbG90ID0gZXZhbEluZm9baV07XG4gICAgICBsZXQgbmFtZSA9IHN5bWJvbHNbc2xvdCAtIDFdO1xuICAgICAgbGV0IHJlZiA9IHNjb3BlLmdldFN5bWJvbChzbG90KTtcbiAgICAgIHRoaXMubG9jYWxzW25hbWVdID0gcmVmO1xuICAgIH1cbiAgfVxuXG4gIGdldChwYXRoOiBzdHJpbmcpOiBSZWZlcmVuY2Uge1xuICAgIGxldCB7IHNjb3BlLCBsb2NhbHMgfSA9IHRoaXM7XG4gICAgbGV0IHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIGxldCBbaGVhZCwgLi4udGFpbF0gPSBwYXRoLnNwbGl0KCcuJyk7XG5cbiAgICBsZXQgZXZhbFNjb3BlID0gc2NvcGUuZ2V0RXZhbFNjb3BlKCkhO1xuICAgIGxldCByZWY6IFJlZmVyZW5jZTtcblxuICAgIGlmIChoZWFkID09PSAndGhpcycpIHtcbiAgICAgIHJlZiA9IHNjb3BlLmdldFNlbGYoKTtcbiAgICB9IGVsc2UgaWYgKGxvY2Fsc1toZWFkXSkge1xuICAgICAgcmVmID0gbG9jYWxzW2hlYWRdO1xuICAgIH0gZWxzZSBpZiAoaGVhZC5pbmRleE9mKCdAJykgPT09IDAgJiYgZXZhbFNjb3BlW2hlYWRdKSB7XG4gICAgICByZWYgPSBldmFsU2NvcGVbaGVhZF0gYXMgUmVmZXJlbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYgPSB0aGlzLnNjb3BlLmdldFNlbGYoKTtcbiAgICAgIHRhaWwgPSBwYXJ0cztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFpbC5yZWR1Y2UoKHIsIHBhcnQpID0+IGNoaWxkUmVmRm9yKHIsIHBhcnQpLCByZWYpO1xuICB9XG59XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5EZWJ1Z2dlciwgKHZtLCB7IG9wMTogX3N5bWJvbHMsIG9wMjogX2V2YWxJbmZvIH0pID0+IHtcbiAgbGV0IHN5bWJvbHMgPSB2bVtDT05TVEFOVFNdLmdldEFycmF5PHN0cmluZz4oX3N5bWJvbHMpO1xuICBsZXQgZXZhbEluZm8gPSB2bVtDT05TVEFOVFNdLmdldEFycmF5PG51bWJlcj4oZGVjb2RlSGFuZGxlKF9ldmFsSW5mbykpO1xuICBsZXQgaW5zcGVjdG9yID0gbmV3IFNjb3BlSW5zcGVjdG9yKHZtLnNjb3BlKCksIHN5bWJvbHMsIGV2YWxJbmZvKTtcbiAgY2FsbGJhY2sodmFsdWVGb3JSZWYodm0uZ2V0U2VsZigpKSwgKHBhdGgpID0+IHZhbHVlRm9yUmVmKGluc3BlY3Rvci5nZXQocGF0aCkpKTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==