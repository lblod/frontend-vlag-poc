"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _reference = require("@glimmer/reference");

var _runtime = require("@glimmer/runtime");

var _globalContext = require("@glimmer/global-context");

var _util = require("@glimmer/util");

var _internalHelper = require("./internal-helper");

var _env = require("@glimmer/env");

let wrapHashProxy;

if (_env.DEBUG) {
  wrapHashProxy = hash => {
    return new Proxy(hash, {
      set(target, key, value) {
        (0, _globalContext.deprecate)(`You set the '${String(key)}' property on a {{hash}} object. Setting properties on objects generated by {{hash}} is deprecated. Please update to use an object created with a tracked property or getter, or with a custom helper.`, false, {
          id: 'setting-on-hash'
        });
        target[key] = value;
        return true;
      }

    });
  };
}
/**
   Use the `{{hash}}` helper to create a hash to pass as an option to your
   components. This is specially useful for contextual components where you can
   just yield a hash:

   ```handlebars
   {{yield (hash
      name='Sarah'
      title=office
   )}}
   ```

   Would result in an object such as:

   ```js
   { name: 'Sarah', title: this.get('office') }
   ```

   Where the `title` is bound to updates of the `office` property.

   Note that the hash is an empty object with no prototype chain, therefore
   common methods like `toString` are not available in the resulting hash.
   If you need to use such a method, you can use the `call` or `apply`
   approach:

   ```js
   function toString(obj) {
     return Object.prototype.toString.apply(obj);
   }
   ```

   @method hash
   @param {Object} options
   @return {Object} Hash
   @public
 */


var _default = (0, _internalHelper.internalHelper)(({
  named
}) => {
  let ref = (0, _reference.createComputeRef)(() => {
    let hash = (0, _runtime.reifyNamed)(named);

    if (_env.DEBUG && _util.HAS_NATIVE_PROXY) {
      hash = wrapHashProxy(hash);
    }

    return hash;
  }, null, 'hash'); // Setup the children so that templates can bypass getting the value of
  // the reference and treat children lazily

  let children = new Map();

  for (let name in named) {
    children.set(name, named[name]);
  }

  ref.children = children;
  return ref;
});

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2hlbHBlcnMvaGFzaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUEsSUFBQSxhQUFBOztBQUVBLElBQUEsVUFBQSxFQUFXO0FBQ1QsRUFBQSxhQUFhLEdBQUksSUFBRCxJQUFrQztBQUNoRCxXQUFPLElBQUEsS0FBQSxDQUFBLElBQUEsRUFBZ0I7QUFDckIsTUFBQSxHQUFHLENBQUEsTUFBQSxFQUFBLEdBQUEsRUFBQSxLQUFBLEVBQW1CO0FBQ3BCLHNDQUNFLGdCQUFnQixNQUFNLENBQUEsR0FBQSxDQURmLHdNQUFULEVBQVMsS0FBVCxFQUtFO0FBQUUsVUFBQSxFQUFFLEVBQUU7QUFBTixTQUxGO0FBUUEsUUFBQSxNQUFNLENBQU4sR0FBTSxDQUFOLEdBQUEsS0FBQTtBQUVBLGVBQUEsSUFBQTtBQUNEOztBQWJvQixLQUFoQixDQUFQO0FBREYsR0FBQTtBQWlCRDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQW9DZSxvQ0FDYixDQUFDO0FBQUUsRUFBQTtBQUFGLENBQUQsS0FBMkQ7QUFDekQsTUFBSSxHQUFHLEdBQUcsaUNBQ1IsTUFBSztBQUNILFFBQUksSUFBSSxHQUFHLHlCQUFYLEtBQVcsQ0FBWDs7QUFFQSxRQUFJLGNBQUosc0JBQUEsRUFBK0I7QUFDN0IsTUFBQSxJQUFJLEdBQUcsYUFBYSxDQUFwQixJQUFvQixDQUFwQjtBQUNEOztBQUVELFdBQUEsSUFBQTtBQVJzQixHQUFoQixFQUFnQixJQUFoQixFQUQrQyxNQUMvQyxDQUFWLENBRHlELENBZXpEO0FBQ0E7O0FBQ0EsTUFBSSxRQUFRLEdBQUcsSUFBZixHQUFlLEVBQWY7O0FBRUEsT0FBSyxJQUFMLElBQUEsSUFBQSxLQUFBLEVBQXdCO0FBQ3RCLElBQUEsUUFBUSxDQUFSLEdBQUEsQ0FBQSxJQUFBLEVBQW1CLEtBQUssQ0FBeEIsSUFBd0IsQ0FBeEI7QUFDRDs7QUFFRCxFQUFBLEdBQUcsQ0FBSCxRQUFBLEdBQUEsUUFBQTtBQUVBLFNBQUEsR0FBQTtBQTFCSixDQUFlLEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDYXB0dXJlZEFyZ3VtZW50cywgRGljdCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgY3JlYXRlQ29tcHV0ZVJlZiwgUmVmZXJlbmNlIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IHJlaWZ5TmFtZWQgfSBmcm9tICdAZ2xpbW1lci9ydW50aW1lJztcbmltcG9ydCB7IGRlcHJlY2F0ZSB9IGZyb20gJ0BnbGltbWVyL2dsb2JhbC1jb250ZXh0JztcbmltcG9ydCB7IEhBU19OQVRJVkVfUFJPWFkgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IGludGVybmFsSGVscGVyIH0gZnJvbSAnLi9pbnRlcm5hbC1oZWxwZXInO1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuXG5sZXQgd3JhcEhhc2hQcm94eTogKGhhc2g6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSA9PiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcblxuaWYgKERFQlVHKSB7XG4gIHdyYXBIYXNoUHJveHkgPSAoaGFzaDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pID0+IHtcbiAgICByZXR1cm4gbmV3IFByb3h5KGhhc2gsIHtcbiAgICAgIHNldCh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgZGVwcmVjYXRlKFxuICAgICAgICAgIGBZb3Ugc2V0IHRoZSAnJHtTdHJpbmcoXG4gICAgICAgICAgICBrZXlcbiAgICAgICAgICApfScgcHJvcGVydHkgb24gYSB7e2hhc2h9fSBvYmplY3QuIFNldHRpbmcgcHJvcGVydGllcyBvbiBvYmplY3RzIGdlbmVyYXRlZCBieSB7e2hhc2h9fSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXBkYXRlIHRvIHVzZSBhbiBvYmplY3QgY3JlYXRlZCB3aXRoIGEgdHJhY2tlZCBwcm9wZXJ0eSBvciBnZXR0ZXIsIG9yIHdpdGggYSBjdXN0b20gaGVscGVyLmAsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgeyBpZDogJ3NldHRpbmctb24taGFzaCcgfVxuICAgICAgICApO1xuXG4gICAgICAgIHRhcmdldFtrZXkgYXMgc3RyaW5nXSA9IHZhbHVlO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gICBVc2UgdGhlIGB7e2hhc2h9fWAgaGVscGVyIHRvIGNyZWF0ZSBhIGhhc2ggdG8gcGFzcyBhcyBhbiBvcHRpb24gdG8geW91clxuICAgY29tcG9uZW50cy4gVGhpcyBpcyBzcGVjaWFsbHkgdXNlZnVsIGZvciBjb250ZXh0dWFsIGNvbXBvbmVudHMgd2hlcmUgeW91IGNhblxuICAganVzdCB5aWVsZCBhIGhhc2g6XG5cbiAgIGBgYGhhbmRsZWJhcnNcbiAgIHt7eWllbGQgKGhhc2hcbiAgICAgIG5hbWU9J1NhcmFoJ1xuICAgICAgdGl0bGU9b2ZmaWNlXG4gICApfX1cbiAgIGBgYFxuXG4gICBXb3VsZCByZXN1bHQgaW4gYW4gb2JqZWN0IHN1Y2ggYXM6XG5cbiAgIGBgYGpzXG4gICB7IG5hbWU6ICdTYXJhaCcsIHRpdGxlOiB0aGlzLmdldCgnb2ZmaWNlJykgfVxuICAgYGBgXG5cbiAgIFdoZXJlIHRoZSBgdGl0bGVgIGlzIGJvdW5kIHRvIHVwZGF0ZXMgb2YgdGhlIGBvZmZpY2VgIHByb3BlcnR5LlxuXG4gICBOb3RlIHRoYXQgdGhlIGhhc2ggaXMgYW4gZW1wdHkgb2JqZWN0IHdpdGggbm8gcHJvdG90eXBlIGNoYWluLCB0aGVyZWZvcmVcbiAgIGNvbW1vbiBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBhcmUgbm90IGF2YWlsYWJsZSBpbiB0aGUgcmVzdWx0aW5nIGhhc2guXG4gICBJZiB5b3UgbmVlZCB0byB1c2Ugc3VjaCBhIG1ldGhvZCwgeW91IGNhbiB1c2UgdGhlIGBjYWxsYCBvciBgYXBwbHlgXG4gICBhcHByb2FjaDpcblxuICAgYGBganNcbiAgIGZ1bmN0aW9uIHRvU3RyaW5nKG9iaikge1xuICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShvYmopO1xuICAgfVxuICAgYGBgXG5cbiAgIEBtZXRob2QgaGFzaFxuICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgIEByZXR1cm4ge09iamVjdH0gSGFzaFxuICAgQHB1YmxpY1xuICovXG5leHBvcnQgZGVmYXVsdCBpbnRlcm5hbEhlbHBlcihcbiAgKHsgbmFtZWQgfTogQ2FwdHVyZWRBcmd1bWVudHMpOiBSZWZlcmVuY2U8RGljdDx1bmtub3duPj4gPT4ge1xuICAgIGxldCByZWYgPSBjcmVhdGVDb21wdXRlUmVmKFxuICAgICAgKCkgPT4ge1xuICAgICAgICBsZXQgaGFzaCA9IHJlaWZ5TmFtZWQobmFtZWQpO1xuXG4gICAgICAgIGlmIChERUJVRyAmJiBIQVNfTkFUSVZFX1BST1hZKSB7XG4gICAgICAgICAgaGFzaCA9IHdyYXBIYXNoUHJveHkoaGFzaCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgIH0sXG4gICAgICBudWxsLFxuICAgICAgJ2hhc2gnXG4gICAgKTtcblxuICAgIC8vIFNldHVwIHRoZSBjaGlsZHJlbiBzbyB0aGF0IHRlbXBsYXRlcyBjYW4gYnlwYXNzIGdldHRpbmcgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIHJlZmVyZW5jZSBhbmQgdHJlYXQgY2hpbGRyZW4gbGF6aWx5XG4gICAgbGV0IGNoaWxkcmVuID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yIChsZXQgbmFtZSBpbiBuYW1lZCkge1xuICAgICAgY2hpbGRyZW4uc2V0KG5hbWUsIG5hbWVkW25hbWVdKTtcbiAgICB9XG5cbiAgICByZWYuY2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgIHJldHVybiByZWY7XG4gIH1cbik7XG4iXSwic291cmNlUm9vdCI6IiJ9