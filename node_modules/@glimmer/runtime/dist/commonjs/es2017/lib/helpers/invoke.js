"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.invokeHelper = invokeHelper;

var _env = require("@glimmer/env");

var _validator = require("@glimmer/validator");

var _util = require("@glimmer/util");

var _manager = require("@glimmer/manager");

var _arguments = require("../vm/arguments");

var _owner = require("@glimmer/owner");

var _destroyable = require("@glimmer/destroyable");

let ARGS_CACHES = _env.DEBUG ? new WeakMap() : undefined;

function getArgs(proxy) {
  return (0, _validator.getValue)(_env.DEBUG ? ARGS_CACHES.get(proxy) : proxy.argsCache);
}

class SimpleArgsProxy {
  constructor(context, computeArgs = () => _arguments.EMPTY_ARGS) {
    let argsCache = (0, _validator.createCache)(() => computeArgs(context));

    if (_env.DEBUG) {
      ARGS_CACHES.set(this, argsCache);
      Object.freeze(this);
    } else {
      this.argsCache = argsCache;
    }
  }

  get named() {
    return getArgs(this).named || _arguments.EMPTY_NAMED;
  }

  get positional() {
    return getArgs(this).positional || _arguments.EMPTY_POSITIONAL;
  }

} ////////////


function invokeHelper(context, definition, computeArgs) {
  if (_env.DEBUG && (typeof context !== 'object' || context === null)) {
    throw new Error(`Expected a context object to be passed as the first parameter to invokeHelper, got ${context}`);
  }

  const owner = (0, _owner.getOwner)(context);
  const internalManager = (0, _manager.getInternalHelperManager)(definition); // TODO: figure out why assert isn't using the TS assert thing

  if (_env.DEBUG && !internalManager) {
    throw new Error(`Expected a helper definition to be passed as the second parameter to invokeHelper, but no helper manager was found. The definition value that was passed was \`${(0, _util.debugToString)(definition)}\`. Did you use setHelperManager to associate a helper manager with this value?`);
  }

  if (_env.DEBUG && typeof internalManager === 'function') {
    throw new Error('Found a helper manager, but it was an internal built-in helper manager. `invokeHelper` does not support internal helpers yet.');
  }

  const manager = internalManager.getDelegateFor(owner);
  let args = new SimpleArgsProxy(context, computeArgs);
  let bucket = manager.createHelper(definition, args);
  let cache;

  if ((0, _manager.hasValue)(manager)) {
    cache = (0, _validator.createCache)(() => {
      if (_env.DEBUG && ((0, _destroyable.isDestroying)(cache) || (0, _destroyable.isDestroyed)(cache))) {
        throw new Error(`You attempted to get the value of a helper after the helper was destroyed, which is not allowed`);
      }

      return manager.getValue(bucket);
    });
    (0, _destroyable.associateDestroyableChild)(context, cache);
  } else {
    throw new Error('TODO: unreachable, to be implemented with hasScheduledEffect');
  }

  if ((0, _manager.hasDestroyable)(manager)) {
    let destroyable = manager.getDestroyable(bucket);
    (0, _destroyable.associateDestroyableChild)(cache, destroyable);
  }

  return cache;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2hlbHBlcnMvaW52b2tlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFFQSxJQUFJLFdBQVcsR0FBRyxhQUFRLElBQUgsT0FBRyxFQUFSLEdBQWxCLFNBQUE7O0FBRUEsU0FBQSxPQUFBLENBQUEsS0FBQSxFQUF1QztBQUNyQyxTQUFPLHlCQUFTLGFBQVEsV0FBWSxDQUFaLEdBQUEsQ0FBSCxLQUFHLENBQVIsR0FBbUMsS0FBSyxDQUF4RCxTQUFPLENBQVA7QUFDRDs7QUFFRCxNQUFBLGVBQUEsQ0FBcUI7QUFHbkIsRUFBQSxXQUFBLENBQUEsT0FBQSxFQUVFLFdBQUEsR0FBdUQsTUFGekQscUJBQUEsRUFFeUU7QUFFdkUsUUFBSSxTQUFTLEdBQUcsNEJBQVksTUFBTSxXQUFXLENBQTdDLE9BQTZDLENBQTdCLENBQWhCOztBQUVBLFFBQUEsVUFBQSxFQUFXO0FBQ1QsTUFBQSxXQUFZLENBQVosR0FBQSxDQUFBLElBQUEsRUFBQSxTQUFBO0FBQ0EsTUFBQSxNQUFNLENBQU4sTUFBQSxDQUFBLElBQUE7QUFGRixLQUFBLE1BR087QUFDTCxXQUFBLFNBQUEsR0FBQSxTQUFBO0FBQ0Q7QUFDRjs7QUFFRCxNQUFBLEtBQUEsR0FBUztBQUNQLFdBQU8sT0FBTyxDQUFQLElBQU8sQ0FBUCxDQUFBLEtBQUEsSUFBUCxzQkFBQTtBQUNEOztBQUVELE1BQUEsVUFBQSxHQUFjO0FBQ1osV0FBTyxPQUFPLENBQVAsSUFBTyxDQUFQLENBQUEsVUFBQSxJQUFQLDJCQUFBO0FBQ0Q7O0FBdkJrQixDLENBMEJyQjs7O0FBRU0sU0FBQSxZQUFBLENBQUEsT0FBQSxFQUFBLFVBQUEsRUFBQSxXQUFBLEVBR2lEO0FBRXJELE1BQUksZUFBVSxPQUFBLE9BQUEsS0FBQSxRQUFBLElBQStCLE9BQU8sS0FBcEQsSUFBSSxDQUFKLEVBQWdFO0FBQzlELFVBQU0sSUFBQSxLQUFBLENBQ0osc0ZBQXNGLE9BRHhGLEVBQU0sQ0FBTjtBQUdEOztBQUVELFFBQU0sS0FBSyxHQUFHLHFCQUFkLE9BQWMsQ0FBZDtBQUNBLFFBQU0sZUFBZSxHQUFHLHVDQVQ2QixVQVM3QixDQUF4QixDQVRxRCxDQVdyRDs7QUFDQSxNQUFJLGNBQVMsQ0FBYixlQUFBLEVBQStCO0FBQzdCLFVBQU0sSUFBQSxLQUFBLENBQ0osa0tBQWtLLHlCQUFjLFVBQWQsQ0FEcEssaUZBQU0sQ0FBTjtBQUtEOztBQUVELE1BQUksY0FBUyxPQUFBLGVBQUEsS0FBYixVQUFBLEVBQW9EO0FBQ2xELFVBQU0sSUFBQSxLQUFBLENBQU4sK0hBQU0sQ0FBTjtBQUdEOztBQUVELFFBQU0sT0FBTyxHQUFJLGVBQWlELENBQWpELGNBQUEsQ0FBakIsS0FBaUIsQ0FBakI7QUFDQSxNQUFJLElBQUksR0FBRyxJQUFBLGVBQUEsQ0FBQSxPQUFBLEVBQVgsV0FBVyxDQUFYO0FBQ0EsTUFBSSxNQUFNLEdBQUcsT0FBTyxDQUFQLFlBQUEsQ0FBQSxVQUFBLEVBQWIsSUFBYSxDQUFiO0FBRUEsTUFBQSxLQUFBOztBQUVBLE1BQUksdUJBQUosT0FBSSxDQUFKLEVBQXVCO0FBQ3JCLElBQUEsS0FBSyxHQUFHLDRCQUFZLE1BQUs7QUFDdkIsVUFBSSxlQUFVLCtCQUFBLEtBQUEsS0FBdUIsOEJBQXJDLEtBQXFDLENBQWpDLENBQUosRUFBMEQ7QUFDeEQsY0FBTSxJQUFBLEtBQUEsQ0FBTixpR0FBTSxDQUFOO0FBR0Q7O0FBRUQsYUFBTyxPQUFPLENBQVAsUUFBQSxDQUFQLE1BQU8sQ0FBUDtBQVBGLEtBQVEsQ0FBUjtBQVVBLGdEQUF5QixPQUF6QixFQUFBLEtBQUE7QUFYRixHQUFBLE1BWU87QUFDTCxVQUFNLElBQUEsS0FBQSxDQUFOLDhEQUFNLENBQU47QUFDRDs7QUFFRCxNQUFJLDZCQUFKLE9BQUksQ0FBSixFQUE2QjtBQUMzQixRQUFJLFdBQVcsR0FBRyxPQUFPLENBQVAsY0FBQSxDQUFsQixNQUFrQixDQUFsQjtBQUVBLGdEQUF5QixLQUF6QixFQUFBLFdBQUE7QUFDRDs7QUFFRCxTQUFBLEtBQUE7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IENhY2hlLCBjcmVhdGVDYWNoZSwgZ2V0VmFsdWUgfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHsgQXJndW1lbnRzLCBJbnRlcm5hbEhlbHBlck1hbmFnZXIgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGRlYnVnVG9TdHJpbmcgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IGdldEludGVybmFsSGVscGVyTWFuYWdlciwgaGFzRGVzdHJveWFibGUsIGhhc1ZhbHVlIH0gZnJvbSAnQGdsaW1tZXIvbWFuYWdlcic7XG5cbmltcG9ydCB7IEVNUFRZX0FSR1MsIEVNUFRZX05BTUVELCBFTVBUWV9QT1NJVElPTkFMIH0gZnJvbSAnLi4vdm0vYXJndW1lbnRzJztcbmltcG9ydCB7IGdldE93bmVyIH0gZnJvbSAnQGdsaW1tZXIvb3duZXInO1xuaW1wb3J0IHsgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZCwgaXNEZXN0cm95ZWQsIGlzRGVzdHJveWluZyB9IGZyb20gJ0BnbGltbWVyL2Rlc3Ryb3lhYmxlJztcblxubGV0IEFSR1NfQ0FDSEVTID0gREVCVUcgPyBuZXcgV2Vha01hcDxTaW1wbGVBcmdzUHJveHksIENhY2hlPFBhcnRpYWw8QXJndW1lbnRzPj4+KCkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGdldEFyZ3MocHJveHk6IFNpbXBsZUFyZ3NQcm94eSk6IFBhcnRpYWw8QXJndW1lbnRzPiB7XG4gIHJldHVybiBnZXRWYWx1ZShERUJVRyA/IEFSR1NfQ0FDSEVTIS5nZXQocHJveHkpISA6IHByb3h5LmFyZ3NDYWNoZSEpITtcbn1cblxuY2xhc3MgU2ltcGxlQXJnc1Byb3h5IHtcbiAgYXJnc0NhY2hlPzogQ2FjaGU8UGFydGlhbDxBcmd1bWVudHM+PjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBjb250ZXh0OiBvYmplY3QsXG4gICAgY29tcHV0ZUFyZ3M6IChjb250ZXh0OiBvYmplY3QpID0+IFBhcnRpYWw8QXJndW1lbnRzPiA9ICgpID0+IEVNUFRZX0FSR1NcbiAgKSB7XG4gICAgbGV0IGFyZ3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCgpID0+IGNvbXB1dGVBcmdzKGNvbnRleHQpKTtcblxuICAgIGlmIChERUJVRykge1xuICAgICAgQVJHU19DQUNIRVMhLnNldCh0aGlzLCBhcmdzQ2FjaGUpO1xuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcmdzQ2FjaGUgPSBhcmdzQ2FjaGU7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG5hbWVkKCkge1xuICAgIHJldHVybiBnZXRBcmdzKHRoaXMpLm5hbWVkIHx8IEVNUFRZX05BTUVEO1xuICB9XG5cbiAgZ2V0IHBvc2l0aW9uYWwoKSB7XG4gICAgcmV0dXJuIGdldEFyZ3ModGhpcykucG9zaXRpb25hbCB8fCBFTVBUWV9QT1NJVElPTkFMO1xuICB9XG59XG5cbi8vLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlSGVscGVyKFxuICBjb250ZXh0OiBvYmplY3QsXG4gIGRlZmluaXRpb246IG9iamVjdCxcbiAgY29tcHV0ZUFyZ3M/OiAoY29udGV4dDogb2JqZWN0KSA9PiBQYXJ0aWFsPEFyZ3VtZW50cz5cbik6IENhY2hlPHVua25vd24+IHtcbiAgaWYgKERFQlVHICYmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcgfHwgY29udGV4dCA9PT0gbnVsbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBjb250ZXh0IG9iamVjdCB0byBiZSBwYXNzZWQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBpbnZva2VIZWxwZXIsIGdvdCAke2NvbnRleHR9YFxuICAgICk7XG4gIH1cblxuICBjb25zdCBvd25lciA9IGdldE93bmVyKGNvbnRleHQpO1xuICBjb25zdCBpbnRlcm5hbE1hbmFnZXIgPSBnZXRJbnRlcm5hbEhlbHBlck1hbmFnZXIoZGVmaW5pdGlvbikhO1xuXG4gIC8vIFRPRE86IGZpZ3VyZSBvdXQgd2h5IGFzc2VydCBpc24ndCB1c2luZyB0aGUgVFMgYXNzZXJ0IHRoaW5nXG4gIGlmIChERUJVRyAmJiAhaW50ZXJuYWxNYW5hZ2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGEgaGVscGVyIGRlZmluaXRpb24gdG8gYmUgcGFzc2VkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGludm9rZUhlbHBlciwgYnV0IG5vIGhlbHBlciBtYW5hZ2VyIHdhcyBmb3VuZC4gVGhlIGRlZmluaXRpb24gdmFsdWUgdGhhdCB3YXMgcGFzc2VkIHdhcyBcXGAke2RlYnVnVG9TdHJpbmchKFxuICAgICAgICBkZWZpbml0aW9uXG4gICAgICApfVxcYC4gRGlkIHlvdSB1c2Ugc2V0SGVscGVyTWFuYWdlciB0byBhc3NvY2lhdGUgYSBoZWxwZXIgbWFuYWdlciB3aXRoIHRoaXMgdmFsdWU/YFxuICAgICk7XG4gIH1cblxuICBpZiAoREVCVUcgJiYgdHlwZW9mIGludGVybmFsTWFuYWdlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdGb3VuZCBhIGhlbHBlciBtYW5hZ2VyLCBidXQgaXQgd2FzIGFuIGludGVybmFsIGJ1aWx0LWluIGhlbHBlciBtYW5hZ2VyLiBgaW52b2tlSGVscGVyYCBkb2VzIG5vdCBzdXBwb3J0IGludGVybmFsIGhlbHBlcnMgeWV0LidcbiAgICApO1xuICB9XG5cbiAgY29uc3QgbWFuYWdlciA9IChpbnRlcm5hbE1hbmFnZXIgYXMgSW50ZXJuYWxIZWxwZXJNYW5hZ2VyPG9iamVjdD4pLmdldERlbGVnYXRlRm9yKG93bmVyKTtcbiAgbGV0IGFyZ3MgPSBuZXcgU2ltcGxlQXJnc1Byb3h5KGNvbnRleHQsIGNvbXB1dGVBcmdzKTtcbiAgbGV0IGJ1Y2tldCA9IG1hbmFnZXIuY3JlYXRlSGVscGVyKGRlZmluaXRpb24sIGFyZ3MpO1xuXG4gIGxldCBjYWNoZTogQ2FjaGU8dW5rbm93bj47XG5cbiAgaWYgKGhhc1ZhbHVlKG1hbmFnZXIpKSB7XG4gICAgY2FjaGUgPSBjcmVhdGVDYWNoZSgoKSA9PiB7XG4gICAgICBpZiAoREVCVUcgJiYgKGlzRGVzdHJveWluZyhjYWNoZSkgfHwgaXNEZXN0cm95ZWQoY2FjaGUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBhdHRlbXB0ZWQgdG8gZ2V0IHRoZSB2YWx1ZSBvZiBhIGhlbHBlciBhZnRlciB0aGUgaGVscGVyIHdhcyBkZXN0cm95ZWQsIHdoaWNoIGlzIG5vdCBhbGxvd2VkYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFuYWdlci5nZXRWYWx1ZShidWNrZXQpO1xuICAgIH0pO1xuXG4gICAgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZChjb250ZXh0LCBjYWNoZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUT0RPOiB1bnJlYWNoYWJsZSwgdG8gYmUgaW1wbGVtZW50ZWQgd2l0aCBoYXNTY2hlZHVsZWRFZmZlY3QnKTtcbiAgfVxuXG4gIGlmIChoYXNEZXN0cm95YWJsZShtYW5hZ2VyKSkge1xuICAgIGxldCBkZXN0cm95YWJsZSA9IG1hbmFnZXIuZ2V0RGVzdHJveWFibGUoYnVja2V0KTtcblxuICAgIGFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQoY2FjaGUsIGRlc3Ryb3lhYmxlKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=