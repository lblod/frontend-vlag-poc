"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.APPEND_OPCODES = exports.AppendOpcodes = void 0;

var _reference = require("@glimmer/reference");

var _util = require("@glimmer/util");

var _vm = require("@glimmer/vm");

var _scope = require("./scope");

var _symbols = require("./symbols");

var _elementBuilder = require("./vm/element-builder");

class AppendOpcodes {
  constructor() {
    this.evaluateOpcode = (0, _util.fillNulls)(104
    /* Size */
    ).slice();
  }

  add(name, evaluate, kind = 'syscall') {
    this.evaluateOpcode[name] = {
      syscall: kind !== 'machine',
      evaluate
    };
  }

  debugBefore(vm, opcode) {
    let params = undefined;
    let opName = undefined;

    if (false
    /* LOCAL_SHOULD_LOG */
    ) {
        let pos = vm[_symbols.INNER_VM].fetchRegister(_vm.$pc) - opcode.size;
        [opName, params] = []; // console.log(`${typePos(vm['pc'])}.`);

        _util.LOCAL_LOGGER.log(`${pos}. ${""}`);

        let debugParams = [];

        for (let prop in params) {
          debugParams.push(prop, '=', params[prop]);
        }

        _util.LOCAL_LOGGER.log(...debugParams);
      }

    let sp;

    if (false
    /* LOCAL_DEBUG */
    ) {
        sp = vm.fetchValue(_vm.$sp);
      }

    return {
      sp: sp,
      pc: vm.fetchValue(_vm.$pc),
      name: opName,
      params,
      type: opcode.type,
      isMachine: opcode.isMachine,
      size: opcode.size,
      state: undefined
    };
  }

  debugAfter(vm, pre) {
    let {
      sp,
      type,
      isMachine,
      pc
    } = pre;

    if (false
    /* LOCAL_DEBUG */
    ) {
        let meta = type;
        let actualChange = vm.fetchValue(_vm.$sp) - sp;

        if (meta && meta.check && typeof meta.stackChange === 'number' && meta.stackChange !== actualChange) {
          throw new Error(`Error in ${pre.name}:\n\n${pc}. ${""}\n\nStack changed by ${actualChange}, expected ${meta.stackChange}`);
        }

        if (false
        /* LOCAL_SHOULD_LOG */
        ) {
            _util.LOCAL_LOGGER.log('%c -> pc: %d, ra: %d, fp: %d, sp: %d, s0: %O, s1: %O, t0: %O, t1: %O, v0: %O', 'color: orange', vm[_symbols.INNER_VM].registers[_vm.$pc], vm[_symbols.INNER_VM].registers[_vm.$ra], vm[_symbols.INNER_VM].registers[_vm.$fp], vm[_symbols.INNER_VM].registers[_vm.$sp], vm['s0'], vm['s1'], vm['t0'], vm['t1'], vm['v0']);

            _util.LOCAL_LOGGER.log('%c -> eval stack', 'color: red', vm.stack.toArray());

            _util.LOCAL_LOGGER.log('%c -> block stack', 'color: magenta', vm.elements().debugBlocks());

            _util.LOCAL_LOGGER.log('%c -> destructor stack', 'color: violet', vm[_symbols.DESTROYABLE_STACK].toArray());

            if (vm[_symbols.STACKS].scope.current === null) {
              _util.LOCAL_LOGGER.log('%c -> scope', 'color: green', 'null');
            } else {
              _util.LOCAL_LOGGER.log('%c -> scope', 'color: green', vm.scope().slots.map(s => (0, _scope.isScopeReference)(s) ? (0, _reference.valueForRef)(s) : s));
            }

            _util.LOCAL_LOGGER.log('%c -> elements', 'color: blue', vm.elements()[_elementBuilder.CURSOR_STACK].current.element);

            _util.LOCAL_LOGGER.log('%c -> constructing', 'color: aqua', vm.elements()['constructing']);
          }
      }
  }

  evaluate(vm, opcode, type) {
    let operation = this.evaluateOpcode[type];

    if (operation.syscall) {
      false && (0, _util.assert)(!opcode.isMachine, `BUG: Mismatch between operation.syscall (${operation.syscall}) and opcode.isMachine (${opcode.isMachine}) for ${opcode.type}`);
      operation.evaluate(vm, opcode);
    } else {
      false && (0, _util.assert)(opcode.isMachine, `BUG: Mismatch between operation.syscall (${operation.syscall}) and opcode.isMachine (${opcode.isMachine}) for ${opcode.type}`);
      operation.evaluate(vm[_symbols.INNER_VM], opcode);
    }
  }

}

exports.AppendOpcodes = AppendOpcodes;
const APPEND_OPCODES = new AppendOpcodes();
exports.APPEND_OPCODES = APPEND_OPCODES;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL29wY29kZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUdBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBOztBQWlDTSxNQUFBLGFBQUEsQ0FBb0I7QUFBMUIsRUFBQSxXQUFBLEdBQUE7QUFDVSxTQUFBLGNBQUEsR0FBNkIscUJBQVM7QUFBQTtBQUFULE1BQTdCLEtBQTZCLEVBQTdCO0FBaUlUOztBQTdIQyxFQUFBLEdBQUcsQ0FBQSxJQUFBLEVBQUEsUUFBQSxFQUFpRSxJQUFJLEdBQXJFLFNBQUEsRUFBaUY7QUFDbEYsU0FBQSxjQUFBLENBQUEsSUFBQSxJQUFzQztBQUNwQyxNQUFBLE9BQU8sRUFBRSxJQUFJLEtBRHVCLFNBQUE7QUFFcEMsTUFBQTtBQUZvQyxLQUF0QztBQUlEOztBQUVELEVBQUEsV0FBVyxDQUFBLEVBQUEsRUFBQSxNQUFBLEVBQTBCO0FBQ25DLFFBQUksTUFBTSxHQUFWLFNBQUE7QUFDQSxRQUFJLE1BQU0sR0FBVixTQUFBOztBQUVBLFFBQUE7QUFBQTtBQUFBLE1BQXNCO0FBQ3BCLFlBQUksR0FBRyxHQUFHLEVBQUUsQ0FBRixpQkFBRSxDQUFGLENBQUEsYUFBQSxDQUFBLE9BQUEsSUFBa0MsTUFBTSxDQUFsRCxJQUFBO0FBRUEsU0FBQSxNQUFBLEVBQUEsTUFBQSxJQUhvQixFQUdwQixDQUhvQixDQUtwQjs7QUFDQSwyQkFBQSxHQUFBLENBQWlCLEdBQUcsR0FBRyxLQUFOLEVBQWpCLEVBQUE7O0FBRUEsWUFBSSxXQUFXLEdBQWYsRUFBQTs7QUFDQSxhQUFLLElBQUwsSUFBQSxJQUFBLE1BQUEsRUFBeUI7QUFDdkIsVUFBQSxXQUFXLENBQVgsSUFBQSxDQUFBLElBQUEsRUFBQSxHQUFBLEVBQTRCLE1BQU0sQ0FBbEMsSUFBa0MsQ0FBbEM7QUFDRDs7QUFFRCwyQkFBQSxHQUFBLENBQWlCLEdBQWpCLFdBQUE7QUFDRDs7QUFF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Q0FIRixPQUFBOztBQU1BLCtCQUFBLEdBQUEsQ0FBQSxvQkFBQSxFQUFBLGFBQUEsRUFBc0QsRUFBRSxDQUFGLFFBQUEsR0FBdEQsY0FBc0QsQ0FBdEQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsRUFBQSxRQUFRLENBQUEsRUFBQSxFQUFBLE1BQUEsRUFBQSxJQUFBLEVBQXdDO0FBQzlDLFFBQUksU0FBUyxHQUFHLEtBQUEsY0FBQSxDQUFoQixJQUFnQixDQUFoQjs7QUFFQSxRQUFJLFNBQVMsQ0FBYixPQUFBLEVBQXVCO0FBQUEsZUFDckIsa0JBQ0UsQ0FBQyxNQUFNLENBREgsU0FBTixFQUVFLDRDQUE0QyxTQUFTLENBQUMsT0FBTywyQkFBMkIsTUFBTSxDQUFDLFNBQVMsU0FBUyxNQUFNLENBQUMsSUFIckcsRUFDckIsQ0FEcUI7QUFLckIsTUFBQSxTQUFTLENBQVQsUUFBQSxDQUFBLEVBQUEsRUFBQSxNQUFBO0FBTEYsS0FBQSxNQU1PO0FBQUEsZUFDTCxrQkFDRSxNQUFNLENBREYsU0FBTixFQUVFLDRDQUE0QyxTQUFTLENBQUMsT0FBTywyQkFBMkIsTUFBTSxDQUFDLFNBQVMsU0FBUyxNQUFNLENBQUMsSUFIckgsRUFDTCxDQURLO0FBS0wsTUFBQSxTQUFTLENBQVQsUUFBQSxDQUFtQixFQUFFLENBQXJCLGlCQUFxQixDQUFyQixFQUFBLE1BQUE7QUFDRDtBQUNGOztBQWpJdUI7OztBQW9JbkIsTUFBTSxjQUFjLEdBQUcsSUFBdkIsYUFBdUIsRUFBdkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWJ1ZywgbG9nT3Bjb2RlLCBvcGNvZGVNZXRhZGF0YSwgcmVjb3JkU3RhY2tTaXplIH0gZnJvbSAnQGdsaW1tZXIvZGVidWcnO1xuaW1wb3J0IHsgRGljdCwgTWF5YmUsIE9wLCBPcHRpb24sIFJ1bnRpbWVPcCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTE9DQUxfREVCVUcsIExPQ0FMX1NIT1VMRF9MT0cgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyB2YWx1ZUZvclJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBhc3NlcnQsIGZpbGxOdWxscywgTE9DQUxfTE9HR0VSIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyAkZnAsICRwYywgJHJhLCAkc3AgfSBmcm9tICdAZ2xpbW1lci92bSc7XG5pbXBvcnQgeyBpc1Njb3BlUmVmZXJlbmNlIH0gZnJvbSAnLi9zY29wZSc7XG5pbXBvcnQgeyBDT05TVEFOVFMsIERFU1RST1lBQkxFX1NUQUNLLCBJTk5FUl9WTSwgU1RBQ0tTIH0gZnJvbSAnLi9zeW1ib2xzJztcbmltcG9ydCB7IExvd0xldmVsVk0sIFZNIH0gZnJvbSAnLi92bSc7XG5pbXBvcnQgeyBJbnRlcm5hbFZNIH0gZnJvbSAnLi92bS9hcHBlbmQnO1xuaW1wb3J0IHsgQ1VSU09SX1NUQUNLIH0gZnJvbSAnLi92bS9lbGVtZW50LWJ1aWxkZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9wY29kZUpTT04ge1xuICB0eXBlOiBudW1iZXIgfCBzdHJpbmc7XG4gIGd1aWQ/OiBPcHRpb248bnVtYmVyPjtcbiAgZGVvcHRlZD86IGJvb2xlYW47XG4gIGFyZ3M/OiBzdHJpbmdbXTtcbiAgZGV0YWlscz86IERpY3Q8T3B0aW9uPHN0cmluZz4+O1xuICBjaGlsZHJlbj86IE9wY29kZUpTT05bXTtcbn1cblxuZXhwb3J0IHR5cGUgT3BlcmFuZDEgPSBudW1iZXI7XG5leHBvcnQgdHlwZSBPcGVyYW5kMiA9IG51bWJlcjtcbmV4cG9ydCB0eXBlIE9wZXJhbmQzID0gbnVtYmVyO1xuXG5leHBvcnQgdHlwZSBTeXNjYWxsID0gKHZtOiBJbnRlcm5hbFZNLCBvcGNvZGU6IFJ1bnRpbWVPcCkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIE1hY2hpbmVPcGNvZGUgPSAodm06IExvd0xldmVsVk0sIG9wY29kZTogUnVudGltZU9wKSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBFdmFsdWF0ZSA9XG4gIHwgeyBzeXNjYWxsOiB0cnVlOyBldmFsdWF0ZTogU3lzY2FsbCB9XG4gIHwgeyBzeXNjYWxsOiBmYWxzZTsgZXZhbHVhdGU6IE1hY2hpbmVPcGNvZGUgfTtcblxuZXhwb3J0IHR5cGUgRGVidWdTdGF0ZSA9IHtcbiAgcGM6IG51bWJlcjtcbiAgc3A6IG51bWJlcjtcbiAgdHlwZTogbnVtYmVyO1xuICBpc01hY2hpbmU6IDAgfCAxO1xuICBzaXplOiBudW1iZXI7XG4gIHBhcmFtcz86IE1heWJlPERpY3Q+O1xuICBuYW1lPzogc3RyaW5nO1xuICBzdGF0ZTogdW5rbm93bjtcbn07XG5cbmV4cG9ydCBjbGFzcyBBcHBlbmRPcGNvZGVzIHtcbiAgcHJpdmF0ZSBldmFsdWF0ZU9wY29kZTogRXZhbHVhdGVbXSA9IGZpbGxOdWxsczxFdmFsdWF0ZT4oT3AuU2l6ZSkuc2xpY2UoKTtcblxuICBhZGQ8TmFtZSBleHRlbmRzIE9wPihuYW1lOiBOYW1lLCBldmFsdWF0ZTogU3lzY2FsbCk6IHZvaWQ7XG4gIGFkZDxOYW1lIGV4dGVuZHMgT3A+KG5hbWU6IE5hbWUsIGV2YWx1YXRlOiBNYWNoaW5lT3Bjb2RlLCBraW5kOiAnbWFjaGluZScpOiB2b2lkO1xuICBhZGQ8TmFtZSBleHRlbmRzIE9wPihuYW1lOiBOYW1lLCBldmFsdWF0ZTogU3lzY2FsbCB8IE1hY2hpbmVPcGNvZGUsIGtpbmQgPSAnc3lzY2FsbCcpOiB2b2lkIHtcbiAgICB0aGlzLmV2YWx1YXRlT3Bjb2RlW25hbWUgYXMgbnVtYmVyXSA9IHtcbiAgICAgIHN5c2NhbGw6IGtpbmQgIT09ICdtYWNoaW5lJyxcbiAgICAgIGV2YWx1YXRlLFxuICAgIH0gYXMgRXZhbHVhdGU7XG4gIH1cblxuICBkZWJ1Z0JlZm9yZSh2bTogVk0sIG9wY29kZTogUnVudGltZU9wKTogRGVidWdTdGF0ZSB7XG4gICAgbGV0IHBhcmFtczogTWF5YmU8RGljdD4gPSB1bmRlZmluZWQ7XG4gICAgbGV0IG9wTmFtZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKExPQ0FMX1NIT1VMRF9MT0cpIHtcbiAgICAgIGxldCBwb3MgPSB2bVtJTk5FUl9WTV0uZmV0Y2hSZWdpc3RlcigkcGMpIC0gb3Bjb2RlLnNpemU7XG5cbiAgICAgIFtvcE5hbWUsIHBhcmFtc10gPSBkZWJ1Zyh2bVtDT05TVEFOVFNdLCBvcGNvZGUsIG9wY29kZS5pc01hY2hpbmUpITtcblxuICAgICAgLy8gY29uc29sZS5sb2coYCR7dHlwZVBvcyh2bVsncGMnXSl9LmApO1xuICAgICAgTE9DQUxfTE9HR0VSLmxvZyhgJHtwb3N9LiAke2xvZ09wY29kZShvcE5hbWUsIHBhcmFtcyl9YCk7XG5cbiAgICAgIGxldCBkZWJ1Z1BhcmFtcyA9IFtdO1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBwYXJhbXMpIHtcbiAgICAgICAgZGVidWdQYXJhbXMucHVzaChwcm9wLCAnPScsIHBhcmFtc1twcm9wXSk7XG4gICAgICB9XG5cbiAgICAgIExPQ0FMX0xPR0dFUi5sb2coLi4uZGVidWdQYXJhbXMpO1xuICAgIH1cblxuICAgIGxldCBzcDogbnVtYmVyO1xuXG4gICAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgICBzcCA9IHZtLmZldGNoVmFsdWUoJHNwKTtcbiAgICB9XG5cbiAgICByZWNvcmRTdGFja1NpemUodm0uZmV0Y2hWYWx1ZSgkc3ApKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3A6IHNwISxcbiAgICAgIHBjOiB2bS5mZXRjaFZhbHVlKCRwYyksXG4gICAgICBuYW1lOiBvcE5hbWUsXG4gICAgICBwYXJhbXMsXG4gICAgICB0eXBlOiBvcGNvZGUudHlwZSxcbiAgICAgIGlzTWFjaGluZTogb3Bjb2RlLmlzTWFjaGluZSxcbiAgICAgIHNpemU6IG9wY29kZS5zaXplLFxuICAgICAgc3RhdGU6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG5cbiAgZGVidWdBZnRlcih2bTogVk0sIHByZTogRGVidWdTdGF0ZSkge1xuICAgIGxldCB7IHNwLCB0eXBlLCBpc01hY2hpbmUsIHBjIH0gPSBwcmU7XG5cbiAgICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAgIGxldCBtZXRhID0gb3Bjb2RlTWV0YWRhdGEodHlwZSwgaXNNYWNoaW5lKTtcbiAgICAgIGxldCBhY3R1YWxDaGFuZ2UgPSB2bS5mZXRjaFZhbHVlKCRzcCkgLSBzcCE7XG4gICAgICBpZiAoXG4gICAgICAgIG1ldGEgJiZcbiAgICAgICAgbWV0YS5jaGVjayAmJlxuICAgICAgICB0eXBlb2YgbWV0YS5zdGFja0NoYW5nZSEgPT09ICdudW1iZXInICYmXG4gICAgICAgIG1ldGEuc3RhY2tDaGFuZ2UhICE9PSBhY3R1YWxDaGFuZ2VcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEVycm9yIGluICR7cHJlLm5hbWV9OlxcblxcbiR7cGN9LiAke2xvZ09wY29kZShcbiAgICAgICAgICAgIHByZS5uYW1lISxcbiAgICAgICAgICAgIHByZS5wYXJhbXMhXG4gICAgICAgICAgKX1cXG5cXG5TdGFjayBjaGFuZ2VkIGJ5ICR7YWN0dWFsQ2hhbmdlfSwgZXhwZWN0ZWQgJHttZXRhLnN0YWNrQ2hhbmdlIX1gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChMT0NBTF9TSE9VTERfTE9HKSB7XG4gICAgICAgIExPQ0FMX0xPR0dFUi5sb2coXG4gICAgICAgICAgJyVjIC0+IHBjOiAlZCwgcmE6ICVkLCBmcDogJWQsIHNwOiAlZCwgczA6ICVPLCBzMTogJU8sIHQwOiAlTywgdDE6ICVPLCB2MDogJU8nLFxuICAgICAgICAgICdjb2xvcjogb3JhbmdlJyxcbiAgICAgICAgICB2bVtJTk5FUl9WTV0ucmVnaXN0ZXJzWyRwY10sXG4gICAgICAgICAgdm1bSU5ORVJfVk1dLnJlZ2lzdGVyc1skcmFdLFxuICAgICAgICAgIHZtW0lOTkVSX1ZNXS5yZWdpc3RlcnNbJGZwXSxcbiAgICAgICAgICB2bVtJTk5FUl9WTV0ucmVnaXN0ZXJzWyRzcF0sXG4gICAgICAgICAgdm1bJ3MwJ10sXG4gICAgICAgICAgdm1bJ3MxJ10sXG4gICAgICAgICAgdm1bJ3QwJ10sXG4gICAgICAgICAgdm1bJ3QxJ10sXG4gICAgICAgICAgdm1bJ3YwJ11cbiAgICAgICAgKTtcbiAgICAgICAgTE9DQUxfTE9HR0VSLmxvZygnJWMgLT4gZXZhbCBzdGFjaycsICdjb2xvcjogcmVkJywgdm0uc3RhY2sudG9BcnJheSgpKTtcbiAgICAgICAgTE9DQUxfTE9HR0VSLmxvZygnJWMgLT4gYmxvY2sgc3RhY2snLCAnY29sb3I6IG1hZ2VudGEnLCB2bS5lbGVtZW50cygpLmRlYnVnQmxvY2tzKCkpO1xuICAgICAgICBMT0NBTF9MT0dHRVIubG9nKFxuICAgICAgICAgICclYyAtPiBkZXN0cnVjdG9yIHN0YWNrJyxcbiAgICAgICAgICAnY29sb3I6IHZpb2xldCcsXG4gICAgICAgICAgdm1bREVTVFJPWUFCTEVfU1RBQ0tdLnRvQXJyYXkoKVxuICAgICAgICApO1xuICAgICAgICBpZiAodm1bU1RBQ0tTXS5zY29wZS5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgTE9DQUxfTE9HR0VSLmxvZygnJWMgLT4gc2NvcGUnLCAnY29sb3I6IGdyZWVuJywgJ251bGwnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBMT0NBTF9MT0dHRVIubG9nKFxuICAgICAgICAgICAgJyVjIC0+IHNjb3BlJyxcbiAgICAgICAgICAgICdjb2xvcjogZ3JlZW4nLFxuICAgICAgICAgICAgdm0uc2NvcGUoKS5zbG90cy5tYXAoKHMpID0+IChpc1Njb3BlUmVmZXJlbmNlKHMpID8gdmFsdWVGb3JSZWYocykgOiBzKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgTE9DQUxfTE9HR0VSLmxvZyhcbiAgICAgICAgICAnJWMgLT4gZWxlbWVudHMnLFxuICAgICAgICAgICdjb2xvcjogYmx1ZScsXG4gICAgICAgICAgdm0uZWxlbWVudHMoKVtDVVJTT1JfU1RBQ0tdLmN1cnJlbnQhLmVsZW1lbnRcbiAgICAgICAgKTtcblxuICAgICAgICBMT0NBTF9MT0dHRVIubG9nKCclYyAtPiBjb25zdHJ1Y3RpbmcnLCAnY29sb3I6IGFxdWEnLCB2bS5lbGVtZW50cygpWydjb25zdHJ1Y3RpbmcnXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZXZhbHVhdGUodm06IFZNLCBvcGNvZGU6IFJ1bnRpbWVPcCwgdHlwZTogbnVtYmVyKSB7XG4gICAgbGV0IG9wZXJhdGlvbiA9IHRoaXMuZXZhbHVhdGVPcGNvZGVbdHlwZV07XG5cbiAgICBpZiAob3BlcmF0aW9uLnN5c2NhbGwpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgIW9wY29kZS5pc01hY2hpbmUsXG4gICAgICAgIGBCVUc6IE1pc21hdGNoIGJldHdlZW4gb3BlcmF0aW9uLnN5c2NhbGwgKCR7b3BlcmF0aW9uLnN5c2NhbGx9KSBhbmQgb3Bjb2RlLmlzTWFjaGluZSAoJHtvcGNvZGUuaXNNYWNoaW5lfSkgZm9yICR7b3Bjb2RlLnR5cGV9YFxuICAgICAgKTtcbiAgICAgIG9wZXJhdGlvbi5ldmFsdWF0ZSh2bSwgb3Bjb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KFxuICAgICAgICBvcGNvZGUuaXNNYWNoaW5lLFxuICAgICAgICBgQlVHOiBNaXNtYXRjaCBiZXR3ZWVuIG9wZXJhdGlvbi5zeXNjYWxsICgke29wZXJhdGlvbi5zeXNjYWxsfSkgYW5kIG9wY29kZS5pc01hY2hpbmUgKCR7b3Bjb2RlLmlzTWFjaGluZX0pIGZvciAke29wY29kZS50eXBlfWBcbiAgICAgICk7XG4gICAgICBvcGVyYXRpb24uZXZhbHVhdGUodm1bSU5ORVJfVk1dLCBvcGNvZGUpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQVBQRU5EX09QQ09ERVMgPSBuZXcgQXBwZW5kT3Bjb2RlcygpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==