"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _env = require("@glimmer/env");

var _reference = require("@glimmer/reference");

var _runtime = require("@glimmer/runtime");

var _util = require("@glimmer/util");

var _internalHelper = require("./internal-helper");

var context = (0, _util.buildUntouchableThis)('`fn` helper');
/**
  The `fn` helper allows you to ensure a function that you are passing off
  to another component, helper, or modifier has access to arguments that are
  available in the template.

  For example, if you have an `each` helper looping over a number of items, you
  may need to pass a function that expects to receive the item as an argument
  to a component invoked within the loop. Here's how you could use the `fn`
  helper to pass both the function and its arguments together:

    ```app/templates/components/items-listing.hbs
  {{#each @items as |item|}}
    <DisplayItem @item=item @select={{fn this.handleSelected item}} />
  {{/each}}
  ```

  ```app/components/items-list.js
  import Component from '@glimmer/component';
  import { action } from '@ember/object';

  export default class ItemsList extends Component {
    handleSelected = (item) => {
      // ...snip...
    }
  }
  ```

  In this case the `display-item` component will receive a normal function
  that it can invoke. When it invokes the function, the `handleSelected`
  function will receive the `item` and any arguments passed, thanks to the
  `fn` helper.

  Let's take look at what that means in a couple circumstances:

  - When invoked as `this.args.select()` the `handleSelected` function will
    receive the `item` from the loop as its first and only argument.
  - When invoked as `this.args.select('foo')` the `handleSelected` function
    will receive the `item` from the loop as its first argument and the
    string `'foo'` as its second argument.

  In the example above, we used an arrow function to ensure that
  `handleSelected` is properly bound to the `items-list`, but let's explore what
  happens if we left out the arrow function:

  ```app/components/items-list.js
  import Component from '@glimmer/component';

  export default class ItemsList extends Component {
    handleSelected(item) {
      // ...snip...
    }
  }
  ```

  In this example, when `handleSelected` is invoked inside the `display-item`
  component, it will **not** have access to the component instance. In other
  words, it will have no `this` context, so please make sure your functions
  are bound (via an arrow function or other means) before passing into `fn`!

  See also [partial application](https://en.wikipedia.org/wiki/Partial_application).

  @method fn
  @public
*/

var _default = (0, _internalHelper.internalHelper)(function (_ref) {
  var positional = _ref.positional;
  var callbackRef = positional[0];
  if (_env.DEBUG) assertCallbackIsFn(callbackRef);
  return (0, _reference.createComputeRef)(function () {
    return function () {
      var _reifyPositional = (0, _runtime.reifyPositional)(positional),
          fn = _reifyPositional[0],
          args = _reifyPositional.slice(1);

      if (_env.DEBUG) assertCallbackIsFn(callbackRef);

      for (var _len = arguments.length, invocationArgs = new Array(_len), _key = 0; _key < _len; _key++) {
        invocationArgs[_key] = arguments[_key];
      }

      if ((0, _reference.isInvokableRef)(callbackRef)) {
        var value = args.length > 0 ? args[0] : invocationArgs[0];
        return (0, _reference.updateRef)(callbackRef, value);
      } else {
        return fn.call.apply(fn, [context].concat(args, invocationArgs));
      }
    };
  }, null, 'fn');
});

exports.default = _default;

function assertCallbackIsFn(callbackRef) {
  if (!(callbackRef && ((0, _reference.isInvokableRef)(callbackRef) || typeof (0, _reference.valueForRef)(callbackRef) === 'function'))) {
    throw new Error("You must pass a function as the `fn` helper's first argument, you passed " + (callbackRef ? (0, _reference.valueForRef)(callbackRef) : callbackRef) + ". While rendering:\n\n" + (callbackRef === null || callbackRef === void 0 ? void 0 : callbackRef.debugLabel));
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2hlbHBlcnMvZm4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBOztBQU9BOztBQUNBOztBQUNBOztBQUVBLElBQU0sT0FBTyxHQUFHLGdDQUFoQixhQUFnQixDQUFoQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztlQWdFZSxvQ0FBZSxVQUFBLElBQUEsRUFBc0M7QUFBQSxNQUFuQyxVQUFtQyxHQUFBLElBQUEsQ0FBbkMsVUFBbUM7QUFDbEUsTUFBSSxXQUFXLEdBQUcsVUFBVSxDQUE1QixDQUE0QixDQUE1QjtBQUVBLE1BQUEsVUFBQSxFQUFXLGtCQUFrQixDQUFsQixXQUFrQixDQUFsQjtBQUVYLFNBQU8saUNBQ0wsWUFBSztBQUNILFdBQU8sWUFBaUM7QUFBQSxVQUFBLGdCQUFBLEdBQ2xCLDhCQURrQixVQUNsQixDQURrQjtBQUFBLFVBQ2xDLEVBRGtDLEdBQUEsZ0JBQUEsQ0FBQSxDQUFBLENBQUE7QUFBQSxVQUNsQyxJQURrQyxHQUFBLGdCQUFBLENBQUEsS0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFHdEMsVUFBQSxVQUFBLEVBQVcsa0JBQWtCLENBQWxCLFdBQWtCLENBQWxCOztBQUgyQixXQUFBLElBQUEsSUFBQSxHQUFBLFNBQUEsQ0FBQSxNQUFBLEVBQWpDLGNBQWlDLEdBQUEsSUFBQSxLQUFBLENBQUEsSUFBQSxDQUFBLEVBQUEsSUFBQSxHQUFBLENBQUEsRUFBQSxJQUFBLEdBQUEsSUFBQSxFQUFBLElBQUEsRUFBQSxFQUFBO0FBQWpDLFFBQUEsY0FBaUMsQ0FBQSxJQUFBLENBQWpDLEdBQWlDLFNBQUEsQ0FBQSxJQUFBLENBQWpDO0FBQWlDOztBQUt0QyxVQUFJLCtCQUFKLFdBQUksQ0FBSixFQUFpQztBQUMvQixZQUFJLEtBQUssR0FBRyxJQUFJLENBQUosTUFBQSxHQUFBLENBQUEsR0FBa0IsSUFBSSxDQUF0QixDQUFzQixDQUF0QixHQUE0QixjQUFjLENBQXRELENBQXNELENBQXREO0FBQ0EsZUFBTywwQkFBUyxXQUFULEVBQVAsS0FBTyxDQUFQO0FBRkYsT0FBQSxNQUdPO0FBQ0wsZUFBUSxFQUFlLENBQWYsSUFBQSxDQUFBLEtBQUEsQ0FBQSxFQUFBLEVBQWUsQ0FBZixPQUFlLEVBQUEsTUFBQSxDQUFmLElBQWUsRUFBdkIsY0FBdUIsQ0FBZixDQUFSO0FBQ0Q7QUFWSCxLQUFBO0FBRm1CLEdBQWhCLEVBQWdCLElBQWhCLEVBQVAsSUFBTyxDQUFQO0FBTEYsQ0FBZSxDOzs7O0FBeUJmLFNBQUEsa0JBQUEsQ0FBQSxXQUFBLEVBQWtEO0FBQ2hELE1BQ0UsRUFDRSxXQUFXLEtBQ1YsK0JBQUEsV0FBQSxLQUErQixPQUFPLDRCQUFQLFdBQU8sQ0FBUCxLQUhwQyxVQUVlLENBRGIsQ0FERixFQUtFO0FBQ0EsVUFBTSxJQUFBLEtBQUEsQ0FBQSwrRUFFRixXQUFXLEdBQUcsNEJBQUgsV0FBRyxDQUFILEdBRlQsV0FBQSxJQUFBLHdCQUFBLElBR3FCLFdBQVcsS0FBWCxJQUFBLElBQUEsV0FBVyxLQUFBLEtBQVgsQ0FBQSxHQUFXLEtBQVgsQ0FBQSxHQUFBLFdBQVcsQ0FIdEMsVUFBTSxDQUFBLENBQU47QUFLRDtBQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHsgQ2FwdHVyZWRBcmd1bWVudHMgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7XG4gIGNyZWF0ZUNvbXB1dGVSZWYsXG4gIGlzSW52b2thYmxlUmVmLFxuICBSZWZlcmVuY2UsXG4gIHVwZGF0ZVJlZixcbiAgdmFsdWVGb3JSZWYsXG59IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyByZWlmeVBvc2l0aW9uYWwgfSBmcm9tICdAZ2xpbW1lci9ydW50aW1lJztcbmltcG9ydCB7IGJ1aWxkVW50b3VjaGFibGVUaGlzIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBpbnRlcm5hbEhlbHBlciB9IGZyb20gJy4vaW50ZXJuYWwtaGVscGVyJztcblxuY29uc3QgY29udGV4dCA9IGJ1aWxkVW50b3VjaGFibGVUaGlzKCdgZm5gIGhlbHBlcicpO1xuXG4vKipcbiAgVGhlIGBmbmAgaGVscGVyIGFsbG93cyB5b3UgdG8gZW5zdXJlIGEgZnVuY3Rpb24gdGhhdCB5b3UgYXJlIHBhc3Npbmcgb2ZmXG4gIHRvIGFub3RoZXIgY29tcG9uZW50LCBoZWxwZXIsIG9yIG1vZGlmaWVyIGhhcyBhY2Nlc3MgdG8gYXJndW1lbnRzIHRoYXQgYXJlXG4gIGF2YWlsYWJsZSBpbiB0aGUgdGVtcGxhdGUuXG5cbiAgRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIGFuIGBlYWNoYCBoZWxwZXIgbG9vcGluZyBvdmVyIGEgbnVtYmVyIG9mIGl0ZW1zLCB5b3VcbiAgbWF5IG5lZWQgdG8gcGFzcyBhIGZ1bmN0aW9uIHRoYXQgZXhwZWN0cyB0byByZWNlaXZlIHRoZSBpdGVtIGFzIGFuIGFyZ3VtZW50XG4gIHRvIGEgY29tcG9uZW50IGludm9rZWQgd2l0aGluIHRoZSBsb29wLiBIZXJlJ3MgaG93IHlvdSBjb3VsZCB1c2UgdGhlIGBmbmBcbiAgaGVscGVyIHRvIHBhc3MgYm90aCB0aGUgZnVuY3Rpb24gYW5kIGl0cyBhcmd1bWVudHMgdG9nZXRoZXI6XG5cbiAgICBgYGBhcHAvdGVtcGxhdGVzL2NvbXBvbmVudHMvaXRlbXMtbGlzdGluZy5oYnNcbiAge3sjZWFjaCBAaXRlbXMgYXMgfGl0ZW18fX1cbiAgICA8RGlzcGxheUl0ZW0gQGl0ZW09aXRlbSBAc2VsZWN0PXt7Zm4gdGhpcy5oYW5kbGVTZWxlY3RlZCBpdGVtfX0gLz5cbiAge3svZWFjaH19XG4gIGBgYFxuXG4gIGBgYGFwcC9jb21wb25lbnRzL2l0ZW1zLWxpc3QuanNcbiAgaW1wb3J0IENvbXBvbmVudCBmcm9tICdAZ2xpbW1lci9jb21wb25lbnQnO1xuICBpbXBvcnQgeyBhY3Rpb24gfSBmcm9tICdAZW1iZXIvb2JqZWN0JztcblxuICBleHBvcnQgZGVmYXVsdCBjbGFzcyBJdGVtc0xpc3QgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGhhbmRsZVNlbGVjdGVkID0gKGl0ZW0pID0+IHtcbiAgICAgIC8vIC4uLnNuaXAuLi5cbiAgICB9XG4gIH1cbiAgYGBgXG5cbiAgSW4gdGhpcyBjYXNlIHRoZSBgZGlzcGxheS1pdGVtYCBjb21wb25lbnQgd2lsbCByZWNlaXZlIGEgbm9ybWFsIGZ1bmN0aW9uXG4gIHRoYXQgaXQgY2FuIGludm9rZS4gV2hlbiBpdCBpbnZva2VzIHRoZSBmdW5jdGlvbiwgdGhlIGBoYW5kbGVTZWxlY3RlZGBcbiAgZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBgaXRlbWAgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkLCB0aGFua3MgdG8gdGhlXG4gIGBmbmAgaGVscGVyLlxuXG4gIExldCdzIHRha2UgbG9vayBhdCB3aGF0IHRoYXQgbWVhbnMgaW4gYSBjb3VwbGUgY2lyY3Vtc3RhbmNlczpcblxuICAtIFdoZW4gaW52b2tlZCBhcyBgdGhpcy5hcmdzLnNlbGVjdCgpYCB0aGUgYGhhbmRsZVNlbGVjdGVkYCBmdW5jdGlvbiB3aWxsXG4gICAgcmVjZWl2ZSB0aGUgYGl0ZW1gIGZyb20gdGhlIGxvb3AgYXMgaXRzIGZpcnN0IGFuZCBvbmx5IGFyZ3VtZW50LlxuICAtIFdoZW4gaW52b2tlZCBhcyBgdGhpcy5hcmdzLnNlbGVjdCgnZm9vJylgIHRoZSBgaGFuZGxlU2VsZWN0ZWRgIGZ1bmN0aW9uXG4gICAgd2lsbCByZWNlaXZlIHRoZSBgaXRlbWAgZnJvbSB0aGUgbG9vcCBhcyBpdHMgZmlyc3QgYXJndW1lbnQgYW5kIHRoZVxuICAgIHN0cmluZyBgJ2ZvbydgIGFzIGl0cyBzZWNvbmQgYXJndW1lbnQuXG5cbiAgSW4gdGhlIGV4YW1wbGUgYWJvdmUsIHdlIHVzZWQgYW4gYXJyb3cgZnVuY3Rpb24gdG8gZW5zdXJlIHRoYXRcbiAgYGhhbmRsZVNlbGVjdGVkYCBpcyBwcm9wZXJseSBib3VuZCB0byB0aGUgYGl0ZW1zLWxpc3RgLCBidXQgbGV0J3MgZXhwbG9yZSB3aGF0XG4gIGhhcHBlbnMgaWYgd2UgbGVmdCBvdXQgdGhlIGFycm93IGZ1bmN0aW9uOlxuXG4gIGBgYGFwcC9jb21wb25lbnRzL2l0ZW1zLWxpc3QuanNcbiAgaW1wb3J0IENvbXBvbmVudCBmcm9tICdAZ2xpbW1lci9jb21wb25lbnQnO1xuXG4gIGV4cG9ydCBkZWZhdWx0IGNsYXNzIEl0ZW1zTGlzdCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgaGFuZGxlU2VsZWN0ZWQoaXRlbSkge1xuICAgICAgLy8gLi4uc25pcC4uLlxuICAgIH1cbiAgfVxuICBgYGBcblxuICBJbiB0aGlzIGV4YW1wbGUsIHdoZW4gYGhhbmRsZVNlbGVjdGVkYCBpcyBpbnZva2VkIGluc2lkZSB0aGUgYGRpc3BsYXktaXRlbWBcbiAgY29tcG9uZW50LCBpdCB3aWxsICoqbm90KiogaGF2ZSBhY2Nlc3MgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZS4gSW4gb3RoZXJcbiAgd29yZHMsIGl0IHdpbGwgaGF2ZSBubyBgdGhpc2AgY29udGV4dCwgc28gcGxlYXNlIG1ha2Ugc3VyZSB5b3VyIGZ1bmN0aW9uc1xuICBhcmUgYm91bmQgKHZpYSBhbiBhcnJvdyBmdW5jdGlvbiBvciBvdGhlciBtZWFucykgYmVmb3JlIHBhc3NpbmcgaW50byBgZm5gIVxuXG4gIFNlZSBhbHNvIFtwYXJ0aWFsIGFwcGxpY2F0aW9uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYXJ0aWFsX2FwcGxpY2F0aW9uKS5cblxuICBAbWV0aG9kIGZuXG4gIEBwdWJsaWNcbiovXG5leHBvcnQgZGVmYXVsdCBpbnRlcm5hbEhlbHBlcigoeyBwb3NpdGlvbmFsIH06IENhcHR1cmVkQXJndW1lbnRzKSA9PiB7XG4gIGxldCBjYWxsYmFja1JlZiA9IHBvc2l0aW9uYWxbMF07XG5cbiAgaWYgKERFQlVHKSBhc3NlcnRDYWxsYmFja0lzRm4oY2FsbGJhY2tSZWYpO1xuXG4gIHJldHVybiBjcmVhdGVDb21wdXRlUmVmKFxuICAgICgpID0+IHtcbiAgICAgIHJldHVybiAoLi4uaW52b2NhdGlvbkFyZ3M6IHVua25vd25bXSkgPT4ge1xuICAgICAgICBsZXQgW2ZuLCAuLi5hcmdzXSA9IHJlaWZ5UG9zaXRpb25hbChwb3NpdGlvbmFsKTtcblxuICAgICAgICBpZiAoREVCVUcpIGFzc2VydENhbGxiYWNrSXNGbihjYWxsYmFja1JlZik7XG5cbiAgICAgICAgaWYgKGlzSW52b2thYmxlUmVmKGNhbGxiYWNrUmVmKSkge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGFyZ3MubGVuZ3RoID4gMCA/IGFyZ3NbMF0gOiBpbnZvY2F0aW9uQXJnc1swXTtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlUmVmKGNhbGxiYWNrUmVmLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIChmbiBhcyBGdW5jdGlvbikuY2FsbChjb250ZXh0LCAuLi5hcmdzLCAuLi5pbnZvY2F0aW9uQXJncyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBudWxsLFxuICAgICdmbidcbiAgKTtcbn0pO1xuXG5mdW5jdGlvbiBhc3NlcnRDYWxsYmFja0lzRm4oY2FsbGJhY2tSZWY6IFJlZmVyZW5jZSkge1xuICBpZiAoXG4gICAgIShcbiAgICAgIGNhbGxiYWNrUmVmICYmXG4gICAgICAoaXNJbnZva2FibGVSZWYoY2FsbGJhY2tSZWYpIHx8IHR5cGVvZiB2YWx1ZUZvclJlZihjYWxsYmFja1JlZikgPT09ICdmdW5jdGlvbicpXG4gICAgKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIHRoZSBcXGBmblxcYCBoZWxwZXIncyBmaXJzdCBhcmd1bWVudCwgeW91IHBhc3NlZCAke1xuICAgICAgICBjYWxsYmFja1JlZiA/IHZhbHVlRm9yUmVmKGNhbGxiYWNrUmVmKSA6IGNhbGxiYWNrUmVmXG4gICAgICB9LiBXaGlsZSByZW5kZXJpbmc6XFxuXFxuJHtjYWxsYmFja1JlZj8uZGVidWdMYWJlbH1gXG4gICAgKTtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==