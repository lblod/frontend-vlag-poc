"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.invokeHelper = invokeHelper;

var _env = require("@glimmer/env");

var _validator = require("@glimmer/validator");

var _util = require("@glimmer/util");

var _manager = require("@glimmer/manager");

var _arguments = require("../vm/arguments");

var _owner = require("@glimmer/owner");

var _destroyable = require("@glimmer/destroyable");

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var ARGS_CACHES = _env.DEBUG ? new WeakMap() : undefined;

function getArgs(proxy) {
  return (0, _validator.getValue)(_env.DEBUG ? ARGS_CACHES.get(proxy) : proxy.argsCache);
}

var SimpleArgsProxy = /*#__PURE__*/function () {
  function SimpleArgsProxy(context, computeArgs) {
    if (computeArgs === void 0) {
      computeArgs = function computeArgs() {
        return _arguments.EMPTY_ARGS;
      };
    }

    var argsCache = (0, _validator.createCache)(function () {
      return computeArgs(context);
    });

    if (_env.DEBUG) {
      ARGS_CACHES.set(this, argsCache);
      Object.freeze(this);
    } else {
      this.argsCache = argsCache;
    }
  }

  _createClass(SimpleArgsProxy, [{
    key: "named",
    get: function get() {
      return getArgs(this).named || _arguments.EMPTY_NAMED;
    }
  }, {
    key: "positional",
    get: function get() {
      return getArgs(this).positional || _arguments.EMPTY_POSITIONAL;
    }
  }]);

  return SimpleArgsProxy;
}(); ////////////


function invokeHelper(context, definition, computeArgs) {
  if (_env.DEBUG && (typeof context !== 'object' || context === null)) {
    throw new Error("Expected a context object to be passed as the first parameter to invokeHelper, got " + context);
  }

  var owner = (0, _owner.getOwner)(context);
  var internalManager = (0, _manager.getInternalHelperManager)(definition); // TODO: figure out why assert isn't using the TS assert thing

  if (_env.DEBUG && !internalManager) {
    throw new Error("Expected a helper definition to be passed as the second parameter to invokeHelper, but no helper manager was found. The definition value that was passed was `" + (0, _util.debugToString)(definition) + "`. Did you use setHelperManager to associate a helper manager with this value?");
  }

  if (_env.DEBUG && typeof internalManager === 'function') {
    throw new Error('Found a helper manager, but it was an internal built-in helper manager. `invokeHelper` does not support internal helpers yet.');
  }

  var manager = internalManager.getDelegateFor(owner);
  var args = new SimpleArgsProxy(context, computeArgs);
  var bucket = manager.createHelper(definition, args);
  var cache;

  if ((0, _manager.hasValue)(manager)) {
    cache = (0, _validator.createCache)(function () {
      if (_env.DEBUG && ((0, _destroyable.isDestroying)(cache) || (0, _destroyable.isDestroyed)(cache))) {
        throw new Error("You attempted to get the value of a helper after the helper was destroyed, which is not allowed");
      }

      return manager.getValue(bucket);
    });
    (0, _destroyable.associateDestroyableChild)(context, cache);
  } else {
    throw new Error('TODO: unreachable, to be implemented with hasScheduledEffect');
  }

  if ((0, _manager.hasDestroyable)(manager)) {
    var destroyable = manager.getDestroyable(bucket);
    (0, _destroyable.associateDestroyableChild)(cache, destroyable);
  }

  return cache;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2hlbHBlcnMvaW52b2tlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBSSxXQUFXLEdBQUcsYUFBUSxJQUFILE9BQUcsRUFBUixHQUFsQixTQUFBOztBQUVBLFNBQUEsT0FBQSxDQUFBLEtBQUEsRUFBdUM7QUFDckMsU0FBTyx5QkFBUyxhQUFRLFdBQVksQ0FBWixHQUFBLENBQUgsS0FBRyxDQUFSLEdBQW1DLEtBQUssQ0FBeEQsU0FBTyxDQUFQO0FBQ0Q7O0lBRUQsZTtBQUdFLFdBQUEsZUFBQSxDQUFBLE9BQUEsRUFBQSxXQUFBLEVBRXlFO0FBQUEsUUFBdkUsV0FBdUUsS0FBQSxLQUFBLENBQUEsRUFBQTtBQUF2RSxNQUFBLFdBQXVFLEdBQWhCLFNBQUEsV0FBQSxHQUFBO0FBQUEsZUFGekQscUJBRXlEO0FBQWdCLE9BQXZFO0FBQXVFOztBQUV2RSxRQUFJLFNBQVMsR0FBRyw0QkFBWSxZQUFBO0FBQUEsYUFBTSxXQUFXLENBQTdDLE9BQTZDLENBQWpCO0FBQTVCLEtBQWdCLENBQWhCOztBQUVBLFFBQUEsVUFBQSxFQUFXO0FBQ1QsTUFBQSxXQUFZLENBQVosR0FBQSxDQUFBLElBQUEsRUFBQSxTQUFBO0FBQ0EsTUFBQSxNQUFNLENBQU4sTUFBQSxDQUFBLElBQUE7QUFGRixLQUFBLE1BR087QUFDTCxXQUFBLFNBQUEsR0FBQSxTQUFBO0FBQ0Q7QUFDRjs7Ozt3QkFFUTtBQUNQLGFBQU8sT0FBTyxDQUFQLElBQU8sQ0FBUCxDQUFBLEtBQUEsSUFBUCxzQkFBQTtBQUNEOzs7d0JBRWE7QUFDWixhQUFPLE9BQU8sQ0FBUCxJQUFPLENBQVAsQ0FBQSxVQUFBLElBQVAsMkJBQUE7QUFDRDs7OztLQUdIOzs7QUFFTSxTQUFBLFlBQUEsQ0FBQSxPQUFBLEVBQUEsVUFBQSxFQUFBLFdBQUEsRUFHaUQ7QUFFckQsTUFBSSxlQUFVLE9BQUEsT0FBQSxLQUFBLFFBQUEsSUFBK0IsT0FBTyxLQUFwRCxJQUFJLENBQUosRUFBZ0U7QUFDOUQsVUFBTSxJQUFBLEtBQUEsQ0FBQSx3RkFBTixPQUFNLENBQU47QUFHRDs7QUFFRCxNQUFNLEtBQUssR0FBRyxxQkFBZCxPQUFjLENBQWQ7QUFDQSxNQUFNLGVBQWUsR0FBRyx1Q0FUNkIsVUFTN0IsQ0FBeEIsQ0FUcUQsQ0FXckQ7O0FBQ0EsTUFBSSxjQUFTLENBQWIsZUFBQSxFQUErQjtBQUM3QixVQUFNLElBQUEsS0FBQSxDQUFBLG1LQUM4Six5QkFEcEssVUFDb0ssQ0FEOUosR0FBTixnRkFBTSxDQUFOO0FBS0Q7O0FBRUQsTUFBSSxjQUFTLE9BQUEsZUFBQSxLQUFiLFVBQUEsRUFBb0Q7QUFDbEQsVUFBTSxJQUFBLEtBQUEsQ0FBTiwrSEFBTSxDQUFOO0FBR0Q7O0FBRUQsTUFBTSxPQUFPLEdBQUksZUFBaUQsQ0FBakQsY0FBQSxDQUFqQixLQUFpQixDQUFqQjtBQUNBLE1BQUksSUFBSSxHQUFHLElBQUEsZUFBQSxDQUFBLE9BQUEsRUFBWCxXQUFXLENBQVg7QUFDQSxNQUFJLE1BQU0sR0FBRyxPQUFPLENBQVAsWUFBQSxDQUFBLFVBQUEsRUFBYixJQUFhLENBQWI7QUFFQSxNQUFBLEtBQUE7O0FBRUEsTUFBSSx1QkFBSixPQUFJLENBQUosRUFBdUI7QUFDckIsSUFBQSxLQUFLLEdBQUcsNEJBQVksWUFBSztBQUN2QixVQUFJLGVBQVUsK0JBQUEsS0FBQSxLQUF1Qiw4QkFBckMsS0FBcUMsQ0FBakMsQ0FBSixFQUEwRDtBQUN4RCxjQUFNLElBQU4sS0FBTSxDQUFOLGlHQUFNLENBQU47QUFHRDs7QUFFRCxhQUFPLE9BQU8sQ0FBUCxRQUFBLENBQVAsTUFBTyxDQUFQO0FBUEYsS0FBUSxDQUFSO0FBVUEsZ0RBQXlCLE9BQXpCLEVBQUEsS0FBQTtBQVhGLEdBQUEsTUFZTztBQUNMLFVBQU0sSUFBQSxLQUFBLENBQU4sOERBQU0sQ0FBTjtBQUNEOztBQUVELE1BQUksNkJBQUosT0FBSSxDQUFKLEVBQTZCO0FBQzNCLFFBQUksV0FBVyxHQUFHLE9BQU8sQ0FBUCxjQUFBLENBQWxCLE1BQWtCLENBQWxCO0FBRUEsZ0RBQXlCLEtBQXpCLEVBQUEsV0FBQTtBQUNEOztBQUVELFNBQUEsS0FBQTtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHsgQ2FjaGUsIGNyZWF0ZUNhY2hlLCBnZXRWYWx1ZSB9IGZyb20gJ0BnbGltbWVyL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBBcmd1bWVudHMsIEludGVybmFsSGVscGVyTWFuYWdlciB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgZGVidWdUb1N0cmluZyB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgZ2V0SW50ZXJuYWxIZWxwZXJNYW5hZ2VyLCBoYXNEZXN0cm95YWJsZSwgaGFzVmFsdWUgfSBmcm9tICdAZ2xpbW1lci9tYW5hZ2VyJztcblxuaW1wb3J0IHsgRU1QVFlfQVJHUywgRU1QVFlfTkFNRUQsIEVNUFRZX1BPU0lUSU9OQUwgfSBmcm9tICcuLi92bS9hcmd1bWVudHMnO1xuaW1wb3J0IHsgZ2V0T3duZXIgfSBmcm9tICdAZ2xpbW1lci9vd25lcic7XG5pbXBvcnQgeyBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkLCBpc0Rlc3Ryb3llZCwgaXNEZXN0cm95aW5nIH0gZnJvbSAnQGdsaW1tZXIvZGVzdHJveWFibGUnO1xuXG5sZXQgQVJHU19DQUNIRVMgPSBERUJVRyA/IG5ldyBXZWFrTWFwPFNpbXBsZUFyZ3NQcm94eSwgQ2FjaGU8UGFydGlhbDxBcmd1bWVudHM+Pj4oKSA6IHVuZGVmaW5lZDtcblxuZnVuY3Rpb24gZ2V0QXJncyhwcm94eTogU2ltcGxlQXJnc1Byb3h5KTogUGFydGlhbDxBcmd1bWVudHM+IHtcbiAgcmV0dXJuIGdldFZhbHVlKERFQlVHID8gQVJHU19DQUNIRVMhLmdldChwcm94eSkhIDogcHJveHkuYXJnc0NhY2hlISkhO1xufVxuXG5jbGFzcyBTaW1wbGVBcmdzUHJveHkge1xuICBhcmdzQ2FjaGU/OiBDYWNoZTxQYXJ0aWFsPEFyZ3VtZW50cz4+O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGNvbnRleHQ6IG9iamVjdCxcbiAgICBjb21wdXRlQXJnczogKGNvbnRleHQ6IG9iamVjdCkgPT4gUGFydGlhbDxBcmd1bWVudHM+ID0gKCkgPT4gRU1QVFlfQVJHU1xuICApIHtcbiAgICBsZXQgYXJnc0NhY2hlID0gY3JlYXRlQ2FjaGUoKCkgPT4gY29tcHV0ZUFyZ3MoY29udGV4dCkpO1xuXG4gICAgaWYgKERFQlVHKSB7XG4gICAgICBBUkdTX0NBQ0hFUyEuc2V0KHRoaXMsIGFyZ3NDYWNoZSk7XG4gICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFyZ3NDYWNoZSA9IGFyZ3NDYWNoZTtcbiAgICB9XG4gIH1cblxuICBnZXQgbmFtZWQoKSB7XG4gICAgcmV0dXJuIGdldEFyZ3ModGhpcykubmFtZWQgfHwgRU1QVFlfTkFNRUQ7XG4gIH1cblxuICBnZXQgcG9zaXRpb25hbCgpIHtcbiAgICByZXR1cm4gZ2V0QXJncyh0aGlzKS5wb3NpdGlvbmFsIHx8IEVNUFRZX1BPU0lUSU9OQUw7XG4gIH1cbn1cblxuLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZva2VIZWxwZXIoXG4gIGNvbnRleHQ6IG9iamVjdCxcbiAgZGVmaW5pdGlvbjogb2JqZWN0LFxuICBjb21wdXRlQXJncz86IChjb250ZXh0OiBvYmplY3QpID0+IFBhcnRpYWw8QXJndW1lbnRzPlxuKTogQ2FjaGU8dW5rbm93bj4ge1xuICBpZiAoREVCVUcgJiYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JyB8fCBjb250ZXh0ID09PSBudWxsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBFeHBlY3RlZCBhIGNvbnRleHQgb2JqZWN0IHRvIGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIHRvIGludm9rZUhlbHBlciwgZ290ICR7Y29udGV4dH1gXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IG93bmVyID0gZ2V0T3duZXIoY29udGV4dCk7XG4gIGNvbnN0IGludGVybmFsTWFuYWdlciA9IGdldEludGVybmFsSGVscGVyTWFuYWdlcihkZWZpbml0aW9uKSE7XG5cbiAgLy8gVE9ETzogZmlndXJlIG91dCB3aHkgYXNzZXJ0IGlzbid0IHVzaW5nIHRoZSBUUyBhc3NlcnQgdGhpbmdcbiAgaWYgKERFQlVHICYmICFpbnRlcm5hbE1hbmFnZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBoZWxwZXIgZGVmaW5pdGlvbiB0byBiZSBwYXNzZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gaW52b2tlSGVscGVyLCBidXQgbm8gaGVscGVyIG1hbmFnZXIgd2FzIGZvdW5kLiBUaGUgZGVmaW5pdGlvbiB2YWx1ZSB0aGF0IHdhcyBwYXNzZWQgd2FzIFxcYCR7ZGVidWdUb1N0cmluZyEoXG4gICAgICAgIGRlZmluaXRpb25cbiAgICAgICl9XFxgLiBEaWQgeW91IHVzZSBzZXRIZWxwZXJNYW5hZ2VyIHRvIGFzc29jaWF0ZSBhIGhlbHBlciBtYW5hZ2VyIHdpdGggdGhpcyB2YWx1ZT9gXG4gICAgKTtcbiAgfVxuXG4gIGlmIChERUJVRyAmJiB0eXBlb2YgaW50ZXJuYWxNYW5hZ2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ZvdW5kIGEgaGVscGVyIG1hbmFnZXIsIGJ1dCBpdCB3YXMgYW4gaW50ZXJuYWwgYnVpbHQtaW4gaGVscGVyIG1hbmFnZXIuIGBpbnZva2VIZWxwZXJgIGRvZXMgbm90IHN1cHBvcnQgaW50ZXJuYWwgaGVscGVycyB5ZXQuJ1xuICAgICk7XG4gIH1cblxuICBjb25zdCBtYW5hZ2VyID0gKGludGVybmFsTWFuYWdlciBhcyBJbnRlcm5hbEhlbHBlck1hbmFnZXI8b2JqZWN0PikuZ2V0RGVsZWdhdGVGb3Iob3duZXIpO1xuICBsZXQgYXJncyA9IG5ldyBTaW1wbGVBcmdzUHJveHkoY29udGV4dCwgY29tcHV0ZUFyZ3MpO1xuICBsZXQgYnVja2V0ID0gbWFuYWdlci5jcmVhdGVIZWxwZXIoZGVmaW5pdGlvbiwgYXJncyk7XG5cbiAgbGV0IGNhY2hlOiBDYWNoZTx1bmtub3duPjtcblxuICBpZiAoaGFzVmFsdWUobWFuYWdlcikpIHtcbiAgICBjYWNoZSA9IGNyZWF0ZUNhY2hlKCgpID0+IHtcbiAgICAgIGlmIChERUJVRyAmJiAoaXNEZXN0cm95aW5nKGNhY2hlKSB8fCBpc0Rlc3Ryb3llZChjYWNoZSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IGF0dGVtcHRlZCB0byBnZXQgdGhlIHZhbHVlIG9mIGEgaGVscGVyIGFmdGVyIHRoZSBoZWxwZXIgd2FzIGRlc3Ryb3llZCwgd2hpY2ggaXMgbm90IGFsbG93ZWRgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYW5hZ2VyLmdldFZhbHVlKGJ1Y2tldCk7XG4gICAgfSk7XG5cbiAgICBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkKGNvbnRleHQsIGNhY2hlKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RPRE86IHVucmVhY2hhYmxlLCB0byBiZSBpbXBsZW1lbnRlZCB3aXRoIGhhc1NjaGVkdWxlZEVmZmVjdCcpO1xuICB9XG5cbiAgaWYgKGhhc0Rlc3Ryb3lhYmxlKG1hbmFnZXIpKSB7XG4gICAgbGV0IGRlc3Ryb3lhYmxlID0gbWFuYWdlci5nZXREZXN0cm95YWJsZShidWNrZXQpO1xuXG4gICAgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZChjYWNoZSwgZGVzdHJveWFibGUpO1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==