"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Ref = void 0;

var _env = require("@glimmer/env");

var _util = require("@glimmer/util");

var _arguments = require("./vm/arguments");

var GUID = 0;

var Ref = /*#__PURE__*/function () {
  function Ref(value) {
    this.id = GUID++;
    this.value = value;
  }

  var _proto = Ref.prototype;

  _proto.get = function get() {
    return this.value;
  };

  _proto.release = function release() {
    if (_env.DEBUG && this.value === null) {
      throw new Error('BUG: double release?');
    }

    this.value = null;
  };

  _proto.toString = function toString() {
    var label = "Ref " + this.id;

    if (this.value === null) {
      return label + " (released)";
    } else {
      try {
        return label + ": " + this.value;
      } catch (_a) {
        return label;
      }
    }
  };

  return Ref;
}();

exports.Ref = Ref;

var DebugRenderTreeImpl = /*#__PURE__*/function () {
  function DebugRenderTreeImpl() {
    this.stack = new _util.Stack();
    this.refs = new WeakMap();
    this.roots = new Set();
    this.nodes = new WeakMap();
  }

  var _proto2 = DebugRenderTreeImpl.prototype;

  _proto2.begin = function begin() {
    this.reset();
  };

  _proto2.create = function create(state, node) {
    var internalNode = (0, _util.assign)({}, node, {
      bounds: null,
      refs: new Set()
    });
    this.nodes.set(state, internalNode);
    this.appendChild(internalNode, state);
    this.enter(state);
  };

  _proto2.update = function update(state) {
    this.enter(state);
  };

  _proto2.didRender = function didRender(state, bounds) {
    if (_env.DEBUG && this.stack.current !== state) {
      throw new Error("BUG: expecting " + this.stack.current + ", got " + state);
    }

    this.nodeFor(state).bounds = bounds;
    this.exit();
  };

  _proto2.willDestroy = function willDestroy(state) {
    this.refs.get(state).release();
  };

  _proto2.commit = function commit() {
    this.reset();
  };

  _proto2.capture = function capture() {
    return this.captureRefs(this.roots);
  };

  _proto2.reset = function reset() {
    if (this.stack.size !== 0) {
      // We probably encountered an error during the rendering loop. This will
      // likely trigger undefined behavior and memory leaks as the error left
      // things in an inconsistent state. It is recommended that the user
      // refresh the page.
      // TODO: We could warn here? But this happens all the time in our tests?
      // Clean up the root reference to prevent errors from happening if we
      // attempt to capture the render tree (Ember Inspector may do this)
      var root = this.stack.toArray()[0];
      var ref = this.refs.get(root);

      if (ref !== undefined) {
        this.roots["delete"](ref);
      }

      while (!this.stack.isEmpty()) {
        this.stack.pop();
      }
    }
  };

  _proto2.enter = function enter(state) {
    this.stack.push(state);
  };

  _proto2.exit = function exit() {
    if (_env.DEBUG && this.stack.size === 0) {
      throw new Error('BUG: unbalanced pop');
    }

    this.stack.pop();
  };

  _proto2.nodeFor = function nodeFor(state) {
    return this.nodes.get(state);
  };

  _proto2.appendChild = function appendChild(node, state) {
    if (_env.DEBUG && this.refs.has(state)) {
      throw new Error('BUG: child already appended');
    }

    var parent = this.stack.current;
    var ref = new Ref(state);
    this.refs.set(state, ref);

    if (parent) {
      var parentNode = this.nodeFor(parent);
      parentNode.refs.add(ref);
      node.parent = parentNode;
    } else {
      this.roots.add(ref);
    }
  };

  _proto2.captureRefs = function captureRefs(refs) {
    var _this = this;

    var captured = [];
    refs.forEach(function (ref) {
      var state = ref.get();

      if (state) {
        captured.push(_this.captureNode("render-node:" + ref.id, state));
      } else {
        refs["delete"](ref);
      }
    });
    return captured;
  };

  _proto2.captureNode = function captureNode(id, state) {
    var node = this.nodeFor(state);
    var type = node.type,
        name = node.name,
        args = node.args,
        instance = node.instance,
        refs = node.refs;
    var template = this.captureTemplate(node);
    var bounds = this.captureBounds(node);
    var children = this.captureRefs(refs);
    return {
      id: id,
      type: type,
      name: name,
      args: (0, _arguments.reifyArgs)(args),
      instance: instance,
      template: template,
      bounds: bounds,
      children: children
    };
  };

  _proto2.captureTemplate = function captureTemplate(_ref) {
    var template = _ref.template;
    return template || null;
  };

  _proto2.captureBounds = function captureBounds(node) {
    var bounds = node.bounds;
    var parentElement = bounds.parentElement();
    var firstNode = bounds.firstNode();
    var lastNode = bounds.lastNode();
    return {
      parentElement: parentElement,
      firstNode: firstNode,
      lastNode: lastNode
    };
  };

  return DebugRenderTreeImpl;
}();

exports.default = DebugRenderTreeImpl;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2RlYnVnLXJlbmRlci10cmVlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFRQTs7QUFDQTs7QUFRQSxJQUFJLElBQUksR0FBUixDQUFBOztBQUVBLElBQU0sR0FBTixHQUFBLGFBQUEsWUFBQTtBQUlFLFdBQUEsR0FBQSxDQUFBLEtBQUEsRUFBb0I7QUFIWCxTQUFBLEVBQUEsR0FBYSxJQUFiLEVBQUE7QUFJUCxTQUFBLEtBQUEsR0FBQSxLQUFBO0FBQ0Q7O0FBTkgsTUFBQSxNQUFBLEdBQUEsR0FBQSxDQUFBLFNBQUE7O0FBQUEsRUFBQSxNQUFBLENBQUEsR0FBQSxHQVFFLFNBQUEsR0FBQSxHQUFHO0FBQ0QsV0FBTyxLQUFQLEtBQUE7QUFUSixHQUFBOztBQUFBLEVBQUEsTUFBQSxDQUFBLE9BQUEsR0FZRSxTQUFBLE9BQUEsR0FBTztBQUNMLFFBQUksY0FBUyxLQUFBLEtBQUEsS0FBYixJQUFBLEVBQWtDO0FBQ2hDLFlBQU0sSUFBQSxLQUFBLENBQU4sc0JBQU0sQ0FBTjtBQUNEOztBQUVELFNBQUEsS0FBQSxHQUFBLElBQUE7QUFqQkosR0FBQTs7QUFBQSxFQUFBLE1BQUEsQ0FBQSxRQUFBLEdBb0JFLFNBQUEsUUFBQSxHQUFRO0FBQ04sUUFBSSxLQUFLLEdBQUEsU0FBVSxLQUFuQixFQUFBOztBQUVBLFFBQUksS0FBQSxLQUFBLEtBQUosSUFBQSxFQUF5QjtBQUN2QixhQUFBLEtBQUEsR0FBQSxhQUFBO0FBREYsS0FBQSxNQUVPO0FBQ0wsVUFBSTtBQUNGLGVBQVUsS0FBVixHQUFBLElBQVUsR0FBVSxLQUFwQixLQUFBO0FBREYsT0FBQSxDQUVFLE9BQUEsRUFBQSxFQUFNO0FBQ04sZUFBQSxLQUFBO0FBQ0Q7QUFDRjtBQS9CTCxHQUFBOztBQUFBLFNBQUEsR0FBQTtBQUFBLENBQUEsRUFBQTs7OztJQW1DYyxtQjtBQUFkLFdBQUEsbUJBQUEs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QUFQIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHtcbiAgQm91bmRzLFxuICBDYXB0dXJlZFJlbmRlck5vZGUsXG4gIERlYnVnUmVuZGVyVHJlZSxcbiAgT3B0aW9uLFxuICBSZW5kZXJOb2RlLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGV4cGVjdCwgYXNzaWduLCBTdGFjayB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgcmVpZnlBcmdzIH0gZnJvbSAnLi92bS9hcmd1bWVudHMnO1xuXG5pbnRlcmZhY2UgSW50ZXJuYWxSZW5kZXJOb2RlPFQgZXh0ZW5kcyBvYmplY3Q+IGV4dGVuZHMgUmVuZGVyTm9kZSB7XG4gIGJvdW5kczogT3B0aW9uPEJvdW5kcz47XG4gIHJlZnM6IFNldDxSZWY8VD4+O1xuICBwYXJlbnQ/OiBJbnRlcm5hbFJlbmRlck5vZGU8VD47XG59XG5cbmxldCBHVUlEID0gMDtcblxuZXhwb3J0IGNsYXNzIFJlZjxUIGV4dGVuZHMgb2JqZWN0PiB7XG4gIHJlYWRvbmx5IGlkOiBudW1iZXIgPSBHVUlEKys7XG4gIHByaXZhdGUgdmFsdWU6IE9wdGlvbjxUPjtcblxuICBjb25zdHJ1Y3Rvcih2YWx1ZTogVCkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCgpOiBPcHRpb248VD4ge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbiAgcmVsZWFzZSgpOiB2b2lkIHtcbiAgICBpZiAoREVCVUcgJiYgdGhpcy52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCVUc6IGRvdWJsZSByZWxlYXNlPycpO1xuICAgIH1cblxuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICB9XG5cbiAgdG9TdHJpbmcoKTogU3RyaW5nIHtcbiAgICBsZXQgbGFiZWwgPSBgUmVmICR7dGhpcy5pZH1gO1xuXG4gICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBgJHtsYWJlbH0gKHJlbGVhc2VkKWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBgJHtsYWJlbH06ICR7dGhpcy52YWx1ZX1gO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVidWdSZW5kZXJUcmVlSW1wbDxUQnVja2V0IGV4dGVuZHMgb2JqZWN0PlxuICBpbXBsZW1lbnRzIERlYnVnUmVuZGVyVHJlZTxUQnVja2V0PiB7XG4gIHByaXZhdGUgc3RhY2sgPSBuZXcgU3RhY2s8VEJ1Y2tldD4oKTtcblxuICBwcml2YXRlIHJlZnMgPSBuZXcgV2Vha01hcDxUQnVja2V0LCBSZWY8VEJ1Y2tldD4+KCk7XG4gIHByaXZhdGUgcm9vdHMgPSBuZXcgU2V0PFJlZjxUQnVja2V0Pj4oKTtcbiAgcHJpdmF0ZSBub2RlcyA9IG5ldyBXZWFrTWFwPFRCdWNrZXQsIEludGVybmFsUmVuZGVyTm9kZTxUQnVja2V0Pj4oKTtcblxuICBiZWdpbigpOiB2b2lkIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICBjcmVhdGUoc3RhdGU6IFRCdWNrZXQsIG5vZGU6IFJlbmRlck5vZGUpOiB2b2lkIHtcbiAgICBsZXQgaW50ZXJuYWxOb2RlOiBJbnRlcm5hbFJlbmRlck5vZGU8VEJ1Y2tldD4gPSBhc3NpZ24oe30sIG5vZGUsIHtcbiAgICAgIGJvdW5kczogbnVsbCxcbiAgICAgIHJlZnM6IG5ldyBTZXQ8UmVmPFRCdWNrZXQ+PigpLFxuICAgIH0pO1xuICAgIHRoaXMubm9kZXMuc2V0KHN0YXRlLCBpbnRlcm5hbE5vZGUpO1xuICAgIHRoaXMuYXBwZW5kQ2hpbGQoaW50ZXJuYWxOb2RlLCBzdGF0ZSk7XG4gICAgdGhpcy5lbnRlcihzdGF0ZSk7XG4gIH1cblxuICB1cGRhdGUoc3RhdGU6IFRCdWNrZXQpOiB2b2lkIHtcbiAgICB0aGlzLmVudGVyKHN0YXRlKTtcbiAgfVxuXG4gIGRpZFJlbmRlcihzdGF0ZTogVEJ1Y2tldCwgYm91bmRzOiBCb3VuZHMpOiB2b2lkIHtcbiAgICBpZiAoREVCVUcgJiYgdGhpcy5zdGFjay5jdXJyZW50ICE9PSBzdGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCVUc6IGV4cGVjdGluZyAke3RoaXMuc3RhY2suY3VycmVudH0sIGdvdCAke3N0YXRlfWApO1xuICAgIH1cblxuICAgIHRoaXMubm9kZUZvcihzdGF0ZSkuYm91bmRzID0gYm91bmRzO1xuICAgIHRoaXMuZXhpdCgpO1xuICB9XG5cbiAgd2lsbERlc3Ryb3koc3RhdGU6IFRCdWNrZXQpOiB2b2lkIHtcbiAgICBleHBlY3QodGhpcy5yZWZzLmdldChzdGF0ZSksICdCVUc6IG1pc3NpbmcgcmVmJykucmVsZWFzZSgpO1xuICB9XG5cbiAgY29tbWl0KCk6IHZvaWQge1xuICAgIHRoaXMucmVzZXQoKTtcbiAgfVxuXG4gIGNhcHR1cmUoKTogQ2FwdHVyZWRSZW5kZXJOb2RlW10ge1xuICAgIHJldHVybiB0aGlzLmNhcHR1cmVSZWZzKHRoaXMucm9vdHMpO1xuICB9XG5cbiAgcHJpdmF0ZSByZXNldCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zdGFjay5zaXplICE9PSAwKSB7XG4gICAgICAvLyBXZSBwcm9iYWJseSBlbmNvdW50ZXJlZCBhbiBlcnJvciBkdXJpbmcgdGhlIHJlbmRlcmluZyBsb29wLiBUaGlzIHdpbGxcbiAgICAgIC8vIGxpa2VseSB0cmlnZ2VyIHVuZGVmaW5lZCBiZWhhdmlvciBhbmQgbWVtb3J5IGxlYWtzIGFzIHRoZSBlcnJvciBsZWZ0XG4gICAgICAvLyB0aGluZ3MgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBJdCBpcyByZWNvbW1lbmRlZCB0aGF0IHRoZSB1c2VyXG4gICAgICAvLyByZWZyZXNoIHRoZSBwYWdlLlxuXG4gICAgICAvLyBUT0RPOiBXZSBjb3VsZCB3YXJuIGhlcmU/IEJ1dCB0aGlzIGhhcHBlbnMgYWxsIHRoZSB0aW1lIGluIG91ciB0ZXN0cz9cblxuICAgICAgLy8gQ2xlYW4gdXAgdGhlIHJvb3QgcmVmZXJlbmNlIHRvIHByZXZlbnQgZXJyb3JzIGZyb20gaGFwcGVuaW5nIGlmIHdlXG4gICAgICAvLyBhdHRlbXB0IHRvIGNhcHR1cmUgdGhlIHJlbmRlciB0cmVlIChFbWJlciBJbnNwZWN0b3IgbWF5IGRvIHRoaXMpXG4gICAgICBsZXQgcm9vdCA9IGV4cGVjdCh0aGlzLnN0YWNrLnRvQXJyYXkoKVswXSwgJ2V4cGVjdGVkIHJvb3Qgc3RhdGUgd2hlbiByZXNldHRpbmcgcmVuZGVyIHRyZWUnKTtcbiAgICAgIGxldCByZWYgPSB0aGlzLnJlZnMuZ2V0KHJvb3QpO1xuXG4gICAgICBpZiAocmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5yb290cy5kZWxldGUocmVmKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKCF0aGlzLnN0YWNrLmlzRW1wdHkoKSkge1xuICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZW50ZXIoc3RhdGU6IFRCdWNrZXQpOiB2b2lkIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goc3RhdGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBleGl0KCk6IHZvaWQge1xuICAgIGlmIChERUJVRyAmJiB0aGlzLnN0YWNrLnNpemUgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQlVHOiB1bmJhbGFuY2VkIHBvcCcpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gIH1cblxuICBwcml2YXRlIG5vZGVGb3Ioc3RhdGU6IFRCdWNrZXQpOiBJbnRlcm5hbFJlbmRlck5vZGU8VEJ1Y2tldD4ge1xuICAgIHJldHVybiBleHBlY3QodGhpcy5ub2Rlcy5nZXQoc3RhdGUpLCAnQlVHOiBtaXNzaW5nIG5vZGUnKTtcbiAgfVxuXG4gIHByaXZhdGUgYXBwZW5kQ2hpbGQobm9kZTogSW50ZXJuYWxSZW5kZXJOb2RlPFRCdWNrZXQ+LCBzdGF0ZTogVEJ1Y2tldCk6IHZvaWQge1xuICAgIGlmIChERUJVRyAmJiB0aGlzLnJlZnMuaGFzKHN0YXRlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCVUc6IGNoaWxkIGFscmVhZHkgYXBwZW5kZWQnKTtcbiAgICB9XG5cbiAgICBsZXQgcGFyZW50ID0gdGhpcy5zdGFjay5jdXJyZW50O1xuICAgIGxldCByZWYgPSBuZXcgUmVmKHN0YXRlKTtcblxuICAgIHRoaXMucmVmcy5zZXQoc3RhdGUsIHJlZik7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBsZXQgcGFyZW50Tm9kZSA9IHRoaXMubm9kZUZvcihwYXJlbnQpO1xuICAgICAgcGFyZW50Tm9kZS5yZWZzLmFkZChyZWYpO1xuICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvb3RzLmFkZChyZWYpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2FwdHVyZVJlZnMocmVmczogU2V0PFJlZjxUQnVja2V0Pj4pOiBDYXB0dXJlZFJlbmRlck5vZGVbXSB7XG4gICAgbGV0IGNhcHR1cmVkOiBDYXB0dXJlZFJlbmRlck5vZGVbXSA9IFtdO1xuXG4gICAgcmVmcy5mb3JFYWNoKChyZWYpID0+IHtcbiAgICAgIGxldCBzdGF0ZSA9IHJlZi5nZXQoKTtcblxuICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgIGNhcHR1cmVkLnB1c2godGhpcy5jYXB0dXJlTm9kZShgcmVuZGVyLW5vZGU6JHtyZWYuaWR9YCwgc3RhdGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnMuZGVsZXRlKHJlZik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FwdHVyZWQ7XG4gIH1cblxuICBwcml2YXRlIGNhcHR1cmVOb2RlKGlkOiBzdHJpbmcsIHN0YXRlOiBUQnVja2V0KTogQ2FwdHVyZWRSZW5kZXJOb2RlIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMubm9kZUZvcihzdGF0ZSk7XG4gICAgbGV0IHsgdHlwZSwgbmFtZSwgYXJncywgaW5zdGFuY2UsIHJlZnMgfSA9IG5vZGU7XG4gICAgbGV0IHRlbXBsYXRlID0gdGhpcy5jYXB0dXJlVGVtcGxhdGUobm9kZSk7XG4gICAgbGV0IGJvdW5kcyA9IHRoaXMuY2FwdHVyZUJvdW5kcyhub2RlKTtcbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNhcHR1cmVSZWZzKHJlZnMpO1xuICAgIHJldHVybiB7IGlkLCB0eXBlLCBuYW1lLCBhcmdzOiByZWlmeUFyZ3MoYXJncyksIGluc3RhbmNlLCB0ZW1wbGF0ZSwgYm91bmRzLCBjaGlsZHJlbiB9O1xuICB9XG5cbiAgcHJpdmF0ZSBjYXB0dXJlVGVtcGxhdGUoeyB0ZW1wbGF0ZSB9OiBJbnRlcm5hbFJlbmRlck5vZGU8VEJ1Y2tldD4pOiBPcHRpb248c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRlbXBsYXRlIHx8IG51bGw7XG4gIH1cblxuICBwcml2YXRlIGNhcHR1cmVCb3VuZHMobm9kZTogSW50ZXJuYWxSZW5kZXJOb2RlPFRCdWNrZXQ+KTogQ2FwdHVyZWRSZW5kZXJOb2RlWydib3VuZHMnXSB7XG4gICAgbGV0IGJvdW5kcyA9IGV4cGVjdChub2RlLmJvdW5kcywgJ0JVRzogbWlzc2luZyBib3VuZHMnKTtcbiAgICBsZXQgcGFyZW50RWxlbWVudCA9IGJvdW5kcy5wYXJlbnRFbGVtZW50KCk7XG4gICAgbGV0IGZpcnN0Tm9kZSA9IGJvdW5kcy5maXJzdE5vZGUoKTtcbiAgICBsZXQgbGFzdE5vZGUgPSBib3VuZHMubGFzdE5vZGUoKTtcbiAgICByZXR1cm4geyBwYXJlbnRFbGVtZW50LCBmaXJzdE5vZGUsIGxhc3ROb2RlIH07XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=