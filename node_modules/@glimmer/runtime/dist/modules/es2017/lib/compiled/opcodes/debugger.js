import { childRefFor, valueForRef } from '@glimmer/reference';
import { dict, decodeHandle } from '@glimmer/util';
import { APPEND_OPCODES } from '../../opcodes';
import { CONSTANTS } from '../../symbols';

function debugCallback(context, get) {
  // eslint-disable-next-line no-console
  console.info('Use `context`, and `get(<path>)` to debug this template.'); // for example...
  // eslint-disable-next-line no-unused-expressions

  context === get('this'); // eslint-disable-next-line no-debugger

  debugger;
}

let callback = debugCallback; // For testing purposes

export function setDebuggerCallback(cb) {
  callback = cb;
}
export function resetDebuggerCallback() {
  callback = debugCallback;
}

class ScopeInspector {
  constructor(scope, symbols, evalInfo) {
    this.scope = scope;
    this.locals = dict();

    for (let i = 0; i < evalInfo.length; i++) {
      let slot = evalInfo[i];
      let name = symbols[slot - 1];
      let ref = scope.getSymbol(slot);
      this.locals[name] = ref;
    }
  }

  get(path) {
    let {
      scope,
      locals
    } = this;
    let parts = path.split('.');
    let [head, ...tail] = path.split('.');
    let evalScope = scope.getEvalScope();
    let ref;

    if (head === 'this') {
      ref = scope.getSelf();
    } else if (locals[head]) {
      ref = locals[head];
    } else if (head.indexOf('@') === 0 && evalScope[head]) {
      ref = evalScope[head];
    } else {
      ref = this.scope.getSelf();
      tail = parts;
    }

    return tail.reduce((r, part) => childRefFor(r, part), ref);
  }

}

APPEND_OPCODES.add(103
/* Debugger */
, (vm, {
  op1: _symbols,
  op2: _evalInfo
}) => {
  let symbols = vm[CONSTANTS].getArray(_symbols);
  let evalInfo = vm[CONSTANTS].getArray(decodeHandle(_evalInfo));
  let inspector = new ScopeInspector(vm.scope(), symbols, evalInfo);
  callback(valueForRef(vm.getSelf()), path => valueForRef(inspector.get(path)));
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2NvbXBpbGVkL29wY29kZXMvZGVidWdnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsU0FBb0IsV0FBcEIsRUFBaUMsV0FBakMsUUFBb0Qsb0JBQXBEO0FBQ0EsU0FBUyxJQUFULEVBQWUsWUFBZixRQUFtQyxlQUFuQztBQUNBLFNBQVMsY0FBVCxRQUErQixlQUEvQjtBQUNBLFNBQVMsU0FBVCxRQUEwQixlQUExQjs7QUFNQSxTQUFTLGFBQVQsQ0FBdUIsT0FBdkIsRUFBeUMsR0FBekMsRUFBc0Q7QUFDcEQ7QUFDQSxFQUFBLE9BQU8sQ0FBQyxJQUFSLENBQWEsMERBQWIsRUFGb0QsQ0FJcEQ7QUFDQTs7QUFDQSxFQUFBLE9BQU8sS0FBSyxHQUFHLENBQUMsTUFBRCxDQUFmLENBTm9ELENBUXBEOztBQUNBO0FBQ0Q7O0FBRUQsSUFBSSxRQUFRLEdBQUcsYUFBZixDLENBRUE7O0FBQ0EsT0FBTSxTQUFVLG1CQUFWLENBQThCLEVBQTlCLEVBQStDO0FBQ25ELEVBQUEsUUFBUSxHQUFHLEVBQVg7QUFDRDtBQUVELE9BQU0sU0FBVSxxQkFBVixHQUErQjtBQUNuQyxFQUFBLFFBQVEsR0FBRyxhQUFYO0FBQ0Q7O0FBRUQsTUFBTSxjQUFOLENBQW9CO0FBR2xCLEVBQUEsV0FBQSxDQUFvQixLQUFwQixFQUFrQyxPQUFsQyxFQUFxRCxRQUFyRCxFQUF1RTtBQUFuRCxTQUFBLEtBQUEsR0FBQSxLQUFBO0FBRlosU0FBQSxNQUFBLEdBQVMsSUFBSSxFQUFiOztBQUdOLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBYixFQUFnQixDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQTdCLEVBQXFDLENBQUMsRUFBdEMsRUFBMEM7QUFDeEMsVUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLENBQUQsQ0FBbkI7QUFDQSxVQUFJLElBQUksR0FBRyxPQUFPLENBQUMsSUFBSSxHQUFHLENBQVIsQ0FBbEI7QUFDQSxVQUFJLEdBQUcsR0FBRyxLQUFLLENBQUMsU0FBTixDQUFnQixJQUFoQixDQUFWO0FBQ0EsV0FBSyxNQUFMLENBQVksSUFBWixJQUFvQixHQUFwQjtBQUNEO0FBQ0Y7O0FBRUQsRUFBQSxHQUFHLENBQUMsSUFBRCxFQUFhO0FBQ2QsUUFBSTtBQUFFLE1BQUEsS0FBRjtBQUFTLE1BQUE7QUFBVCxRQUFvQixJQUF4QjtBQUNBLFFBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsR0FBWCxDQUFaO0FBQ0EsUUFBSSxDQUFDLElBQUQsRUFBTyxHQUFHLElBQVYsSUFBa0IsSUFBSSxDQUFDLEtBQUwsQ0FBVyxHQUFYLENBQXRCO0FBRUEsUUFBSSxTQUFTLEdBQUcsS0FBSyxDQUFDLFlBQU4sRUFBaEI7QUFDQSxRQUFJLEdBQUo7O0FBRUEsUUFBSSxJQUFJLEtBQUssTUFBYixFQUFxQjtBQUNuQixNQUFBLEdBQUcsR0FBRyxLQUFLLENBQUMsT0FBTixFQUFOO0FBQ0QsS0FGRCxNQUVPLElBQUksTUFBTSxDQUFDLElBQUQsQ0FBVixFQUFrQjtBQUN2QixNQUFBLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBRCxDQUFaO0FBQ0QsS0FGTSxNQUVBLElBQUksSUFBSSxDQUFDLE9BQUwsQ0FBYSxHQUFiLE1BQXNCLENBQXRCLElBQTJCLFNBQVMsQ0FBQyxJQUFELENBQXhDLEVBQWdEO0FBQ3JELE1BQUEsR0FBRyxHQUFHLFNBQVMsQ0FBQyxJQUFELENBQWY7QUFDRCxLQUZNLE1BRUE7QUFDTCxNQUFBLEdBQUcsR0FBRyxLQUFLLEtBQUwsQ0FBVyxPQUFYLEVBQU47QUFDQSxNQUFBLElBQUksR0FBRyxLQUFQO0FBQ0Q7O0FBRUQsV0FBTyxJQUFJLENBQUMsTUFBTCxDQUFZLENBQUMsQ0FBRCxFQUFJLElBQUosS0FBYSxXQUFXLENBQUMsQ0FBRCxFQUFJLElBQUosQ0FBcEMsRUFBK0MsR0FBL0MsQ0FBUDtBQUNEOztBQWhDaUI7O0FBbUNwQixjQUFjLENBQUMsR0FBZixDQUFrQjtBQUFBO0FBQWxCLEVBQWdDLENBQUMsRUFBRCxFQUFLO0FBQUUsRUFBQSxHQUFHLEVBQUUsUUFBUDtBQUFpQixFQUFBLEdBQUcsRUFBRTtBQUF0QixDQUFMLEtBQTBDO0FBQ3hFLE1BQUksT0FBTyxHQUFHLEVBQUUsQ0FBQyxTQUFELENBQUYsQ0FBYyxRQUFkLENBQStCLFFBQS9CLENBQWQ7QUFDQSxNQUFJLFFBQVEsR0FBRyxFQUFFLENBQUMsU0FBRCxDQUFGLENBQWMsUUFBZCxDQUErQixZQUFZLENBQUMsU0FBRCxDQUEzQyxDQUFmO0FBQ0EsTUFBSSxTQUFTLEdBQUcsSUFBSSxjQUFKLENBQW1CLEVBQUUsQ0FBQyxLQUFILEVBQW5CLEVBQStCLE9BQS9CLEVBQXdDLFFBQXhDLENBQWhCO0FBQ0EsRUFBQSxRQUFRLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxPQUFILEVBQUQsQ0FBWixFQUE2QixJQUFELElBQVUsV0FBVyxDQUFDLFNBQVMsQ0FBQyxHQUFWLENBQWMsSUFBZCxDQUFELENBQWpELENBQVI7QUFDRCxDQUxEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT3AsIFNjb3BlIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBSZWZlcmVuY2UsIGNoaWxkUmVmRm9yLCB2YWx1ZUZvclJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBkaWN0LCBkZWNvZGVIYW5kbGUgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IEFQUEVORF9PUENPREVTIH0gZnJvbSAnLi4vLi4vb3Bjb2Rlcyc7XG5pbXBvcnQgeyBDT05TVEFOVFMgfSBmcm9tICcuLi8uLi9zeW1ib2xzJztcblxuZXhwb3J0IHR5cGUgRGVidWdHZXQgPSAocGF0aDogc3RyaW5nKSA9PiB1bmtub3duO1xuXG5leHBvcnQgdHlwZSBEZWJ1Z0NhbGxiYWNrID0gKGNvbnRleHQ6IHVua25vd24sIGdldDogRGVidWdHZXQpID0+IHZvaWQ7XG5cbmZ1bmN0aW9uIGRlYnVnQ2FsbGJhY2soY29udGV4dDogdW5rbm93biwgZ2V0OiBEZWJ1Z0dldCk6IHZvaWQge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICBjb25zb2xlLmluZm8oJ1VzZSBgY29udGV4dGAsIGFuZCBgZ2V0KDxwYXRoPilgIHRvIGRlYnVnIHRoaXMgdGVtcGxhdGUuJyk7XG5cbiAgLy8gZm9yIGV4YW1wbGUuLi5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICBjb250ZXh0ID09PSBnZXQoJ3RoaXMnKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZGVidWdnZXJcbiAgZGVidWdnZXI7XG59XG5cbmxldCBjYWxsYmFjayA9IGRlYnVnQ2FsbGJhY2s7XG5cbi8vIEZvciB0ZXN0aW5nIHB1cnBvc2VzXG5leHBvcnQgZnVuY3Rpb24gc2V0RGVidWdnZXJDYWxsYmFjayhjYjogRGVidWdDYWxsYmFjaykge1xuICBjYWxsYmFjayA9IGNiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXREZWJ1Z2dlckNhbGxiYWNrKCkge1xuICBjYWxsYmFjayA9IGRlYnVnQ2FsbGJhY2s7XG59XG5cbmNsYXNzIFNjb3BlSW5zcGVjdG9yIHtcbiAgcHJpdmF0ZSBsb2NhbHMgPSBkaWN0PFJlZmVyZW5jZT4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNjb3BlOiBTY29wZSwgc3ltYm9sczogc3RyaW5nW10sIGV2YWxJbmZvOiBudW1iZXJbXSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZhbEluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzbG90ID0gZXZhbEluZm9baV07XG4gICAgICBsZXQgbmFtZSA9IHN5bWJvbHNbc2xvdCAtIDFdO1xuICAgICAgbGV0IHJlZiA9IHNjb3BlLmdldFN5bWJvbChzbG90KTtcbiAgICAgIHRoaXMubG9jYWxzW25hbWVdID0gcmVmO1xuICAgIH1cbiAgfVxuXG4gIGdldChwYXRoOiBzdHJpbmcpOiBSZWZlcmVuY2Uge1xuICAgIGxldCB7IHNjb3BlLCBsb2NhbHMgfSA9IHRoaXM7XG4gICAgbGV0IHBhcnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIGxldCBbaGVhZCwgLi4udGFpbF0gPSBwYXRoLnNwbGl0KCcuJyk7XG5cbiAgICBsZXQgZXZhbFNjb3BlID0gc2NvcGUuZ2V0RXZhbFNjb3BlKCkhO1xuICAgIGxldCByZWY6IFJlZmVyZW5jZTtcblxuICAgIGlmIChoZWFkID09PSAndGhpcycpIHtcbiAgICAgIHJlZiA9IHNjb3BlLmdldFNlbGYoKTtcbiAgICB9IGVsc2UgaWYgKGxvY2Fsc1toZWFkXSkge1xuICAgICAgcmVmID0gbG9jYWxzW2hlYWRdO1xuICAgIH0gZWxzZSBpZiAoaGVhZC5pbmRleE9mKCdAJykgPT09IDAgJiYgZXZhbFNjb3BlW2hlYWRdKSB7XG4gICAgICByZWYgPSBldmFsU2NvcGVbaGVhZF0gYXMgUmVmZXJlbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWYgPSB0aGlzLnNjb3BlLmdldFNlbGYoKTtcbiAgICAgIHRhaWwgPSBwYXJ0cztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFpbC5yZWR1Y2UoKHIsIHBhcnQpID0+IGNoaWxkUmVmRm9yKHIsIHBhcnQpLCByZWYpO1xuICB9XG59XG5cbkFQUEVORF9PUENPREVTLmFkZChPcC5EZWJ1Z2dlciwgKHZtLCB7IG9wMTogX3N5bWJvbHMsIG9wMjogX2V2YWxJbmZvIH0pID0+IHtcbiAgbGV0IHN5bWJvbHMgPSB2bVtDT05TVEFOVFNdLmdldEFycmF5PHN0cmluZz4oX3N5bWJvbHMpO1xuICBsZXQgZXZhbEluZm8gPSB2bVtDT05TVEFOVFNdLmdldEFycmF5PG51bWJlcj4oZGVjb2RlSGFuZGxlKF9ldmFsSW5mbykpO1xuICBsZXQgaW5zcGVjdG9yID0gbmV3IFNjb3BlSW5zcGVjdG9yKHZtLnNjb3BlKCksIHN5bWJvbHMsIGV2YWxJbmZvKTtcbiAgY2FsbGJhY2sodmFsdWVGb3JSZWYodm0uZ2V0U2VsZigpKSwgKHBhdGgpID0+IHZhbHVlRm9yUmVmKGluc3BlY3Rvci5nZXQocGF0aCkpKTtcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==