import { registerDestructor } from '@glimmer/destroyable';
import { DEBUG } from '@glimmer/env';
import { setInternalModifierManager } from '@glimmer/manager';
import { valueForRef } from '@glimmer/reference';
import { reifyNamed } from '@glimmer/runtime';
import { createUpdatableTag } from '@glimmer/validator';
import { buildUntouchableThis } from '@glimmer/util';
const untouchableContext = buildUntouchableThis('`on` modifier');
/*
  Internet Explorer 11 does not support `once` and also does not support
  passing `eventOptions`. In some situations it then throws a weird script
  error, like:

  ```
  Could not complete the operation due to error 80020101
  ```

  This flag determines, whether `{ once: true }` and thus also event options in
  general are supported.
*/

const SUPPORTS_EVENT_OPTIONS = (() => {
  try {
    const div = document.createElement('div');
    let counter = 0;
    div.addEventListener('click', () => counter++, {
      once: true
    });
    let event;

    if (typeof Event === 'function') {
      event = new Event('click');
    } else {
      event = document.createEvent('Event');
      event.initEvent('click', true, true);
    }

    div.dispatchEvent(event);
    div.dispatchEvent(event);
    return counter === 1;
  } catch (error) {
    return false;
  }
})();

export class OnModifierState {
  constructor(element, args) {
    this.tag = createUpdatableTag();
    this.shouldUpdate = true;
    this.element = element;
    this.args = args;
  }

  updateFromArgs() {
    let {
      args
    } = this;
    let {
      once,
      passive,
      capture
    } = reifyNamed(args.named);

    if (once !== this.once) {
      this.once = once;
      this.shouldUpdate = true;
    }

    if (passive !== this.passive) {
      this.passive = passive;
      this.shouldUpdate = true;
    }

    if (capture !== this.capture) {
      this.capture = capture;
      this.shouldUpdate = true;
    }

    let options;

    if (once || passive || capture) {
      options = this.options = {
        once,
        passive,
        capture
      };
    } else {
      this.options = undefined;
    }

    if (DEBUG && (args.positional[0] === undefined || typeof valueForRef(args.positional[0]) !== 'string')) {
      throw new Error('You must pass a valid DOM event name as the first argument to the `on` modifier');
    }

    let eventName = valueForRef(args.positional[0]);

    if (eventName !== this.eventName) {
      this.eventName = eventName;
      this.shouldUpdate = true;
    }

    let userProvidedCallbackReference = args.positional[1];

    if (DEBUG) {
      if (args.positional[1] === undefined) {
        throw new Error(`You must pass a function as the second argument to the \`on\` modifier.`);
      }

      let value = valueForRef(userProvidedCallbackReference);

      if (typeof value !== 'function') {
        throw new Error(`You must pass a function as the second argument to the \`on\` modifier; you passed ${value === null ? 'null' : typeof value}. While rendering:\n\n${userProvidedCallbackReference.debugLabel}`);
      }
    }

    let userProvidedCallback = valueForRef(userProvidedCallbackReference);

    if (userProvidedCallback !== this.userProvidedCallback) {
      this.userProvidedCallback = userProvidedCallback;
      this.shouldUpdate = true;
    }

    if (DEBUG && args.positional.length !== 2) {
      throw new Error(`You can only pass two positional arguments (event name and callback) to the \`on\` modifier, but you provided ${args.positional.length}. Consider using the \`fn\` helper to provide additional arguments to the \`on\` callback.`);
    }

    let needsCustomCallback = SUPPORTS_EVENT_OPTIONS === false && once ||
    /* needs manual once implementation */
    DEBUG && passive;
    /* needs passive enforcement */

    if (this.shouldUpdate) {
      if (needsCustomCallback) {
        let callback = this.callback = function (event) {
          if (DEBUG && passive) {
            event.preventDefault = () => {
              throw new Error(`You marked this listener as 'passive', meaning that you must not call 'event.preventDefault()': \n\n${userProvidedCallback}`);
            };
          }

          if (!SUPPORTS_EVENT_OPTIONS && once) {
            removeEventListener(this, eventName, callback, options);
          }

          return userProvidedCallback.call(untouchableContext, event);
        };
      } else if (DEBUG) {
        // prevent the callback from being bound to the element
        this.callback = userProvidedCallback.bind(untouchableContext);
      } else {
        this.callback = userProvidedCallback;
      }
    }
  }

}
let adds = 0;
let removes = 0;

function removeEventListener(element, eventName, callback, options) {
  removes++;

  if (SUPPORTS_EVENT_OPTIONS) {
    // when options are supported, use them across the board
    element.removeEventListener(eventName, callback, options);
  } else if (options !== undefined && options.capture) {
    // used only in the following case:
    //
    // `{ once: true | false, passive: true | false, capture: true }
    //
    // `once` is handled via a custom callback that removes after first
    // invocation so we only care about capture here as a boolean
    element.removeEventListener(eventName, callback, true);
  } else {
    // used only in the following cases:
    //
    // * where there is no options
    // * `{ once: true | false, passive: true | false, capture: false }
    element.removeEventListener(eventName, callback);
  }
}

function addEventListener(element, eventName, callback, options) {
  adds++;

  if (SUPPORTS_EVENT_OPTIONS) {
    // when options are supported, use them across the board
    element.addEventListener(eventName, callback, options);
  } else if (options !== undefined && options.capture) {
    // used only in the following case:
    //
    // `{ once: true | false, passive: true | false, capture: true }
    //
    // `once` is handled via a custom callback that removes after first
    // invocation so we only care about capture here as a boolean
    element.addEventListener(eventName, callback, true);
  } else {
    // used only in the following cases:
    //
    // * where there is no options
    // * `{ once: true | false, passive: true | false, capture: false }
    element.addEventListener(eventName, callback);
  }
}
/**
  The `{{on}}` modifier lets you easily add event listeners (it uses
  [EventTarget.addEventListener](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)
  internally).

  For example, if you'd like to run a function on your component when a `<button>`
  in the components template is clicked you might do something like:

  ```app/components/like-post.hbs
  <button {{on 'click' this.saveLike}}>Like this post!</button>
  ```

  ```app/components/like-post.js
  import Component from '@glimmer/component';
  import { action } from '@ember/object';

  export default class LikePostComponent extends Component {
    saveLike = () => {
      // someone likes your post!
      // better send a request off to your server...
    }
  }
  ```

  ### Arguments

  `{{on}}` accepts two positional arguments, and a few named arguments.

  The positional arguments are:

  - `event` -- the name to use when calling `addEventListener`
  - `callback` -- the function to be passed to `addEventListener`

  The named arguments are:

  - capture -- a `true` value indicates that events of this type will be dispatched
    to the registered listener before being dispatched to any EventTarget beneath it
    in the DOM tree.
  - once -- indicates that the listener should be invoked at most once after being
    added. If true, the listener would be automatically removed when invoked.
  - passive -- if `true`, indicates that the function specified by listener will never
    call preventDefault(). If a passive listener does call preventDefault(), the user
    agent will do nothing other than generate a console warning. See
    [Improving scrolling performance with passive listeners](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners)
    to learn more.

  The callback function passed to `{{on}}` will receive any arguments that are passed
  to the event handler. Most commonly this would be the `event` itself.

  If you would like to pass additional arguments to the function you should use
  the `{{fn}}` helper.

  For example, in our example case above if you'd like to pass in the post that
  was being liked when the button is clicked you could do something like:

  ```app/components/like-post.hbs
  <button {{on 'click' (fn this.saveLike @post)}}>Like this post!</button>
  ```

  In this case, the `saveLike` function will receive two arguments: the click event
  and the value of `@post`.

  ### Function Context

  In the example above, we used an arrow function to ensure that `likePost` is
  properly bound to the `items-list`, but let's explore what happens if we
  left out the arrow function:

  ```app/components/like-post.js
  import Component from '@glimmer/component';

  export default class LikePostComponent extends Component {
    saveLike() {
      // ...snip...
    }
  }
  ```

  In this example, when the button is clicked `saveLike` will be invoked,
  it will **not** have access to the component instance. In other
  words, it will have no `this` context, so please make sure your functions
  are bound (via an arrow function or other means) before passing into `on`!

  @method on
  @public
*/


class OnModifierManager {
  constructor() {
    this.SUPPORTS_EVENT_OPTIONS = SUPPORTS_EVENT_OPTIONS;
  }

  getDebugName() {
    return 'on';
  }

  get counters() {
    return {
      adds,
      removes
    };
  }

  create(_owner, element, _state, args) {
    return new OnModifierState(element, args);
  }

  getTag(state) {
    if (state === null) {
      return null;
    }

    return state.tag;
  }

  install(state) {
    if (state === null) {
      return;
    }

    state.updateFromArgs();
    let {
      element,
      eventName,
      callback,
      options
    } = state;
    addEventListener(element, eventName, callback, options);
    registerDestructor(state, () => removeEventListener(element, eventName, callback, options));
    state.shouldUpdate = false;
  }

  update(state) {
    if (state === null) {
      return;
    } // stash prior state for el.removeEventListener


    let {
      element,
      eventName,
      callback,
      options
    } = state;
    state.updateFromArgs();

    if (!state.shouldUpdate) {
      return;
    } // use prior state values for removal


    removeEventListener(element, eventName, callback, options); // read updated values from the state object

    addEventListener(state.element, state.eventName, state.callback, state.options);
    state.shouldUpdate = false;
  }

  getDestroyable(state) {
    return state;
  }

}

export default setInternalModifierManager(new OnModifierManager(), {});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL21vZGlmaWVycy9vbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLGtCQUFULFFBQW1DLHNCQUFuQztBQUNBLFNBQVMsS0FBVCxRQUFzQixjQUF0QjtBQUVBLFNBQVMsMEJBQVQsUUFBMkMsa0JBQTNDO0FBQ0EsU0FBUyxXQUFULFFBQTRCLG9CQUE1QjtBQUNBLFNBQVMsVUFBVCxRQUEyQixrQkFBM0I7QUFDQSxTQUFTLGtCQUFULFFBQWlELG9CQUFqRDtBQUVBLFNBQVMsb0JBQVQsUUFBcUMsZUFBckM7QUFFQSxNQUFNLGtCQUFrQixHQUFHLG9CQUFvQixDQUFDLGVBQUQsQ0FBL0M7QUFFQTs7Ozs7Ozs7Ozs7OztBQVlBLE1BQU0sc0JBQXNCLEdBQUcsQ0FBQyxNQUFLO0FBQ25DLE1BQUk7QUFDRixVQUFNLEdBQUcsR0FBRyxRQUFRLENBQUMsYUFBVCxDQUF1QixLQUF2QixDQUFaO0FBQ0EsUUFBSSxPQUFPLEdBQUcsQ0FBZDtBQUNBLElBQUEsR0FBRyxDQUFDLGdCQUFKLENBQXFCLE9BQXJCLEVBQThCLE1BQU0sT0FBTyxFQUEzQyxFQUErQztBQUFFLE1BQUEsSUFBSSxFQUFFO0FBQVIsS0FBL0M7QUFFQSxRQUFJLEtBQUo7O0FBQ0EsUUFBSSxPQUFPLEtBQVAsS0FBaUIsVUFBckIsRUFBaUM7QUFDL0IsTUFBQSxLQUFLLEdBQUcsSUFBSSxLQUFKLENBQVUsT0FBVixDQUFSO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsTUFBQSxLQUFLLEdBQUcsUUFBUSxDQUFDLFdBQVQsQ0FBcUIsT0FBckIsQ0FBUjtBQUNBLE1BQUEsS0FBSyxDQUFDLFNBQU4sQ0FBZ0IsT0FBaEIsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0I7QUFDRDs7QUFFRCxJQUFBLEdBQUcsQ0FBQyxhQUFKLENBQWtCLEtBQWxCO0FBQ0EsSUFBQSxHQUFHLENBQUMsYUFBSixDQUFrQixLQUFsQjtBQUVB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QUNBLFFBQUk7QUFBRSxNQUFBLE9BQUY7QUFBVyxNQUFBLFNBQVg7QUFBc0IsTUFBQSxRQUF0QjtBQUFnQyxNQUFBO0FBQWhDLFFBQTRDLEtBQWhEO0FBRUEsSUFBQSxLQUFLLENBQUMsY0FBTjs7QUFFQSxRQUFJLENBQUMsS0FBSyxDQUFDLFlBQVgsRUFBeUI7QUFDdkI7QUFDRCxLQVppQyxDQWNsQzs7O0FBQ0EsSUFBQSxtQkFBbUIsQ0FBQyxPQUFELEVBQVUsU0FBVixFQUFxQixRQUFyQixFQUErQixPQUEvQixDQUFuQixDQWZrQyxDQWlCbEM7O0FBQ0EsSUFBQSxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsT0FBUCxFQUFnQixLQUFLLENBQUMsU0FBdEIsRUFBaUMsS0FBSyxDQUFDLFFBQXZDLEVBQWlELEtBQUssQ0FBQyxPQUF2RCxDQUFoQjtBQUVBLElBQUEsS0FBSyxDQUFDLFlBQU4sR0FBcUIsS0FBckI7QUFDRDs7QUFFRCxFQUFBLGNBQWMsQ0FBQyxLQUFELEVBQThCO0FBQzFDLFdBQU8sS0FBUDtBQUNEOztBQXJFb0I7O0FBd0V2QixlQUFlLDBCQUEwQixDQUFDLElBQUksaUJBQUosRUFBRCxFQUEwQixFQUExQixDQUF6QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlZ2lzdGVyRGVzdHJ1Y3RvciB9IGZyb20gJ0BnbGltbWVyL2Rlc3Ryb3lhYmxlJztcbmltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IENhcHR1cmVkQXJndW1lbnRzLCBJbnRlcm5hbE1vZGlmaWVyTWFuYWdlciwgT3duZXIgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IHNldEludGVybmFsTW9kaWZpZXJNYW5hZ2VyIH0gZnJvbSAnQGdsaW1tZXIvbWFuYWdlcic7XG5pbXBvcnQgeyB2YWx1ZUZvclJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyByZWlmeU5hbWVkIH0gZnJvbSAnQGdsaW1tZXIvcnVudGltZSc7XG5pbXBvcnQgeyBjcmVhdGVVcGRhdGFibGVUYWcsIFVwZGF0YWJsZVRhZyB9IGZyb20gJ0BnbGltbWVyL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBTaW1wbGVFbGVtZW50IH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcbmltcG9ydCB7IGJ1aWxkVW50b3VjaGFibGVUaGlzIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmNvbnN0IHVudG91Y2hhYmxlQ29udGV4dCA9IGJ1aWxkVW50b3VjaGFibGVUaGlzKCdgb25gIG1vZGlmaWVyJyk7XG5cbi8qXG4gIEludGVybmV0IEV4cGxvcmVyIDExIGRvZXMgbm90IHN1cHBvcnQgYG9uY2VgIGFuZCBhbHNvIGRvZXMgbm90IHN1cHBvcnRcbiAgcGFzc2luZyBgZXZlbnRPcHRpb25zYC4gSW4gc29tZSBzaXR1YXRpb25zIGl0IHRoZW4gdGhyb3dzIGEgd2VpcmQgc2NyaXB0XG4gIGVycm9yLCBsaWtlOlxuXG4gIGBgYFxuICBDb3VsZCBub3QgY29tcGxldGUgdGhlIG9wZXJhdGlvbiBkdWUgdG8gZXJyb3IgODAwMjAxMDFcbiAgYGBgXG5cbiAgVGhpcyBmbGFnIGRldGVybWluZXMsIHdoZXRoZXIgYHsgb25jZTogdHJ1ZSB9YCBhbmQgdGh1cyBhbHNvIGV2ZW50IG9wdGlvbnMgaW5cbiAgZ2VuZXJhbCBhcmUgc3VwcG9ydGVkLlxuKi9cbmNvbnN0IFNVUFBPUlRTX0VWRU5UX09QVElPTlMgPSAoKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBjb3VudGVyKyssIHsgb25jZTogdHJ1ZSB9KTtcblxuICAgIGxldCBldmVudDtcbiAgICBpZiAodHlwZW9mIEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBldmVudCA9IG5ldyBFdmVudCgnY2xpY2snKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2ZW50LmluaXRFdmVudCgnY2xpY2snLCB0cnVlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBkaXYuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgZGl2LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgcmV0dXJuIGNvdW50ZXIgPT09IDE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG5leHBvcnQgY2xhc3MgT25Nb2RpZmllclN0YXRlIHtcbiAgcHVibGljIHRhZyA9IGNyZWF0ZVVwZGF0YWJsZVRhZygpO1xuICBwdWJsaWMgZWxlbWVudDogRWxlbWVudDtcbiAgcHVibGljIGFyZ3M6IENhcHR1cmVkQXJndW1lbnRzO1xuICBwdWJsaWMgZXZlbnROYW1lITogc3RyaW5nO1xuICBwdWJsaWMgY2FsbGJhY2shOiBFdmVudExpc3RlbmVyO1xuICBwcml2YXRlIHVzZXJQcm92aWRlZENhbGxiYWNrITogRXZlbnRMaXN0ZW5lcjtcbiAgcHVibGljIG9uY2U/OiBib29sZWFuO1xuICBwdWJsaWMgcGFzc2l2ZT86IGJvb2xlYW47XG4gIHB1YmxpYyBjYXB0dXJlPzogYm9vbGVhbjtcbiAgcHVibGljIG9wdGlvbnM/OiBBZGRFdmVudExpc3RlbmVyT3B0aW9ucztcbiAgcHVibGljIHNob3VsZFVwZGF0ZSA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IoZWxlbWVudDogRWxlbWVudCwgYXJnczogQ2FwdHVyZWRBcmd1bWVudHMpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gIH1cblxuICB1cGRhdGVGcm9tQXJncygpOiB2b2lkIHtcbiAgICBsZXQgeyBhcmdzIH0gPSB0aGlzO1xuXG4gICAgbGV0IHsgb25jZSwgcGFzc2l2ZSwgY2FwdHVyZSB9OiBBZGRFdmVudExpc3RlbmVyT3B0aW9ucyA9IHJlaWZ5TmFtZWQoYXJncy5uYW1lZCk7XG4gICAgaWYgKG9uY2UgIT09IHRoaXMub25jZSkge1xuICAgICAgdGhpcy5vbmNlID0gb25jZTtcbiAgICAgIHRoaXMuc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocGFzc2l2ZSAhPT0gdGhpcy5wYXNzaXZlKSB7XG4gICAgICB0aGlzLnBhc3NpdmUgPSBwYXNzaXZlO1xuICAgICAgdGhpcy5zaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjYXB0dXJlICE9PSB0aGlzLmNhcHR1cmUpIHtcbiAgICAgIHRoaXMuY2FwdHVyZSA9IGNhcHR1cmU7XG4gICAgICB0aGlzLnNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgbGV0IG9wdGlvbnM6IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zO1xuICAgIGlmIChvbmNlIHx8IHBhc3NpdmUgfHwgY2FwdHVyZSkge1xuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyA9IHsgb25jZSwgcGFzc2l2ZSwgY2FwdHVyZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgREVCVUcgJiZcbiAgICAgIChhcmdzLnBvc2l0aW9uYWxbMF0gPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWVGb3JSZWYoYXJncy5wb3NpdGlvbmFsWzBdKSAhPT0gJ3N0cmluZycpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdZb3UgbXVzdCBwYXNzIGEgdmFsaWQgRE9NIGV2ZW50IG5hbWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBgb25gIG1vZGlmaWVyJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgZXZlbnROYW1lID0gdmFsdWVGb3JSZWYoYXJncy5wb3NpdGlvbmFsWzBdKSBhcyBzdHJpbmc7XG4gICAgaWYgKGV2ZW50TmFtZSAhPT0gdGhpcy5ldmVudE5hbWUpIHtcbiAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgdGhpcy5zaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCB1c2VyUHJvdmlkZWRDYWxsYmFja1JlZmVyZW5jZSA9IGFyZ3MucG9zaXRpb25hbFsxXTtcblxuICAgIGlmIChERUJVRykge1xuICAgICAgaWYgKGFyZ3MucG9zaXRpb25hbFsxXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcGFzcyBhIGZ1bmN0aW9uIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgdG8gdGhlIFxcYG9uXFxgIG1vZGlmaWVyLmApO1xuICAgICAgfVxuXG4gICAgICBsZXQgdmFsdWUgPSB2YWx1ZUZvclJlZih1c2VyUHJvdmlkZWRDYWxsYmFja1JlZmVyZW5jZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgbXVzdCBwYXNzIGEgZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgXFxgb25cXGAgbW9kaWZpZXI7IHlvdSBwYXNzZWQgJHtcbiAgICAgICAgICAgIHZhbHVlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHZhbHVlXG4gICAgICAgICAgfS4gV2hpbGUgcmVuZGVyaW5nOlxcblxcbiR7dXNlclByb3ZpZGVkQ2FsbGJhY2tSZWZlcmVuY2UuZGVidWdMYWJlbH1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHVzZXJQcm92aWRlZENhbGxiYWNrID0gdmFsdWVGb3JSZWYodXNlclByb3ZpZGVkQ2FsbGJhY2tSZWZlcmVuY2UpIGFzIEV2ZW50TGlzdGVuZXI7XG4gICAgaWYgKHVzZXJQcm92aWRlZENhbGxiYWNrICE9PSB0aGlzLnVzZXJQcm92aWRlZENhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVzZXJQcm92aWRlZENhbGxiYWNrID0gdXNlclByb3ZpZGVkQ2FsbGJhY2s7XG4gICAgICB0aGlzLnNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKERFQlVHICYmIGFyZ3MucG9zaXRpb25hbC5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFlvdSBjYW4gb25seSBwYXNzIHR3byBwb3NpdGlvbmFsIGFyZ3VtZW50cyAoZXZlbnQgbmFtZSBhbmQgY2FsbGJhY2spIHRvIHRoZSBcXGBvblxcYCBtb2RpZmllciwgYnV0IHlvdSBwcm92aWRlZCAke2FyZ3MucG9zaXRpb25hbC5sZW5ndGh9LiBDb25zaWRlciB1c2luZyB0aGUgXFxgZm5cXGAgaGVscGVyIHRvIHByb3ZpZGUgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gdGhlIFxcYG9uXFxgIGNhbGxiYWNrLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IG5lZWRzQ3VzdG9tQ2FsbGJhY2sgPVxuICAgICAgKFNVUFBPUlRTX0VWRU5UX09QVElPTlMgPT09IGZhbHNlICYmIG9uY2UpIC8qIG5lZWRzIG1hbnVhbCBvbmNlIGltcGxlbWVudGF0aW9uICovIHx8XG4gICAgICAoREVCVUcgJiYgcGFzc2l2ZSk7IC8qIG5lZWRzIHBhc3NpdmUgZW5mb3JjZW1lbnQgKi9cblxuICAgIGlmICh0aGlzLnNob3VsZFVwZGF0ZSkge1xuICAgICAgaWYgKG5lZWRzQ3VzdG9tQ2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGNhbGxiYWNrID0gKHRoaXMuY2FsbGJhY2sgPSBmdW5jdGlvbiAodGhpczogRWxlbWVudCwgZXZlbnQpIHtcbiAgICAgICAgICBpZiAoREVCVUcgJiYgcGFzc2l2ZSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgWW91IG1hcmtlZCB0aGlzIGxpc3RlbmVyIGFzICdwYXNzaXZlJywgbWVhbmluZyB0aGF0IHlvdSBtdXN0IG5vdCBjYWxsICdldmVudC5wcmV2ZW50RGVmYXVsdCgpJzogXFxuXFxuJHt1c2VyUHJvdmlkZWRDYWxsYmFja31gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghU1VQUE9SVFNfRVZFTlRfT1BUSU9OUyAmJiBvbmNlKSB7XG4gICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdXNlclByb3ZpZGVkQ2FsbGJhY2suY2FsbCh1bnRvdWNoYWJsZUNvbnRleHQsIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKERFQlVHKSB7XG4gICAgICAgIC8vIHByZXZlbnQgdGhlIGNhbGxiYWNrIGZyb20gYmVpbmcgYm91bmQgdG8gdGhlIGVsZW1lbnRcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IHVzZXJQcm92aWRlZENhbGxiYWNrLmJpbmQodW50b3VjaGFibGVDb250ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSB1c2VyUHJvdmlkZWRDYWxsYmFjaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubGV0IGFkZHMgPSAwO1xubGV0IHJlbW92ZXMgPSAwO1xuXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKFxuICBlbGVtZW50OiBFbGVtZW50LFxuICBldmVudE5hbWU6IHN0cmluZyxcbiAgY2FsbGJhY2s6IEV2ZW50TGlzdGVuZXIsXG4gIG9wdGlvbnM/OiBBZGRFdmVudExpc3RlbmVyT3B0aW9uc1xuKTogdm9pZCB7XG4gIHJlbW92ZXMrKztcblxuICBpZiAoU1VQUE9SVFNfRVZFTlRfT1BUSU9OUykge1xuICAgIC8vIHdoZW4gb3B0aW9ucyBhcmUgc3VwcG9ydGVkLCB1c2UgdGhlbSBhY3Jvc3MgdGhlIGJvYXJkXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmNhcHR1cmUpIHtcbiAgICAvLyB1c2VkIG9ubHkgaW4gdGhlIGZvbGxvd2luZyBjYXNlOlxuICAgIC8vXG4gICAgLy8gYHsgb25jZTogdHJ1ZSB8IGZhbHNlLCBwYXNzaXZlOiB0cnVlIHwgZmFsc2UsIGNhcHR1cmU6IHRydWUgfVxuICAgIC8vXG4gICAgLy8gYG9uY2VgIGlzIGhhbmRsZWQgdmlhIGEgY3VzdG9tIGNhbGxiYWNrIHRoYXQgcmVtb3ZlcyBhZnRlciBmaXJzdFxuICAgIC8vIGludm9jYXRpb24gc28gd2Ugb25seSBjYXJlIGFib3V0IGNhcHR1cmUgaGVyZSBhcyBhIGJvb2xlYW5cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlZCBvbmx5IGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gICAgLy9cbiAgICAvLyAqIHdoZXJlIHRoZXJlIGlzIG5vIG9wdGlvbnNcbiAgICAvLyAqIGB7IG9uY2U6IHRydWUgfCBmYWxzZSwgcGFzc2l2ZTogdHJ1ZSB8IGZhbHNlLCBjYXB0dXJlOiBmYWxzZSB9XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoXG4gIGVsZW1lbnQ6IEVsZW1lbnQsXG4gIGV2ZW50TmFtZTogc3RyaW5nLFxuICBjYWxsYmFjazogRXZlbnRMaXN0ZW5lcixcbiAgb3B0aW9ucz86IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zXG4pOiB2b2lkIHtcbiAgYWRkcysrO1xuXG4gIGlmIChTVVBQT1JUU19FVkVOVF9PUFRJT05TKSB7XG4gICAgLy8gd2hlbiBvcHRpb25zIGFyZSBzdXBwb3J0ZWQsIHVzZSB0aGVtIGFjcm9zcyB0aGUgYm9hcmRcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuY2FwdHVyZSkge1xuICAgIC8vIHVzZWQgb25seSBpbiB0aGUgZm9sbG93aW5nIGNhc2U6XG4gICAgLy9cbiAgICAvLyBgeyBvbmNlOiB0cnVlIHwgZmFsc2UsIHBhc3NpdmU6IHRydWUgfCBmYWxzZSwgY2FwdHVyZTogdHJ1ZSB9XG4gICAgLy9cbiAgICAvLyBgb25jZWAgaXMgaGFuZGxlZCB2aWEgYSBjdXN0b20gY2FsbGJhY2sgdGhhdCByZW1vdmVzIGFmdGVyIGZpcnN0XG4gICAgLy8gaW52b2NhdGlvbiBzbyB3ZSBvbmx5IGNhcmUgYWJvdXQgY2FwdHVyZSBoZXJlIGFzIGEgYm9vbGVhblxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1c2VkIG9ubHkgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAvL1xuICAgIC8vICogd2hlcmUgdGhlcmUgaXMgbm8gb3B0aW9uc1xuICAgIC8vICogYHsgb25jZTogdHJ1ZSB8IGZhbHNlLCBwYXNzaXZlOiB0cnVlIHwgZmFsc2UsIGNhcHR1cmU6IGZhbHNlIH1cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gIH1cbn1cblxuLyoqXG4gIFRoZSBge3tvbn19YCBtb2RpZmllciBsZXRzIHlvdSBlYXNpbHkgYWRkIGV2ZW50IGxpc3RlbmVycyAoaXQgdXNlc1xuICBbRXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIpXG4gIGludGVybmFsbHkpLlxuXG4gIEZvciBleGFtcGxlLCBpZiB5b3UnZCBsaWtlIHRvIHJ1biBhIGZ1bmN0aW9uIG9uIHlvdXIgY29tcG9uZW50IHdoZW4gYSBgPGJ1dHRvbj5gXG4gIGluIHRoZSBjb21wb25lbnRzIHRlbXBsYXRlIGlzIGNsaWNrZWQgeW91IG1pZ2h0IGRvIHNvbWV0aGluZyBsaWtlOlxuXG4gIGBgYGFwcC9jb21wb25lbnRzL2xpa2UtcG9zdC5oYnNcbiAgPGJ1dHRvbiB7e29uICdjbGljaycgdGhpcy5zYXZlTGlrZX19Pkxpa2UgdGhpcyBwb3N0ITwvYnV0dG9uPlxuICBgYGBcblxuICBgYGBhcHAvY29tcG9uZW50cy9saWtlLXBvc3QuanNcbiAgaW1wb3J0IENvbXBvbmVudCBmcm9tICdAZ2xpbW1lci9jb21wb25lbnQnO1xuICBpbXBvcnQgeyBhY3Rpb24gfSBmcm9tICdAZW1iZXIvb2JqZWN0JztcblxuICBleHBvcnQgZGVmYXVsdCBjbGFzcyBMaWtlUG9zdENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgc2F2ZUxpa2UgPSAoKSA9PiB7XG4gICAgICAvLyBzb21lb25lIGxpa2VzIHlvdXIgcG9zdCFcbiAgICAgIC8vIGJldHRlciBzZW5kIGEgcmVxdWVzdCBvZmYgdG8geW91ciBzZXJ2ZXIuLi5cbiAgICB9XG4gIH1cbiAgYGBgXG5cbiAgIyMjIEFyZ3VtZW50c1xuXG4gIGB7e29ufX1gIGFjY2VwdHMgdHdvIHBvc2l0aW9uYWwgYXJndW1lbnRzLCBhbmQgYSBmZXcgbmFtZWQgYXJndW1lbnRzLlxuXG4gIFRoZSBwb3NpdGlvbmFsIGFyZ3VtZW50cyBhcmU6XG5cbiAgLSBgZXZlbnRgIC0tIHRoZSBuYW1lIHRvIHVzZSB3aGVuIGNhbGxpbmcgYGFkZEV2ZW50TGlzdGVuZXJgXG4gIC0gYGNhbGxiYWNrYCAtLSB0aGUgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIGBhZGRFdmVudExpc3RlbmVyYFxuXG4gIFRoZSBuYW1lZCBhcmd1bWVudHMgYXJlOlxuXG4gIC0gY2FwdHVyZSAtLSBhIGB0cnVlYCB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCBldmVudHMgb2YgdGhpcyB0eXBlIHdpbGwgYmUgZGlzcGF0Y2hlZFxuICAgIHRvIHRoZSByZWdpc3RlcmVkIGxpc3RlbmVyIGJlZm9yZSBiZWluZyBkaXNwYXRjaGVkIHRvIGFueSBFdmVudFRhcmdldCBiZW5lYXRoIGl0XG4gICAgaW4gdGhlIERPTSB0cmVlLlxuICAtIG9uY2UgLS0gaW5kaWNhdGVzIHRoYXQgdGhlIGxpc3RlbmVyIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZ1xuICAgIGFkZGVkLiBJZiB0cnVlLCB0aGUgbGlzdGVuZXIgd291bGQgYmUgYXV0b21hdGljYWxseSByZW1vdmVkIHdoZW4gaW52b2tlZC5cbiAgLSBwYXNzaXZlIC0tIGlmIGB0cnVlYCwgaW5kaWNhdGVzIHRoYXQgdGhlIGZ1bmN0aW9uIHNwZWNpZmllZCBieSBsaXN0ZW5lciB3aWxsIG5ldmVyXG4gICAgY2FsbCBwcmV2ZW50RGVmYXVsdCgpLiBJZiBhIHBhc3NpdmUgbGlzdGVuZXIgZG9lcyBjYWxsIHByZXZlbnREZWZhdWx0KCksIHRoZSB1c2VyXG4gICAgYWdlbnQgd2lsbCBkbyBub3RoaW5nIG90aGVyIHRoYW4gZ2VuZXJhdGUgYSBjb25zb2xlIHdhcm5pbmcuIFNlZVxuICAgIFtJbXByb3Zpbmcgc2Nyb2xsaW5nIHBlcmZvcm1hbmNlIHdpdGggcGFzc2l2ZSBsaXN0ZW5lcnNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI0ltcHJvdmluZ19zY3JvbGxpbmdfcGVyZm9ybWFuY2Vfd2l0aF9wYXNzaXZlX2xpc3RlbmVycylcbiAgICB0byBsZWFybiBtb3JlLlxuXG4gIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBwYXNzZWQgdG8gYHt7b259fWAgd2lsbCByZWNlaXZlIGFueSBhcmd1bWVudHMgdGhhdCBhcmUgcGFzc2VkXG4gIHRvIHRoZSBldmVudCBoYW5kbGVyLiBNb3N0IGNvbW1vbmx5IHRoaXMgd291bGQgYmUgdGhlIGBldmVudGAgaXRzZWxmLlxuXG4gIElmIHlvdSB3b3VsZCBsaWtlIHRvIHBhc3MgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uIHlvdSBzaG91bGQgdXNlXG4gIHRoZSBge3tmbn19YCBoZWxwZXIuXG5cbiAgRm9yIGV4YW1wbGUsIGluIG91ciBleGFtcGxlIGNhc2UgYWJvdmUgaWYgeW91J2QgbGlrZSB0byBwYXNzIGluIHRoZSBwb3N0IHRoYXRcbiAgd2FzIGJlaW5nIGxpa2VkIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkIHlvdSBjb3VsZCBkbyBzb21ldGhpbmcgbGlrZTpcblxuICBgYGBhcHAvY29tcG9uZW50cy9saWtlLXBvc3QuaGJzXG4gIDxidXR0b24ge3tvbiAnY2xpY2snIChmbiB0aGlzLnNhdmVMaWtlIEBwb3N0KX19Pkxpa2UgdGhpcyBwb3N0ITwvYnV0dG9uPlxuICBgYGBcblxuICBJbiB0aGlzIGNhc2UsIHRoZSBgc2F2ZUxpa2VgIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0d28gYXJndW1lbnRzOiB0aGUgY2xpY2sgZXZlbnRcbiAgYW5kIHRoZSB2YWx1ZSBvZiBgQHBvc3RgLlxuXG4gICMjIyBGdW5jdGlvbiBDb250ZXh0XG5cbiAgSW4gdGhlIGV4YW1wbGUgYWJvdmUsIHdlIHVzZWQgYW4gYXJyb3cgZnVuY3Rpb24gdG8gZW5zdXJlIHRoYXQgYGxpa2VQb3N0YCBpc1xuICBwcm9wZXJseSBib3VuZCB0byB0aGUgYGl0ZW1zLWxpc3RgLCBidXQgbGV0J3MgZXhwbG9yZSB3aGF0IGhhcHBlbnMgaWYgd2VcbiAgbGVmdCBvdXQgdGhlIGFycm93IGZ1bmN0aW9uOlxuXG4gIGBgYGFwcC9jb21wb25lbnRzL2xpa2UtcG9zdC5qc1xuICBpbXBvcnQgQ29tcG9uZW50IGZyb20gJ0BnbGltbWVyL2NvbXBvbmVudCc7XG5cbiAgZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlrZVBvc3RDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIHNhdmVMaWtlKCkge1xuICAgICAgLy8gLi4uc25pcC4uLlxuICAgIH1cbiAgfVxuICBgYGBcblxuICBJbiB0aGlzIGV4YW1wbGUsIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkIGBzYXZlTGlrZWAgd2lsbCBiZSBpbnZva2VkLFxuICBpdCB3aWxsICoqbm90KiogaGF2ZSBhY2Nlc3MgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZS4gSW4gb3RoZXJcbiAgd29yZHMsIGl0IHdpbGwgaGF2ZSBubyBgdGhpc2AgY29udGV4dCwgc28gcGxlYXNlIG1ha2Ugc3VyZSB5b3VyIGZ1bmN0aW9uc1xuICBhcmUgYm91bmQgKHZpYSBhbiBhcnJvdyBmdW5jdGlvbiBvciBvdGhlciBtZWFucykgYmVmb3JlIHBhc3NpbmcgaW50byBgb25gIVxuXG4gIEBtZXRob2Qgb25cbiAgQHB1YmxpY1xuKi9cbmNsYXNzIE9uTW9kaWZpZXJNYW5hZ2VyIGltcGxlbWVudHMgSW50ZXJuYWxNb2RpZmllck1hbmFnZXI8T25Nb2RpZmllclN0YXRlIHwgbnVsbCwgb2JqZWN0PiB7XG4gIHB1YmxpYyBTVVBQT1JUU19FVkVOVF9PUFRJT05TOiBib29sZWFuID0gU1VQUE9SVFNfRVZFTlRfT1BUSU9OUztcblxuICBnZXREZWJ1Z05hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ29uJztcbiAgfVxuXG4gIGdldCBjb3VudGVycygpOiB7IGFkZHM6IG51bWJlcjsgcmVtb3ZlczogbnVtYmVyIH0ge1xuICAgIHJldHVybiB7IGFkZHMsIHJlbW92ZXMgfTtcbiAgfVxuXG4gIGNyZWF0ZShcbiAgICBfb3duZXI6IE93bmVyLFxuICAgIGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQgfCBFbGVtZW50LFxuICAgIF9zdGF0ZTogb2JqZWN0LFxuICAgIGFyZ3M6IENhcHR1cmVkQXJndW1lbnRzXG4gICk6IE9uTW9kaWZpZXJTdGF0ZSB8IG51bGwge1xuICAgIHJldHVybiBuZXcgT25Nb2RpZmllclN0YXRlKGVsZW1lbnQgYXMgRWxlbWVudCwgYXJncyk7XG4gIH1cblxuICBnZXRUYWcoc3RhdGU6IE9uTW9kaWZpZXJTdGF0ZSB8IG51bGwpOiBVcGRhdGFibGVUYWcgfCBudWxsIHtcbiAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBzdGF0ZS50YWc7XG4gIH1cblxuICBpbnN0YWxsKHN0YXRlOiBPbk1vZGlmaWVyU3RhdGUgfCBudWxsKTogdm9pZCB7XG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdGUudXBkYXRlRnJvbUFyZ3MoKTtcblxuICAgIGxldCB7IGVsZW1lbnQsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdGlvbnMgfSA9IHN0YXRlO1xuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKTtcblxuICAgIHJlZ2lzdGVyRGVzdHJ1Y3RvcihzdGF0ZSwgKCkgPT4gcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKSk7XG5cbiAgICBzdGF0ZS5zaG91bGRVcGRhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHVwZGF0ZShzdGF0ZTogT25Nb2RpZmllclN0YXRlIHwgbnVsbCk6IHZvaWQge1xuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHN0YXNoIHByaW9yIHN0YXRlIGZvciBlbC5yZW1vdmVFdmVudExpc3RlbmVyXG4gICAgbGV0IHsgZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0aW9ucyB9ID0gc3RhdGU7XG5cbiAgICBzdGF0ZS51cGRhdGVGcm9tQXJncygpO1xuXG4gICAgaWYgKCFzdGF0ZS5zaG91bGRVcGRhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB1c2UgcHJpb3Igc3RhdGUgdmFsdWVzIGZvciByZW1vdmFsXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRpb25zKTtcblxuICAgIC8vIHJlYWQgdXBkYXRlZCB2YWx1ZXMgZnJvbSB0aGUgc3RhdGUgb2JqZWN0XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihzdGF0ZS5lbGVtZW50LCBzdGF0ZS5ldmVudE5hbWUsIHN0YXRlLmNhbGxiYWNrLCBzdGF0ZS5vcHRpb25zKTtcblxuICAgIHN0YXRlLnNob3VsZFVwZGF0ZSA9IGZhbHNlO1xuICB9XG5cbiAgZ2V0RGVzdHJveWFibGUoc3RhdGU6IE9uTW9kaWZpZXJTdGF0ZSB8IG51bGwpOiBPbk1vZGlmaWVyU3RhdGUgfCBudWxsIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgc2V0SW50ZXJuYWxNb2RpZmllck1hbmFnZXIobmV3IE9uTW9kaWZpZXJNYW5hZ2VyKCksIHt9KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=