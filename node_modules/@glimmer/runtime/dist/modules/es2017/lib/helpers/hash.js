import { createComputeRef } from '@glimmer/reference';
import { reifyNamed } from '@glimmer/runtime';
import { deprecate } from '@glimmer/global-context';
import { HAS_NATIVE_PROXY } from '@glimmer/util';
import { internalHelper } from './internal-helper';
import { DEBUG } from '@glimmer/env';
let wrapHashProxy;

if (DEBUG) {
  wrapHashProxy = hash => {
    return new Proxy(hash, {
      set(target, key, value) {
        deprecate(`You set the '${String(key)}' property on a {{hash}} object. Setting properties on objects generated by {{hash}} is deprecated. Please update to use an object created with a tracked property or getter, or with a custom helper.`, false, {
          id: 'setting-on-hash'
        });
        target[key] = value;
        return true;
      }

    });
  };
}
/**
   Use the `{{hash}}` helper to create a hash to pass as an option to your
   components. This is specially useful for contextual components where you can
   just yield a hash:

   ```handlebars
   {{yield (hash
      name='Sarah'
      title=office
   )}}
   ```

   Would result in an object such as:

   ```js
   { name: 'Sarah', title: this.get('office') }
   ```

   Where the `title` is bound to updates of the `office` property.

   Note that the hash is an empty object with no prototype chain, therefore
   common methods like `toString` are not available in the resulting hash.
   If you need to use such a method, you can use the `call` or `apply`
   approach:

   ```js
   function toString(obj) {
     return Object.prototype.toString.apply(obj);
   }
   ```

   @method hash
   @param {Object} options
   @return {Object} Hash
   @public
 */


export default internalHelper(({
  named
}) => {
  let ref = createComputeRef(() => {
    let hash = reifyNamed(named);

    if (DEBUG && HAS_NATIVE_PROXY) {
      hash = wrapHashProxy(hash);
    }

    return hash;
  }, null, 'hash'); // Setup the children so that templates can bypass getting the value of
  // the reference and treat children lazily

  let children = new Map();

  for (let name in named) {
    children.set(name, named[name]);
  }

  ref.children = children;
  return ref;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2hlbHBlcnMvaGFzaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxTQUFTLGdCQUFULFFBQTRDLG9CQUE1QztBQUNBLFNBQVMsVUFBVCxRQUEyQixrQkFBM0I7QUFDQSxTQUFTLFNBQVQsUUFBMEIseUJBQTFCO0FBQ0EsU0FBUyxnQkFBVCxRQUFpQyxlQUFqQztBQUNBLFNBQVMsY0FBVCxRQUErQixtQkFBL0I7QUFDQSxTQUFTLEtBQVQsUUFBc0IsY0FBdEI7QUFFQSxJQUFJLGFBQUo7O0FBRUEsSUFBSSxLQUFKLEVBQVc7QUFDVCxFQUFBLGFBQWEsR0FBSSxJQUFELElBQWtDO0FBQ2hELFdBQU8sSUFBSSxLQUFKLENBQVUsSUFBVixFQUFnQjtBQUNyQixNQUFBLEdBQUcsQ0FBQyxNQUFELEVBQVMsR0FBVCxFQUFjLEtBQWQsRUFBbUI7QUFDcEIsUUFBQSxTQUFTLENBQ1AsZ0JBQWdCLE1BQU0sQ0FDcEIsR0FEb0IsQ0FFckIsd01BSE0sRUFJUCxLQUpPLEVBS1A7QUFBRSxVQUFBLEVBQUUsRUFBRTtBQUFOLFNBTE8sQ0FBVDtBQVFBLFFBQUEsTUFBTSxDQUFDLEdBQUQsQ0FBTixHQUF3QixLQUF4QjtBQUVBLGVBQU8sSUFBUDtBQUNEOztBQWJvQixLQUFoQixDQUFQO0FBZUQsR0FoQkQ7QUFpQkQ7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ0EsZUFBZSxjQUFjLENBQzNCLENBQUM7QUFBRSxFQUFBO0FBQUYsQ0FBRCxLQUEyRDtBQUN6RCxNQUFJLEdBQUcsR0FBRyxnQkFBZ0IsQ0FDeEIsTUFBSztBQUNILFFBQUksSUFBSSxHQUFHLFVBQVUsQ0FBQyxLQUFELENBQXJCOztBQUVBLFFBQUksS0FBSyxJQUFJLGdCQUFiLEVBQStCO0FBQzdCLE1BQUEsSUFBSSxHQUFHLGFBQWEsQ0FBQyxJQUFELENBQXBCO0FBQ0Q7O0FBRUQsV0FBTyxJQUFQO0FBQ0QsR0FUdUIsRUFVeEIsSUFWd0IsRUFXeEIsTUFYd0IsQ0FBMUIsQ0FEeUQsQ0FlekQ7QUFDQTs7QUFDQSxNQUFJLFFBQVEsR0FBRyxJQUFJLEdBQUosRUFBZjs7QUFFQSxPQUFLLElBQUksSUFBVCxJQUFpQixLQUFqQixFQUF3QjtBQUN0QixJQUFBLFFBQVEsQ0FBQyxHQUFULENBQWEsSUFBYixFQUFtQixLQUFLLENBQUMsSUFBRCxDQUF4QjtBQUNEOztBQUVELEVBQUEsR0FBRyxDQUFDLFFBQUosR0FBZSxRQUFmO0FBRUEsU0FBTyxHQUFQO0FBQ0QsQ0EzQjBCLENBQTdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2FwdHVyZWRBcmd1bWVudHMsIERpY3QgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGNyZWF0ZUNvbXB1dGVSZWYsIFJlZmVyZW5jZSB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyByZWlmeU5hbWVkIH0gZnJvbSAnQGdsaW1tZXIvcnVudGltZSc7XG5pbXBvcnQgeyBkZXByZWNhdGUgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5pbXBvcnQgeyBIQVNfTkFUSVZFX1BST1hZIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBpbnRlcm5hbEhlbHBlciB9IGZyb20gJy4vaW50ZXJuYWwtaGVscGVyJztcbmltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcblxubGV0IHdyYXBIYXNoUHJveHk6IChoYXNoOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgPT4gUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG5cbmlmIChERUJVRykge1xuICB3cmFwSGFzaFByb3h5ID0gKGhhc2g6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm94eShoYXNoLCB7XG4gICAgICBzZXQodGFyZ2V0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgIGRlcHJlY2F0ZShcbiAgICAgICAgICBgWW91IHNldCB0aGUgJyR7U3RyaW5nKFxuICAgICAgICAgICAga2V5XG4gICAgICAgICAgKX0nIHByb3BlcnR5IG9uIGEge3toYXNofX0gb2JqZWN0LiBTZXR0aW5nIHByb3BlcnRpZXMgb24gb2JqZWN0cyBnZW5lcmF0ZWQgYnkge3toYXNofX0gaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVwZGF0ZSB0byB1c2UgYW4gb2JqZWN0IGNyZWF0ZWQgd2l0aCBhIHRyYWNrZWQgcHJvcGVydHkgb3IgZ2V0dGVyLCBvciB3aXRoIGEgY3VzdG9tIGhlbHBlci5gLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIHsgaWQ6ICdzZXR0aW5nLW9uLWhhc2gnIH1cbiAgICAgICAgKTtcblxuICAgICAgICB0YXJnZXRba2V5IGFzIHN0cmluZ10gPSB2YWx1ZTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH07XG59XG5cbi8qKlxuICAgVXNlIHRoZSBge3toYXNofX1gIGhlbHBlciB0byBjcmVhdGUgYSBoYXNoIHRvIHBhc3MgYXMgYW4gb3B0aW9uIHRvIHlvdXJcbiAgIGNvbXBvbmVudHMuIFRoaXMgaXMgc3BlY2lhbGx5IHVzZWZ1bCBmb3IgY29udGV4dHVhbCBjb21wb25lbnRzIHdoZXJlIHlvdSBjYW5cbiAgIGp1c3QgeWllbGQgYSBoYXNoOlxuXG4gICBgYGBoYW5kbGViYXJzXG4gICB7e3lpZWxkIChoYXNoXG4gICAgICBuYW1lPSdTYXJhaCdcbiAgICAgIHRpdGxlPW9mZmljZVxuICAgKX19XG4gICBgYGBcblxuICAgV291bGQgcmVzdWx0IGluIGFuIG9iamVjdCBzdWNoIGFzOlxuXG4gICBgYGBqc1xuICAgeyBuYW1lOiAnU2FyYWgnLCB0aXRsZTogdGhpcy5nZXQoJ29mZmljZScpIH1cbiAgIGBgYFxuXG4gICBXaGVyZSB0aGUgYHRpdGxlYCBpcyBib3VuZCB0byB1cGRhdGVzIG9mIHRoZSBgb2ZmaWNlYCBwcm9wZXJ0eS5cblxuICAgTm90ZSB0aGF0IHRoZSBoYXNoIGlzIGFuIGVtcHR5IG9iamVjdCB3aXRoIG5vIHByb3RvdHlwZSBjaGFpbiwgdGhlcmVmb3JlXG4gICBjb21tb24gbWV0aG9kcyBsaWtlIGB0b1N0cmluZ2AgYXJlIG5vdCBhdmFpbGFibGUgaW4gdGhlIHJlc3VsdGluZyBoYXNoLlxuICAgSWYgeW91IG5lZWQgdG8gdXNlIHN1Y2ggYSBtZXRob2QsIHlvdSBjYW4gdXNlIHRoZSBgY2FsbGAgb3IgYGFwcGx5YFxuICAgYXBwcm9hY2g6XG5cbiAgIGBgYGpzXG4gICBmdW5jdGlvbiB0b1N0cmluZyhvYmopIHtcbiAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkob2JqKTtcbiAgIH1cbiAgIGBgYFxuXG4gICBAbWV0aG9kIGhhc2hcbiAgIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICBAcmV0dXJuIHtPYmplY3R9IEhhc2hcbiAgIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgaW50ZXJuYWxIZWxwZXIoXG4gICh7IG5hbWVkIH06IENhcHR1cmVkQXJndW1lbnRzKTogUmVmZXJlbmNlPERpY3Q8dW5rbm93bj4+ID0+IHtcbiAgICBsZXQgcmVmID0gY3JlYXRlQ29tcHV0ZVJlZihcbiAgICAgICgpID0+IHtcbiAgICAgICAgbGV0IGhhc2ggPSByZWlmeU5hbWVkKG5hbWVkKTtcblxuICAgICAgICBpZiAoREVCVUcgJiYgSEFTX05BVElWRV9QUk9YWSkge1xuICAgICAgICAgIGhhc2ggPSB3cmFwSGFzaFByb3h5KGhhc2gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICB9LFxuICAgICAgbnVsbCxcbiAgICAgICdoYXNoJ1xuICAgICk7XG5cbiAgICAvLyBTZXR1cCB0aGUgY2hpbGRyZW4gc28gdGhhdCB0ZW1wbGF0ZXMgY2FuIGJ5cGFzcyBnZXR0aW5nIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSByZWZlcmVuY2UgYW5kIHRyZWF0IGNoaWxkcmVuIGxhemlseVxuICAgIGxldCBjaGlsZHJlbiA9IG5ldyBNYXAoKTtcblxuICAgIGZvciAobGV0IG5hbWUgaW4gbmFtZWQpIHtcbiAgICAgIGNoaWxkcmVuLnNldChuYW1lLCBuYW1lZFtuYW1lXSk7XG4gICAgfVxuXG4gICAgcmVmLmNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICByZXR1cm4gcmVmO1xuICB9XG4pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==