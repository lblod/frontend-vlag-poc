import { childRefFor, createConstRef } from '@glimmer/reference';
import { unwrapHandle } from '@glimmer/util';
import { ARGS, CONSTANTS } from './symbols';
import VM from './vm/append';
import { DynamicScopeImpl } from './scope';
import { inTransaction } from './environment';
import { DEBUG } from '@glimmer/env';
import { runInTrackingTransaction } from '@glimmer/validator';

class TemplateIteratorImpl {
  constructor(vm) {
    this.vm = vm;
  }

  next() {
    return this.vm.next();
  }

  sync() {
    if (DEBUG) {
      return runInTrackingTransaction(() => this.vm.execute(), '- While rendering:');
    } else {
      return this.vm.execute();
    }
  }

}

export function renderSync(env, iterator) {
  let result;
  inTransaction(env, () => result = iterator.sync());
  return result;
}
export function renderMain(runtime, context, owner, self, treeBuilder, layout, dynamicScope = new DynamicScopeImpl()) {
  let handle = unwrapHandle(layout.compile(context));
  let numSymbols = layout.symbolTable.symbols.length;
  let vm = VM.initial(runtime, context, {
    self,
    dynamicScope,
    treeBuilder,
    handle,
    numSymbols,
    owner
  });
  return new TemplateIteratorImpl(vm);
}

function renderInvocation(vm, context, owner, definition, args) {
  // Get a list of tuples of argument names and references, like
  // [['title', reference], ['name', reference]]
  const argList = Object.keys(args).map(key => [key, args[key]]);
  const blockNames = ['main', 'else', 'attrs']; // Prefix argument names with `@` symbol

  const argNames = argList.map(([name]) => `@${name}`);
  let reified = vm[CONSTANTS].component(definition, owner);
  vm.pushFrame(); // Push blocks on to the stack, three stack values per block

  for (let i = 0; i < 3 * blockNames.length; i++) {
    vm.stack.push(null);
  }

  vm.stack.push(null); // For each argument, push its backing reference on to the stack

  argList.forEach(([, reference]) => {
    vm.stack.push(reference);
  }); // Configure VM based on blocks and args just pushed on to the stack.

  vm[ARGS].setup(vm.stack, argNames, blockNames, 0, true);
  const compilable = reified.compilable;
  const layoutHandle = unwrapHandle(compilable.compile(context));
  const invocation = {
    handle: layoutHandle,
    symbolTable: compilable.symbolTable
  }; // Needed for the Op.Main opcode: arguments, component invocation object, and
  // component definition.

  vm.stack.push(vm[ARGS]);
  vm.stack.push(invocation);
  vm.stack.push(reified);
  return new TemplateIteratorImpl(vm);
}

export function renderComponent(runtime, treeBuilder, context, owner, definition, args = {}, dynamicScope = new DynamicScopeImpl()) {
  let vm = VM.empty(runtime, {
    treeBuilder,
    handle: context.stdlib.main,
    dynamicScope,
    owner
  }, context);
  return renderInvocation(vm, context, owner, definition, recordToReference(args));
}

function recordToReference(record) {
  const root = createConstRef(record, 'args');
  return Object.keys(record).reduce((acc, key) => {
    acc[key] = childRefFor(root, key);
    return acc;
  }, {});
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3JlbmRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFhQSxTQUFTLFdBQVQsRUFBc0IsY0FBdEIsUUFBdUQsb0JBQXZEO0FBQ0EsU0FBaUIsWUFBakIsUUFBcUMsZUFBckM7QUFDQSxTQUFTLElBQVQsRUFBZSxTQUFmLFFBQWdDLFdBQWhDO0FBQ0EsT0FBTyxFQUFQLE1BQStCLGFBQS9CO0FBQ0EsU0FBUyxnQkFBVCxRQUFpQyxTQUFqQztBQUNBLFNBQVMsYUFBVCxRQUE4QixlQUE5QjtBQUNBLFNBQVMsS0FBVCxRQUFzQixjQUF0QjtBQUNBLFNBQVMsd0JBQVQsUUFBeUMsb0JBQXpDOztBQUVBLE1BQU0sb0JBQU4sQ0FBMEI7QUFDeEIsRUFBQSxXQUFBLENBQW9CLEVBQXBCLEVBQWtDO0FBQWQsU0FBQSxFQUFBLEdBQUEsRUFBQTtBQUFrQjs7QUFDdEMsRUFBQSxJQUFJLEdBQUE7QUFDRixXQUFPLEtBQUssRUFBTCxDQUFRLElBQVIsRUFBUDtBQUNEOztBQUVELEVBQUEsSUFBSSxHQUFBO0FBQ0YsUUFBSSxLQUFKLEVBQVc7QUFDVCxhQUFPLHdCQUF5QixDQUFDLE1BQU0sS0FBSyxFQUFMLENBQVEsT0FBUixFQUFQLEVBQTBCLG9CQUExQixDQUFoQztBQUNELEtBRkQsTUFFTztBQUNMLGFBQU8sS0FBSyxFQUFMLENBQVEsT0FBUixFQUFQO0FBQ0Q7QUFDRjs7QUFadUI7O0FBZTFCLE9BQU0sU0FBVSxVQUFWLENBQXFCLEdBQXJCLEVBQXVDLFFBQXZDLEVBQWlFO0FBQ3JFLE1BQUksTUFBSjtBQUVBLEVBQUEsYUFBYSxDQUFDLEdBQUQsRUFBTSxNQUFPLE1BQU0sR0FBRyxRQUFRLENBQUMsSUFBVCxFQUF0QixDQUFiO0FBRUEsU0FBTyxNQUFQO0FBQ0Q7QUFFRCxPQUFNLFNBQVUsVUFBVixDQUNKLE9BREksRUFFSixPQUZJLEVBR0osS0FISSxFQUlKLElBSkksRUFLSixX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QSxHQUFnQyxFQU41QixFQU9KLFlBQUEsR0FBNkIsSUFBSSxnQkFBSixFQVB6QixFQU8rQztBQUVuRCxNQUFJLEVBQUUsR0FBRyxFQUFFLENBQUMsS0FBSCxDQUNQLE9BRE8sRUFFUDtBQUFFLElBQUEsV0FBRjtBQUFlLElBQUEsTUFBTSxFQUFFLE9BQU8sQ0FBQyxNQUFSLENBQWUsSUFBdEM7QUFBNEMsSUFBQSxZQUE1QztBQUEwRCxJQUFBO0FBQTFELEdBRk8sRUFHUCxPQUhPLENBQVQ7QUFLQSxTQUFPLGdCQUFnQixDQUFDLEVBQUQsRUFBSyxPQUFMLEVBQWMsS0FBZCxFQUFxQixVQUFyQixFQUFpQyxpQkFBaUIsQ0FBQyxJQUFELENBQWxELENBQXZCO0FBQ0Q7O0FBRUQsU0FBUyxpQkFBVCxDQUEyQixNQUEzQixFQUEwRDtBQUN4RCxRQUFNLElBQUksR0FBRyxjQUFjLENBQUMsTUFBRCxFQUFTLE1BQVQsQ0FBM0I7QUFFQSxTQUFPLE1BQU0sQ0FBQyxJQUFQLENBQVksTUFBWixFQUFvQixNQUFwQixDQUEyQixDQUFDLEdBQUQsRUFBTSxHQUFOLEtBQWE7QUFDN0MsSUFBQSxHQUFHLENBQUMsR0FBRCxDQUFILEdBQVcsV0FBVyxDQUFDLElBQUQsRUFBTyxHQUFQLENBQXRCO0FBQ0EsV0FBTyxHQUFQO0FBQ0QsR0FITSxFQUdKLEVBSEksQ0FBUDtBQUlEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRHluYW1pY1Njb3BlLFxuICBFbnZpcm9ubWVudCxcbiAgUmVuZGVyUmVzdWx0LFxuICBSaWNoSXRlcmF0b3JSZXN1bHQsXG4gIFRlbXBsYXRlSXRlcmF0b3IsXG4gIFJ1bnRpbWVDb250ZXh0LFxuICBFbGVtZW50QnVpbGRlcixcbiAgQ29tcGlsYWJsZVByb2dyYW0sXG4gIENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0LFxuICBDb21wb25lbnREZWZpbml0aW9uU3RhdGUsXG4gIE93bmVyLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGNoaWxkUmVmRm9yLCBjcmVhdGVDb25zdFJlZiwgUmVmZXJlbmNlIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IGV4cGVjdCwgdW53cmFwSGFuZGxlIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBBUkdTLCBDT05TVEFOVFMgfSBmcm9tICcuL3N5bWJvbHMnO1xuaW1wb3J0IFZNLCB7IEludGVybmFsVk0gfSBmcm9tICcuL3ZtL2FwcGVuZCc7XG5pbXBvcnQgeyBEeW5hbWljU2NvcGVJbXBsIH0gZnJvbSAnLi9zY29wZSc7XG5pbXBvcnQgeyBpblRyYW5zYWN0aW9uIH0gZnJvbSAnLi9lbnZpcm9ubWVudCc7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQgeyBydW5JblRyYWNraW5nVHJhbnNhY3Rpb24gfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuXG5jbGFzcyBUZW1wbGF0ZUl0ZXJhdG9ySW1wbCBpbXBsZW1lbnRzIFRlbXBsYXRlSXRlcmF0b3Ige1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHZtOiBJbnRlcm5hbFZNKSB7fVxuICBuZXh0KCk6IFJpY2hJdGVyYXRvclJlc3VsdDxudWxsLCBSZW5kZXJSZXN1bHQ+IHtcbiAgICByZXR1cm4gdGhpcy52bS5uZXh0KCk7XG4gIH1cblxuICBzeW5jKCk6IFJlbmRlclJlc3VsdCB7XG4gICAgaWYgKERFQlVHKSB7XG4gICAgICByZXR1cm4gcnVuSW5UcmFja2luZ1RyYW5zYWN0aW9uISgoKSA9PiB0aGlzLnZtLmV4ZWN1dGUoKSwgJy0gV2hpbGUgcmVuZGVyaW5nOicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy52bS5leGVjdXRlKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJTeW5jKGVudjogRW52aXJvbm1lbnQsIGl0ZXJhdG9yOiBUZW1wbGF0ZUl0ZXJhdG9yKTogUmVuZGVyUmVzdWx0IHtcbiAgbGV0IHJlc3VsdDogUmVuZGVyUmVzdWx0O1xuXG4gIGluVHJhbnNhY3Rpb24oZW52LCAoKSA9PiAocmVzdWx0ID0gaXRlcmF0b3Iuc3luYygpKSk7XG5cbiAgcmV0dXJuIHJlc3VsdCE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJNYWluKFxuICBydW50aW1lOiBSdW50aW1lQ29udGV4dCxcbiAgY29udGV4dDogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIG93bmVyOiBPd25lcixcbiAgc2VsZjogUmVmZXJlbmNlLFxuICB0cmVlQnVpbGRlcjogRWxlbWVudEJ1aWxkZXIsXG4gIGxheW91dDogQ29tcGlsYWJsZVByb2dyYW0sXG4gIGR5bmFtaWNTY29wZTogRHluYW1pY1Njb3BlID0gbmV3IER5bmFtaWNTY29wZUltcGwoKVxuKTogVGVtcGxhdGVJdGVyYXRvciB7XG4gIGxldCBoYW5kbGUgPSB1bndyYXBIYW5kbGUobGF5b3V0LmNvbXBpbGUoY29udGV4dCkpO1xuICBsZXQgbnVtU3ltYm9scyA9IGxheW91dC5zeW1ib2xUYWJsZS5zeW1ib2xzLmxlbmd0aDtcbiAgbGV0IHZtID0gVk0uaW5pdGlhbChydW50aW1lLCBjb250ZXh0LCB7XG4gICAgc2VsZixcbiAgICBkeW5hbWljU2NvcGUsXG4gICAgdHJlZUJ1aWxkZXIsXG4gICAgaGFuZGxlLFxuICAgIG51bVN5bWJvbHMsXG4gICAgb3duZXIsXG4gIH0pO1xuICByZXR1cm4gbmV3IFRlbXBsYXRlSXRlcmF0b3JJbXBsKHZtKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVySW52b2NhdGlvbihcbiAgdm06IEludGVybmFsVk0sXG4gIGNvbnRleHQ6IENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0LFxuICBvd25lcjogT3duZXIsXG4gIGRlZmluaXRpb246IENvbXBvbmVudERlZmluaXRpb25TdGF0ZSxcbiAgYXJnczogUmVjb3JkPHN0cmluZywgUmVmZXJlbmNlPlxuKTogVGVtcGxhdGVJdGVyYXRvciB7XG4gIC8vIEdldCBhIGxpc3Qgb2YgdHVwbGVzIG9mIGFyZ3VtZW50IG5hbWVzIGFuZCByZWZlcmVuY2VzLCBsaWtlXG4gIC8vIFtbJ3RpdGxlJywgcmVmZXJlbmNlXSwgWyduYW1lJywgcmVmZXJlbmNlXV1cbiAgY29uc3QgYXJnTGlzdCA9IE9iamVjdC5rZXlzKGFyZ3MpLm1hcCgoa2V5KSA9PiBba2V5LCBhcmdzW2tleV1dKTtcblxuICBjb25zdCBibG9ja05hbWVzID0gWydtYWluJywgJ2Vsc2UnLCAnYXR0cnMnXTtcbiAgLy8gUHJlZml4IGFyZ3VtZW50IG5hbWVzIHdpdGggYEBgIHN5bWJvbFxuICBjb25zdCBhcmdOYW1lcyA9IGFyZ0xpc3QubWFwKChbbmFtZV0pID0+IGBAJHtuYW1lfWApO1xuXG4gIGxldCByZWlmaWVkID0gdm1bQ09OU1RBTlRTXS5jb21wb25lbnQoZGVmaW5pdGlvbiwgb3duZXIpO1xuXG4gIHZtLnB1c2hGcmFtZSgpO1xuXG4gIC8vIFB1c2ggYmxvY2tzIG9uIHRvIHRoZSBzdGFjaywgdGhyZWUgc3RhY2sgdmFsdWVzIHBlciBibG9ja1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDMgKiBibG9ja05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdm0uc3RhY2sucHVzaChudWxsKTtcbiAgfVxuXG4gIHZtLnN0YWNrLnB1c2gobnVsbCk7XG5cbiAgLy8gRm9yIGVhY2ggYXJndW1lbnQsIHB1c2ggaXRzIGJhY2tpbmcgcmVmZXJlbmNlIG9uIHRvIHRoZSBzdGFja1xuICBhcmdMaXN0LmZvckVhY2goKFssIHJlZmVyZW5jZV0pID0+IHtcbiAgICB2bS5zdGFjay5wdXNoKHJlZmVyZW5jZSk7XG4gIH0pO1xuXG4gIC8vIENvbmZpZ3VyZSBWTSBiYXNlZCBvbiBibG9ja3MgYW5kIGFyZ3MganVzdCBwdXNoZWQgb24gdG8gdGhlIHN0YWNrLlxuICB2bVtBUkdTXS5zZXR1cCh2bS5zdGFjaywgYXJnTmFtZXMsIGJsb2NrTmFtZXMsIDAsIHRydWUpO1xuXG4gIGNvbnN0IGNvbXBpbGFibGUgPSBleHBlY3QoXG4gICAgcmVpZmllZC5jb21waWxhYmxlLFxuICAgICdCVUc6IEV4cGVjdGVkIHRoZSByb290IGNvbXBvbmVudCByZW5kZXJlZCB3aXRoIHJlbmRlckNvbXBvbmVudCB0byBoYXZlIGFuIGFzc29jaWF0ZWQgdGVtcGxhdGUsIHNldCB3aXRoIHNldENvbXBvbmVudFRlbXBsYXRlJ1xuICApO1xuICBjb25zdCBsYXlvdXRIYW5kbGUgPSB1bndyYXBIYW5kbGUoY29tcGlsYWJsZS5jb21waWxlKGNvbnRleHQpKTtcbiAgY29uc3QgaW52b2NhdGlvbiA9IHsgaGFuZGxlOiBsYXlvdXRIYW5kbGUsIHN5bWJvbFRhYmxlOiBjb21waWxhYmxlLnN5bWJvbFRhYmxlIH07XG5cbiAgLy8gTmVlZGVkIGZvciB0aGUgT3AuTWFpbiBvcGNvZGU6IGFyZ3VtZW50cywgY29tcG9uZW50IGludm9jYXRpb24gb2JqZWN0LCBhbmRcbiAgLy8gY29tcG9uZW50IGRlZmluaXRpb24uXG4gIHZtLnN0YWNrLnB1c2godm1bQVJHU10pO1xuICB2bS5zdGFjay5wdXNoKGludm9jYXRpb24pO1xuICB2bS5zdGFjay5wdXNoKHJlaWZpZWQpO1xuXG4gIHJldHVybiBuZXcgVGVtcGxhdGVJdGVyYXRvckltcGwodm0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50KFxuICBydW50aW1lOiBSdW50aW1lQ29udGV4dCxcbiAgdHJlZUJ1aWxkZXI6IEVsZW1lbnRCdWlsZGVyLFxuICBjb250ZXh0OiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCxcbiAgb3duZXI6IE93bmVyLFxuICBkZWZpbml0aW9uOiBDb21wb25lbnREZWZpbml0aW9uU3RhdGUsXG4gIGFyZ3M6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge30sXG4gIGR5bmFtaWNTY29wZTogRHluYW1pY1Njb3BlID0gbmV3IER5bmFtaWNTY29wZUltcGwoKVxuKTogVGVtcGxhdGVJdGVyYXRvciB7XG4gIGxldCB2bSA9IFZNLmVtcHR5KFxuICAgIHJ1bnRpbWUsXG4gICAgeyB0cmVlQnVpbGRlciwgaGFuZGxlOiBjb250ZXh0LnN0ZGxpYi5tYWluLCBkeW5hbWljU2NvcGUsIG93bmVyIH0sXG4gICAgY29udGV4dFxuICApO1xuICByZXR1cm4gcmVuZGVySW52b2NhdGlvbih2bSwgY29udGV4dCwgb3duZXIsIGRlZmluaXRpb24sIHJlY29yZFRvUmVmZXJlbmNlKGFyZ3MpKTtcbn1cblxuZnVuY3Rpb24gcmVjb3JkVG9SZWZlcmVuY2UocmVjb3JkOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPik6IFJlY29yZDxzdHJpbmcsIFJlZmVyZW5jZT4ge1xuICBjb25zdCByb290ID0gY3JlYXRlQ29uc3RSZWYocmVjb3JkLCAnYXJncycpO1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhyZWNvcmQpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBhY2Nba2V5XSA9IGNoaWxkUmVmRm9yKHJvb3QsIGtleSk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgUmVmZXJlbmNlPik7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9