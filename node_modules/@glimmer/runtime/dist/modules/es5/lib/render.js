import { childRefFor, createConstRef } from '@glimmer/reference';
import { unwrapHandle } from '@glimmer/util';
import { ARGS, CONSTANTS } from './symbols';
import VM from './vm/append';
import { DynamicScopeImpl } from './scope';
import { inTransaction } from './environment';
import { DEBUG } from '@glimmer/env';
import { runInTrackingTransaction } from '@glimmer/validator';

var TemplateIteratorImpl = /*#__PURE__*/function () {
  function TemplateIteratorImpl(vm) {
    this.vm = vm;
  }

  var _proto = TemplateIteratorImpl.prototype;

  _proto.next = function next() {
    return this.vm.next();
  };

  _proto.sync = function sync() {
    var _this = this;

    if (DEBUG) {
      return runInTrackingTransaction(function () {
        return _this.vm.execute();
      }, '- While rendering:');
    } else {
      return this.vm.execute();
    }
  };

  return TemplateIteratorImpl;
}();

export function renderSync(env, iterator) {
  var result;
  inTransaction(env, function () {
    return result = iterator.sync();
  });
  return result;
}
export function renderMain(runtime, context, owner, self, treeBuilder, layout, dynamicScope) {
  if (dynamicScope === void 0) {
    dynamicScope = new DynamicScopeImpl();
  }

  var handle = unwrapHandle(layout.compile(context));
  var numSymbols = layout.symbolTable.symbols.length;
  var vm = VM.initial(runtime, context, {
    self: self,
    dynamicScope: dynamicScope,
    treeBuilder: treeBuilder,
    handle: handle,
    numSymbols: numSymbols,
    owner: owner
  });
  return new TemplateIteratorImpl(vm);
}

function renderInvocation(vm, context, owner, definition, args) {
  // Get a list of tuples of argument names and references, like
  // [['title', reference], ['name', reference]]
  var argList = Object.keys(args).map(function (key) {
    return [key, args[key]];
  });
  var blockNames = ['main', 'else', 'attrs']; // Prefix argument names with `@` symbol

  var argNames = argList.map(function (_ref) {
    var name = _ref[0];
    return "@" + name;
  });
  var reified = vm[CONSTANTS].component(definition, owner);
  vm.pushFrame(); // Push blocks on to the stack, three stack values per block

  for (var i = 0; i < 3 * blockNames.length; i++) {
    vm.stack.push(null);
  }

  vm.stack.push(null); // For each argument, push its backing reference on to the stack

  argList.forEach(function (_ref2) {
    var reference = _ref2[1];
    vm.stack.push(reference);
  }); // Configure VM based on blocks and args just pushed on to the stack.

  vm[ARGS].setup(vm.stack, argNames, blockNames, 0, true);
  var compilable = reified.compilable;
  var layoutHandle = unwrapHandle(compilable.compile(context));
  var invocation = {
    handle: layoutHandle,
    symbolTable: compilable.symbolTable
  }; // Needed for the Op.Main opcode: arguments, component invocation object, and
  // component definition.

  vm.stack.push(vm[ARGS]);
  vm.stack.push(invocation);
  vm.stack.push(reified);
  return new TemplateIteratorImpl(vm);
}

export function renderComponent(runtime, treeBuilder, context, owner, definition, args, dynamicScope) {
  if (args === void 0) {
    args = {};
  }

  if (dynamicScope === void 0) {
    dynamicScope = new DynamicScopeImpl();
  }

  var vm = VM.empty(runtime, {
    treeBuilder: treeBuilder,
    handle: context.stdlib.main,
    dynamicScope: dynamicScope,
    owner: owner
  }, context);
  return renderInvocation(vm, context, owner, definition, recordToReference(args));
}

function recordToReference(record) {
  var root = createConstRef(record, 'args');
  return Object.keys(record).reduce(function (acc, key) {
    acc[key] = childRefFor(root, key);
    return acc;
  }, {});
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL3JlbmRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFhQSxTQUFBLFdBQUEsRUFBQSxjQUFBLFFBQUEsb0JBQUE7QUFDQSxTQUFBLFlBQUEsUUFBQSxlQUFBO0FBQ0EsU0FBQSxJQUFBLEVBQUEsU0FBQSxRQUFBLFdBQUE7QUFDQSxPQUFBLEVBQUEsTUFBQSxhQUFBO0FBQ0EsU0FBQSxnQkFBQSxRQUFBLFNBQUE7QUFDQSxTQUFBLGFBQUEsUUFBQSxlQUFBO0FBQ0EsU0FBQSxLQUFBLFFBQUEsY0FBQTtBQUNBLFNBQUEsd0JBQUEsUUFBQSxvQkFBQTs7SUFFQSxvQjtBQUNFLGdDQUFBLEVBQUEsRUFBa0M7QUFBZCxTQUFBLEVBQUEsR0FBQSxFQUFBO0FBQWtCOzs7O1NBQ3RDLEksR0FBQSxnQkFBSTtBQUNGLFdBQU8sS0FBQSxFQUFBLENBQVAsSUFBTyxFQUFQO0FBQ0QsRzs7U0FFRCxJLEdBQUEsZ0JBQUk7QUFBQTs7QUFDRixRQUFBLEtBQUEsRUFBVztBQUNULGFBQU8sd0JBQXlCLENBQUM7QUFBQSxlQUFNLEtBQUEsQ0FBQSxFQUFBLENBQVAsT0FBTyxFQUFOO0FBQUEsT0FBRCxFQUFoQyxvQkFBZ0MsQ0FBaEM7QUFERixLQUFBLE1BRU87QUFDTCxhQUFPLEtBQUEsRUFBQSxDQUFQLE9BQU8sRUFBUDtBQUNEO0FBQ0YsRzs7Ozs7QUFHSCxPQUFNLFNBQUEsVUFBQSxDQUFBLEdBQUEsRUFBQSxRQUFBLEVBQWlFO0FBQ3JFLE1BQUEsTUFBQTtBQUVBLEVBQUEsYUFBYSxDQUFBLEdBQUEsRUFBTTtBQUFBLFdBQU8sTUFBTSxHQUFHLFFBQVEsQ0FBM0MsSUFBbUMsRUFBaEI7QUFBQSxHQUFOLENBQWI7QUFFQSxTQUFBLE1BQUE7QUFDRDtBQUVELE9BQU0sU0FBQSxVQUFBLENBQUEsT0FBQSxFQUFBLE9BQUEsRUFBQSxLQUFBLEVBQUEsSUFBQSxFQUFBLFdBQUEsRUFBQSxN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QU8sSUFBQSxvQkFBQSxDQUFQLEVBQU8sQ0FBUDtBQUNEOztBQUVELE9BQU0sU0FBQSxlQUFBLENBQUEsT0FBQSxFQUFBLFdBQUEsRUFBQSxPQUFBLEVBQUEsS0FBQSxFQUFBLFVBQUEsRUFNSixJQU5JLEVBT0osWUFQSSxFQU8rQztBQUFBLE1BRG5ELElBQ21EO0FBRG5ELElBQUEsSUFDbUQsR0FQL0MsRUFPK0M7QUFBQTs7QUFBQSxNQUFuRCxZQUFtRDtBQUFuRCxJQUFBLFlBQW1ELEdBQXRCLElBUHpCLGdCQU95QixFQUFzQjtBQUFBOztBQUVuRCxNQUFJLEVBQUUsR0FBRyxFQUFFLENBQUYsS0FBQSxDQUFBLE9BQUEsRUFFUDtBQUFFLElBQUEsV0FBRixFQUFFLFdBQUY7QUFBZSxJQUFBLE1BQU0sRUFBRSxPQUFPLENBQVAsTUFBQSxDQUF2QixJQUFBO0FBQTRDLElBQUEsWUFBNUMsRUFBNEMsWUFBNUM7QUFBMEQsSUFBQSxLQUFBLEVBQUE7QUFBMUQsR0FGTyxFQUFULE9BQVMsQ0FBVDtBQUtBLFNBQU8sZ0JBQWdCLENBQUEsRUFBQSxFQUFBLE9BQUEsRUFBQSxLQUFBLEVBQUEsVUFBQSxFQUFpQyxpQkFBaUIsQ0FBekUsSUFBeUUsQ0FBbEQsQ0FBdkI7QUFDRDs7QUFFRCxTQUFBLGlCQUFBLENBQUEsTUFBQSxFQUEwRDtBQUN4RCxNQUFNLElBQUksR0FBRyxjQUFjLENBQUEsTUFBQSxFQUEzQixNQUEyQixDQUEzQjtBQUVBLFNBQU8sTUFBTSxDQUFOLElBQUEsQ0FBQSxNQUFBLEVBQUEsTUFBQSxDQUEyQixVQUFBLEdBQUEsRUFBQSxHQUFBLEVBQWE7QUFDN0MsSUFBQSxHQUFHLENBQUgsR0FBRyxDQUFILEdBQVcsV0FBVyxDQUFBLElBQUEsRUFBdEIsR0FBc0IsQ0FBdEI7QUFDQSxXQUFBLEdBQUE7QUFGSyxHQUFBLEVBQVAsRUFBTyxDQUFQO0FBSUQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEeW5hbWljU2NvcGUsXG4gIEVudmlyb25tZW50LFxuICBSZW5kZXJSZXN1bHQsXG4gIFJpY2hJdGVyYXRvclJlc3VsdCxcbiAgVGVtcGxhdGVJdGVyYXRvcixcbiAgUnVudGltZUNvbnRleHQsXG4gIEVsZW1lbnRCdWlsZGVyLFxuICBDb21waWxhYmxlUHJvZ3JhbSxcbiAgQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIENvbXBvbmVudERlZmluaXRpb25TdGF0ZSxcbiAgT3duZXIsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgY2hpbGRSZWZGb3IsIGNyZWF0ZUNvbnN0UmVmLCBSZWZlcmVuY2UgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgZXhwZWN0LCB1bndyYXBIYW5kbGUgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IEFSR1MsIENPTlNUQU5UUyB9IGZyb20gJy4vc3ltYm9scyc7XG5pbXBvcnQgVk0sIHsgSW50ZXJuYWxWTSB9IGZyb20gJy4vdm0vYXBwZW5kJztcbmltcG9ydCB7IER5bmFtaWNTY29wZUltcGwgfSBmcm9tICcuL3Njb3BlJztcbmltcG9ydCB7IGluVHJhbnNhY3Rpb24gfSBmcm9tICcuL2Vudmlyb25tZW50JztcbmltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IHJ1bkluVHJhY2tpbmdUcmFuc2FjdGlvbiB9IGZyb20gJ0BnbGltbWVyL3ZhbGlkYXRvcic7XG5cbmNsYXNzIFRlbXBsYXRlSXRlcmF0b3JJbXBsIGltcGxlbWVudHMgVGVtcGxhdGVJdGVyYXRvciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdm06IEludGVybmFsVk0pIHt9XG4gIG5leHQoKTogUmljaEl0ZXJhdG9yUmVzdWx0PG51bGwsIFJlbmRlclJlc3VsdD4ge1xuICAgIHJldHVybiB0aGlzLnZtLm5leHQoKTtcbiAgfVxuXG4gIHN5bmMoKTogUmVuZGVyUmVzdWx0IHtcbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIHJldHVybiBydW5JblRyYWNraW5nVHJhbnNhY3Rpb24hKCgpID0+IHRoaXMudm0uZXhlY3V0ZSgpLCAnLSBXaGlsZSByZW5kZXJpbmc6Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnZtLmV4ZWN1dGUoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlclN5bmMoZW52OiBFbnZpcm9ubWVudCwgaXRlcmF0b3I6IFRlbXBsYXRlSXRlcmF0b3IpOiBSZW5kZXJSZXN1bHQge1xuICBsZXQgcmVzdWx0OiBSZW5kZXJSZXN1bHQ7XG5cbiAgaW5UcmFuc2FjdGlvbihlbnYsICgpID0+IChyZXN1bHQgPSBpdGVyYXRvci5zeW5jKCkpKTtcblxuICByZXR1cm4gcmVzdWx0ITtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlck1haW4oXG4gIHJ1bnRpbWU6IFJ1bnRpbWVDb250ZXh0LFxuICBjb250ZXh0OiBDb21waWxlVGltZUNvbXBpbGF0aW9uQ29udGV4dCxcbiAgb3duZXI6IE93bmVyLFxuICBzZWxmOiBSZWZlcmVuY2UsXG4gIHRyZWVCdWlsZGVyOiBFbGVtZW50QnVpbGRlcixcbiAgbGF5b3V0OiBDb21waWxhYmxlUHJvZ3JhbSxcbiAgZHluYW1pY1Njb3BlOiBEeW5hbWljU2NvcGUgPSBuZXcgRHluYW1pY1Njb3BlSW1wbCgpXG4pOiBUZW1wbGF0ZUl0ZXJhdG9yIHtcbiAgbGV0IGhhbmRsZSA9IHVud3JhcEhhbmRsZShsYXlvdXQuY29tcGlsZShjb250ZXh0KSk7XG4gIGxldCBudW1TeW1ib2xzID0gbGF5b3V0LnN5bWJvbFRhYmxlLnN5bWJvbHMubGVuZ3RoO1xuICBsZXQgdm0gPSBWTS5pbml0aWFsKHJ1bnRpbWUsIGNvbnRleHQsIHtcbiAgICBzZWxmLFxuICAgIGR5bmFtaWNTY29wZSxcbiAgICB0cmVlQnVpbGRlcixcbiAgICBoYW5kbGUsXG4gICAgbnVtU3ltYm9scyxcbiAgICBvd25lcixcbiAgfSk7XG4gIHJldHVybiBuZXcgVGVtcGxhdGVJdGVyYXRvckltcGwodm0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJJbnZvY2F0aW9uKFxuICB2bTogSW50ZXJuYWxWTSxcbiAgY29udGV4dDogQ29tcGlsZVRpbWVDb21waWxhdGlvbkNvbnRleHQsXG4gIG93bmVyOiBPd25lcixcbiAgZGVmaW5pdGlvbjogQ29tcG9uZW50RGVmaW5pdGlvblN0YXRlLFxuICBhcmdzOiBSZWNvcmQ8c3RyaW5nLCBSZWZlcmVuY2U+XG4pOiBUZW1wbGF0ZUl0ZXJhdG9yIHtcbiAgLy8gR2V0IGEgbGlzdCBvZiB0dXBsZXMgb2YgYXJndW1lbnQgbmFtZXMgYW5kIHJlZmVyZW5jZXMsIGxpa2VcbiAgLy8gW1sndGl0bGUnLCByZWZlcmVuY2VdLCBbJ25hbWUnLCByZWZlcmVuY2VdXVxuICBjb25zdCBhcmdMaXN0ID0gT2JqZWN0LmtleXMoYXJncykubWFwKChrZXkpID0+IFtrZXksIGFyZ3Nba2V5XV0pO1xuXG4gIGNvbnN0IGJsb2NrTmFtZXMgPSBbJ21haW4nLCAnZWxzZScsICdhdHRycyddO1xuICAvLyBQcmVmaXggYXJndW1lbnQgbmFtZXMgd2l0aCBgQGAgc3ltYm9sXG4gIGNvbnN0IGFyZ05hbWVzID0gYXJnTGlzdC5tYXAoKFtuYW1lXSkgPT4gYEAke25hbWV9YCk7XG5cbiAgbGV0IHJlaWZpZWQgPSB2bVtDT05TVEFOVFNdLmNvbXBvbmVudChkZWZpbml0aW9uLCBvd25lcik7XG5cbiAgdm0ucHVzaEZyYW1lKCk7XG5cbiAgLy8gUHVzaCBibG9ja3Mgb24gdG8gdGhlIHN0YWNrLCB0aHJlZSBzdGFjayB2YWx1ZXMgcGVyIGJsb2NrXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMyAqIGJsb2NrTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2bS5zdGFjay5wdXNoKG51bGwpO1xuICB9XG5cbiAgdm0uc3RhY2sucHVzaChudWxsKTtcblxuICAvLyBGb3IgZWFjaCBhcmd1bWVudCwgcHVzaCBpdHMgYmFja2luZyByZWZlcmVuY2Ugb24gdG8gdGhlIHN0YWNrXG4gIGFyZ0xpc3QuZm9yRWFjaCgoWywgcmVmZXJlbmNlXSkgPT4ge1xuICAgIHZtLnN0YWNrLnB1c2gocmVmZXJlbmNlKTtcbiAgfSk7XG5cbiAgLy8gQ29uZmlndXJlIFZNIGJhc2VkIG9uIGJsb2NrcyBhbmQgYXJncyBqdXN0IHB1c2hlZCBvbiB0byB0aGUgc3RhY2suXG4gIHZtW0FSR1NdLnNldHVwKHZtLnN0YWNrLCBhcmdOYW1lcywgYmxvY2tOYW1lcywgMCwgdHJ1ZSk7XG5cbiAgY29uc3QgY29tcGlsYWJsZSA9IGV4cGVjdChcbiAgICByZWlmaWVkLmNvbXBpbGFibGUsXG4gICAgJ0JVRzogRXhwZWN0ZWQgdGhlIHJvb3QgY29tcG9uZW50IHJlbmRlcmVkIHdpdGggcmVuZGVyQ29tcG9uZW50IHRvIGhhdmUgYW4gYXNzb2NpYXRlZCB0ZW1wbGF0ZSwgc2V0IHdpdGggc2V0Q29tcG9uZW50VGVtcGxhdGUnXG4gICk7XG4gIGNvbnN0IGxheW91dEhhbmRsZSA9IHVud3JhcEhhbmRsZShjb21waWxhYmxlLmNvbXBpbGUoY29udGV4dCkpO1xuICBjb25zdCBpbnZvY2F0aW9uID0geyBoYW5kbGU6IGxheW91dEhhbmRsZSwgc3ltYm9sVGFibGU6IGNvbXBpbGFibGUuc3ltYm9sVGFibGUgfTtcblxuICAvLyBOZWVkZWQgZm9yIHRoZSBPcC5NYWluIG9wY29kZTogYXJndW1lbnRzLCBjb21wb25lbnQgaW52b2NhdGlvbiBvYmplY3QsIGFuZFxuICAvLyBjb21wb25lbnQgZGVmaW5pdGlvbi5cbiAgdm0uc3RhY2sucHVzaCh2bVtBUkdTXSk7XG4gIHZtLnN0YWNrLnB1c2goaW52b2NhdGlvbik7XG4gIHZtLnN0YWNrLnB1c2gocmVpZmllZCk7XG5cbiAgcmV0dXJuIG5ldyBUZW1wbGF0ZUl0ZXJhdG9ySW1wbCh2bSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJDb21wb25lbnQoXG4gIHJ1bnRpbWU6IFJ1bnRpbWVDb250ZXh0LFxuICB0cmVlQnVpbGRlcjogRWxlbWVudEJ1aWxkZXIsXG4gIGNvbnRleHQ6IENvbXBpbGVUaW1lQ29tcGlsYXRpb25Db250ZXh0LFxuICBvd25lcjogT3duZXIsXG4gIGRlZmluaXRpb246IENvbXBvbmVudERlZmluaXRpb25TdGF0ZSxcbiAgYXJnczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gPSB7fSxcbiAgZHluYW1pY1Njb3BlOiBEeW5hbWljU2NvcGUgPSBuZXcgRHluYW1pY1Njb3BlSW1wbCgpXG4pOiBUZW1wbGF0ZUl0ZXJhdG9yIHtcbiAgbGV0IHZtID0gVk0uZW1wdHkoXG4gICAgcnVudGltZSxcbiAgICB7IHRyZWVCdWlsZGVyLCBoYW5kbGU6IGNvbnRleHQuc3RkbGliLm1haW4sIGR5bmFtaWNTY29wZSwgb3duZXIgfSxcbiAgICBjb250ZXh0XG4gICk7XG4gIHJldHVybiByZW5kZXJJbnZvY2F0aW9uKHZtLCBjb250ZXh0LCBvd25lciwgZGVmaW5pdGlvbiwgcmVjb3JkVG9SZWZlcmVuY2UoYXJncykpO1xufVxuXG5mdW5jdGlvbiByZWNvcmRUb1JlZmVyZW5jZShyZWNvcmQ6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogUmVjb3JkPHN0cmluZywgUmVmZXJlbmNlPiB7XG4gIGNvbnN0IHJvb3QgPSBjcmVhdGVDb25zdFJlZihyZWNvcmQsICdhcmdzJyk7XG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKHJlY29yZCkucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0gY2hpbGRSZWZGb3Iocm9vdCwga2V5KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBSZWZlcmVuY2U+KTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=