function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import { DEBUG } from '@glimmer/env';
import { createCache, getValue } from '@glimmer/validator';
import { debugToString } from '@glimmer/util';
import { getInternalHelperManager, hasDestroyable, hasValue } from '@glimmer/manager';
import { EMPTY_ARGS, EMPTY_NAMED, EMPTY_POSITIONAL } from '../vm/arguments';
import { getOwner } from '@glimmer/owner';
import { associateDestroyableChild, isDestroyed, isDestroying } from '@glimmer/destroyable';
var ARGS_CACHES = DEBUG ? new WeakMap() : undefined;

function getArgs(proxy) {
  return getValue(DEBUG ? ARGS_CACHES.get(proxy) : proxy.argsCache);
}

var SimpleArgsProxy = /*#__PURE__*/function () {
  function SimpleArgsProxy(context, computeArgs) {
    if (computeArgs === void 0) {
      computeArgs = function computeArgs() {
        return EMPTY_ARGS;
      };
    }

    var argsCache = createCache(function () {
      return computeArgs(context);
    });

    if (DEBUG) {
      ARGS_CACHES.set(this, argsCache);
      Object.freeze(this);
    } else {
      this.argsCache = argsCache;
    }
  }

  _createClass(SimpleArgsProxy, [{
    key: "named",
    get: function get() {
      return getArgs(this).named || EMPTY_NAMED;
    }
  }, {
    key: "positional",
    get: function get() {
      return getArgs(this).positional || EMPTY_POSITIONAL;
    }
  }]);

  return SimpleArgsProxy;
}(); ////////////


export function invokeHelper(context, definition, computeArgs) {
  if (DEBUG && (typeof context !== 'object' || context === null)) {
    throw new Error("Expected a context object to be passed as the first parameter to invokeHelper, got " + context);
  }

  var owner = getOwner(context);
  var internalManager = getInternalHelperManager(definition); // TODO: figure out why assert isn't using the TS assert thing

  if (DEBUG && !internalManager) {
    throw new Error("Expected a helper definition to be passed as the second parameter to invokeHelper, but no helper manager was found. The definition value that was passed was `" + debugToString(definition) + "`. Did you use setHelperManager to associate a helper manager with this value?");
  }

  if (DEBUG && typeof internalManager === 'function') {
    throw new Error('Found a helper manager, but it was an internal built-in helper manager. `invokeHelper` does not support internal helpers yet.');
  }

  var manager = internalManager.getDelegateFor(owner);
  var args = new SimpleArgsProxy(context, computeArgs);
  var bucket = manager.createHelper(definition, args);
  var cache;

  if (hasValue(manager)) {
    cache = createCache(function () {
      if (DEBUG && (isDestroying(cache) || isDestroyed(cache))) {
        throw new Error("You attempted to get the value of a helper after the helper was destroyed, which is not allowed");
      }

      return manager.getValue(bucket);
    });
    associateDestroyableChild(context, cache);
  } else {
    throw new Error('TODO: unreachable, to be implemented with hasScheduledEffect');
  }

  if (hasDestroyable(manager)) {
    var destroyable = manager.getDestroyable(bucket);
    associateDestroyableChild(cache, destroyable);
  }

  return cache;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2hlbHBlcnMvaW52b2tlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxTQUFBLEtBQUEsUUFBQSxjQUFBO0FBQ0EsU0FBQSxXQUFBLEVBQUEsUUFBQSxRQUFBLG9CQUFBO0FBRUEsU0FBQSxhQUFBLFFBQUEsZUFBQTtBQUNBLFNBQUEsd0JBQUEsRUFBQSxjQUFBLEVBQUEsUUFBQSxRQUFBLGtCQUFBO0FBRUEsU0FBQSxVQUFBLEVBQUEsV0FBQSxFQUFBLGdCQUFBLFFBQUEsaUJBQUE7QUFDQSxTQUFBLFFBQUEsUUFBQSxnQkFBQTtBQUNBLFNBQUEseUJBQUEsRUFBQSxXQUFBLEVBQUEsWUFBQSxRQUFBLHNCQUFBO0FBRUEsSUFBSSxXQUFXLEdBQUcsS0FBSyxHQUFHLElBQUgsT0FBRyxFQUFILEdBQXZCLFNBQUE7O0FBRUEsU0FBQSxPQUFBLENBQUEsS0FBQSxFQUF1QztBQUNyQyxTQUFPLFFBQVEsQ0FBQyxLQUFLLEdBQUcsV0FBWSxDQUFaLEdBQUEsQ0FBSCxLQUFHLENBQUgsR0FBOEIsS0FBSyxDQUF4RCxTQUFlLENBQWY7QUFDRDs7SUFFRCxlO0FBR0UsMkJBQUEsT0FBQSxFQUVFLFdBRkYsRUFFeUU7QUFBQSxRQUF2RSxXQUF1RTtBQUF2RSxNQUFBLFdBQXVFLEdBQWhCO0FBQUEsZUFGekQsVUFFeUQ7QUFBQSxPQUFnQjtBQUFBOztBQUV2RSxRQUFJLFNBQVMsR0FBRyxXQUFXLENBQUM7QUFBQSxhQUFNLFdBQVcsQ0FBN0MsT0FBNkMsQ0FBakI7QUFBQSxLQUFELENBQTNCOztBQUVBLFFBQUEsS0FBQSxFQUFXO0FBQ1QsTUFBQSxXQUFZLENBQVosR0FBQSxDQUFBLElBQUEsRUFBQSxTQUFBO0FBQ0EsTUFBQSxNQUFNLENBQU4sTUFBQSxDQUFBLElBQUE7QUFGRixLQUFBLE1BR087QUFDTCxXQUFBLFNBQUEsR0FBQSxTQUFBO0FBQ0Q7QUFDRjs7Ozt3QkFFUTtBQUNQLGFBQU8sT0FBTyxDQUFQLElBQU8sQ0FBUCxDQUFBLEtBQUEsSUFBUCxXQUFBO0FBQ0Q7Ozt3QkFFYTtBQUNaLGFBQU8sT0FBTyxDQUFQLElBQU8sQ0FBUCxDQUFBLFVBQUEsSUFBUCxnQkFBQTtBQUNEOzs7O0tBR0g7OztBQUVBLE9BQU0sU0FBQSxZQUFBLENBQUEsT0FBQSxFQUFBLFVBQUEsRUFBQSxXQUFBLEVBR2lEO0FBRXJELE1BQUksS0FBSyxLQUFLLE9BQUEsT0FBQSxLQUFBLFFBQUEsSUFBK0IsT0FBTyxLQUFwRCxJQUFTLENBQVQsRUFBZ0U7QUFDOUQsVUFBTSxJQUFBLEtBQUEseUZBQU4sT0FBTSxDQUFOO0FBR0Q7O0FBRUQsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUF0QixPQUFzQixDQUF0QjtBQUNBLE1BQU0sZUFBZSxHQUFHLHdCQUF3QixDQVRLLFVBU0wsQ0FBaEQsQ0FUcUQsQ0FXckQ7O0FBQ0EsTUFBSSxLQUFLLElBQUksQ0FBYixlQUFBLEVBQStCO0FBQzdCLFVBQU0sSUFBQSxLQUFBLG9LQUM4SixhQUFjLENBRGxMLFVBQ2tMLENBRDVLLG9GQUFOO0FBS0Q7O0FBRUQsTUFBSSxLQUFLLElBQUksT0FBQSxlQUFBLEtBQWIsVUFBQSxFQUFvRDtBQUNsRCxVQUFNLElBQUEsS0FBQSxDQUFOLCtIQUFNLENBQU47QUFHRDs7QUFFRCxNQUFNLE9BQU8sR0FBSSxlQUFpRCxDQUFqRCxjQUFBLENBQWpCLEtBQWlCLENBQWpCO0FBQ0EsTUFBSSxJQUFJLEdBQUcsSUFBQSxlQUFBLENBQUEsT0FBQSxFQUFYLFdBQVcsQ0FBWDtBQUNBLE1BQUksTUFBTSxHQUFHLE9BQU8sQ0FBUCxZQUFBLENBQUEsVUFBQSxFQUFiLElBQWEsQ0FBYjtBQUVBLE1BQUEsS0FBQTs7QUFFQSxNQUFJLFFBQVEsQ0FBWixPQUFZLENBQVosRUFBdUI7QUFDckIsSUFBQSxLQUFLLEdBQUcsV0FBVyxDQUFDLFlBQUs7QUFDdkIsVUFBSSxLQUFLLEtBQUssWUFBWSxDQUFaLEtBQVksQ0FBWixJQUF1QixXQUFXLENBQWhELEtBQWdELENBQXZDLENBQVQsRUFBMEQ7QUFDeEQsY0FBTSxJQUFOLEtBQU0sbUdBQU47QUFHRDs7QUFFRCxhQUFPLE9BQU8sQ0FBUCxRQUFBLENBQVAsTUFBTyxDQUFQO0FBUEYsS0FBbUIsQ0FBbkI7QUFVQSxJQUFBLHlCQUF5QixDQUFBLE9BQUEsRUFBekIsS0FBeUIsQ0FBekI7QUFYRixHQUFBLE1BWU87QUFDTCxVQUFNLElBQUEsS0FBQSxDQUFOLDhEQUFNLENBQU47QUFDRDs7QUFFRCxNQUFJLGNBQWMsQ0FBbEIsT0FBa0IsQ0FBbEIsRUFBNkI7QUFDM0IsUUFBSSxXQUFXLEdBQUcsT0FBTyxDQUFQLGNBQUEsQ0FBbEIsTUFBa0IsQ0FBbEI7QUFFQSxJQUFBLHlCQUF5QixDQUFBLEtBQUEsRUFBekIsV0FBeUIsQ0FBekI7QUFDRDs7QUFFRCxTQUFBLEtBQUE7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IENhY2hlLCBjcmVhdGVDYWNoZSwgZ2V0VmFsdWUgfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHsgQXJndW1lbnRzLCBJbnRlcm5hbEhlbHBlck1hbmFnZXIgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGRlYnVnVG9TdHJpbmcgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IGdldEludGVybmFsSGVscGVyTWFuYWdlciwgaGFzRGVzdHJveWFibGUsIGhhc1ZhbHVlIH0gZnJvbSAnQGdsaW1tZXIvbWFuYWdlcic7XG5cbmltcG9ydCB7IEVNUFRZX0FSR1MsIEVNUFRZX05BTUVELCBFTVBUWV9QT1NJVElPTkFMIH0gZnJvbSAnLi4vdm0vYXJndW1lbnRzJztcbmltcG9ydCB7IGdldE93bmVyIH0gZnJvbSAnQGdsaW1tZXIvb3duZXInO1xuaW1wb3J0IHsgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZCwgaXNEZXN0cm95ZWQsIGlzRGVzdHJveWluZyB9IGZyb20gJ0BnbGltbWVyL2Rlc3Ryb3lhYmxlJztcblxubGV0IEFSR1NfQ0FDSEVTID0gREVCVUcgPyBuZXcgV2Vha01hcDxTaW1wbGVBcmdzUHJveHksIENhY2hlPFBhcnRpYWw8QXJndW1lbnRzPj4+KCkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGdldEFyZ3MocHJveHk6IFNpbXBsZUFyZ3NQcm94eSk6IFBhcnRpYWw8QXJndW1lbnRzPiB7XG4gIHJldHVybiBnZXRWYWx1ZShERUJVRyA/IEFSR1NfQ0FDSEVTIS5nZXQocHJveHkpISA6IHByb3h5LmFyZ3NDYWNoZSEpITtcbn1cblxuY2xhc3MgU2ltcGxlQXJnc1Byb3h5IHtcbiAgYXJnc0NhY2hlPzogQ2FjaGU8UGFydGlhbDxBcmd1bWVudHM+PjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBjb250ZXh0OiBvYmplY3QsXG4gICAgY29tcHV0ZUFyZ3M6IChjb250ZXh0OiBvYmplY3QpID0+IFBhcnRpYWw8QXJndW1lbnRzPiA9ICgpID0+IEVNUFRZX0FSR1NcbiAgKSB7XG4gICAgbGV0IGFyZ3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCgpID0+IGNvbXB1dGVBcmdzKGNvbnRleHQpKTtcblxuICAgIGlmIChERUJVRykge1xuICAgICAgQVJHU19DQUNIRVMhLnNldCh0aGlzLCBhcmdzQ2FjaGUpO1xuICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcmdzQ2FjaGUgPSBhcmdzQ2FjaGU7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG5hbWVkKCkge1xuICAgIHJldHVybiBnZXRBcmdzKHRoaXMpLm5hbWVkIHx8IEVNUFRZX05BTUVEO1xuICB9XG5cbiAgZ2V0IHBvc2l0aW9uYWwoKSB7XG4gICAgcmV0dXJuIGdldEFyZ3ModGhpcykucG9zaXRpb25hbCB8fCBFTVBUWV9QT1NJVElPTkFMO1xuICB9XG59XG5cbi8vLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlSGVscGVyKFxuICBjb250ZXh0OiBvYmplY3QsXG4gIGRlZmluaXRpb246IG9iamVjdCxcbiAgY29tcHV0ZUFyZ3M/OiAoY29udGV4dDogb2JqZWN0KSA9PiBQYXJ0aWFsPEFyZ3VtZW50cz5cbik6IENhY2hlPHVua25vd24+IHtcbiAgaWYgKERFQlVHICYmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcgfHwgY29udGV4dCA9PT0gbnVsbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRXhwZWN0ZWQgYSBjb250ZXh0IG9iamVjdCB0byBiZSBwYXNzZWQgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciB0byBpbnZva2VIZWxwZXIsIGdvdCAke2NvbnRleHR9YFxuICAgICk7XG4gIH1cblxuICBjb25zdCBvd25lciA9IGdldE93bmVyKGNvbnRleHQpO1xuICBjb25zdCBpbnRlcm5hbE1hbmFnZXIgPSBnZXRJbnRlcm5hbEhlbHBlck1hbmFnZXIoZGVmaW5pdGlvbikhO1xuXG4gIC8vIFRPRE86IGZpZ3VyZSBvdXQgd2h5IGFzc2VydCBpc24ndCB1c2luZyB0aGUgVFMgYXNzZXJ0IHRoaW5nXG4gIGlmIChERUJVRyAmJiAhaW50ZXJuYWxNYW5hZ2VyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEV4cGVjdGVkIGEgaGVscGVyIGRlZmluaXRpb24gdG8gYmUgcGFzc2VkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGludm9rZUhlbHBlciwgYnV0IG5vIGhlbHBlciBtYW5hZ2VyIHdhcyBmb3VuZC4gVGhlIGRlZmluaXRpb24gdmFsdWUgdGhhdCB3YXMgcGFzc2VkIHdhcyBcXGAke2RlYnVnVG9TdHJpbmchKFxuICAgICAgICBkZWZpbml0aW9uXG4gICAgICApfVxcYC4gRGlkIHlvdSB1c2Ugc2V0SGVscGVyTWFuYWdlciB0byBhc3NvY2lhdGUgYSBoZWxwZXIgbWFuYWdlciB3aXRoIHRoaXMgdmFsdWU/YFxuICAgICk7XG4gIH1cblxuICBpZiAoREVCVUcgJiYgdHlwZW9mIGludGVybmFsTWFuYWdlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdGb3VuZCBhIGhlbHBlciBtYW5hZ2VyLCBidXQgaXQgd2FzIGFuIGludGVybmFsIGJ1aWx0LWluIGhlbHBlciBtYW5hZ2VyLiBgaW52b2tlSGVscGVyYCBkb2VzIG5vdCBzdXBwb3J0IGludGVybmFsIGhlbHBlcnMgeWV0LidcbiAgICApO1xuICB9XG5cbiAgY29uc3QgbWFuYWdlciA9IChpbnRlcm5hbE1hbmFnZXIgYXMgSW50ZXJuYWxIZWxwZXJNYW5hZ2VyPG9iamVjdD4pLmdldERlbGVnYXRlRm9yKG93bmVyKTtcbiAgbGV0IGFyZ3MgPSBuZXcgU2ltcGxlQXJnc1Byb3h5KGNvbnRleHQsIGNvbXB1dGVBcmdzKTtcbiAgbGV0IGJ1Y2tldCA9IG1hbmFnZXIuY3JlYXRlSGVscGVyKGRlZmluaXRpb24sIGFyZ3MpO1xuXG4gIGxldCBjYWNoZTogQ2FjaGU8dW5rbm93bj47XG5cbiAgaWYgKGhhc1ZhbHVlKG1hbmFnZXIpKSB7XG4gICAgY2FjaGUgPSBjcmVhdGVDYWNoZSgoKSA9PiB7XG4gICAgICBpZiAoREVCVUcgJiYgKGlzRGVzdHJveWluZyhjYWNoZSkgfHwgaXNEZXN0cm95ZWQoY2FjaGUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBhdHRlbXB0ZWQgdG8gZ2V0IHRoZSB2YWx1ZSBvZiBhIGhlbHBlciBhZnRlciB0aGUgaGVscGVyIHdhcyBkZXN0cm95ZWQsIHdoaWNoIGlzIG5vdCBhbGxvd2VkYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFuYWdlci5nZXRWYWx1ZShidWNrZXQpO1xuICAgIH0pO1xuXG4gICAgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZChjb250ZXh0LCBjYWNoZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUT0RPOiB1bnJlYWNoYWJsZSwgdG8gYmUgaW1wbGVtZW50ZWQgd2l0aCBoYXNTY2hlZHVsZWRFZmZlY3QnKTtcbiAgfVxuXG4gIGlmIChoYXNEZXN0cm95YWJsZShtYW5hZ2VyKSkge1xuICAgIGxldCBkZXN0cm95YWJsZSA9IG1hbmFnZXIuZ2V0RGVzdHJveWFibGUoYnVja2V0KTtcblxuICAgIGFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQoY2FjaGUsIGRlc3Ryb3lhYmxlKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=