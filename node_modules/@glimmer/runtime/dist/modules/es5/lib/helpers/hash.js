import { createComputeRef } from '@glimmer/reference';
import { reifyNamed } from '@glimmer/runtime';
import { deprecate } from '@glimmer/global-context';
import { HAS_NATIVE_PROXY } from '@glimmer/util';
import { internalHelper } from './internal-helper';
import { DEBUG } from '@glimmer/env';
var wrapHashProxy;

if (DEBUG) {
  wrapHashProxy = function wrapHashProxy(hash) {
    return new Proxy(hash, {
      set: function set(target, key, value) {
        deprecate("You set the '" + String(key) + "' property on a {{hash}} object. Setting properties on objects generated by {{hash}} is deprecated. Please update to use an object created with a tracked property or getter, or with a custom helper.", false, {
          id: 'setting-on-hash'
        });
        target[key] = value;
        return true;
      }
    });
  };
}
/**
   Use the `{{hash}}` helper to create a hash to pass as an option to your
   components. This is specially useful for contextual components where you can
   just yield a hash:

   ```handlebars
   {{yield (hash
      name='Sarah'
      title=office
   )}}
   ```

   Would result in an object such as:

   ```js
   { name: 'Sarah', title: this.get('office') }
   ```

   Where the `title` is bound to updates of the `office` property.

   Note that the hash is an empty object with no prototype chain, therefore
   common methods like `toString` are not available in the resulting hash.
   If you need to use such a method, you can use the `call` or `apply`
   approach:

   ```js
   function toString(obj) {
     return Object.prototype.toString.apply(obj);
   }
   ```

   @method hash
   @param {Object} options
   @return {Object} Hash
   @public
 */


export default internalHelper(function (_ref) {
  var named = _ref.named;
  var ref = createComputeRef(function () {
    var hash = reifyNamed(named);

    if (DEBUG && HAS_NATIVE_PROXY) {
      hash = wrapHashProxy(hash);
    }

    return hash;
  }, null, 'hash'); // Setup the children so that templates can bypass getting the value of
  // the reference and treat children lazily

  var children = new Map();

  for (var name in named) {
    children.set(name, named[name]);
  }

  ref.children = children;
  return ref;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL2hlbHBlcnMvaGFzaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxTQUFBLGdCQUFBLFFBQUEsb0JBQUE7QUFDQSxTQUFBLFVBQUEsUUFBQSxrQkFBQTtBQUNBLFNBQUEsU0FBQSxRQUFBLHlCQUFBO0FBQ0EsU0FBQSxnQkFBQSxRQUFBLGVBQUE7QUFDQSxTQUFBLGNBQUEsUUFBQSxtQkFBQTtBQUNBLFNBQUEsS0FBQSxRQUFBLGNBQUE7QUFFQSxJQUFBLGFBQUE7O0FBRUEsSUFBQSxLQUFBLEVBQVc7QUFDVCxFQUFBLGFBQWEsR0FBSSx1QkFBQSxJQUFELEVBQWtDO0FBQ2hELFdBQU8sSUFBQSxLQUFBLENBQUEsSUFBQSxFQUFnQjtBQUNyQixNQUFBLEdBRHFCLGVBQ2xCLE1BRGtCLEVBQ2xCLEdBRGtCLEVBQ2xCLEtBRGtCLEVBQ0M7QUFDcEIsUUFBQSxTQUFTLG1CQUNTLE1BQU0sQ0FEZixHQUNlLENBRGYsNk1BQUEsS0FBQSxFQUtQO0FBQUUsVUFBQSxFQUFFLEVBQUU7QUFBTixTQUxPLENBQVQ7QUFRQSxRQUFBLE1BQU0sQ0FBTixHQUFNLENBQU4sR0FBQSxLQUFBO0FBRUEsZUFBQSxJQUFBO0FBQ0Q7QUFib0IsS0FBaEIsQ0FBUDtBQURGLEdBQUE7QUFpQkQ7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ0EsZUFBZSxjQUFjLENBQzNCLGdCQUEyRDtBQUFBLE1BQXhELEtBQXdELFFBQXhELEtBQXdEO0FBQ3pELE1BQUksR0FBRyxHQUFHLGdCQUFnQixDQUN4QixZQUFLO0FBQ0gsUUFBSSxJQUFJLEdBQUcsVUFBVSxDQUFyQixLQUFxQixDQUFyQjs7QUFFQSxRQUFJLEtBQUssSUFBVCxnQkFBQSxFQUErQjtBQUM3QixNQUFBLElBQUksR0FBRyxhQUFhLENBQXBCLElBQW9CLENBQXBCO0FBQ0Q7O0FBRUQsV0FBQSxJQUFBO0FBUnNCLEdBQUEsRUFBQSxJQUFBLEVBRCtCLE1BQy9CLENBQTFCLENBRHlELENBZXpEO0FBQ0E7O0FBQ0EsTUFBSSxRQUFRLEdBQUcsSUFBZixHQUFlLEVBQWY7O0FBRUEsT0FBSyxJQUFMLElBQUEsSUFBQSxLQUFBLEVBQXdCO0FBQ3RCLElBQUEsUUFBUSxDQUFSLEdBQUEsQ0FBQSxJQUFBLEVBQW1CLEtBQUssQ0FBeEIsSUFBd0IsQ0FBeEI7QUFDRDs7QUFFRCxFQUFBLEdBQUcsQ0FBSCxRQUFBLEdBQUEsUUFBQTtBQUVBLFNBQUEsR0FBQTtBQTFCSixDQUE2QixDQUE3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENhcHR1cmVkQXJndW1lbnRzLCBEaWN0IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjcmVhdGVDb21wdXRlUmVmLCBSZWZlcmVuY2UgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgcmVpZnlOYW1lZCB9IGZyb20gJ0BnbGltbWVyL3J1bnRpbWUnO1xuaW1wb3J0IHsgZGVwcmVjYXRlIH0gZnJvbSAnQGdsaW1tZXIvZ2xvYmFsLWNvbnRleHQnO1xuaW1wb3J0IHsgSEFTX05BVElWRV9QUk9YWSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgaW50ZXJuYWxIZWxwZXIgfSBmcm9tICcuL2ludGVybmFsLWhlbHBlcic7XG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5cbmxldCB3cmFwSGFzaFByb3h5OiAoaGFzaDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pID0+IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuXG5pZiAoREVCVUcpIHtcbiAgd3JhcEhhc2hQcm94eSA9IChoYXNoOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikgPT4ge1xuICAgIHJldHVybiBuZXcgUHJveHkoaGFzaCwge1xuICAgICAgc2V0KHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBkZXByZWNhdGUoXG4gICAgICAgICAgYFlvdSBzZXQgdGhlICcke1N0cmluZyhcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9JyBwcm9wZXJ0eSBvbiBhIHt7aGFzaH19IG9iamVjdC4gU2V0dGluZyBwcm9wZXJ0aWVzIG9uIG9iamVjdHMgZ2VuZXJhdGVkIGJ5IHt7aGFzaH19IGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1cGRhdGUgdG8gdXNlIGFuIG9iamVjdCBjcmVhdGVkIHdpdGggYSB0cmFja2VkIHByb3BlcnR5IG9yIGdldHRlciwgb3Igd2l0aCBhIGN1c3RvbSBoZWxwZXIuYCxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICB7IGlkOiAnc2V0dGluZy1vbi1oYXNoJyB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGFyZ2V0W2tleSBhcyBzdHJpbmddID0gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAgIFVzZSB0aGUgYHt7aGFzaH19YCBoZWxwZXIgdG8gY3JlYXRlIGEgaGFzaCB0byBwYXNzIGFzIGFuIG9wdGlvbiB0byB5b3VyXG4gICBjb21wb25lbnRzLiBUaGlzIGlzIHNwZWNpYWxseSB1c2VmdWwgZm9yIGNvbnRleHR1YWwgY29tcG9uZW50cyB3aGVyZSB5b3UgY2FuXG4gICBqdXN0IHlpZWxkIGEgaGFzaDpcblxuICAgYGBgaGFuZGxlYmFyc1xuICAge3t5aWVsZCAoaGFzaFxuICAgICAgbmFtZT0nU2FyYWgnXG4gICAgICB0aXRsZT1vZmZpY2VcbiAgICl9fVxuICAgYGBgXG5cbiAgIFdvdWxkIHJlc3VsdCBpbiBhbiBvYmplY3Qgc3VjaCBhczpcblxuICAgYGBganNcbiAgIHsgbmFtZTogJ1NhcmFoJywgdGl0bGU6IHRoaXMuZ2V0KCdvZmZpY2UnKSB9XG4gICBgYGBcblxuICAgV2hlcmUgdGhlIGB0aXRsZWAgaXMgYm91bmQgdG8gdXBkYXRlcyBvZiB0aGUgYG9mZmljZWAgcHJvcGVydHkuXG5cbiAgIE5vdGUgdGhhdCB0aGUgaGFzaCBpcyBhbiBlbXB0eSBvYmplY3Qgd2l0aCBubyBwcm90b3R5cGUgY2hhaW4sIHRoZXJlZm9yZVxuICAgY29tbW9uIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIGFyZSBub3QgYXZhaWxhYmxlIGluIHRoZSByZXN1bHRpbmcgaGFzaC5cbiAgIElmIHlvdSBuZWVkIHRvIHVzZSBzdWNoIGEgbWV0aG9kLCB5b3UgY2FuIHVzZSB0aGUgYGNhbGxgIG9yIGBhcHBseWBcbiAgIGFwcHJvYWNoOlxuXG4gICBgYGBqc1xuICAgZnVuY3Rpb24gdG9TdHJpbmcob2JqKSB7XG4gICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KG9iaik7XG4gICB9XG4gICBgYGBcblxuICAgQG1ldGhvZCBoYXNoXG4gICBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgQHJldHVybiB7T2JqZWN0fSBIYXNoXG4gICBAcHVibGljXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGludGVybmFsSGVscGVyKFxuICAoeyBuYW1lZCB9OiBDYXB0dXJlZEFyZ3VtZW50cyk6IFJlZmVyZW5jZTxEaWN0PHVua25vd24+PiA9PiB7XG4gICAgbGV0IHJlZiA9IGNyZWF0ZUNvbXB1dGVSZWYoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGxldCBoYXNoID0gcmVpZnlOYW1lZChuYW1lZCk7XG5cbiAgICAgICAgaWYgKERFQlVHICYmIEhBU19OQVRJVkVfUFJPWFkpIHtcbiAgICAgICAgICBoYXNoID0gd3JhcEhhc2hQcm94eShoYXNoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoYXNoO1xuICAgICAgfSxcbiAgICAgIG51bGwsXG4gICAgICAnaGFzaCdcbiAgICApO1xuXG4gICAgLy8gU2V0dXAgdGhlIGNoaWxkcmVuIHNvIHRoYXQgdGVtcGxhdGVzIGNhbiBieXBhc3MgZ2V0dGluZyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgcmVmZXJlbmNlIGFuZCB0cmVhdCBjaGlsZHJlbiBsYXppbHlcbiAgICBsZXQgY2hpbGRyZW4gPSBuZXcgTWFwKCk7XG5cbiAgICBmb3IgKGxldCBuYW1lIGluIG5hbWVkKSB7XG4gICAgICBjaGlsZHJlbi5zZXQobmFtZSwgbmFtZWRbbmFtZV0pO1xuICAgIH1cblxuICAgIHJlZi5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=