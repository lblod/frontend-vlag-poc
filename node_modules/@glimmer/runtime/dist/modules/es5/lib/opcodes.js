import { valueForRef } from '@glimmer/reference';
import { assert, fillNulls, LOCAL_LOGGER } from '@glimmer/util';
import { $fp, $pc, $ra, $sp } from '@glimmer/vm';
import { isScopeReference } from './scope';
import { DESTROYABLE_STACK, INNER_VM, STACKS } from './symbols';
import { CURSOR_STACK } from './vm/element-builder';
export var AppendOpcodes = /*#__PURE__*/function () {
  function AppendOpcodes() {
    this.evaluateOpcode = fillNulls(104
    /* Size */
    ).slice();
  }

  var _proto = AppendOpcodes.prototype;

  _proto.add = function add(name, evaluate, kind) {
    if (kind === void 0) {
      kind = 'syscall';
    }

    this.evaluateOpcode[name] = {
      syscall: kind !== 'machine',
      evaluate: evaluate
    };
  };

  _proto.debugBefore = function debugBefore(vm, opcode) {
    var params = undefined;
    var opName = undefined;

    if (false
    /* LOCAL_SHOULD_LOG */
    ) {
        var pos = vm[INNER_VM].fetchRegister($pc) - opcode.size;
        var _ref = [];
        opName = _ref[0];
        params = _ref[1];
        // console.log(`${typePos(vm['pc'])}.`);
        LOCAL_LOGGER.log(pos + ". ");
        var debugParams = [];

        for (var prop in params) {
          debugParams.push(prop, '=', params[prop]);
        }

        LOCAL_LOGGER.log.apply(LOCAL_LOGGER, debugParams);
      }

    var sp;

    if (false
    /* LOCAL_DEBUG */
    ) {
        sp = vm.fetchValue($sp);
      }

    return {
      sp: sp,
      pc: vm.fetchValue($pc),
      name: opName,
      params: params,
      type: opcode.type,
      isMachine: opcode.isMachine,
      size: opcode.size,
      state: undefined
    };
  };

  _proto.debugAfter = function debugAfter(vm, pre) {
    var sp = pre.sp,
        type = pre.type,
        isMachine = pre.isMachine,
        pc = pre.pc;

    if (false
    /* LOCAL_DEBUG */
    ) {
        var meta = type;
        var actualChange = vm.fetchValue($sp) - sp;

        if (meta && meta.check && typeof meta.stackChange === 'number' && meta.stackChange !== actualChange) {
          throw new Error("Error in " + pre.name + ":\n\n" + pc + ". " + "\n\nStack changed by " + actualChange + ", expected " + meta.stackChange);
        }

        if (false
        /* LOCAL_SHOULD_LOG */
        ) {
            LOCAL_LOGGER.log('%c -> pc: %d, ra: %d, fp: %d, sp: %d, s0: %O, s1: %O, t0: %O, t1: %O, v0: %O', 'color: orange', vm[INNER_VM].registers[$pc], vm[INNER_VM].registers[$ra], vm[INNER_VM].registers[$fp], vm[INNER_VM].registers[$sp], vm['s0'], vm['s1'], vm['t0'], vm['t1'], vm['v0']);
            LOCAL_LOGGER.log('%c -> eval stack', 'color: red', vm.stack.toArray());
            LOCAL_LOGGER.log('%c -> block stack', 'color: magenta', vm.elements().debugBlocks());
            LOCAL_LOGGER.log('%c -> destructor stack', 'color: violet', vm[DESTROYABLE_STACK].toArray());

            if (vm[STACKS].scope.current === null) {
              LOCAL_LOGGER.log('%c -> scope', 'color: green', 'null');
            } else {
              LOCAL_LOGGER.log('%c -> scope', 'color: green', vm.scope().slots.map(function (s) {
                return isScopeReference(s) ? valueForRef(s) : s;
              }));
            }

            LOCAL_LOGGER.log('%c -> elements', 'color: blue', vm.elements()[CURSOR_STACK].current.element);
            LOCAL_LOGGER.log('%c -> constructing', 'color: aqua', vm.elements()['constructing']);
          }
      }
  };

  _proto.evaluate = function evaluate(vm, opcode, type) {
    var operation = this.evaluateOpcode[type];

    if (operation.syscall) {
      false && assert(!opcode.isMachine, "BUG: Mismatch between operation.syscall (" + operation.syscall + ") and opcode.isMachine (" + opcode.isMachine + ") for " + opcode.type);
      operation.evaluate(vm, opcode);
    } else {
      false && assert(opcode.isMachine, "BUG: Mismatch between operation.syscall (" + operation.syscall + ") and opcode.isMachine (" + opcode.isMachine + ") for " + opcode.type);
      operation.evaluate(vm[INNER_VM], opcode);
    }
  };

  return AppendOpcodes;
}();
export var APPEND_OPCODES = new AppendOpcodes();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3J1bnRpbWUvbGliL29wY29kZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBR0EsU0FBQSxXQUFBLFFBQUEsb0JBQUE7QUFDQSxTQUFBLE1BQUEsRUFBQSxTQUFBLEVBQUEsWUFBQSxRQUFBLGVBQUE7QUFDQSxTQUFBLEdBQUEsRUFBQSxHQUFBLEVBQUEsR0FBQSxFQUFBLEdBQUEsUUFBQSxhQUFBO0FBQ0EsU0FBQSxnQkFBQSxRQUFBLFNBQUE7QUFDQSxTQUFBLGlCQUFBLEVBQUEsUUFBQSxFQUFBLE1BQUEsUUFBQSxXQUFBO0FBR0EsU0FBQSxZQUFBLFFBQUEsc0JBQUE7QUFpQ0EsV0FBTSxhQUFOO0FBQUEsMkJBQUE7QUFDVSxTQUFBLGNBQUEsR0FBNkIsU0FBUyxDQUFBO0FBQUE7QUFBQSxLQUFULENBQTdCLEtBQTZCLEVBQTdCO0FBaUlUOztBQWxJRDs7QUFBQSxTQUtFLEdBTEYsR0FLRSxhQUFHLElBQUgsRUFBRyxRQUFILEVBQW9FLElBQXBFLEVBQW9GO0FBQUEsUUFBaEIsSUFBZ0I7QUFBaEIsTUFBQSxJQUFnQixHQUFqRixTQUFpRjtBQUFBOztBQUNsRixTQUFBLGNBQUEsQ0FBQSxJQUFBLElBQXNDO0FBQ3BDLE1BQUEsT0FBTyxFQUFFLElBQUksS0FEdUIsU0FBQTtBQUVwQyxNQUFBLFFBQUEsRUFBQTtBQUZvQyxLQUF0QztBQUlELEdBVkg7O0FBQUEsU0FZRSxXQVpGLEdBWUUscUJBQVcsRUFBWCxFQUFXLE1BQVgsRUFBcUM7QUFDbkMsUUFBSSxNQUFNLEdBQVYsU0FBQTtBQUNBLFFBQUksTUFBTSxHQUFWLFNBQUE7O0FBRUEsUUFBQTtBQUFBO0FBQUEsTUFBc0I7QUFDcEIsWUFBSSxHQUFHLEdBQUcsRUFBRSxDQUFGLFFBQUUsQ0FBRixDQUFBLGFBQUEsQ0FBQSxHQUFBLElBQWtDLE1BQU0sQ0FBbEQsSUFBQTtBQURvQixtQkFBQSxFQUFBO0FBR3BCLFFBQUEsTUFIb0I7QUFH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LFNBQUEsZ0RBRXdDLFNBQVMsQ0FBQyxPQUZsRCxnQ0FFb0YsTUFBTSxDQUFDLFNBRjNGLGNBRTZHLE1BQU0sQ0FIcEgsSUFDQyxDQUREO0FBS0wsTUFBQSxTQUFTLENBQVQsUUFBQSxDQUFtQixFQUFFLENBQXJCLFFBQXFCLENBQXJCLEVBQUEsTUFBQTtBQUNEO0FBQ0YsR0FqSUg7O0FBQUE7QUFBQTtBQW9JQSxPQUFPLElBQU0sY0FBYyxHQUFHLElBQXZCLGFBQXVCLEVBQXZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVidWcsIGxvZ09wY29kZSwgb3Bjb2RlTWV0YWRhdGEsIHJlY29yZFN0YWNrU2l6ZSB9IGZyb20gJ0BnbGltbWVyL2RlYnVnJztcbmltcG9ydCB7IERpY3QsIE1heWJlLCBPcCwgT3B0aW9uLCBSdW50aW1lT3AgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IExPQ0FMX0RFQlVHLCBMT0NBTF9TSE9VTERfTE9HIH0gZnJvbSAnQGdsaW1tZXIvbG9jYWwtZGVidWctZmxhZ3MnO1xuaW1wb3J0IHsgdmFsdWVGb3JSZWYgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgYXNzZXJ0LCBmaWxsTnVsbHMsIExPQ0FMX0xPR0dFUiB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgJGZwLCAkcGMsICRyYSwgJHNwIH0gZnJvbSAnQGdsaW1tZXIvdm0nO1xuaW1wb3J0IHsgaXNTY29wZVJlZmVyZW5jZSB9IGZyb20gJy4vc2NvcGUnO1xuaW1wb3J0IHsgQ09OU1RBTlRTLCBERVNUUk9ZQUJMRV9TVEFDSywgSU5ORVJfVk0sIFNUQUNLUyB9IGZyb20gJy4vc3ltYm9scyc7XG5pbXBvcnQgeyBMb3dMZXZlbFZNLCBWTSB9IGZyb20gJy4vdm0nO1xuaW1wb3J0IHsgSW50ZXJuYWxWTSB9IGZyb20gJy4vdm0vYXBwZW5kJztcbmltcG9ydCB7IENVUlNPUl9TVEFDSyB9IGZyb20gJy4vdm0vZWxlbWVudC1idWlsZGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBPcGNvZGVKU09OIHtcbiAgdHlwZTogbnVtYmVyIHwgc3RyaW5nO1xuICBndWlkPzogT3B0aW9uPG51bWJlcj47XG4gIGRlb3B0ZWQ/OiBib29sZWFuO1xuICBhcmdzPzogc3RyaW5nW107XG4gIGRldGFpbHM/OiBEaWN0PE9wdGlvbjxzdHJpbmc+PjtcbiAgY2hpbGRyZW4/OiBPcGNvZGVKU09OW107XG59XG5cbmV4cG9ydCB0eXBlIE9wZXJhbmQxID0gbnVtYmVyO1xuZXhwb3J0IHR5cGUgT3BlcmFuZDIgPSBudW1iZXI7XG5leHBvcnQgdHlwZSBPcGVyYW5kMyA9IG51bWJlcjtcblxuZXhwb3J0IHR5cGUgU3lzY2FsbCA9ICh2bTogSW50ZXJuYWxWTSwgb3Bjb2RlOiBSdW50aW1lT3ApID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBNYWNoaW5lT3Bjb2RlID0gKHZtOiBMb3dMZXZlbFZNLCBvcGNvZGU6IFJ1bnRpbWVPcCkgPT4gdm9pZDtcblxuZXhwb3J0IHR5cGUgRXZhbHVhdGUgPVxuICB8IHsgc3lzY2FsbDogdHJ1ZTsgZXZhbHVhdGU6IFN5c2NhbGwgfVxuICB8IHsgc3lzY2FsbDogZmFsc2U7IGV2YWx1YXRlOiBNYWNoaW5lT3Bjb2RlIH07XG5cbmV4cG9ydCB0eXBlIERlYnVnU3RhdGUgPSB7XG4gIHBjOiBudW1iZXI7XG4gIHNwOiBudW1iZXI7XG4gIHR5cGU6IG51bWJlcjtcbiAgaXNNYWNoaW5lOiAwIHwgMTtcbiAgc2l6ZTogbnVtYmVyO1xuICBwYXJhbXM/OiBNYXliZTxEaWN0PjtcbiAgbmFtZT86IHN0cmluZztcbiAgc3RhdGU6IHVua25vd247XG59O1xuXG5leHBvcnQgY2xhc3MgQXBwZW5kT3Bjb2RlcyB7XG4gIHByaXZhdGUgZXZhbHVhdGVPcGNvZGU6IEV2YWx1YXRlW10gPSBmaWxsTnVsbHM8RXZhbHVhdGU+KE9wLlNpemUpLnNsaWNlKCk7XG5cbiAgYWRkPE5hbWUgZXh0ZW5kcyBPcD4obmFtZTogTmFtZSwgZXZhbHVhdGU6IFN5c2NhbGwpOiB2b2lkO1xuICBhZGQ8TmFtZSBleHRlbmRzIE9wPihuYW1lOiBOYW1lLCBldmFsdWF0ZTogTWFjaGluZU9wY29kZSwga2luZDogJ21hY2hpbmUnKTogdm9pZDtcbiAgYWRkPE5hbWUgZXh0ZW5kcyBPcD4obmFtZTogTmFtZSwgZXZhbHVhdGU6IFN5c2NhbGwgfCBNYWNoaW5lT3Bjb2RlLCBraW5kID0gJ3N5c2NhbGwnKTogdm9pZCB7XG4gICAgdGhpcy5ldmFsdWF0ZU9wY29kZVtuYW1lIGFzIG51bWJlcl0gPSB7XG4gICAgICBzeXNjYWxsOiBraW5kICE9PSAnbWFjaGluZScsXG4gICAgICBldmFsdWF0ZSxcbiAgICB9IGFzIEV2YWx1YXRlO1xuICB9XG5cbiAgZGVidWdCZWZvcmUodm06IFZNLCBvcGNvZGU6IFJ1bnRpbWVPcCk6IERlYnVnU3RhdGUge1xuICAgIGxldCBwYXJhbXM6IE1heWJlPERpY3Q+ID0gdW5kZWZpbmVkO1xuICAgIGxldCBvcE5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChMT0NBTF9TSE9VTERfTE9HKSB7XG4gICAgICBsZXQgcG9zID0gdm1bSU5ORVJfVk1dLmZldGNoUmVnaXN0ZXIoJHBjKSAtIG9wY29kZS5zaXplO1xuXG4gICAgICBbb3BOYW1lLCBwYXJhbXNdID0gZGVidWcodm1bQ09OU1RBTlRTXSwgb3Bjb2RlLCBvcGNvZGUuaXNNYWNoaW5lKSE7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKGAke3R5cGVQb3Modm1bJ3BjJ10pfS5gKTtcbiAgICAgIExPQ0FMX0xPR0dFUi5sb2coYCR7cG9zfS4gJHtsb2dPcGNvZGUob3BOYW1lLCBwYXJhbXMpfWApO1xuXG4gICAgICBsZXQgZGVidWdQYXJhbXMgPSBbXTtcbiAgICAgIGZvciAobGV0IHByb3AgaW4gcGFyYW1zKSB7XG4gICAgICAgIGRlYnVnUGFyYW1zLnB1c2gocHJvcCwgJz0nLCBwYXJhbXNbcHJvcF0pO1xuICAgICAgfVxuXG4gICAgICBMT0NBTF9MT0dHRVIubG9nKC4uLmRlYnVnUGFyYW1zKTtcbiAgICB9XG5cbiAgICBsZXQgc3A6IG51bWJlcjtcblxuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgc3AgPSB2bS5mZXRjaFZhbHVlKCRzcCk7XG4gICAgfVxuXG4gICAgcmVjb3JkU3RhY2tTaXplKHZtLmZldGNoVmFsdWUoJHNwKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNwOiBzcCEsXG4gICAgICBwYzogdm0uZmV0Y2hWYWx1ZSgkcGMpLFxuICAgICAgbmFtZTogb3BOYW1lLFxuICAgICAgcGFyYW1zLFxuICAgICAgdHlwZTogb3Bjb2RlLnR5cGUsXG4gICAgICBpc01hY2hpbmU6IG9wY29kZS5pc01hY2hpbmUsXG4gICAgICBzaXplOiBvcGNvZGUuc2l6ZSxcbiAgICAgIHN0YXRlOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxuXG4gIGRlYnVnQWZ0ZXIodm06IFZNLCBwcmU6IERlYnVnU3RhdGUpIHtcbiAgICBsZXQgeyBzcCwgdHlwZSwgaXNNYWNoaW5lLCBwYyB9ID0gcHJlO1xuXG4gICAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgICBsZXQgbWV0YSA9IG9wY29kZU1ldGFkYXRhKHR5cGUsIGlzTWFjaGluZSk7XG4gICAgICBsZXQgYWN0dWFsQ2hhbmdlID0gdm0uZmV0Y2hWYWx1ZSgkc3ApIC0gc3AhO1xuICAgICAgaWYgKFxuICAgICAgICBtZXRhICYmXG4gICAgICAgIG1ldGEuY2hlY2sgJiZcbiAgICAgICAgdHlwZW9mIG1ldGEuc3RhY2tDaGFuZ2UhID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBtZXRhLnN0YWNrQ2hhbmdlISAhPT0gYWN0dWFsQ2hhbmdlXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBFcnJvciBpbiAke3ByZS5uYW1lfTpcXG5cXG4ke3BjfS4gJHtsb2dPcGNvZGUoXG4gICAgICAgICAgICBwcmUubmFtZSEsXG4gICAgICAgICAgICBwcmUucGFyYW1zIVxuICAgICAgICAgICl9XFxuXFxuU3RhY2sgY2hhbmdlZCBieSAke2FjdHVhbENoYW5nZX0sIGV4cGVjdGVkICR7bWV0YS5zdGFja0NoYW5nZSF9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoTE9DQUxfU0hPVUxEX0xPRykge1xuICAgICAgICBMT0NBTF9MT0dHRVIubG9nKFxuICAgICAgICAgICclYyAtPiBwYzogJWQsIHJhOiAlZCwgZnA6ICVkLCBzcDogJWQsIHMwOiAlTywgczE6ICVPLCB0MDogJU8sIHQxOiAlTywgdjA6ICVPJyxcbiAgICAgICAgICAnY29sb3I6IG9yYW5nZScsXG4gICAgICAgICAgdm1bSU5ORVJfVk1dLnJlZ2lzdGVyc1skcGNdLFxuICAgICAgICAgIHZtW0lOTkVSX1ZNXS5yZWdpc3RlcnNbJHJhXSxcbiAgICAgICAgICB2bVtJTk5FUl9WTV0ucmVnaXN0ZXJzWyRmcF0sXG4gICAgICAgICAgdm1bSU5ORVJfVk1dLnJlZ2lzdGVyc1skc3BdLFxuICAgICAgICAgIHZtWydzMCddLFxuICAgICAgICAgIHZtWydzMSddLFxuICAgICAgICAgIHZtWyd0MCddLFxuICAgICAgICAgIHZtWyd0MSddLFxuICAgICAgICAgIHZtWyd2MCddXG4gICAgICAgICk7XG4gICAgICAgIExPQ0FMX0xPR0dFUi5sb2coJyVjIC0+IGV2YWwgc3RhY2snLCAnY29sb3I6IHJlZCcsIHZtLnN0YWNrLnRvQXJyYXkoKSk7XG4gICAgICAgIExPQ0FMX0xPR0dFUi5sb2coJyVjIC0+IGJsb2NrIHN0YWNrJywgJ2NvbG9yOiBtYWdlbnRhJywgdm0uZWxlbWVudHMoKS5kZWJ1Z0Jsb2NrcygpKTtcbiAgICAgICAgTE9DQUxfTE9HR0VSLmxvZyhcbiAgICAgICAgICAnJWMgLT4gZGVzdHJ1Y3RvciBzdGFjaycsXG4gICAgICAgICAgJ2NvbG9yOiB2aW9sZXQnLFxuICAgICAgICAgIHZtW0RFU1RST1lBQkxFX1NUQUNLXS50b0FycmF5KClcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHZtW1NUQUNLU10uc2NvcGUuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIExPQ0FMX0xPR0dFUi5sb2coJyVjIC0+IHNjb3BlJywgJ2NvbG9yOiBncmVlbicsICdudWxsJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgTE9DQUxfTE9HR0VSLmxvZyhcbiAgICAgICAgICAgICclYyAtPiBzY29wZScsXG4gICAgICAgICAgICAnY29sb3I6IGdyZWVuJyxcbiAgICAgICAgICAgIHZtLnNjb3BlKCkuc2xvdHMubWFwKChzKSA9PiAoaXNTY29wZVJlZmVyZW5jZShzKSA/IHZhbHVlRm9yUmVmKHMpIDogcykpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIExPQ0FMX0xPR0dFUi5sb2coXG4gICAgICAgICAgJyVjIC0+IGVsZW1lbnRzJyxcbiAgICAgICAgICAnY29sb3I6IGJsdWUnLFxuICAgICAgICAgIHZtLmVsZW1lbnRzKClbQ1VSU09SX1NUQUNLXS5jdXJyZW50IS5lbGVtZW50XG4gICAgICAgICk7XG5cbiAgICAgICAgTE9DQUxfTE9HR0VSLmxvZygnJWMgLT4gY29uc3RydWN0aW5nJywgJ2NvbG9yOiBhcXVhJywgdm0uZWxlbWVudHMoKVsnY29uc3RydWN0aW5nJ10pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlKHZtOiBWTSwgb3Bjb2RlOiBSdW50aW1lT3AsIHR5cGU6IG51bWJlcikge1xuICAgIGxldCBvcGVyYXRpb24gPSB0aGlzLmV2YWx1YXRlT3Bjb2RlW3R5cGVdO1xuXG4gICAgaWYgKG9wZXJhdGlvbi5zeXNjYWxsKSB7XG4gICAgICBhc3NlcnQoXG4gICAgICAgICFvcGNvZGUuaXNNYWNoaW5lLFxuICAgICAgICBgQlVHOiBNaXNtYXRjaCBiZXR3ZWVuIG9wZXJhdGlvbi5zeXNjYWxsICgke29wZXJhdGlvbi5zeXNjYWxsfSkgYW5kIG9wY29kZS5pc01hY2hpbmUgKCR7b3Bjb2RlLmlzTWFjaGluZX0pIGZvciAke29wY29kZS50eXBlfWBcbiAgICAgICk7XG4gICAgICBvcGVyYXRpb24uZXZhbHVhdGUodm0sIG9wY29kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgb3Bjb2RlLmlzTWFjaGluZSxcbiAgICAgICAgYEJVRzogTWlzbWF0Y2ggYmV0d2VlbiBvcGVyYXRpb24uc3lzY2FsbCAoJHtvcGVyYXRpb24uc3lzY2FsbH0pIGFuZCBvcGNvZGUuaXNNYWNoaW5lICgke29wY29kZS5pc01hY2hpbmV9KSBmb3IgJHtvcGNvZGUudHlwZX1gXG4gICAgICApO1xuICAgICAgb3BlcmF0aW9uLmV2YWx1YXRlKHZtW0lOTkVSX1ZNXSwgb3Bjb2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEFQUEVORF9PUENPREVTID0gbmV3IEFwcGVuZE9wY29kZXMoKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=