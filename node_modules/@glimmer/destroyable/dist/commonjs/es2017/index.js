"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.associateDestroyableChild = associateDestroyableChild;
exports.registerDestructor = registerDestructor;
exports.unregisterDestructor = unregisterDestructor;
exports.destroy = destroy;
exports.destroyChildren = destroyChildren;
exports._hasDestroyableChildren = _hasDestroyableChildren;
exports.isDestroying = isDestroying;
exports.isDestroyed = isDestroyed;
exports.assertDestroyablesDestroyed = exports.enableDestroyableTracking = void 0;

var _env = require("@glimmer/env");

var _util = require("@glimmer/util");

var _globalContext = require("@glimmer/global-context");

let DESTROYABLE_META = new WeakMap();

function push(collection, newItem) {
  if (collection === null) {
    return newItem;
  } else if (Array.isArray(collection)) {
    collection.push(newItem);
    return collection;
  } else {
    return [collection, newItem];
  }
}

function iterate(collection, fn) {
  if (Array.isArray(collection)) {
    for (let i = 0; i < collection.length; i++) {
      fn(collection[i]);
    }
  } else if (collection !== null) {
    fn(collection);
  }
}

function remove(collection, item, message) {
  if (_env.DEBUG) {
    let collectionIsItem = collection === item;
    let collectionContainsItem = Array.isArray(collection) && collection.indexOf(item) !== -1;

    if (!collectionIsItem && !collectionContainsItem) {
      throw new Error(String(message));
    }
  }

  if (Array.isArray(collection) && collection.length > 1) {
    let index = collection.indexOf(item);
    collection.splice(index, 1);
    return collection;
  } else {
    return null;
  }
}

function getDestroyableMeta(destroyable) {
  let meta = DESTROYABLE_META.get(destroyable);

  if (meta === undefined) {
    meta = {
      parents: null,
      children: null,
      eagerDestructors: null,
      destructors: null,
      state: 0
      /* Live */

    };

    if (_env.DEBUG) {
      meta.source = destroyable;
    }

    DESTROYABLE_META.set(destroyable, meta);
  }

  return meta;
}

function associateDestroyableChild(parent, child) {
  if (_env.DEBUG && isDestroying(parent)) {
    throw new Error('Attempted to associate a destroyable child with an object that is already destroying or destroyed');
  }

  let parentMeta = getDestroyableMeta(parent);
  let childMeta = getDestroyableMeta(child);
  parentMeta.children = push(parentMeta.children, child);
  childMeta.parents = push(childMeta.parents, parent);
  return child;
}

function registerDestructor(destroyable, destructor, eager = false) {
  if (_env.DEBUG && isDestroying(destroyable)) {
    throw new Error('Attempted to register a destructor with an object that is already destroying or destroyed');
  }

  let meta = getDestroyableMeta(destroyable);
  let destructorsKey = eager === true ? 'eagerDestructors' : 'destructors';
  meta[destructorsKey] = push(meta[destructorsKey], destructor);
  return destructor;
}

function unregisterDestructor(destroyable, destructor, eager = false) {
  if (_env.DEBUG && isDestroying(destroyable)) {
    throw new Error('Attempted to unregister a destructor with an object that is already destroying or destroyed');
  }

  let meta = getDestroyableMeta(destroyable);
  let destructorsKey = eager === true ? 'eagerDestructors' : 'destructors';
  meta[destructorsKey] = remove(meta[destructorsKey], destructor, _env.DEBUG && 'attempted to remove a destructor that was not registered with the destroyable');
} ////////////


function destroy(destroyable) {
  let meta = getDestroyableMeta(destroyable);
  if (meta.state >= 1
  /* Destroying */
  ) return;
  let {
    parents,
    children,
    eagerDestructors,
    destructors
  } = meta;
  meta.state = 1
  /* Destroying */
  ;
  iterate(children, destroy);
  iterate(eagerDestructors, destructor => destructor(destroyable));
  iterate(destructors, destructor => (0, _globalContext.scheduleDestroy)(destroyable, destructor));
  (0, _globalContext.scheduleDestroyed)(() => {
    iterate(parents, parent => removeChildFromParent(destroyable, parent));
    meta.state = 2
    /* Destroyed */
    ;
  });
}

function removeChildFromParent(child, parent) {
  let parentMeta = getDestroyableMeta(parent);

  if (parentMeta.state === 0
  /* Live */
  ) {
      parentMeta.children = remove(parentMeta.children, child, _env.DEBUG && "attempted to remove child from parent, but the parent's children did not contain the child. This is likely a bug with destructors.");
    }
}

function destroyChildren(destroyable) {
  let {
    children
  } = getDestroyableMeta(destroyable);
  iterate(children, destroy);
}

function _hasDestroyableChildren(destroyable) {
  let meta = DESTROYABLE_META.get(destroyable);
  return meta === undefined ? false : meta.children !== null;
}

function isDestroying(destroyable) {
  let meta = DESTROYABLE_META.get(destroyable);
  return meta === undefined ? false : meta.state >= 1
  /* Destroying */
  ;
}

function isDestroyed(destroyable) {
  let meta = DESTROYABLE_META.get(destroyable);
  return meta === undefined ? false : meta.state >= 2
  /* Destroyed */
  ;
} ////////////


let enableDestroyableTracking;
exports.enableDestroyableTracking = enableDestroyableTracking;
let assertDestroyablesDestroyed;
exports.assertDestroyablesDestroyed = assertDestroyablesDestroyed;

if (_env.DEBUG) {
  let isTesting = false;

  exports.enableDestroyableTracking = enableDestroyableTracking = () => {
    if (isTesting) {
      // Reset destroyable meta just in case, before throwing the error
      DESTROYABLE_META = new WeakMap();
      throw new Error('Attempted to start destroyable testing, but you did not end the previous destroyable test. Did you forget to call `assertDestroyablesDestroyed()`');
    }

    isTesting = true;
    DESTROYABLE_META = new Map();
  };

  exports.assertDestroyablesDestroyed = assertDestroyablesDestroyed = () => {
    if (!isTesting) {
      throw new Error('Attempted to assert destroyables destroyed, but you did not start a destroyable test. Did you forget to call `enableDestroyableTracking()`');
    }

    isTesting = false;
    let map = DESTROYABLE_META;
    DESTROYABLE_META = new WeakMap();
    let undestroyed = [];
    map.forEach(meta => {
      if (meta.state !== 2
      /* Destroyed */
      ) {
          undestroyed.push(meta.source);
        }
    });

    if (undestroyed.length > 0) {
      let objectsToString = undestroyed.map(_util.debugToString).join('\n    ');
      let error = new Error(`Some destroyables were not destroyed during this test:\n    ${objectsToString}`);
      error.destroyables = undestroyed;
      throw error;
    }
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2Rlc3Ryb3lhYmxlL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUVBOztBQUNBOztBQXVCQSxJQUFJLGdCQUFnQixHQUVxQyxJQUZ6RCxPQUV5RCxFQUZ6RDs7QUFJQSxTQUFBLElBQUEsQ0FBQSxVQUFBLEVBQUEsT0FBQSxFQUFvRTtBQUNsRSxNQUFJLFVBQVUsS0FBZCxJQUFBLEVBQXlCO0FBQ3ZCLFdBQUEsT0FBQTtBQURGLEdBQUEsTUFFTyxJQUFJLEtBQUssQ0FBTCxPQUFBLENBQUosVUFBSSxDQUFKLEVBQStCO0FBQ3BDLElBQUEsVUFBVSxDQUFWLElBQUEsQ0FBQSxPQUFBO0FBQ0EsV0FBQSxVQUFBO0FBRkssR0FBQSxNQUdBO0FBQ0wsV0FBTyxDQUFBLFVBQUEsRUFBUCxPQUFPLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQUEsT0FBQSxDQUFBLFVBQUEsRUFBQSxFQUFBLEVBQWtGO0FBQ2hGLE1BQUksS0FBSyxDQUFMLE9BQUEsQ0FBSixVQUFJLENBQUosRUFBK0I7QUFDN0IsU0FBSyxJQUFJLENBQUMsR0FBVixDQUFBLEVBQWdCLENBQUMsR0FBRyxVQUFVLENBQTlCLE1BQUEsRUFBdUMsQ0FBdkMsRUFBQSxFQUE0QztBQUMxQyxNQUFBLEVBQUUsQ0FBQyxVQUFVLENBQWIsQ0FBYSxDQUFYLENBQUY7QUFDRDtBQUhILEdBQUEsTUFJTyxJQUFJLFVBQVUsS0FBZCxJQUFBLEVBQXlCO0FBQzlCLElBQUEsRUFBRSxDQUFGLFVBQUUsQ0FBRjtBQUNEO0FBQ0Y7O0FBRUQsU0FBQSxNQUFBLENBQUEsVUFBQSxFQUFBLElBQUEsRUFBQSxPQUFBLEVBQTRGO0FBQzFGLE1BQUEsVUFBQSxFQUFXO0FBQ1QsUUFBSSxnQkFBZ0IsR0FBRyxVQUFVLEtBQWpDLElBQUE7QUFDQSxRQUFJLHNCQUFzQixHQUFHLEtBQUssQ0FBTCxPQUFBLENBQUEsVUFBQSxLQUE2QixVQUFVLENBQVYsT0FBQSxDQUFBLElBQUEsTUFBNkIsQ0FBdkYsQ0FBQTs7QUFFQSxRQUFJLENBQUEsZ0JBQUEsSUFBcUIsQ0FBekIsc0JBQUEsRUFBa0Q7QUFDaEQsWUFBTSxJQUFBLEtBQUEsQ0FBVSxNQUFNLENBQXRCLE9BQXNCLENBQWhCLENBQU47QUFDRDtBQUNGOztBQUVELE1BQUksS0FBSyxDQUFMLE9BQUEsQ0FBQSxVQUFBLEtBQTZCLFVBQVUsQ0FBVixNQUFBLEdBQWpDLENBQUEsRUFBd0Q7QUFDdEQsUUFBSSxLQUFLLEdBQUcsVUFBVyxDQUFYLE9BQUEsQ0FBWixJQUFZLENBQVo7QUFDQSxJQUFBLFVBQVcsQ0FBWCxNQUFBLENBQUEsS0FBQSxFQUFBLENBQUE7QUFDQSxXQUFBLFVBQUE7QUFIRixHQUFBLE1BSU87QUFDTCxXQUFBLElBQUE7QUFDRDtBQUNGOztBQUVELFNBQUEsa0JBQUEsQ0FBQSxXQUFBLEVBQWlFO0FBQy9ELE1BQUksSUFBSSxHQUFHLGdCQUFnQixDQUFoQixHQUFBLENBQVgsV0FBVyxDQUFYOztBQUVBLE1BQUksSUFBSSxLQUFSLFNBQUEsRUFBd0I7QUFDdEIsSUFBQSxJQUFJLEdBQUc7QUFDTCxNQUFBLE9BQU8sRUFERixJQUFBO0FBRUwsTUFBQSxRQUFRLEVBRkgsSUFBQTtBQUdMLE1BQUEsZ0JBQWdCLEVBSFgsSUFBQTtBQUlMLE1BQUEsV0FBVyxFQUpOLElBQUE7QUFLTCxNQUFBLEtBQUssRUFBQTtBQUFBOztBQUxBLEtBQVA7O0FBUUEsUUFBQSxVQUFBLEVBQVc7QUFDVCxNQUFBLElBQUksQ0FBSixNQUFBLEdBQUEsV0FBQTtBQUNEOztBQUVELElBQUEsZ0JBQWdCLENBQWhCLEdBQUEsQ0FBQSxXQUFBLEVBQUEsSUFBQTtBQUNEOztBQUVELFNBQUEsSUFBQTtBQUNEOztBQUVLLFNBQUEseUJBQUEsQ0FBQSxNQUFBLEVBQUEsS0FBQSxFQUF3RjtBQUM1RixNQUFJLGNBQVMsWUFBWSxDQUF6QixNQUF5QixDQUF6QixFQUFtQztBQUNqQyxVQUFNLElBQUEsS0FBQSxDQUFOLG1HQUFNLENBQU47QUFHRDs7QUFFRCxNQUFJLFVBQVUsR0FBRyxrQkFBa0IsQ0FBbkMsTUFBbUMsQ0FBbkM7QUFDQSxNQUFJLFNBQVMsR0FBRyxrQkFBa0IsQ0FBbEMsS0FBa0MsQ0FBbEM7QUFFQSxFQUFBLFVBQVUsQ0FBVixRQUFBLEdBQXNCLElBQUksQ0FBQyxVQUFVLENBQVgsUUFBQSxFQUExQixLQUEwQixDQUExQjtBQUNBLEVBQUEsU0FBUyxDQUFULE9BQUEsR0FBb0IsSUFBSSxDQUFDLFNBQVMsQ0FBVixPQUFBLEVBQXhCLE1BQXdCLENBQXhCO0FBRUEsU0FBQSxLQUFBO0FBQ0Q7O0FBRUssU0FBQSxrQkFBQSxDQUFBLFdBQUEsRUFBQSxVQUFBLEVBR0osS0FBSyxHQUhELEtBQUEsRUFHUztBQUViLE1BQUksY0FBUyxZQUFZLENBQXpCLFdBQXlCLENBQXpCLEVBQXdDO0FBQ3RDLFVBQU0sSUFBQSxLQUFBLENBQU4sMkZBQU0sQ0FBTjtBQUdEOztBQUVELE1BQUksSUFBSSxHQUFHLGtCQUFrQixDQUE3QixXQUE2QixDQUE3QjtBQUVBLE1BQUksY0FBYyxHQUNoQixLQUFLLEtBQUwsSUFBQSxHQUFBLGtCQUFBLEdBREYsYUFBQTtBQUdBLEVBQUEsSUFBSSxDQUFKLGNBQUksQ0FBSixHQUF1QixJQUFJLENBQUMsSUFBSSxDQUFMLGNBQUssQ0FBTCxFQUEzQixVQUEyQixDQUEzQjtBQUVBLFNBQUEsVUFBQTtBQUNEOztBQUVLLFNBQUEsb0JBQUEsQ0FBQSxXQUFBLEVBQUEsVUFBQSxFQUdKLEtBQUssR0FIRCxLQUFBLEVBR1M7QUFFYixNQUFJLGNBQVMsWUFBWSxDQUF6QixXQUF5QixDQUF6QixFQUF3QztBQUN0QyxVQUFNLElBQUEsS0FBQSxDQUFOLDZGQUFNLENBQU47QUFHRDs7QUFFRCxNQUFJLElBQUksR0FBRyxrQkFBa0IsQ0FBN0IsV0FBNkIsQ0FBN0I7QUFFQSxNQUFJLGNBQWMsR0FDaEIsS0FBSyxLQUFMLElBQUEsR0FBQSxrQkFBQSxHQURGLGFBQUE7QUFHQSxFQUFBLElBQUksQ0FBSixjQUFJLENBQUosR0FBdUIsTUFBTSxDQUMzQixJQUFJLENBRHVCLGNBQ3ZCLENBRHVCLEVBQUEsVUFBQSxFQUczQixjQUhGLCtFQUE2QixDQUE3QjtFQU9GOzs7QUFFTSxTQUFBLE9BQUEsQ0FBQSxXQUFBLEVBQTBDO0FBQzlDLE1BQUksSUFBSSxHQUFHLGtCQUFrQixDQUE3QixXQUE2QixDQUE3QjtBQUVBLE1BQUksSUFBSSxDQUFKLEtBQUEsSUFBVTtBQUFBO0FBQWQsSUFBOEM7QUFFOUMsTUFBSTtBQUFBLElBQUEsT0FBQTtBQUFBLElBQUEsUUFBQTtBQUFBLElBQUEsZ0JBQUE7QUFBdUMsSUFBQTtBQUF2QyxNQUFKLElBQUE7QUFFQSxFQUFBLElBQUksQ0FBSixLQUFBLEdBQVU7QUFBQTtBQUFWO0FBRUEsRUFBQSxPQUFPLENBQUEsUUFBQSxFQUFQLE9BQU8sQ0FBUDtBQUNBLEVBQUEsT0FBTyxDQUFBLGdCQUFBLEVBQW9CLFVBQUQsSUFBZ0IsVUFBVSxDQUFwRCxXQUFvRCxDQUE3QyxDQUFQO0FBQ0EsRUFBQSxPQUFPLENBQUEsV0FBQSxFQUFlLFVBQUQsSUFBZ0Isb0NBQWUsV0FBZixFQUFyQyxVQUFxQyxDQUE5QixDQUFQO0FBRUEsd0NBQWtCLE1BQUs7QUFDckIsSUFBQSxPQUFPLENBQUEsT0FBQSxFQUFXLE1BQUQsSUFBWSxxQkFBcUIsQ0FBQSxXQUFBLEVBQWxELE1BQWtELENBQTNDLENBQVA7QUFFQSxJQUFBLElBQUksQ0FBSixLQUFBLEdBQVU7QUFBQTtBQUFWO0FBSEYsR0FBQTtBQUtEOztBQUVELFNBQUEscUJBQUEsQ0FBQSxLQUFBLEVBQUEsTUFBQSxFQUFzRTtBQUNwRSxNQUFJLFVBQVUsR0FBRyxrQkFBa0IsQ0FBbkMsTUFBbUMsQ0FBbkM7O0FBRUEsTUFBSSxVQUFVLENBQVYsS0FBQSxLQUFnQjtBQUFBO0FBQXBCLElBQStDO0FBQzdDLE1BQUEsVUFBVSxDQUFWLFFBQUEsR0FBc0IsTUFBTSxDQUMxQixVQUFVLENBRGdCLFFBQUEsRUFBQSxLQUFBLEVBRzFCLGNBSEYsb0lBQTRCLENBQTVCO0FBTUQ7QUFDRjs7QUFFSyxTQUFBLGVBQUEsQ0FBQSxXQUFBLEVBQWtEO0FBQ3RELE1BQUk7QUFBRSxJQUFBO0FBQUYsTUFBZSxrQkFBa0IsQ0FBckMsV0FBcUMsQ0FBckM7QUFFQSxFQUFBLE9BQU8sQ0FBQSxRQUFBLEVBQVAsT0FBTyxDQUFQO0FBQ0Q7O0FBRUssU0FBQSx1QkFBQSxDQUFBLFdBQUEsRUFBMEQ7QUFDOUQsTUFBSSxJQUFJLEdBQUcsZ0JBQWdCLENBQWhCLEdBQUEsQ0FBWCxXQUFXLENBQVg7QUFFQSxTQUFPLElBQUksS0FBSixTQUFBLEdBQUEsS0FBQSxHQUE2QixJQUFJLENBQUosUUFBQSxLQUFwQyxJQUFBO0FBQ0Q7O0FBRUssU0FBQSxZQUFBLENBQUEsV0FBQSxFQUErQztBQUNuRCxNQUFJLElBQUksR0FBRyxnQkFBZ0IsQ0FBaEIsR0FBQSxDQUFYLFdBQVcsQ0FBWDtBQUVBLFNBQU8sSUFBSSxLQUFKLFNBQUEsR0FBQSxLQUFBLEdBQTZCLElBQUksQ0FBSixLQUFBLElBQVU7QUFBQTtBQUE5QztBQUNEOztBQUVLLFNBQUEsV0FBQSxDQUFBLFdBQUEsRUFBOEM7QUFDbEQsTUFBSSxJQUFJLEdBQUcsZ0JBQWdCLENBQWhCLEdBQUEsQ0FBWCxXQUFXLENBQVg7QUFFQSxTQUFPLElBQUksS0FBSixTQUFBLEdBQUEsS0FBQSxHQUE2QixJQUFJLENBQUosS0FBQSxJQUFVO0FBQUE7QUFBOUM7RUFHRjs7O0FBRU8sSUFBQSx5QkFBQTs7QUFDQSxJQUFBLDJCQUFBOzs7QUFFUCxJQUFBLFVBQUEsRUFBVztBQUNULE1BQUksU0FBUyxHQUFiLEtBQUE7O0FBRUEsc0NBQUEseUJBQXlCLEdBQUcsTUFBSztBQUMvQixRQUFBLFNBQUEsRUFBZTtBQUNiO0FBQ0EsTUFBQSxnQkFBZ0IsR0FBRyxJQUFuQixPQUFtQixFQUFuQjtBQUNBLFlBQU0sSUFBQSxLQUFBLENBQU4sbUpBQU0sQ0FBTjtBQUdEOztBQUVELElBQUEsU0FBUyxHQUFULElBQUE7QUFDQSxJQUFBLGdCQUFnQixHQUFHLElBQW5CLEdBQW1CLEVBQW5CO0FBVkYsR0FBQTs7QUFhQSx3Q0FBQSwyQkFBMkIsR0FBRyxNQUFLO0FBQ2pDLFFBQUksQ0FBSixTQUFBLEVBQWdCO0FBQ2QsWUFBTSxJQUFBLEtBQUEsQ0FBTiw0SUFBTSxDQUFOO0FBR0Q7O0FBRUQsSUFBQSxTQUFTLEdBQVQsS0FBQTtBQUVBLFFBQUksR0FBRyxHQUFQLGdCQUFBO0FBQ0EsSUFBQSxnQkFBZ0IsR0FBRyxJQUFuQixPQUFtQixFQUFuQjtBQUVBLFFBQUksV0FBVyxHQUFmLEVBQUE7QUFFQSxJQUFBLEdBQUcsQ0FBSCxPQUFBLENBQWEsSUFBRCxJQUFTO0FBQ25CLFVBQUksSUFBSSxDQUFKLEtBQUEsS0FBVTtBQUFBO0FBQWQsUUFBOEM7QUFDNUMsVUFBQSxXQUFXLENBQVgsSUFBQSxDQUFpQixJQUFJLENBQXJCLE1BQUE7QUFDRDtBQUhILEtBQUE7O0FBTUEsUUFBSSxXQUFXLENBQVgsTUFBQSxHQUFKLENBQUEsRUFBNEI7QUFDMUIsVUFBSSxlQUFlLEdBQUcsV0FBVyxDQUFYLEdBQUEsQ0FBQSxtQkFBQSxFQUFBLElBQUEsQ0FBdEIsUUFBc0IsQ0FBdEI7QUFDQSxVQUFJLEtBQUssR0FBRyxJQUFBLEtBQUEsQ0FDViwrREFBK0QsZUFEakUsRUFBWSxDQUFaO0FBSUEsTUFBQSxLQUFLLENBQUwsWUFBQSxHQUFBLFdBQUE7QUFFQSxZQUFBLEtBQUE7QUFDRDtBQTdCSCxHQUFBO0FBK0JEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHsgRGVzdHJveWFibGUsIERlc3RydWN0b3IgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGRlYnVnVG9TdHJpbmcgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IHNjaGVkdWxlRGVzdHJveSwgc2NoZWR1bGVEZXN0cm95ZWQgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5cbmNvbnN0IGVudW0gRGVzdHJveWluZ1N0YXRlIHtcbiAgTGl2ZSA9IDAsXG4gIERlc3Ryb3lpbmcgPSAxLFxuICBEZXN0cm95ZWQgPSAyLFxufVxuXG50eXBlIE9uZU9yTWFueTxUPiA9IG51bGwgfCBUIHwgVFtdO1xuXG5pbnRlcmZhY2UgRGVzdHJveWFibGVNZXRhPFQgZXh0ZW5kcyBEZXN0cm95YWJsZT4ge1xuICBzb3VyY2U/OiBUO1xuICBwYXJlbnRzOiBPbmVPck1hbnk8RGVzdHJveWFibGU+O1xuICBjaGlsZHJlbjogT25lT3JNYW55PERlc3Ryb3lhYmxlPjtcbiAgZWFnZXJEZXN0cnVjdG9yczogT25lT3JNYW55PERlc3RydWN0b3I8VD4+O1xuICBkZXN0cnVjdG9yczogT25lT3JNYW55PERlc3RydWN0b3I8VD4+O1xuICBzdGF0ZTogRGVzdHJveWluZ1N0YXRlO1xufVxuXG5pbnRlcmZhY2UgVW5kZXN0cm95ZWREZXN0cm95YWJsZXNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgZGVzdHJveWFibGVzOiBvYmplY3RbXTtcbn1cblxubGV0IERFU1RST1lBQkxFX01FVEE6XG4gIHwgTWFwPERlc3Ryb3lhYmxlLCBEZXN0cm95YWJsZU1ldGE8RGVzdHJveWFibGU+PlxuICB8IFdlYWtNYXA8RGVzdHJveWFibGUsIERlc3Ryb3lhYmxlTWV0YTxEZXN0cm95YWJsZT4+ID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gcHVzaDxUIGV4dGVuZHMgb2JqZWN0Pihjb2xsZWN0aW9uOiBPbmVPck1hbnk8VD4sIG5ld0l0ZW06IFQpOiBPbmVPck1hbnk8VD4ge1xuICBpZiAoY29sbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBuZXdJdGVtO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICBjb2xsZWN0aW9uLnB1c2gobmV3SXRlbSk7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtjb2xsZWN0aW9uLCBuZXdJdGVtXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpdGVyYXRlPFQgZXh0ZW5kcyBvYmplY3Q+KGNvbGxlY3Rpb246IE9uZU9yTWFueTxUPiwgZm46IChpdGVtOiBUKSA9PiB2b2lkKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmbihjb2xsZWN0aW9uW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY29sbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIGZuKGNvbGxlY3Rpb24pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZTxUIGV4dGVuZHMgb2JqZWN0Pihjb2xsZWN0aW9uOiBPbmVPck1hbnk8VD4sIGl0ZW06IFQsIG1lc3NhZ2U6IHN0cmluZyB8IGZhbHNlKSB7XG4gIGlmIChERUJVRykge1xuICAgIGxldCBjb2xsZWN0aW9uSXNJdGVtID0gY29sbGVjdGlvbiA9PT0gaXRlbTtcbiAgICBsZXQgY29sbGVjdGlvbkNvbnRhaW5zSXRlbSA9IEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikgJiYgY29sbGVjdGlvbi5pbmRleE9mKGl0ZW0pICE9PSAtMTtcblxuICAgIGlmICghY29sbGVjdGlvbklzSXRlbSAmJiAhY29sbGVjdGlvbkNvbnRhaW5zSXRlbSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFN0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY29sbGVjdGlvbikgJiYgY29sbGVjdGlvbi5sZW5ndGggPiAxKSB7XG4gICAgbGV0IGluZGV4ID0gY29sbGVjdGlvbiEuaW5kZXhPZihpdGVtKTtcbiAgICBjb2xsZWN0aW9uIS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlc3Ryb3lhYmxlTWV0YTxUIGV4dGVuZHMgRGVzdHJveWFibGU+KGRlc3Ryb3lhYmxlOiBUKTogRGVzdHJveWFibGVNZXRhPFQ+IHtcbiAgbGV0IG1ldGEgPSBERVNUUk9ZQUJMRV9NRVRBLmdldChkZXN0cm95YWJsZSk7XG5cbiAgaWYgKG1ldGEgPT09IHVuZGVmaW5lZCkge1xuICAgIG1ldGEgPSB7XG4gICAgICBwYXJlbnRzOiBudWxsLFxuICAgICAgY2hpbGRyZW46IG51bGwsXG4gICAgICBlYWdlckRlc3RydWN0b3JzOiBudWxsLFxuICAgICAgZGVzdHJ1Y3RvcnM6IG51bGwsXG4gICAgICBzdGF0ZTogRGVzdHJveWluZ1N0YXRlLkxpdmUsXG4gICAgfTtcblxuICAgIGlmIChERUJVRykge1xuICAgICAgbWV0YS5zb3VyY2UgPSBkZXN0cm95YWJsZSBhcyBvYmplY3Q7XG4gICAgfVxuXG4gICAgREVTVFJPWUFCTEVfTUVUQS5zZXQoZGVzdHJveWFibGUsIG1ldGEpO1xuICB9XG5cbiAgcmV0dXJuIChtZXRhIGFzIHVua25vd24pIGFzIERlc3Ryb3lhYmxlTWV0YTxUPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQ8VCBleHRlbmRzIERlc3Ryb3lhYmxlPihwYXJlbnQ6IERlc3Ryb3lhYmxlLCBjaGlsZDogVCk6IFQge1xuICBpZiAoREVCVUcgJiYgaXNEZXN0cm95aW5nKHBhcmVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQXR0ZW1wdGVkIHRvIGFzc29jaWF0ZSBhIGRlc3Ryb3lhYmxlIGNoaWxkIHdpdGggYW4gb2JqZWN0IHRoYXQgaXMgYWxyZWFkeSBkZXN0cm95aW5nIG9yIGRlc3Ryb3llZCdcbiAgICApO1xuICB9XG5cbiAgbGV0IHBhcmVudE1ldGEgPSBnZXREZXN0cm95YWJsZU1ldGEocGFyZW50KTtcbiAgbGV0IGNoaWxkTWV0YSA9IGdldERlc3Ryb3lhYmxlTWV0YShjaGlsZCk7XG5cbiAgcGFyZW50TWV0YS5jaGlsZHJlbiA9IHB1c2gocGFyZW50TWV0YS5jaGlsZHJlbiwgY2hpbGQpO1xuICBjaGlsZE1ldGEucGFyZW50cyA9IHB1c2goY2hpbGRNZXRhLnBhcmVudHMsIHBhcmVudCk7XG5cbiAgcmV0dXJuIGNoaWxkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJEZXN0cnVjdG9yPFQgZXh0ZW5kcyBEZXN0cm95YWJsZT4oXG4gIGRlc3Ryb3lhYmxlOiBULFxuICBkZXN0cnVjdG9yOiBEZXN0cnVjdG9yPFQ+LFxuICBlYWdlciA9IGZhbHNlXG4pOiBEZXN0cnVjdG9yPFQ+IHtcbiAgaWYgKERFQlVHICYmIGlzRGVzdHJveWluZyhkZXN0cm95YWJsZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQXR0ZW1wdGVkIHRvIHJlZ2lzdGVyIGEgZGVzdHJ1Y3RvciB3aXRoIGFuIG9iamVjdCB0aGF0IGlzIGFscmVhZHkgZGVzdHJveWluZyBvciBkZXN0cm95ZWQnXG4gICAgKTtcbiAgfVxuXG4gIGxldCBtZXRhID0gZ2V0RGVzdHJveWFibGVNZXRhKGRlc3Ryb3lhYmxlKTtcblxuICBsZXQgZGVzdHJ1Y3RvcnNLZXk6ICdlYWdlckRlc3RydWN0b3JzJyB8ICdkZXN0cnVjdG9ycycgPVxuICAgIGVhZ2VyID09PSB0cnVlID8gJ2VhZ2VyRGVzdHJ1Y3RvcnMnIDogJ2Rlc3RydWN0b3JzJztcblxuICBtZXRhW2Rlc3RydWN0b3JzS2V5XSA9IHB1c2gobWV0YVtkZXN0cnVjdG9yc0tleV0sIGRlc3RydWN0b3IpO1xuXG4gIHJldHVybiBkZXN0cnVjdG9yO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5yZWdpc3RlckRlc3RydWN0b3I8VCBleHRlbmRzIERlc3Ryb3lhYmxlPihcbiAgZGVzdHJveWFibGU6IFQsXG4gIGRlc3RydWN0b3I6IERlc3RydWN0b3I8VD4sXG4gIGVhZ2VyID0gZmFsc2Vcbik6IHZvaWQge1xuICBpZiAoREVCVUcgJiYgaXNEZXN0cm95aW5nKGRlc3Ryb3lhYmxlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdBdHRlbXB0ZWQgdG8gdW5yZWdpc3RlciBhIGRlc3RydWN0b3Igd2l0aCBhbiBvYmplY3QgdGhhdCBpcyBhbHJlYWR5IGRlc3Ryb3lpbmcgb3IgZGVzdHJveWVkJ1xuICAgICk7XG4gIH1cblxuICBsZXQgbWV0YSA9IGdldERlc3Ryb3lhYmxlTWV0YShkZXN0cm95YWJsZSk7XG5cbiAgbGV0IGRlc3RydWN0b3JzS2V5OiAnZWFnZXJEZXN0cnVjdG9ycycgfCAnZGVzdHJ1Y3RvcnMnID1cbiAgICBlYWdlciA9PT0gdHJ1ZSA/ICdlYWdlckRlc3RydWN0b3JzJyA6ICdkZXN0cnVjdG9ycyc7XG5cbiAgbWV0YVtkZXN0cnVjdG9yc0tleV0gPSByZW1vdmUoXG4gICAgbWV0YVtkZXN0cnVjdG9yc0tleV0sXG4gICAgZGVzdHJ1Y3RvcixcbiAgICBERUJVRyAmJiAnYXR0ZW1wdGVkIHRvIHJlbW92ZSBhIGRlc3RydWN0b3IgdGhhdCB3YXMgbm90IHJlZ2lzdGVyZWQgd2l0aCB0aGUgZGVzdHJveWFibGUnXG4gICk7XG59XG5cbi8vLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveShkZXN0cm95YWJsZTogRGVzdHJveWFibGUpIHtcbiAgbGV0IG1ldGEgPSBnZXREZXN0cm95YWJsZU1ldGEoZGVzdHJveWFibGUpO1xuXG4gIGlmIChtZXRhLnN0YXRlID49IERlc3Ryb3lpbmdTdGF0ZS5EZXN0cm95aW5nKSByZXR1cm47XG5cbiAgbGV0IHsgcGFyZW50cywgY2hpbGRyZW4sIGVhZ2VyRGVzdHJ1Y3RvcnMsIGRlc3RydWN0b3JzIH0gPSBtZXRhO1xuXG4gIG1ldGEuc3RhdGUgPSBEZXN0cm95aW5nU3RhdGUuRGVzdHJveWluZztcblxuICBpdGVyYXRlKGNoaWxkcmVuLCBkZXN0cm95KTtcbiAgaXRlcmF0ZShlYWdlckRlc3RydWN0b3JzLCAoZGVzdHJ1Y3RvcikgPT4gZGVzdHJ1Y3RvcihkZXN0cm95YWJsZSkpO1xuICBpdGVyYXRlKGRlc3RydWN0b3JzLCAoZGVzdHJ1Y3RvcikgPT4gc2NoZWR1bGVEZXN0cm95KGRlc3Ryb3lhYmxlLCBkZXN0cnVjdG9yKSk7XG5cbiAgc2NoZWR1bGVEZXN0cm95ZWQoKCkgPT4ge1xuICAgIGl0ZXJhdGUocGFyZW50cywgKHBhcmVudCkgPT4gcmVtb3ZlQ2hpbGRGcm9tUGFyZW50KGRlc3Ryb3lhYmxlLCBwYXJlbnQpKTtcblxuICAgIG1ldGEuc3RhdGUgPSBEZXN0cm95aW5nU3RhdGUuRGVzdHJveWVkO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRGcm9tUGFyZW50KGNoaWxkOiBEZXN0cm95YWJsZSwgcGFyZW50OiBEZXN0cm95YWJsZSkge1xuICBsZXQgcGFyZW50TWV0YSA9IGdldERlc3Ryb3lhYmxlTWV0YShwYXJlbnQpO1xuXG4gIGlmIChwYXJlbnRNZXRhLnN0YXRlID09PSBEZXN0cm95aW5nU3RhdGUuTGl2ZSkge1xuICAgIHBhcmVudE1ldGEuY2hpbGRyZW4gPSByZW1vdmUoXG4gICAgICBwYXJlbnRNZXRhLmNoaWxkcmVuLFxuICAgICAgY2hpbGQsXG4gICAgICBERUJVRyAmJlxuICAgICAgICBcImF0dGVtcHRlZCB0byByZW1vdmUgY2hpbGQgZnJvbSBwYXJlbnQsIGJ1dCB0aGUgcGFyZW50J3MgY2hpbGRyZW4gZGlkIG5vdCBjb250YWluIHRoZSBjaGlsZC4gVGhpcyBpcyBsaWtlbHkgYSBidWcgd2l0aCBkZXN0cnVjdG9ycy5cIlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3lDaGlsZHJlbihkZXN0cm95YWJsZTogRGVzdHJveWFibGUpIHtcbiAgbGV0IHsgY2hpbGRyZW4gfSA9IGdldERlc3Ryb3lhYmxlTWV0YShkZXN0cm95YWJsZSk7XG5cbiAgaXRlcmF0ZShjaGlsZHJlbiwgZGVzdHJveSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfaGFzRGVzdHJveWFibGVDaGlsZHJlbihkZXN0cm95YWJsZTogRGVzdHJveWFibGUpIHtcbiAgbGV0IG1ldGEgPSBERVNUUk9ZQUJMRV9NRVRBLmdldChkZXN0cm95YWJsZSk7XG5cbiAgcmV0dXJuIG1ldGEgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogbWV0YS5jaGlsZHJlbiAhPT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVzdHJveWluZyhkZXN0cm95YWJsZTogRGVzdHJveWFibGUpIHtcbiAgbGV0IG1ldGEgPSBERVNUUk9ZQUJMRV9NRVRBLmdldChkZXN0cm95YWJsZSk7XG5cbiAgcmV0dXJuIG1ldGEgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogbWV0YS5zdGF0ZSA+PSBEZXN0cm95aW5nU3RhdGUuRGVzdHJveWluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVzdHJveWVkKGRlc3Ryb3lhYmxlOiBEZXN0cm95YWJsZSkge1xuICBsZXQgbWV0YSA9IERFU1RST1lBQkxFX01FVEEuZ2V0KGRlc3Ryb3lhYmxlKTtcblxuICByZXR1cm4gbWV0YSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBtZXRhLnN0YXRlID49IERlc3Ryb3lpbmdTdGF0ZS5EZXN0cm95ZWQ7XG59XG5cbi8vLy8vLy8vLy8vL1xuXG5leHBvcnQgbGV0IGVuYWJsZURlc3Ryb3lhYmxlVHJhY2tpbmc6IHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKTtcbmV4cG9ydCBsZXQgYXNzZXJ0RGVzdHJveWFibGVzRGVzdHJveWVkOiB1bmRlZmluZWQgfCAoKCkgPT4gdm9pZCk7XG5cbmlmIChERUJVRykge1xuICBsZXQgaXNUZXN0aW5nID0gZmFsc2U7XG5cbiAgZW5hYmxlRGVzdHJveWFibGVUcmFja2luZyA9ICgpID0+IHtcbiAgICBpZiAoaXNUZXN0aW5nKSB7XG4gICAgICAvLyBSZXNldCBkZXN0cm95YWJsZSBtZXRhIGp1c3QgaW4gY2FzZSwgYmVmb3JlIHRocm93aW5nIHRoZSBlcnJvclxuICAgICAgREVTVFJPWUFCTEVfTUVUQSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdBdHRlbXB0ZWQgdG8gc3RhcnQgZGVzdHJveWFibGUgdGVzdGluZywgYnV0IHlvdSBkaWQgbm90IGVuZCB0aGUgcHJldmlvdXMgZGVzdHJveWFibGUgdGVzdC4gRGlkIHlvdSBmb3JnZXQgdG8gY2FsbCBgYXNzZXJ0RGVzdHJveWFibGVzRGVzdHJveWVkKClgJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpc1Rlc3RpbmcgPSB0cnVlO1xuICAgIERFU1RST1lBQkxFX01FVEEgPSBuZXcgTWFwKCk7XG4gIH07XG5cbiAgYXNzZXJ0RGVzdHJveWFibGVzRGVzdHJveWVkID0gKCkgPT4ge1xuICAgIGlmICghaXNUZXN0aW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdBdHRlbXB0ZWQgdG8gYXNzZXJ0IGRlc3Ryb3lhYmxlcyBkZXN0cm95ZWQsIGJ1dCB5b3UgZGlkIG5vdCBzdGFydCBhIGRlc3Ryb3lhYmxlIHRlc3QuIERpZCB5b3UgZm9yZ2V0IHRvIGNhbGwgYGVuYWJsZURlc3Ryb3lhYmxlVHJhY2tpbmcoKWAnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlzVGVzdGluZyA9IGZhbHNlO1xuXG4gICAgbGV0IG1hcCA9IERFU1RST1lBQkxFX01FVEEgYXMgTWFwPERlc3Ryb3lhYmxlLCBEZXN0cm95YWJsZU1ldGE8RGVzdHJveWFibGU+PjtcbiAgICBERVNUUk9ZQUJMRV9NRVRBID0gbmV3IFdlYWtNYXAoKTtcblxuICAgIGxldCB1bmRlc3Ryb3llZDogb2JqZWN0W10gPSBbXTtcblxuICAgIG1hcC5mb3JFYWNoKChtZXRhKSA9PiB7XG4gICAgICBpZiAobWV0YS5zdGF0ZSAhPT0gRGVzdHJveWluZ1N0YXRlLkRlc3Ryb3llZCkge1xuICAgICAgICB1bmRlc3Ryb3llZC5wdXNoKG1ldGEuc291cmNlISk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodW5kZXN0cm95ZWQubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IG9iamVjdHNUb1N0cmluZyA9IHVuZGVzdHJveWVkLm1hcChkZWJ1Z1RvU3RyaW5nISkuam9pbignXFxuICAgICcpO1xuICAgICAgbGV0IGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBgU29tZSBkZXN0cm95YWJsZXMgd2VyZSBub3QgZGVzdHJveWVkIGR1cmluZyB0aGlzIHRlc3Q6XFxuICAgICR7b2JqZWN0c1RvU3RyaW5nfWBcbiAgICAgICkgYXMgVW5kZXN0cm95ZWREZXN0cm95YWJsZXNFcnJvcjtcblxuICAgICAgZXJyb3IuZGVzdHJveWFibGVzID0gdW5kZXN0cm95ZWQ7XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=