import { DEBUG } from '@glimmer/env';
import { debugToString } from '@glimmer/util';
import { scheduleDestroy, scheduleDestroyed } from '@glimmer/global-context';
var DESTROYABLE_META = new WeakMap();

function push(collection, newItem) {
  if (collection === null) {
    return newItem;
  } else if (Array.isArray(collection)) {
    collection.push(newItem);
    return collection;
  } else {
    return [collection, newItem];
  }
}

function iterate(collection, fn) {
  if (Array.isArray(collection)) {
    for (var i = 0; i < collection.length; i++) {
      fn(collection[i]);
    }
  } else if (collection !== null) {
    fn(collection);
  }
}

function remove(collection, item, message) {
  if (DEBUG) {
    var collectionIsItem = collection === item;
    var collectionContainsItem = Array.isArray(collection) && collection.indexOf(item) !== -1;

    if (!collectionIsItem && !collectionContainsItem) {
      throw new Error(String(message));
    }
  }

  if (Array.isArray(collection) && collection.length > 1) {
    var index = collection.indexOf(item);
    collection.splice(index, 1);
    return collection;
  } else {
    return null;
  }
}

function getDestroyableMeta(destroyable) {
  var meta = DESTROYABLE_META.get(destroyable);

  if (meta === undefined) {
    meta = {
      parents: null,
      children: null,
      eagerDestructors: null,
      destructors: null,
      state: 0
      /* Live */

    };

    if (DEBUG) {
      meta.source = destroyable;
    }

    DESTROYABLE_META.set(destroyable, meta);
  }

  return meta;
}

export function associateDestroyableChild(parent, child) {
  if (DEBUG && isDestroying(parent)) {
    throw new Error('Attempted to associate a destroyable child with an object that is already destroying or destroyed');
  }

  var parentMeta = getDestroyableMeta(parent);
  var childMeta = getDestroyableMeta(child);
  parentMeta.children = push(parentMeta.children, child);
  childMeta.parents = push(childMeta.parents, parent);
  return child;
}
export function registerDestructor(destroyable, destructor, eager) {
  if (eager === void 0) {
    eager = false;
  }

  if (DEBUG && isDestroying(destroyable)) {
    throw new Error('Attempted to register a destructor with an object that is already destroying or destroyed');
  }

  var meta = getDestroyableMeta(destroyable);
  var destructorsKey = eager === true ? 'eagerDestructors' : 'destructors';
  meta[destructorsKey] = push(meta[destructorsKey], destructor);
  return destructor;
}
export function unregisterDestructor(destroyable, destructor, eager) {
  if (eager === void 0) {
    eager = false;
  }

  if (DEBUG && isDestroying(destroyable)) {
    throw new Error('Attempted to unregister a destructor with an object that is already destroying or destroyed');
  }

  var meta = getDestroyableMeta(destroyable);
  var destructorsKey = eager === true ? 'eagerDestructors' : 'destructors';
  meta[destructorsKey] = remove(meta[destructorsKey], destructor, DEBUG && 'attempted to remove a destructor that was not registered with the destroyable');
} ////////////

export function destroy(destroyable) {
  var meta = getDestroyableMeta(destroyable);
  if (meta.state >= 1
  /* Destroying */
  ) return;
  var parents = meta.parents,
      children = meta.children,
      eagerDestructors = meta.eagerDestructors,
      destructors = meta.destructors;
  meta.state = 1
  /* Destroying */
  ;
  iterate(children, destroy);
  iterate(eagerDestructors, function (destructor) {
    return destructor(destroyable);
  });
  iterate(destructors, function (destructor) {
    return scheduleDestroy(destroyable, destructor);
  });
  scheduleDestroyed(function () {
    iterate(parents, function (parent) {
      return removeChildFromParent(destroyable, parent);
    });
    meta.state = 2
    /* Destroyed */
    ;
  });
}

function removeChildFromParent(child, parent) {
  var parentMeta = getDestroyableMeta(parent);

  if (parentMeta.state === 0
  /* Live */
  ) {
      parentMeta.children = remove(parentMeta.children, child, DEBUG && "attempted to remove child from parent, but the parent's children did not contain the child. This is likely a bug with destructors.");
    }
}

export function destroyChildren(destroyable) {
  var _getDestroyableMeta = getDestroyableMeta(destroyable),
      children = _getDestroyableMeta.children;

  iterate(children, destroy);
}
export function _hasDestroyableChildren(destroyable) {
  var meta = DESTROYABLE_META.get(destroyable);
  return meta === undefined ? false : meta.children !== null;
}
export function isDestroying(destroyable) {
  var meta = DESTROYABLE_META.get(destroyable);
  return meta === undefined ? false : meta.state >= 1
  /* Destroying */
  ;
}
export function isDestroyed(destroyable) {
  var meta = DESTROYABLE_META.get(destroyable);
  return meta === undefined ? false : meta.state >= 2
  /* Destroyed */
  ;
} ////////////

export var enableDestroyableTracking;
export var assertDestroyablesDestroyed;

if (DEBUG) {
  var isTesting = false;

  enableDestroyableTracking = function enableDestroyableTracking() {
    if (isTesting) {
      // Reset destroyable meta just in case, before throwing the error
      DESTROYABLE_META = new WeakMap();
      throw new Error('Attempted to start destroyable testing, but you did not end the previous destroyable test. Did you forget to call `assertDestroyablesDestroyed()`');
    }

    isTesting = true;
    DESTROYABLE_META = new Map();
  };

  assertDestroyablesDestroyed = function assertDestroyablesDestroyed() {
    if (!isTesting) {
      throw new Error('Attempted to assert destroyables destroyed, but you did not start a destroyable test. Did you forget to call `enableDestroyableTracking()`');
    }

    isTesting = false;
    var map = DESTROYABLE_META;
    DESTROYABLE_META = new WeakMap();
    var undestroyed = [];
    map.forEach(function (meta) {
      if (meta.state !== 2
      /* Destroyed */
      ) {
          undestroyed.push(meta.source);
        }
    });

    if (undestroyed.length > 0) {
      var objectsToString = undestroyed.map(debugToString).join('\n    ');
      var error = new Error("Some destroyables were not destroyed during this test:\n    " + objectsToString);
      error.destroyables = undestroyed;
      throw error;
    }
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL2Rlc3Ryb3lhYmxlL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFNBQUEsS0FBQSxRQUFBLGNBQUE7QUFFQSxTQUFBLGFBQUEsUUFBQSxlQUFBO0FBQ0EsU0FBQSxlQUFBLEVBQUEsaUJBQUEsUUFBQSx5QkFBQTtBQXVCQSxJQUFJLGdCQUFnQixHQUVxQyxJQUZ6RCxPQUV5RCxFQUZ6RDs7QUFJQSxTQUFBLElBQUEsQ0FBQSxVQUFBLEVBQUEsT0FBQSxFQUFvRTtBQUNsRSxNQUFJLFVBQVUsS0FBZCxJQUFBLEVBQXlCO0FBQ3ZCLFdBQUEsT0FBQTtBQURGLEdBQUEsTUFFTyxJQUFJLEtBQUssQ0FBTCxPQUFBLENBQUosVUFBSSxDQUFKLEVBQStCO0FBQ3BDLElBQUEsVUFBVSxDQUFWLElBQUEsQ0FBQSxPQUFBO0FBQ0EsV0FBQSxVQUFBO0FBRkssR0FBQSxNQUdBO0FBQ0wsV0FBTyxDQUFBLFVBQUEsRUFBUCxPQUFPLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQUEsT0FBQSxDQUFBLFVBQUEsRUFBQSxFQUFBLEVBQWtGO0FBQ2hGLE1BQUksS0FBSyxDQUFMLE9BQUEsQ0FBSixVQUFJLENBQUosRUFBK0I7QUFDN0IsU0FBSyxJQUFJLENBQUMsR0FBVixDQUFBLEVBQWdCLENBQUMsR0FBRyxVQUFVLENBQTlCLE1BQUEsRUFBdUMsQ0FBdkMsRUFBQSxFQUE0QztBQUMxQyxNQUFBLEVBQUUsQ0FBQyxVQUFVLENBQWIsQ0FBYSxDQUFYLENBQUY7QUFDRDtBQUhILEdBQUEsTUFJTyxJQUFJLFVBQVUsS0FBZCxJQUFBLEVBQXlCO0FBQzlCLElBQUEsRUFBRSxDQUFGLFVBQUUsQ0FBRjtBQUNEO0FBQ0Y7O0FBRUQsU0FBQSxNQUFBLENBQUEsVUFBQSxFQUFBLElBQUEsRUFBQSxPQUFBLEVBQTRGO0FBQzFGLE1BQUEsS0FBQSxFQUFXO0FBQ1QsUUFBSSxnQkFBZ0IsR0FBRyxVQUFVLEtBQWpDLElB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QUFLLEdBQUcsSUFBQSxLQUFBLGtFQUFaLGVBQVksQ0FBWjtBQUlBLE1BQUEsS0FBSyxDQUFMLFlBQUEsR0FBQSxXQUFBO0FBRUEsWUFBQSxLQUFBO0FBQ0Q7QUE3QkgsR0FBQTtBQStCRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IERlc3Ryb3lhYmxlLCBEZXN0cnVjdG9yIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBkZWJ1Z1RvU3RyaW5nIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBzY2hlZHVsZURlc3Ryb3ksIHNjaGVkdWxlRGVzdHJveWVkIH0gZnJvbSAnQGdsaW1tZXIvZ2xvYmFsLWNvbnRleHQnO1xuXG5jb25zdCBlbnVtIERlc3Ryb3lpbmdTdGF0ZSB7XG4gIExpdmUgPSAwLFxuICBEZXN0cm95aW5nID0gMSxcbiAgRGVzdHJveWVkID0gMixcbn1cblxudHlwZSBPbmVPck1hbnk8VD4gPSBudWxsIHwgVCB8IFRbXTtcblxuaW50ZXJmYWNlIERlc3Ryb3lhYmxlTWV0YTxUIGV4dGVuZHMgRGVzdHJveWFibGU+IHtcbiAgc291cmNlPzogVDtcbiAgcGFyZW50czogT25lT3JNYW55PERlc3Ryb3lhYmxlPjtcbiAgY2hpbGRyZW46IE9uZU9yTWFueTxEZXN0cm95YWJsZT47XG4gIGVhZ2VyRGVzdHJ1Y3RvcnM6IE9uZU9yTWFueTxEZXN0cnVjdG9yPFQ+PjtcbiAgZGVzdHJ1Y3RvcnM6IE9uZU9yTWFueTxEZXN0cnVjdG9yPFQ+PjtcbiAgc3RhdGU6IERlc3Ryb3lpbmdTdGF0ZTtcbn1cblxuaW50ZXJmYWNlIFVuZGVzdHJveWVkRGVzdHJveWFibGVzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGRlc3Ryb3lhYmxlczogb2JqZWN0W107XG59XG5cbmxldCBERVNUUk9ZQUJMRV9NRVRBOlxuICB8IE1hcDxEZXN0cm95YWJsZSwgRGVzdHJveWFibGVNZXRhPERlc3Ryb3lhYmxlPj5cbiAgfCBXZWFrTWFwPERlc3Ryb3lhYmxlLCBEZXN0cm95YWJsZU1ldGE8RGVzdHJveWFibGU+PiA9IG5ldyBXZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIHB1c2g8VCBleHRlbmRzIG9iamVjdD4oY29sbGVjdGlvbjogT25lT3JNYW55PFQ+LCBuZXdJdGVtOiBUKTogT25lT3JNYW55PFQ+IHtcbiAgaWYgKGNvbGxlY3Rpb24gPT09IG51bGwpIHtcbiAgICByZXR1cm4gbmV3SXRlbTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgY29sbGVjdGlvbi5wdXNoKG5ld0l0ZW0pO1xuICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbY29sbGVjdGlvbiwgbmV3SXRlbV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0ZTxUIGV4dGVuZHMgb2JqZWN0Pihjb2xsZWN0aW9uOiBPbmVPck1hbnk8VD4sIGZuOiAoaXRlbTogVCkgPT4gdm9pZCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb2xsZWN0aW9uKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgZm4oY29sbGVjdGlvbltpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGNvbGxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBmbihjb2xsZWN0aW9uKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmU8VCBleHRlbmRzIG9iamVjdD4oY29sbGVjdGlvbjogT25lT3JNYW55PFQ+LCBpdGVtOiBULCBtZXNzYWdlOiBzdHJpbmcgfCBmYWxzZSkge1xuICBpZiAoREVCVUcpIHtcbiAgICBsZXQgY29sbGVjdGlvbklzSXRlbSA9IGNvbGxlY3Rpb24gPT09IGl0ZW07XG4gICAgbGV0IGNvbGxlY3Rpb25Db250YWluc0l0ZW0gPSBBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24pICYmIGNvbGxlY3Rpb24uaW5kZXhPZihpdGVtKSAhPT0gLTE7XG5cbiAgICBpZiAoIWNvbGxlY3Rpb25Jc0l0ZW0gJiYgIWNvbGxlY3Rpb25Db250YWluc0l0ZW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihTdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGNvbGxlY3Rpb24pICYmIGNvbGxlY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgIGxldCBpbmRleCA9IGNvbGxlY3Rpb24hLmluZGV4T2YoaXRlbSk7XG4gICAgY29sbGVjdGlvbiEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZXN0cm95YWJsZU1ldGE8VCBleHRlbmRzIERlc3Ryb3lhYmxlPihkZXN0cm95YWJsZTogVCk6IERlc3Ryb3lhYmxlTWV0YTxUPiB7XG4gIGxldCBtZXRhID0gREVTVFJPWUFCTEVfTUVUQS5nZXQoZGVzdHJveWFibGUpO1xuXG4gIGlmIChtZXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBtZXRhID0ge1xuICAgICAgcGFyZW50czogbnVsbCxcbiAgICAgIGNoaWxkcmVuOiBudWxsLFxuICAgICAgZWFnZXJEZXN0cnVjdG9yczogbnVsbCxcbiAgICAgIGRlc3RydWN0b3JzOiBudWxsLFxuICAgICAgc3RhdGU6IERlc3Ryb3lpbmdTdGF0ZS5MaXZlLFxuICAgIH07XG5cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIG1ldGEuc291cmNlID0gZGVzdHJveWFibGUgYXMgb2JqZWN0O1xuICAgIH1cblxuICAgIERFU1RST1lBQkxFX01FVEEuc2V0KGRlc3Ryb3lhYmxlLCBtZXRhKTtcbiAgfVxuXG4gIHJldHVybiAobWV0YSBhcyB1bmtub3duKSBhcyBEZXN0cm95YWJsZU1ldGE8VD47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkPFQgZXh0ZW5kcyBEZXN0cm95YWJsZT4ocGFyZW50OiBEZXN0cm95YWJsZSwgY2hpbGQ6IFQpOiBUIHtcbiAgaWYgKERFQlVHICYmIGlzRGVzdHJveWluZyhwYXJlbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0F0dGVtcHRlZCB0byBhc3NvY2lhdGUgYSBkZXN0cm95YWJsZSBjaGlsZCB3aXRoIGFuIG9iamVjdCB0aGF0IGlzIGFscmVhZHkgZGVzdHJveWluZyBvciBkZXN0cm95ZWQnXG4gICAgKTtcbiAgfVxuXG4gIGxldCBwYXJlbnRNZXRhID0gZ2V0RGVzdHJveWFibGVNZXRhKHBhcmVudCk7XG4gIGxldCBjaGlsZE1ldGEgPSBnZXREZXN0cm95YWJsZU1ldGEoY2hpbGQpO1xuXG4gIHBhcmVudE1ldGEuY2hpbGRyZW4gPSBwdXNoKHBhcmVudE1ldGEuY2hpbGRyZW4sIGNoaWxkKTtcbiAgY2hpbGRNZXRhLnBhcmVudHMgPSBwdXNoKGNoaWxkTWV0YS5wYXJlbnRzLCBwYXJlbnQpO1xuXG4gIHJldHVybiBjaGlsZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRGVzdHJ1Y3RvcjxUIGV4dGVuZHMgRGVzdHJveWFibGU+KFxuICBkZXN0cm95YWJsZTogVCxcbiAgZGVzdHJ1Y3RvcjogRGVzdHJ1Y3RvcjxUPixcbiAgZWFnZXIgPSBmYWxzZVxuKTogRGVzdHJ1Y3RvcjxUPiB7XG4gIGlmIChERUJVRyAmJiBpc0Rlc3Ryb3lpbmcoZGVzdHJveWFibGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0F0dGVtcHRlZCB0byByZWdpc3RlciBhIGRlc3RydWN0b3Igd2l0aCBhbiBvYmplY3QgdGhhdCBpcyBhbHJlYWR5IGRlc3Ryb3lpbmcgb3IgZGVzdHJveWVkJ1xuICAgICk7XG4gIH1cblxuICBsZXQgbWV0YSA9IGdldERlc3Ryb3lhYmxlTWV0YShkZXN0cm95YWJsZSk7XG5cbiAgbGV0IGRlc3RydWN0b3JzS2V5OiAnZWFnZXJEZXN0cnVjdG9ycycgfCAnZGVzdHJ1Y3RvcnMnID1cbiAgICBlYWdlciA9PT0gdHJ1ZSA/ICdlYWdlckRlc3RydWN0b3JzJyA6ICdkZXN0cnVjdG9ycyc7XG5cbiAgbWV0YVtkZXN0cnVjdG9yc0tleV0gPSBwdXNoKG1ldGFbZGVzdHJ1Y3RvcnNLZXldLCBkZXN0cnVjdG9yKTtcblxuICByZXR1cm4gZGVzdHJ1Y3Rvcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVucmVnaXN0ZXJEZXN0cnVjdG9yPFQgZXh0ZW5kcyBEZXN0cm95YWJsZT4oXG4gIGRlc3Ryb3lhYmxlOiBULFxuICBkZXN0cnVjdG9yOiBEZXN0cnVjdG9yPFQ+LFxuICBlYWdlciA9IGZhbHNlXG4pOiB2b2lkIHtcbiAgaWYgKERFQlVHICYmIGlzRGVzdHJveWluZyhkZXN0cm95YWJsZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQXR0ZW1wdGVkIHRvIHVucmVnaXN0ZXIgYSBkZXN0cnVjdG9yIHdpdGggYW4gb2JqZWN0IHRoYXQgaXMgYWxyZWFkeSBkZXN0cm95aW5nIG9yIGRlc3Ryb3llZCdcbiAgICApO1xuICB9XG5cbiAgbGV0IG1ldGEgPSBnZXREZXN0cm95YWJsZU1ldGEoZGVzdHJveWFibGUpO1xuXG4gIGxldCBkZXN0cnVjdG9yc0tleTogJ2VhZ2VyRGVzdHJ1Y3RvcnMnIHwgJ2Rlc3RydWN0b3JzJyA9XG4gICAgZWFnZXIgPT09IHRydWUgPyAnZWFnZXJEZXN0cnVjdG9ycycgOiAnZGVzdHJ1Y3RvcnMnO1xuXG4gIG1ldGFbZGVzdHJ1Y3RvcnNLZXldID0gcmVtb3ZlKFxuICAgIG1ldGFbZGVzdHJ1Y3RvcnNLZXldLFxuICAgIGRlc3RydWN0b3IsXG4gICAgREVCVUcgJiYgJ2F0dGVtcHRlZCB0byByZW1vdmUgYSBkZXN0cnVjdG9yIHRoYXQgd2FzIG5vdCByZWdpc3RlcmVkIHdpdGggdGhlIGRlc3Ryb3lhYmxlJ1xuICApO1xufVxuXG4vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlc3Ryb3koZGVzdHJveWFibGU6IERlc3Ryb3lhYmxlKSB7XG4gIGxldCBtZXRhID0gZ2V0RGVzdHJveWFibGVNZXRhKGRlc3Ryb3lhYmxlKTtcblxuICBpZiAobWV0YS5zdGF0ZSA+PSBEZXN0cm95aW5nU3RhdGUuRGVzdHJveWluZykgcmV0dXJuO1xuXG4gIGxldCB7IHBhcmVudHMsIGNoaWxkcmVuLCBlYWdlckRlc3RydWN0b3JzLCBkZXN0cnVjdG9ycyB9ID0gbWV0YTtcblxuICBtZXRhLnN0YXRlID0gRGVzdHJveWluZ1N0YXRlLkRlc3Ryb3lpbmc7XG5cbiAgaXRlcmF0ZShjaGlsZHJlbiwgZGVzdHJveSk7XG4gIGl0ZXJhdGUoZWFnZXJEZXN0cnVjdG9ycywgKGRlc3RydWN0b3IpID0+IGRlc3RydWN0b3IoZGVzdHJveWFibGUpKTtcbiAgaXRlcmF0ZShkZXN0cnVjdG9ycywgKGRlc3RydWN0b3IpID0+IHNjaGVkdWxlRGVzdHJveShkZXN0cm95YWJsZSwgZGVzdHJ1Y3RvcikpO1xuXG4gIHNjaGVkdWxlRGVzdHJveWVkKCgpID0+IHtcbiAgICBpdGVyYXRlKHBhcmVudHMsIChwYXJlbnQpID0+IHJlbW92ZUNoaWxkRnJvbVBhcmVudChkZXN0cm95YWJsZSwgcGFyZW50KSk7XG5cbiAgICBtZXRhLnN0YXRlID0gRGVzdHJveWluZ1N0YXRlLkRlc3Ryb3llZDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkRnJvbVBhcmVudChjaGlsZDogRGVzdHJveWFibGUsIHBhcmVudDogRGVzdHJveWFibGUpIHtcbiAgbGV0IHBhcmVudE1ldGEgPSBnZXREZXN0cm95YWJsZU1ldGEocGFyZW50KTtcblxuICBpZiAocGFyZW50TWV0YS5zdGF0ZSA9PT0gRGVzdHJveWluZ1N0YXRlLkxpdmUpIHtcbiAgICBwYXJlbnRNZXRhLmNoaWxkcmVuID0gcmVtb3ZlKFxuICAgICAgcGFyZW50TWV0YS5jaGlsZHJlbixcbiAgICAgIGNoaWxkLFxuICAgICAgREVCVUcgJiZcbiAgICAgICAgXCJhdHRlbXB0ZWQgdG8gcmVtb3ZlIGNoaWxkIGZyb20gcGFyZW50LCBidXQgdGhlIHBhcmVudCdzIGNoaWxkcmVuIGRpZCBub3QgY29udGFpbiB0aGUgY2hpbGQuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIHdpdGggZGVzdHJ1Y3RvcnMuXCJcbiAgICApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXN0cm95Q2hpbGRyZW4oZGVzdHJveWFibGU6IERlc3Ryb3lhYmxlKSB7XG4gIGxldCB7IGNoaWxkcmVuIH0gPSBnZXREZXN0cm95YWJsZU1ldGEoZGVzdHJveWFibGUpO1xuXG4gIGl0ZXJhdGUoY2hpbGRyZW4sIGRlc3Ryb3kpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2hhc0Rlc3Ryb3lhYmxlQ2hpbGRyZW4oZGVzdHJveWFibGU6IERlc3Ryb3lhYmxlKSB7XG4gIGxldCBtZXRhID0gREVTVFJPWUFCTEVfTUVUQS5nZXQoZGVzdHJveWFibGUpO1xuXG4gIHJldHVybiBtZXRhID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG1ldGEuY2hpbGRyZW4gIT09IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Rlc3Ryb3lpbmcoZGVzdHJveWFibGU6IERlc3Ryb3lhYmxlKSB7XG4gIGxldCBtZXRhID0gREVTVFJPWUFCTEVfTUVUQS5nZXQoZGVzdHJveWFibGUpO1xuXG4gIHJldHVybiBtZXRhID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG1ldGEuc3RhdGUgPj0gRGVzdHJveWluZ1N0YXRlLkRlc3Ryb3lpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Rlc3Ryb3llZChkZXN0cm95YWJsZTogRGVzdHJveWFibGUpIHtcbiAgbGV0IG1ldGEgPSBERVNUUk9ZQUJMRV9NRVRBLmdldChkZXN0cm95YWJsZSk7XG5cbiAgcmV0dXJuIG1ldGEgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogbWV0YS5zdGF0ZSA+PSBEZXN0cm95aW5nU3RhdGUuRGVzdHJveWVkO1xufVxuXG4vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGxldCBlbmFibGVEZXN0cm95YWJsZVRyYWNraW5nOiB1bmRlZmluZWQgfCAoKCkgPT4gdm9pZCk7XG5leHBvcnQgbGV0IGFzc2VydERlc3Ryb3lhYmxlc0Rlc3Ryb3llZDogdW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpO1xuXG5pZiAoREVCVUcpIHtcbiAgbGV0IGlzVGVzdGluZyA9IGZhbHNlO1xuXG4gIGVuYWJsZURlc3Ryb3lhYmxlVHJhY2tpbmcgPSAoKSA9PiB7XG4gICAgaWYgKGlzVGVzdGluZykge1xuICAgICAgLy8gUmVzZXQgZGVzdHJveWFibGUgbWV0YSBqdXN0IGluIGNhc2UsIGJlZm9yZSB0aHJvd2luZyB0aGUgZXJyb3JcbiAgICAgIERFU1RST1lBQkxFX01FVEEgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQXR0ZW1wdGVkIHRvIHN0YXJ0IGRlc3Ryb3lhYmxlIHRlc3RpbmcsIGJ1dCB5b3UgZGlkIG5vdCBlbmQgdGhlIHByZXZpb3VzIGRlc3Ryb3lhYmxlIHRlc3QuIERpZCB5b3UgZm9yZ2V0IHRvIGNhbGwgYGFzc2VydERlc3Ryb3lhYmxlc0Rlc3Ryb3llZCgpYCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaXNUZXN0aW5nID0gdHJ1ZTtcbiAgICBERVNUUk9ZQUJMRV9NRVRBID0gbmV3IE1hcCgpO1xuICB9O1xuXG4gIGFzc2VydERlc3Ryb3lhYmxlc0Rlc3Ryb3llZCA9ICgpID0+IHtcbiAgICBpZiAoIWlzVGVzdGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQXR0ZW1wdGVkIHRvIGFzc2VydCBkZXN0cm95YWJsZXMgZGVzdHJveWVkLCBidXQgeW91IGRpZCBub3Qgc3RhcnQgYSBkZXN0cm95YWJsZSB0ZXN0LiBEaWQgeW91IGZvcmdldCB0byBjYWxsIGBlbmFibGVEZXN0cm95YWJsZVRyYWNraW5nKClgJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpc1Rlc3RpbmcgPSBmYWxzZTtcblxuICAgIGxldCBtYXAgPSBERVNUUk9ZQUJMRV9NRVRBIGFzIE1hcDxEZXN0cm95YWJsZSwgRGVzdHJveWFibGVNZXRhPERlc3Ryb3lhYmxlPj47XG4gICAgREVTVFJPWUFCTEVfTUVUQSA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgICBsZXQgdW5kZXN0cm95ZWQ6IG9iamVjdFtdID0gW107XG5cbiAgICBtYXAuZm9yRWFjaCgobWV0YSkgPT4ge1xuICAgICAgaWYgKG1ldGEuc3RhdGUgIT09IERlc3Ryb3lpbmdTdGF0ZS5EZXN0cm95ZWQpIHtcbiAgICAgICAgdW5kZXN0cm95ZWQucHVzaChtZXRhLnNvdXJjZSEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHVuZGVzdHJveWVkLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBvYmplY3RzVG9TdHJpbmcgPSB1bmRlc3Ryb3llZC5tYXAoZGVidWdUb1N0cmluZyEpLmpvaW4oJ1xcbiAgICAnKTtcbiAgICAgIGxldCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgYFNvbWUgZGVzdHJveWFibGVzIHdlcmUgbm90IGRlc3Ryb3llZCBkdXJpbmcgdGhpcyB0ZXN0OlxcbiAgICAke29iamVjdHNUb1N0cmluZ31gXG4gICAgICApIGFzIFVuZGVzdHJveWVkRGVzdHJveWFibGVzRXJyb3I7XG5cbiAgICAgIGVycm9yLmRlc3Ryb3lhYmxlcyA9IHVuZGVzdHJveWVkO1xuXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9