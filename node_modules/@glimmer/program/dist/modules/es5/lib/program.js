import { RuntimeOpImpl } from './opcode';
import { assert } from '@glimmer/util';
var PAGE_SIZE = 0x100000;
export var RuntimeHeapImpl = /*#__PURE__*/function () {
  function RuntimeHeapImpl(serializedHeap) {
    var buffer = serializedHeap.buffer,
        table = serializedHeap.table;
    this.heap = new Int32Array(buffer);
    this.table = table;
  } // It is illegal to close over this address, as compaction
  // may move it. However, it is legal to use this address
  // multiple times between compactions.


  var _proto = RuntimeHeapImpl.prototype;

  _proto.getaddr = function getaddr(handle) {
    return this.table[handle];
  };

  _proto.getbyaddr = function getbyaddr(address) {
    false && assert(this.heap[address] !== undefined, 'Access memory out of bounds of the heap');
    return this.heap[address];
  };

  _proto.sizeof = function sizeof(handle) {
    return _sizeof(this.table, handle);
  };

  return RuntimeHeapImpl;
}();
export function hydrateHeap(serializedHeap) {
  return new RuntimeHeapImpl(serializedHeap);
}
/**
 * The Heap is responsible for dynamically allocating
 * memory in which we read/write the VM's instructions
 * from/to. When we malloc we pass out a VMHandle, which
 * is used as an indirect way of accessing the memory during
 * execution of the VM. Internally we track the different
 * regions of the memory in an int array known as the table.
 *
 * The table 32-bit aligned and has the following layout:
 *
 * | ... | hp (u32) |       info (u32)   | size (u32) |
 * | ... |  Handle  | Scope Size | State | Size       |
 * | ... | 32bits   | 30bits     | 2bits | 32bit      |
 *
 * With this information we effectively have the ability to
 * control when we want to free memory. That being said you
 * can not free during execution as raw address are only
 * valid during the execution. This means you cannot close
 * over them as you will have a bad memory access exception.
 */

export var HeapImpl = /*#__PURE__*/function () {
  function HeapImpl() {
    this.offset = 0;
    this.handle = 0;
    this.heap = new Int32Array(PAGE_SIZE);
    this.handleTable = [];
    this.handleState = [];
  }

  var _proto2 = HeapImpl.prototype;

  _proto2.push = function push(item) {
    this.sizeCheck();
    this.heap[this.offset++] = item;
  };

  _proto2.sizeCheck = function sizeCheck() {
    var heap = this.heap;

    if (this.offset === this.heap.length) {
      var newHeap = new Int32Array(heap.length + PAGE_SIZE);
      newHeap.set(heap, 0);
      this.heap = newHeap;
    }
  };

  _proto2.getbyaddr = function getbyaddr(address) {
    return this.heap[address];
  };

  _proto2.setbyaddr = function setbyaddr(address, value) {
    this.heap[address] = value;
  };

  _proto2.malloc = function malloc() {
    // push offset, info, size
    this.handleTable.push(this.offset);
    return this.handleTable.length - 1;
  };

  _proto2.finishMalloc = function finishMalloc(handle) {
    // @TODO: At the moment, garbage collection isn't actually used, so this is
    // wrapped to prevent us from allocating extra space in prod. In the future,
    // if we start using the compact API, we should change this.
    if (false
    /* LOCAL_DEBUG */
    ) {
        this.handleState[handle] = 0
        /* Allocated */
        ;
      }
  };

  _proto2.size = function size() {
    return this.offset;
  } // It is illegal to close over this address, as compaction
  // may move it. However, it is legal to use this address
  // multiple times between compactions.
  ;

  _proto2.getaddr = function getaddr(handle) {
    return this.handleTable[handle];
  };

  _proto2.sizeof = function sizeof(handle) {
    return _sizeof(this.handleTable, handle);
  };

  _proto2.free = function free(handle) {
    this.handleState[handle] = 1
    /* Freed */
    ;
  }
  /**
   * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift
   * reachable memory to the bottom of the heap and freeable
   * memory to the top of the heap. When we have shifted all
   * the reachable memory to the top of the heap, we move the
   * offset to the next free position.
   */
  ;

  _proto2.compact = function compact() {
    var compactedSize = 0;
    var handleTable = this.handleTable,
        handleState = this.handleState,
        heap = this.heap;

    for (var i = 0; i < length; i++) {
      var offset = handleTable[i];
      var size = handleTable[i + 1] - offset;
      var state = handleState[i];

      if (state === 2
      /* Purged */
      ) {
          continue;
        } else if (state === 1
      /* Freed */
      ) {
          // transition to "already freed" aka "purged"
          // a good improvement would be to reuse
          // these slots
          handleState[i] = 2
          /* Purged */
          ;
          compactedSize += size;
        } else if (state === 0
      /* Allocated */
      ) {
          for (var j = offset; j <= i + size; j++) {
            heap[j - compactedSize] = heap[j];
          }

          handleTable[i] = offset - compactedSize;
        } else if (state === 3
      /* Pointer */
      ) {
          handleTable[i] = offset - compactedSize;
        }
    }

    this.offset = this.offset - compactedSize;
  };

  _proto2.capture = function capture(offset) {
    if (offset === void 0) {
      offset = this.offset;
    }

    // Only called in eager mode
    var buffer = slice(this.heap, 0, offset).buffer;
    return {
      handle: this.handle,
      table: this.handleTable,
      buffer: buffer
    };
  };

  return HeapImpl;
}();
export var RuntimeProgramImpl = /*#__PURE__*/function () {
  function RuntimeProgramImpl(constants, heap) {
    this.constants = constants;
    this.heap = heap;
    this._opcode = new RuntimeOpImpl(this.heap);
  }

  var _proto3 = RuntimeProgramImpl.prototype;

  _proto3.opcode = function opcode(offset) {
    this._opcode.offset = offset;
    return this._opcode;
  };

  return RuntimeProgramImpl;
}();

function slice(arr, start, end) {
  if (arr.slice !== undefined) {
    return arr.slice(start, end);
  }

  var ret = new Int32Array(end);

  for (; start < end; start++) {
    ret[start] = arr[start];
  }

  return ret;
}

function _sizeof(table, handle) {
  if (false
  /* LOCAL_DEBUG */
  ) {
      return table[handle + 1] - table[handle];
    } else {
    return -1;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3Byb2dyYW0vbGliL3Byb2dyYW0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBVUEsU0FBQSxhQUFBLFFBQUEsVUFBQTtBQUNBLFNBQUEsTUFBQSxRQUFBLGVBQUE7QUFZQSxJQUFNLFNBQVMsR0FBZixRQUFBO0FBRUEsV0FBTSxlQUFOO0FBSUUsMkJBQUEsY0FBQSxFQUEwQztBQUFBLFFBQ3BDLE1BRG9DLEdBQ3hDLGNBRHdDLENBQ3BDLE1BRG9DO0FBQUEsUUFDMUIsS0FEMEIsR0FDeEMsY0FEd0MsQ0FDMUIsS0FEMEI7QUFFeEMsU0FBQSxJQUFBLEdBQVksSUFBQSxVQUFBLENBQVosTUFBWSxDQUFaO0FBQ0EsU0FBQSxLQUFBLEdBQUEsS0FBQTtBQVB3QixHQUE1QixDQVVFO0FBQ0E7QUFDQTs7O0FBWkY7O0FBQUEsU0FhRSxPQWJGLEdBYUUsaUJBQU8sTUFBUCxFQUFzQjtBQUNwQixXQUFPLEtBQUEsS0FBQSxDQUFQLE1BQU8sQ0FBUDtBQUNELEdBZkg7O0FBQUEsU0FpQkUsU0FqQkYsR0FpQkUsbUJBQVMsT0FBVCxFQUF5QjtBQUFBLGFBQ3ZCLE1BQU0sQ0FBQyxLQUFBLElBQUEsQ0FBQSxPQUFBLE1BQUQsU0FBQSxFQURpQix5Q0FDakIsQ0FEaUI7QUFFdkIsV0FBTyxLQUFBLElBQUEsQ0FBUCxPQUFPLENBQVA7QUFDRCxHQXBCSDs7QUFBQSxTQXNCRSxNQXRCRixHQXNCRSxnQkFBTSxNQUFOLEVBQXFCO0FBQ25CLFdBQU8sT0FBTSxDQUFDLEtBQUQsS0FBQSxFQUFiLE1BQWEsQ0FBYjtBQUNELEdBeEJIOztBQUFBO0FBQUE7QUEyQkEsT0FBTSxTQUFBLFdBQUEsQ0FBQSxjQUFBLEVBQW9EO0FBQ3hELFNBQU8sSUFBQSxlQUFBLENBQVAsY0FBTyxDQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBLFdBQU0sUUFBTjtBQVFFLHNCQUFBO0FBUEEsU0FBQSxNQUFBLEdB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QUFBLFNBQUE7QUFDQSxTQUFBLElBQUEsR0FBQSxJQUFBO0FBRVAsU0FBQSxPQUFBLEdBQWUsSUFBQSxhQUFBLENBQWtCLEtBQWpDLElBQWUsQ0FBZjtBQUNEOztBQVZIOztBQUFBLFVBWUUsTUFaRixHQVlFLGdCQUFNLE1BQU4sRUFBcUI7QUFDbkIsU0FBQSxPQUFBLENBQUEsTUFBQSxHQUFBLE1BQUE7QUFDQSxXQUFPLEtBQVAsT0FBQTtBQUNELEdBZkg7O0FBQUE7QUFBQTs7QUFrQkEsU0FBQSxLQUFBLENBQUEsR0FBQSxFQUFBLEtBQUEsRUFBQSxHQUFBLEVBQTBEO0FBQ3hELE1BQUksR0FBRyxDQUFILEtBQUEsS0FBSixTQUFBLEVBQTZCO0FBQzNCLFdBQU8sR0FBRyxDQUFILEtBQUEsQ0FBQSxLQUFBLEVBQVAsR0FBTyxDQUFQO0FBQ0Q7O0FBRUQsTUFBSSxHQUFHLEdBQUcsSUFBQSxVQUFBLENBQVYsR0FBVSxDQUFWOztBQUVBLFNBQU8sS0FBSyxHQUFaLEdBQUEsRUFBb0IsS0FBcEIsRUFBQSxFQUE2QjtBQUMzQixJQUFBLEdBQUcsQ0FBSCxLQUFHLENBQUgsR0FBYSxHQUFHLENBQWhCLEtBQWdCLENBQWhCO0FBQ0Q7O0FBRUQsU0FBQSxHQUFBO0FBQ0Q7O0FBRUQsU0FBQSxPQUFBLENBQUEsS0FBQSxFQUFBLE1BQUEsRUFBK0M7QUFDN0MsTUFBQTtBQUFBO0FBQUEsSUFBaUI7QUFDZixhQUFPLEtBQUssQ0FBQyxNQUFNLEdBQVosQ0FBSyxDQUFMLEdBQW9CLEtBQUssQ0FBaEMsTUFBZ0MsQ0FBaEM7QUFERixLQUFBLE1BRU87QUFDTCxXQUFPLENBQVAsQ0FBQTtBQUNEO0FBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21waWxlVGltZUhlYXAsXG4gIFNlcmlhbGl6ZWRIZWFwLFxuICBSdW50aW1lSGVhcCxcbiAgU3RkTGliT3BlcmFuZCxcbiAgUnVudGltZUNvbnN0YW50cyxcbiAgUnVudGltZVByb2dyYW0sXG4gIFJlc29sdXRpb25UaW1lQ29uc3RhbnRzLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IExPQ0FMX0RFQlVHIH0gZnJvbSAnQGdsaW1tZXIvbG9jYWwtZGVidWctZmxhZ3MnO1xuaW1wb3J0IHsgUnVudGltZU9wSW1wbCB9IGZyb20gJy4vb3Bjb2RlJztcbmltcG9ydCB7IGFzc2VydCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5jb25zdCBlbnVtIFRhYmxlU2xvdFN0YXRlIHtcbiAgQWxsb2NhdGVkLFxuICBGcmVlZCxcbiAgUHVyZ2VkLFxuICBQb2ludGVyLFxufVxuXG5leHBvcnQgdHlwZSBQbGFjZWhvbGRlciA9IFtudW1iZXIsICgpID0+IG51bWJlcl07XG5leHBvcnQgdHlwZSBTdGRsaWJQbGFjZWhvbGRlciA9IFtudW1iZXIsIFN0ZExpYk9wZXJhbmRdO1xuXG5jb25zdCBQQUdFX1NJWkUgPSAweDEwMDAwMDtcblxuZXhwb3J0IGNsYXNzIFJ1bnRpbWVIZWFwSW1wbCBpbXBsZW1lbnRzIFJ1bnRpbWVIZWFwIHtcbiAgcHJpdmF0ZSBoZWFwOiBJbnQzMkFycmF5O1xuICBwcml2YXRlIHRhYmxlOiBudW1iZXJbXTtcblxuICBjb25zdHJ1Y3RvcihzZXJpYWxpemVkSGVhcDogU2VyaWFsaXplZEhlYXApIHtcbiAgICBsZXQgeyBidWZmZXIsIHRhYmxlIH0gPSBzZXJpYWxpemVkSGVhcDtcbiAgICB0aGlzLmhlYXAgPSBuZXcgSW50MzJBcnJheShidWZmZXIpO1xuICAgIHRoaXMudGFibGUgPSB0YWJsZTtcbiAgfVxuXG4gIC8vIEl0IGlzIGlsbGVnYWwgdG8gY2xvc2Ugb3ZlciB0aGlzIGFkZHJlc3MsIGFzIGNvbXBhY3Rpb25cbiAgLy8gbWF5IG1vdmUgaXQuIEhvd2V2ZXIsIGl0IGlzIGxlZ2FsIHRvIHVzZSB0aGlzIGFkZHJlc3NcbiAgLy8gbXVsdGlwbGUgdGltZXMgYmV0d2VlbiBjb21wYWN0aW9ucy5cbiAgZ2V0YWRkcihoYW5kbGU6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMudGFibGVbaGFuZGxlXTtcbiAgfVxuXG4gIGdldGJ5YWRkcihhZGRyZXNzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIGFzc2VydCh0aGlzLmhlYXBbYWRkcmVzc10gIT09IHVuZGVmaW5lZCwgJ0FjY2VzcyBtZW1vcnkgb3V0IG9mIGJvdW5kcyBvZiB0aGUgaGVhcCcpO1xuICAgIHJldHVybiB0aGlzLmhlYXBbYWRkcmVzc107XG4gIH1cblxuICBzaXplb2YoaGFuZGxlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBzaXplb2YodGhpcy50YWJsZSwgaGFuZGxlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZUhlYXAoc2VyaWFsaXplZEhlYXA6IFNlcmlhbGl6ZWRIZWFwKTogUnVudGltZUhlYXAge1xuICByZXR1cm4gbmV3IFJ1bnRpbWVIZWFwSW1wbChzZXJpYWxpemVkSGVhcCk7XG59XG5cbi8qKlxuICogVGhlIEhlYXAgaXMgcmVzcG9uc2libGUgZm9yIGR5bmFtaWNhbGx5IGFsbG9jYXRpbmdcbiAqIG1lbW9yeSBpbiB3aGljaCB3ZSByZWFkL3dyaXRlIHRoZSBWTSdzIGluc3RydWN0aW9uc1xuICogZnJvbS90by4gV2hlbiB3ZSBtYWxsb2Mgd2UgcGFzcyBvdXQgYSBWTUhhbmRsZSwgd2hpY2hcbiAqIGlzIHVzZWQgYXMgYW4gaW5kaXJlY3Qgd2F5IG9mIGFjY2Vzc2luZyB0aGUgbWVtb3J5IGR1cmluZ1xuICogZXhlY3V0aW9uIG9mIHRoZSBWTS4gSW50ZXJuYWxseSB3ZSB0cmFjayB0aGUgZGlmZmVyZW50XG4gKiByZWdpb25zIG9mIHRoZSBtZW1vcnkgaW4gYW4gaW50IGFycmF5IGtub3duIGFzIHRoZSB0YWJsZS5cbiAqXG4gKiBUaGUgdGFibGUgMzItYml0IGFsaWduZWQgYW5kIGhhcyB0aGUgZm9sbG93aW5nIGxheW91dDpcbiAqXG4gKiB8IC4uLiB8IGhwICh1MzIpIHwgICAgICAgaW5mbyAodTMyKSAgIHwgc2l6ZSAodTMyKSB8XG4gKiB8IC4uLiB8ICBIYW5kbGUgIHwgU2NvcGUgU2l6ZSB8IFN0YXRlIHwgU2l6ZSAgICAgICB8XG4gKiB8IC4uLiB8IDMyYml0cyAgIHwgMzBiaXRzICAgICB8IDJiaXRzIHwgMzJiaXQgICAgICB8XG4gKlxuICogV2l0aCB0aGlzIGluZm9ybWF0aW9uIHdlIGVmZmVjdGl2ZWx5IGhhdmUgdGhlIGFiaWxpdHkgdG9cbiAqIGNvbnRyb2wgd2hlbiB3ZSB3YW50IHRvIGZyZWUgbWVtb3J5LiBUaGF0IGJlaW5nIHNhaWQgeW91XG4gKiBjYW4gbm90IGZyZWUgZHVyaW5nIGV4ZWN1dGlvbiBhcyByYXcgYWRkcmVzcyBhcmUgb25seVxuICogdmFsaWQgZHVyaW5nIHRoZSBleGVjdXRpb24uIFRoaXMgbWVhbnMgeW91IGNhbm5vdCBjbG9zZVxuICogb3ZlciB0aGVtIGFzIHlvdSB3aWxsIGhhdmUgYSBiYWQgbWVtb3J5IGFjY2VzcyBleGNlcHRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBIZWFwSW1wbCBpbXBsZW1lbnRzIENvbXBpbGVUaW1lSGVhcCwgUnVudGltZUhlYXAge1xuICBvZmZzZXQgPSAwO1xuXG4gIHByaXZhdGUgaGVhcDogSW50MzJBcnJheTtcbiAgcHJpdmF0ZSBoYW5kbGVUYWJsZTogbnVtYmVyW107XG4gIHByaXZhdGUgaGFuZGxlU3RhdGU6IFRhYmxlU2xvdFN0YXRlW107XG4gIHByaXZhdGUgaGFuZGxlID0gMDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmhlYXAgPSBuZXcgSW50MzJBcnJheShQQUdFX1NJWkUpO1xuICAgIHRoaXMuaGFuZGxlVGFibGUgPSBbXTtcbiAgICB0aGlzLmhhbmRsZVN0YXRlID0gW107XG4gIH1cblxuICBwdXNoKGl0ZW06IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuc2l6ZUNoZWNrKCk7XG4gICAgdGhpcy5oZWFwW3RoaXMub2Zmc2V0KytdID0gaXRlbTtcbiAgfVxuXG4gIHByaXZhdGUgc2l6ZUNoZWNrKCkge1xuICAgIGxldCB7IGhlYXAgfSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5vZmZzZXQgPT09IHRoaXMuaGVhcC5sZW5ndGgpIHtcbiAgICAgIGxldCBuZXdIZWFwID0gbmV3IEludDMyQXJyYXkoaGVhcC5sZW5ndGggKyBQQUdFX1NJWkUpO1xuICAgICAgbmV3SGVhcC5zZXQoaGVhcCwgMCk7XG4gICAgICB0aGlzLmhlYXAgPSBuZXdIZWFwO1xuICAgIH1cbiAgfVxuXG4gIGdldGJ5YWRkcihhZGRyZXNzOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmhlYXBbYWRkcmVzc107XG4gIH1cblxuICBzZXRieWFkZHIoYWRkcmVzczogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKSB7XG4gICAgdGhpcy5oZWFwW2FkZHJlc3NdID0gdmFsdWU7XG4gIH1cblxuICBtYWxsb2MoKTogbnVtYmVyIHtcbiAgICAvLyBwdXNoIG9mZnNldCwgaW5mbywgc2l6ZVxuICAgIHRoaXMuaGFuZGxlVGFibGUucHVzaCh0aGlzLm9mZnNldCk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlVGFibGUubGVuZ3RoIC0gMTtcbiAgfVxuXG4gIGZpbmlzaE1hbGxvYyhoYW5kbGU6IG51bWJlcik6IHZvaWQge1xuICAgIC8vIEBUT0RPOiBBdCB0aGUgbW9tZW50LCBnYXJiYWdlIGNvbGxlY3Rpb24gaXNuJ3QgYWN0dWFsbHkgdXNlZCwgc28gdGhpcyBpc1xuICAgIC8vIHdyYXBwZWQgdG8gcHJldmVudCB1cyBmcm9tIGFsbG9jYXRpbmcgZXh0cmEgc3BhY2UgaW4gcHJvZC4gSW4gdGhlIGZ1dHVyZSxcbiAgICAvLyBpZiB3ZSBzdGFydCB1c2luZyB0aGUgY29tcGFjdCBBUEksIHdlIHNob3VsZCBjaGFuZ2UgdGhpcy5cbiAgICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICAgIHRoaXMuaGFuZGxlU3RhdGVbaGFuZGxlXSA9IFRhYmxlU2xvdFN0YXRlLkFsbG9jYXRlZDtcbiAgICB9XG4gIH1cblxuICBzaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0O1xuICB9XG5cbiAgLy8gSXQgaXMgaWxsZWdhbCB0byBjbG9zZSBvdmVyIHRoaXMgYWRkcmVzcywgYXMgY29tcGFjdGlvblxuICAvLyBtYXkgbW92ZSBpdC4gSG93ZXZlciwgaXQgaXMgbGVnYWwgdG8gdXNlIHRoaXMgYWRkcmVzc1xuICAvLyBtdWx0aXBsZSB0aW1lcyBiZXR3ZWVuIGNvbXBhY3Rpb25zLlxuICBnZXRhZGRyKGhhbmRsZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVUYWJsZVtoYW5kbGVdO1xuICB9XG5cbiAgc2l6ZW9mKGhhbmRsZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gc2l6ZW9mKHRoaXMuaGFuZGxlVGFibGUsIGhhbmRsZSk7XG4gIH1cblxuICBmcmVlKGhhbmRsZTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5oYW5kbGVTdGF0ZVtoYW5kbGVdID0gVGFibGVTbG90U3RhdGUuRnJlZWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGhlYXAgdXNlcyB0aGUgW01hcmstQ29tcGFjdCBBbGdvcml0aG1dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcmstY29tcGFjdF9hbGdvcml0aG0pIHRvIHNoaWZ0XG4gICAqIHJlYWNoYWJsZSBtZW1vcnkgdG8gdGhlIGJvdHRvbSBvZiB0aGUgaGVhcCBhbmQgZnJlZWFibGVcbiAgICogbWVtb3J5IHRvIHRoZSB0b3Agb2YgdGhlIGhlYXAuIFdoZW4gd2UgaGF2ZSBzaGlmdGVkIGFsbFxuICAgKiB0aGUgcmVhY2hhYmxlIG1lbW9yeSB0byB0aGUgdG9wIG9mIHRoZSBoZWFwLCB3ZSBtb3ZlIHRoZVxuICAgKiBvZmZzZXQgdG8gdGhlIG5leHQgZnJlZSBwb3NpdGlvbi5cbiAgICovXG4gIGNvbXBhY3QoKTogdm9pZCB7XG4gICAgbGV0IGNvbXBhY3RlZFNpemUgPSAwO1xuICAgIGxldCB7IGhhbmRsZVRhYmxlLCBoYW5kbGVTdGF0ZSwgaGVhcCB9ID0gdGhpcztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBvZmZzZXQgPSBoYW5kbGVUYWJsZVtpXTtcbiAgICAgIGxldCBzaXplID0gaGFuZGxlVGFibGVbaSArIDFdIC0gb2Zmc2V0O1xuICAgICAgbGV0IHN0YXRlID0gaGFuZGxlU3RhdGVbaV07XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gVGFibGVTbG90U3RhdGUuUHVyZ2VkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gVGFibGVTbG90U3RhdGUuRnJlZWQpIHtcbiAgICAgICAgLy8gdHJhbnNpdGlvbiB0byBcImFscmVhZHkgZnJlZWRcIiBha2EgXCJwdXJnZWRcIlxuICAgICAgICAvLyBhIGdvb2QgaW1wcm92ZW1lbnQgd291bGQgYmUgdG8gcmV1c2VcbiAgICAgICAgLy8gdGhlc2Ugc2xvdHNcbiAgICAgICAgaGFuZGxlU3RhdGVbaV0gPSBUYWJsZVNsb3RTdGF0ZS5QdXJnZWQ7XG4gICAgICAgIGNvbXBhY3RlZFNpemUgKz0gc2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFRhYmxlU2xvdFN0YXRlLkFsbG9jYXRlZCkge1xuICAgICAgICBmb3IgKGxldCBqID0gb2Zmc2V0OyBqIDw9IGkgKyBzaXplOyBqKyspIHtcbiAgICAgICAgICBoZWFwW2ogLSBjb21wYWN0ZWRTaXplXSA9IGhlYXBbal07XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGVUYWJsZVtpXSA9IG9mZnNldCAtIGNvbXBhY3RlZFNpemU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBUYWJsZVNsb3RTdGF0ZS5Qb2ludGVyKSB7XG4gICAgICAgIGhhbmRsZVRhYmxlW2ldID0gb2Zmc2V0IC0gY29tcGFjdGVkU2l6ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9mZnNldCA9IHRoaXMub2Zmc2V0IC0gY29tcGFjdGVkU2l6ZTtcbiAgfVxuXG4gIGNhcHR1cmUob2Zmc2V0ID0gdGhpcy5vZmZzZXQpOiBTZXJpYWxpemVkSGVhcCB7XG4gICAgLy8gT25seSBjYWxsZWQgaW4gZWFnZXIgbW9kZVxuICAgIGxldCBidWZmZXIgPSBzbGljZSh0aGlzLmhlYXAsIDAsIG9mZnNldCkuYnVmZmVyO1xuICAgIHJldHVybiB7XG4gICAgICBoYW5kbGU6IHRoaXMuaGFuZGxlLFxuICAgICAgdGFibGU6IHRoaXMuaGFuZGxlVGFibGUsXG4gICAgICBidWZmZXI6IGJ1ZmZlciBhcyBBcnJheUJ1ZmZlcixcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSdW50aW1lUHJvZ3JhbUltcGwgaW1wbGVtZW50cyBSdW50aW1lUHJvZ3JhbSB7XG4gIFtrZXk6IG51bWJlcl06IG5ldmVyO1xuXG4gIHByaXZhdGUgX29wY29kZTogUnVudGltZU9wSW1wbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgY29uc3RhbnRzOiBSdW50aW1lQ29uc3RhbnRzICYgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG4gICAgcHVibGljIGhlYXA6IFJ1bnRpbWVIZWFwXG4gICkge1xuICAgIHRoaXMuX29wY29kZSA9IG5ldyBSdW50aW1lT3BJbXBsKHRoaXMuaGVhcCk7XG4gIH1cblxuICBvcGNvZGUob2Zmc2V0OiBudW1iZXIpOiBSdW50aW1lT3BJbXBsIHtcbiAgICB0aGlzLl9vcGNvZGUub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzLl9vcGNvZGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2xpY2UoYXJyOiBJbnQzMkFycmF5LCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcik6IEludDMyQXJyYXkge1xuICBpZiAoYXJyLnNsaWNlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICB9XG5cbiAgbGV0IHJldCA9IG5ldyBJbnQzMkFycmF5KGVuZCk7XG5cbiAgZm9yICg7IHN0YXJ0IDwgZW5kOyBzdGFydCsrKSB7XG4gICAgcmV0W3N0YXJ0XSA9IGFycltzdGFydF07XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBzaXplb2YodGFibGU6IG51bWJlcltdLCBoYW5kbGU6IG51bWJlcikge1xuICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICByZXR1cm4gdGFibGVbaGFuZGxlICsgMV0gLSB0YWJsZVtoYW5kbGVdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAtMTtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==