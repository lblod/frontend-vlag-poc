import { RuntimeOpImpl } from './opcode';
import { assert } from '@glimmer/util';
const PAGE_SIZE = 0x100000;
export class RuntimeHeapImpl {
  constructor(serializedHeap) {
    let {
      buffer,
      table
    } = serializedHeap;
    this.heap = new Int32Array(buffer);
    this.table = table;
  } // It is illegal to close over this address, as compaction
  // may move it. However, it is legal to use this address
  // multiple times between compactions.


  getaddr(handle) {
    return this.table[handle];
  }

  getbyaddr(address) {
    (false && assert(this.heap[address] !== undefined, 'Access memory out of bounds of the heap'));
    return this.heap[address];
  }

  sizeof(handle) {
    return sizeof(this.table, handle);
  }

}
export function hydrateHeap(serializedHeap) {
  return new RuntimeHeapImpl(serializedHeap);
}
/**
 * The Heap is responsible for dynamically allocating
 * memory in which we read/write the VM's instructions
 * from/to. When we malloc we pass out a VMHandle, which
 * is used as an indirect way of accessing the memory during
 * execution of the VM. Internally we track the different
 * regions of the memory in an int array known as the table.
 *
 * The table 32-bit aligned and has the following layout:
 *
 * | ... | hp (u32) |       info (u32)   | size (u32) |
 * | ... |  Handle  | Scope Size | State | Size       |
 * | ... | 32bits   | 30bits     | 2bits | 32bit      |
 *
 * With this information we effectively have the ability to
 * control when we want to free memory. That being said you
 * can not free during execution as raw address are only
 * valid during the execution. This means you cannot close
 * over them as you will have a bad memory access exception.
 */

export class HeapImpl {
  constructor() {
    this.offset = 0;
    this.handle = 0;
    this.heap = new Int32Array(PAGE_SIZE);
    this.handleTable = [];
    this.handleState = [];
  }

  push(item) {
    this.sizeCheck();
    this.heap[this.offset++] = item;
  }

  sizeCheck() {
    let {
      heap
    } = this;

    if (this.offset === this.heap.length) {
      let newHeap = new Int32Array(heap.length + PAGE_SIZE);
      newHeap.set(heap, 0);
      this.heap = newHeap;
    }
  }

  getbyaddr(address) {
    return this.heap[address];
  }

  setbyaddr(address, value) {
    this.heap[address] = value;
  }

  malloc() {
    // push offset, info, size
    this.handleTable.push(this.offset);
    return this.handleTable.length - 1;
  }

  finishMalloc(handle) {
    // @TODO: At the moment, garbage collection isn't actually used, so this is
    // wrapped to prevent us from allocating extra space in prod. In the future,
    // if we start using the compact API, we should change this.
    if (false
    /* LOCAL_DEBUG */
    ) {
      this.handleState[handle] = 0
      /* Allocated */
      ;
    }
  }

  size() {
    return this.offset;
  } // It is illegal to close over this address, as compaction
  // may move it. However, it is legal to use this address
  // multiple times between compactions.


  getaddr(handle) {
    return this.handleTable[handle];
  }

  sizeof(handle) {
    return sizeof(this.handleTable, handle);
  }

  free(handle) {
    this.handleState[handle] = 1
    /* Freed */
    ;
  }
  /**
   * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift
   * reachable memory to the bottom of the heap and freeable
   * memory to the top of the heap. When we have shifted all
   * the reachable memory to the top of the heap, we move the
   * offset to the next free position.
   */


  compact() {
    let compactedSize = 0;
    let {
      handleTable,
      handleState,
      heap
    } = this;

    for (let i = 0; i < length; i++) {
      let offset = handleTable[i];
      let size = handleTable[i + 1] - offset;
      let state = handleState[i];

      if (state === 2
      /* Purged */
      ) {
          continue;
        } else if (state === 1
      /* Freed */
      ) {
          // transition to "already freed" aka "purged"
          // a good improvement would be to reuse
          // these slots
          handleState[i] = 2
          /* Purged */
          ;
          compactedSize += size;
        } else if (state === 0
      /* Allocated */
      ) {
          for (let j = offset; j <= i + size; j++) {
            heap[j - compactedSize] = heap[j];
          }

          handleTable[i] = offset - compactedSize;
        } else if (state === 3
      /* Pointer */
      ) {
          handleTable[i] = offset - compactedSize;
        }
    }

    this.offset = this.offset - compactedSize;
  }

  capture(offset = this.offset) {
    // Only called in eager mode
    let buffer = slice(this.heap, 0, offset).buffer;
    return {
      handle: this.handle,
      table: this.handleTable,
      buffer: buffer
    };
  }

}
export class RuntimeProgramImpl {
  constructor(constants, heap) {
    this.constants = constants;
    this.heap = heap;
    this._opcode = new RuntimeOpImpl(this.heap);
  }

  opcode(offset) {
    this._opcode.offset = offset;
    return this._opcode;
  }

}

function slice(arr, start, end) {
  if (arr.slice !== undefined) {
    return arr.slice(start, end);
  }

  let ret = new Int32Array(end);

  for (; start < end; start++) {
    ret[start] = arr[start];
  }

  return ret;
}

function sizeof(table, handle) {
  if (false
  /* LOCAL_DEBUG */
  ) {
    return table[handle + 1] - table[handle];
  } else {
    return -1;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3Byb2dyYW0vbGliL3Byb2dyYW0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBVUEsU0FBUyxhQUFULFFBQThCLFVBQTlCO0FBQ0EsU0FBUyxNQUFULFFBQXVCLGVBQXZCO0FBWUEsTUFBTSxTQUFTLEdBQUcsUUFBbEI7QUFFQSxPQUFNLE1BQU8sZUFBUCxDQUFzQjtBQUkxQixFQUFBLFdBQUEsQ0FBWSxjQUFaLEVBQTBDO0FBQ3hDLFFBQUk7QUFBRSxNQUFBLE1BQUY7QUFBVSxNQUFBO0FBQVYsUUFBb0IsY0FBeEI7QUFDQSxTQUFLLElBQUwsR0FBWSxJQUFJLFVBQUosQ0FBZSxNQUFmLENBQVo7QUFDQSxTQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0QsR0FSeUIsQ0FVMUI7QUFDQTtBQUNBOzs7QUFDQSxFQUFBLE9BQU8sQ0FBQyxNQUFELEVBQWU7QUFDcEIsV0FBTyxLQUFLLEtBQUwsQ0FBVyxNQUFYLENBQVA7QUFDRDs7QUFFRCxFQUFBLFNBQVMsQ0FBQyxPQUFELEVBQWdCO0FBQUEsY0FDdkIsTUFBTSxDQUFDLEtBQUssSUFBTCxDQUFVLE9BQVYsTUFBdUIsU0FBeEIsRUFBbUMseUNBQW5DLENBRGlCO0FBRXZCLFdBQU8sS0FBSyxJQUFMLENBQVUsT0FBVixDQUFQO0FBQ0Q7O0FBRUQsRUFBQSxNQUFNLENBQUMsTUFBRCxFQUFlO0FBQ25CLFdBQU8sTUFBTSxDQUFDLEtBQUssS0FBTixFQUFhLE1BQWIsQ0FBYjtBQUNEOztBQXhCeUI7QUEyQjVCLE9BQU0sU0FBVSxXQUFWLENBQXNCLGNBQXRCLEVBQW9EO0FBQ3hELFNBQU8sSUFBSSxlQUFKLENBQW9CLGNBQXBCLENBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkEsT0FBTSxNQUFPLFFBQVAsQ0FBZTtBQVFuQixFQUFBLFdBQUEsR0FBQTtBQVBBLFNBQUEsTUFBQSxHQUFTLENBQVQ7QUFLUSxTQUFBLE1BQUEsR0FBUyxD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RCxNQUFJLEdBQUcsQ0FBQyxLQUFKLEtBQWMsU0FBbEIsRUFBNkI7QUFDM0IsV0FBTyxHQUFHLENBQUMsS0FBSixDQUFVLEtBQVYsRUFBaUIsR0FBakIsQ0FBUDtBQUNEOztBQUVELE1BQUksR0FBRyxHQUFHLElBQUksVUFBSixDQUFlLEdBQWYsQ0FBVjs7QUFFQSxTQUFPLEtBQUssR0FBRyxHQUFmLEVBQW9CLEtBQUssRUFBekIsRUFBNkI7QUFDM0IsSUFBQSxHQUFHLENBQUMsS0FBRCxDQUFILEdBQWEsR0FBRyxDQUFDLEtBQUQsQ0FBaEI7QUFDRDs7QUFFRCxTQUFPLEdBQVA7QUFDRDs7QUFFRCxTQUFTLE1BQVQsQ0FBZ0IsS0FBaEIsRUFBaUMsTUFBakMsRUFBK0M7QUFDN0M7QUFBQTtBQUFBLElBQWlCO0FBQ2YsV0FBTyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQVYsQ0FBTCxHQUFvQixLQUFLLENBQUMsTUFBRCxDQUFoQztBQUNELEdBRkQsTUFFTztBQUNMLFdBQU8sQ0FBQyxDQUFSO0FBQ0Q7QUFDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBpbGVUaW1lSGVhcCxcbiAgU2VyaWFsaXplZEhlYXAsXG4gIFJ1bnRpbWVIZWFwLFxuICBTdGRMaWJPcGVyYW5kLFxuICBSdW50aW1lQ29uc3RhbnRzLFxuICBSdW50aW1lUHJvZ3JhbSxcbiAgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTE9DQUxfREVCVUcgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBSdW50aW1lT3BJbXBsIH0gZnJvbSAnLi9vcGNvZGUnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmNvbnN0IGVudW0gVGFibGVTbG90U3RhdGUge1xuICBBbGxvY2F0ZWQsXG4gIEZyZWVkLFxuICBQdXJnZWQsXG4gIFBvaW50ZXIsXG59XG5cbmV4cG9ydCB0eXBlIFBsYWNlaG9sZGVyID0gW251bWJlciwgKCkgPT4gbnVtYmVyXTtcbmV4cG9ydCB0eXBlIFN0ZGxpYlBsYWNlaG9sZGVyID0gW251bWJlciwgU3RkTGliT3BlcmFuZF07XG5cbmNvbnN0IFBBR0VfU0laRSA9IDB4MTAwMDAwO1xuXG5leHBvcnQgY2xhc3MgUnVudGltZUhlYXBJbXBsIGltcGxlbWVudHMgUnVudGltZUhlYXAge1xuICBwcml2YXRlIGhlYXA6IEludDMyQXJyYXk7XG4gIHByaXZhdGUgdGFibGU6IG51bWJlcltdO1xuXG4gIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZWRIZWFwOiBTZXJpYWxpemVkSGVhcCkge1xuICAgIGxldCB7IGJ1ZmZlciwgdGFibGUgfSA9IHNlcmlhbGl6ZWRIZWFwO1xuICAgIHRoaXMuaGVhcCA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgdGhpcy50YWJsZSA9IHRhYmxlO1xuICB9XG5cbiAgLy8gSXQgaXMgaWxsZWdhbCB0byBjbG9zZSBvdmVyIHRoaXMgYWRkcmVzcywgYXMgY29tcGFjdGlvblxuICAvLyBtYXkgbW92ZSBpdC4gSG93ZXZlciwgaXQgaXMgbGVnYWwgdG8gdXNlIHRoaXMgYWRkcmVzc1xuICAvLyBtdWx0aXBsZSB0aW1lcyBiZXR3ZWVuIGNvbXBhY3Rpb25zLlxuICBnZXRhZGRyKGhhbmRsZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZVtoYW5kbGVdO1xuICB9XG5cbiAgZ2V0YnlhZGRyKGFkZHJlc3M6IG51bWJlcik6IG51bWJlciB7XG4gICAgYXNzZXJ0KHRoaXMuaGVhcFthZGRyZXNzXSAhPT0gdW5kZWZpbmVkLCAnQWNjZXNzIG1lbW9yeSBvdXQgb2YgYm91bmRzIG9mIHRoZSBoZWFwJyk7XG4gICAgcmV0dXJuIHRoaXMuaGVhcFthZGRyZXNzXTtcbiAgfVxuXG4gIHNpemVvZihoYW5kbGU6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHNpemVvZih0aGlzLnRhYmxlLCBoYW5kbGUpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlSGVhcChzZXJpYWxpemVkSGVhcDogU2VyaWFsaXplZEhlYXApOiBSdW50aW1lSGVhcCB7XG4gIHJldHVybiBuZXcgUnVudGltZUhlYXBJbXBsKHNlcmlhbGl6ZWRIZWFwKTtcbn1cblxuLyoqXG4gKiBUaGUgSGVhcCBpcyByZXNwb25zaWJsZSBmb3IgZHluYW1pY2FsbHkgYWxsb2NhdGluZ1xuICogbWVtb3J5IGluIHdoaWNoIHdlIHJlYWQvd3JpdGUgdGhlIFZNJ3MgaW5zdHJ1Y3Rpb25zXG4gKiBmcm9tL3RvLiBXaGVuIHdlIG1hbGxvYyB3ZSBwYXNzIG91dCBhIFZNSGFuZGxlLCB3aGljaFxuICogaXMgdXNlZCBhcyBhbiBpbmRpcmVjdCB3YXkgb2YgYWNjZXNzaW5nIHRoZSBtZW1vcnkgZHVyaW5nXG4gKiBleGVjdXRpb24gb2YgdGhlIFZNLiBJbnRlcm5hbGx5IHdlIHRyYWNrIHRoZSBkaWZmZXJlbnRcbiAqIHJlZ2lvbnMgb2YgdGhlIG1lbW9yeSBpbiBhbiBpbnQgYXJyYXkga25vd24gYXMgdGhlIHRhYmxlLlxuICpcbiAqIFRoZSB0YWJsZSAzMi1iaXQgYWxpZ25lZCBhbmQgaGFzIHRoZSBmb2xsb3dpbmcgbGF5b3V0OlxuICpcbiAqIHwgLi4uIHwgaHAgKHUzMikgfCAgICAgICBpbmZvICh1MzIpICAgfCBzaXplICh1MzIpIHxcbiAqIHwgLi4uIHwgIEhhbmRsZSAgfCBTY29wZSBTaXplIHwgU3RhdGUgfCBTaXplICAgICAgIHxcbiAqIHwgLi4uIHwgMzJiaXRzICAgfCAzMGJpdHMgICAgIHwgMmJpdHMgfCAzMmJpdCAgICAgIHxcbiAqXG4gKiBXaXRoIHRoaXMgaW5mb3JtYXRpb24gd2UgZWZmZWN0aXZlbHkgaGF2ZSB0aGUgYWJpbGl0eSB0b1xuICogY29udHJvbCB3aGVuIHdlIHdhbnQgdG8gZnJlZSBtZW1vcnkuIFRoYXQgYmVpbmcgc2FpZCB5b3VcbiAqIGNhbiBub3QgZnJlZSBkdXJpbmcgZXhlY3V0aW9uIGFzIHJhdyBhZGRyZXNzIGFyZSBvbmx5XG4gKiB2YWxpZCBkdXJpbmcgdGhlIGV4ZWN1dGlvbi4gVGhpcyBtZWFucyB5b3UgY2Fubm90IGNsb3NlXG4gKiBvdmVyIHRoZW0gYXMgeW91IHdpbGwgaGF2ZSBhIGJhZCBtZW1vcnkgYWNjZXNzIGV4Y2VwdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEhlYXBJbXBsIGltcGxlbWVudHMgQ29tcGlsZVRpbWVIZWFwLCBSdW50aW1lSGVhcCB7XG4gIG9mZnNldCA9IDA7XG5cbiAgcHJpdmF0ZSBoZWFwOiBJbnQzMkFycmF5O1xuICBwcml2YXRlIGhhbmRsZVRhYmxlOiBudW1iZXJbXTtcbiAgcHJpdmF0ZSBoYW5kbGVTdGF0ZTogVGFibGVTbG90U3RhdGVbXTtcbiAgcHJpdmF0ZSBoYW5kbGUgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGVhcCA9IG5ldyBJbnQzMkFycmF5KFBBR0VfU0laRSk7XG4gICAgdGhpcy5oYW5kbGVUYWJsZSA9IFtdO1xuICAgIHRoaXMuaGFuZGxlU3RhdGUgPSBbXTtcbiAgfVxuXG4gIHB1c2goaXRlbTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zaXplQ2hlY2soKTtcbiAgICB0aGlzLmhlYXBbdGhpcy5vZmZzZXQrK10gPSBpdGVtO1xuICB9XG5cbiAgcHJpdmF0ZSBzaXplQ2hlY2soKSB7XG4gICAgbGV0IHsgaGVhcCB9ID0gdGhpcztcblxuICAgIGlmICh0aGlzLm9mZnNldCA9PT0gdGhpcy5oZWFwLmxlbmd0aCkge1xuICAgICAgbGV0IG5ld0hlYXAgPSBuZXcgSW50MzJBcnJheShoZWFwLmxlbmd0aCArIFBBR0VfU0laRSk7XG4gICAgICBuZXdIZWFwLnNldChoZWFwLCAwKTtcbiAgICAgIHRoaXMuaGVhcCA9IG5ld0hlYXA7XG4gICAgfVxuICB9XG5cbiAgZ2V0YnlhZGRyKGFkZHJlc3M6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuaGVhcFthZGRyZXNzXTtcbiAgfVxuXG4gIHNldGJ5YWRkcihhZGRyZXNzOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmhlYXBbYWRkcmVzc10gPSB2YWx1ZTtcbiAgfVxuXG4gIG1hbGxvYygpOiBudW1iZXIge1xuICAgIC8vIHB1c2ggb2Zmc2V0LCBpbmZvLCBzaXplXG4gICAgdGhpcy5oYW5kbGVUYWJsZS5wdXNoKHRoaXMub2Zmc2V0KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVUYWJsZS5sZW5ndGggLSAxO1xuICB9XG5cbiAgZmluaXNoTWFsbG9jKGhhbmRsZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gQFRPRE86IEF0IHRoZSBtb21lbnQsIGdhcmJhZ2UgY29sbGVjdGlvbiBpc24ndCBhY3R1YWxseSB1c2VkLCBzbyB0aGlzIGlzXG4gICAgLy8gd3JhcHBlZCB0byBwcmV2ZW50IHVzIGZyb20gYWxsb2NhdGluZyBleHRyYSBzcGFjZSBpbiBwcm9kLiBJbiB0aGUgZnV0dXJlLFxuICAgIC8vIGlmIHdlIHN0YXJ0IHVzaW5nIHRoZSBjb21wYWN0IEFQSSwgd2Ugc2hvdWxkIGNoYW5nZSB0aGlzLlxuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgdGhpcy5oYW5kbGVTdGF0ZVtoYW5kbGVdID0gVGFibGVTbG90U3RhdGUuQWxsb2NhdGVkO1xuICAgIH1cbiAgfVxuXG4gIHNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XG4gIH1cblxuICAvLyBJdCBpcyBpbGxlZ2FsIHRvIGNsb3NlIG92ZXIgdGhpcyBhZGRyZXNzLCBhcyBjb21wYWN0aW9uXG4gIC8vIG1heSBtb3ZlIGl0LiBIb3dldmVyLCBpdCBpcyBsZWdhbCB0byB1c2UgdGhpcyBhZGRyZXNzXG4gIC8vIG11bHRpcGxlIHRpbWVzIGJldHdlZW4gY29tcGFjdGlvbnMuXG4gIGdldGFkZHIoaGFuZGxlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVRhYmxlW2hhbmRsZV07XG4gIH1cblxuICBzaXplb2YoaGFuZGxlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBzaXplb2YodGhpcy5oYW5kbGVUYWJsZSwgaGFuZGxlKTtcbiAgfVxuXG4gIGZyZWUoaGFuZGxlOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZVN0YXRlW2hhbmRsZV0gPSBUYWJsZVNsb3RTdGF0ZS5GcmVlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaGVhcCB1c2VzIHRoZSBbTWFyay1Db21wYWN0IEFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFyay1jb21wYWN0X2FsZ29yaXRobSkgdG8gc2hpZnRcbiAgICogcmVhY2hhYmxlIG1lbW9yeSB0byB0aGUgYm90dG9tIG9mIHRoZSBoZWFwIGFuZCBmcmVlYWJsZVxuICAgKiBtZW1vcnkgdG8gdGhlIHRvcCBvZiB0aGUgaGVhcC4gV2hlbiB3ZSBoYXZlIHNoaWZ0ZWQgYWxsXG4gICAqIHRoZSByZWFjaGFibGUgbWVtb3J5IHRvIHRoZSB0b3Agb2YgdGhlIGhlYXAsIHdlIG1vdmUgdGhlXG4gICAqIG9mZnNldCB0byB0aGUgbmV4dCBmcmVlIHBvc2l0aW9uLlxuICAgKi9cbiAgY29tcGFjdCgpOiB2b2lkIHtcbiAgICBsZXQgY29tcGFjdGVkU2l6ZSA9IDA7XG4gICAgbGV0IHsgaGFuZGxlVGFibGUsIGhhbmRsZVN0YXRlLCBoZWFwIH0gPSB0aGlzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG9mZnNldCA9IGhhbmRsZVRhYmxlW2ldO1xuICAgICAgbGV0IHNpemUgPSBoYW5kbGVUYWJsZVtpICsgMV0gLSBvZmZzZXQ7XG4gICAgICBsZXQgc3RhdGUgPSBoYW5kbGVTdGF0ZVtpXTtcblxuICAgICAgaWYgKHN0YXRlID09PSBUYWJsZVNsb3RTdGF0ZS5QdXJnZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBUYWJsZVNsb3RTdGF0ZS5GcmVlZCkge1xuICAgICAgICAvLyB0cmFuc2l0aW9uIHRvIFwiYWxyZWFkeSBmcmVlZFwiIGFrYSBcInB1cmdlZFwiXG4gICAgICAgIC8vIGEgZ29vZCBpbXByb3ZlbWVudCB3b3VsZCBiZSB0byByZXVzZVxuICAgICAgICAvLyB0aGVzZSBzbG90c1xuICAgICAgICBoYW5kbGVTdGF0ZVtpXSA9IFRhYmxlU2xvdFN0YXRlLlB1cmdlZDtcbiAgICAgICAgY29tcGFjdGVkU2l6ZSArPSBzaXplO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gVGFibGVTbG90U3RhdGUuQWxsb2NhdGVkKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBvZmZzZXQ7IGogPD0gaSArIHNpemU7IGorKykge1xuICAgICAgICAgIGhlYXBbaiAtIGNvbXBhY3RlZFNpemVdID0gaGVhcFtqXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZVRhYmxlW2ldID0gb2Zmc2V0IC0gY29tcGFjdGVkU2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFRhYmxlU2xvdFN0YXRlLlBvaW50ZXIpIHtcbiAgICAgICAgaGFuZGxlVGFibGVbaV0gPSBvZmZzZXQgLSBjb21wYWN0ZWRTaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5vZmZzZXQgLSBjb21wYWN0ZWRTaXplO1xuICB9XG5cbiAgY2FwdHVyZShvZmZzZXQgPSB0aGlzLm9mZnNldCk6IFNlcmlhbGl6ZWRIZWFwIHtcbiAgICAvLyBPbmx5IGNhbGxlZCBpbiBlYWdlciBtb2RlXG4gICAgbGV0IGJ1ZmZlciA9IHNsaWNlKHRoaXMuaGVhcCwgMCwgb2Zmc2V0KS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZTogdGhpcy5oYW5kbGUsXG4gICAgICB0YWJsZTogdGhpcy5oYW5kbGVUYWJsZSxcbiAgICAgIGJ1ZmZlcjogYnVmZmVyIGFzIEFycmF5QnVmZmVyLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJ1bnRpbWVQcm9ncmFtSW1wbCBpbXBsZW1lbnRzIFJ1bnRpbWVQcm9ncmFtIHtcbiAgW2tleTogbnVtYmVyXTogbmV2ZXI7XG5cbiAgcHJpdmF0ZSBfb3Bjb2RlOiBSdW50aW1lT3BJbXBsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjb25zdGFudHM6IFJ1bnRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgICBwdWJsaWMgaGVhcDogUnVudGltZUhlYXBcbiAgKSB7XG4gICAgdGhpcy5fb3Bjb2RlID0gbmV3IFJ1bnRpbWVPcEltcGwodGhpcy5oZWFwKTtcbiAgfVxuXG4gIG9wY29kZShvZmZzZXQ6IG51bWJlcik6IFJ1bnRpbWVPcEltcGwge1xuICAgIHRoaXMuX29wY29kZS5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHRoaXMuX29wY29kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzbGljZShhcnI6IEludDMyQXJyYXksIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogSW50MzJBcnJheSB7XG4gIGlmIChhcnIuc2xpY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIH1cblxuICBsZXQgcmV0ID0gbmV3IEludDMyQXJyYXkoZW5kKTtcblxuICBmb3IgKDsgc3RhcnQgPCBlbmQ7IHN0YXJ0KyspIHtcbiAgICByZXRbc3RhcnRdID0gYXJyW3N0YXJ0XTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNpemVvZih0YWJsZTogbnVtYmVyW10sIGhhbmRsZTogbnVtYmVyKSB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIHJldHVybiB0YWJsZVtoYW5kbGUgKyAxXSAtIHRhYmxlW2hhbmRsZV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9