"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hydrateHeap = hydrateHeap;
exports.RuntimeProgramImpl = exports.HeapImpl = exports.RuntimeHeapImpl = void 0;

var _opcode = require("./opcode");

var _util = require("@glimmer/util");

var PAGE_SIZE = 0x100000;

var RuntimeHeapImpl = /*#__PURE__*/function () {
  function RuntimeHeapImpl(serializedHeap) {
    var buffer = serializedHeap.buffer,
        table = serializedHeap.table;
    this.heap = new Int32Array(buffer);
    this.table = table;
  } // It is illegal to close over this address, as compaction
  // may move it. However, it is legal to use this address
  // multiple times between compactions.


  var _proto = RuntimeHeapImpl.prototype;

  _proto.getaddr = function getaddr(handle) {
    return this.table[handle];
  };

  _proto.getbyaddr = function getbyaddr(address) {
    false && (0, _util.assert)(this.heap[address] !== undefined, 'Access memory out of bounds of the heap');
    return this.heap[address];
  };

  _proto.sizeof = function sizeof(handle) {
    return _sizeof(this.table, handle);
  };

  return RuntimeHeapImpl;
}();

exports.RuntimeHeapImpl = RuntimeHeapImpl;

function hydrateHeap(serializedHeap) {
  return new RuntimeHeapImpl(serializedHeap);
}
/**
 * The Heap is responsible for dynamically allocating
 * memory in which we read/write the VM's instructions
 * from/to. When we malloc we pass out a VMHandle, which
 * is used as an indirect way of accessing the memory during
 * execution of the VM. Internally we track the different
 * regions of the memory in an int array known as the table.
 *
 * The table 32-bit aligned and has the following layout:
 *
 * | ... | hp (u32) |       info (u32)   | size (u32) |
 * | ... |  Handle  | Scope Size | State | Size       |
 * | ... | 32bits   | 30bits     | 2bits | 32bit      |
 *
 * With this information we effectively have the ability to
 * control when we want to free memory. That being said you
 * can not free during execution as raw address are only
 * valid during the execution. This means you cannot close
 * over them as you will have a bad memory access exception.
 */


var HeapImpl = /*#__PURE__*/function () {
  function HeapImpl() {
    this.offset = 0;
    this.handle = 0;
    this.heap = new Int32Array(PAGE_SIZE);
    this.handleTable = [];
    this.handleState = [];
  }

  var _proto2 = HeapImpl.prototype;

  _proto2.push = function push(item) {
    this.sizeCheck();
    this.heap[this.offset++] = item;
  };

  _proto2.sizeCheck = function sizeCheck() {
    var heap = this.heap;

    if (this.offset === this.heap.length) {
      var newHeap = new Int32Array(heap.length + PAGE_SIZE);
      newHeap.set(heap, 0);
      this.heap = newHeap;
    }
  };

  _proto2.getbyaddr = function getbyaddr(address) {
    return this.heap[address];
  };

  _proto2.setbyaddr = function setbyaddr(address, value) {
    this.heap[address] = value;
  };

  _proto2.malloc = function malloc() {
    // push offset, info, size
    this.handleTable.push(this.offset);
    return this.handleTable.length - 1;
  };

  _proto2.finishMalloc = function finishMalloc(handle) {
    // @TODO: At the moment, garbage collection isn't actually used, so this is
    // wrapped to prevent us from allocating extra space in prod. In the future,
    // if we start using the compact API, we should change this.
    if (false
    /* LOCAL_DEBUG */
    ) {
        this.handleState[handle] = 0
        /* Allocated */
        ;
      }
  };

  _proto2.size = function size() {
    return this.offset;
  } // It is illegal to close over this address, as compaction
  // may move it. However, it is legal to use this address
  // multiple times between compactions.
  ;

  _proto2.getaddr = function getaddr(handle) {
    return this.handleTable[handle];
  };

  _proto2.sizeof = function sizeof(handle) {
    return _sizeof(this.handleTable, handle);
  };

  _proto2.free = function free(handle) {
    this.handleState[handle] = 1
    /* Freed */
    ;
  }
  /**
   * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift
   * reachable memory to the bottom of the heap and freeable
   * memory to the top of the heap. When we have shifted all
   * the reachable memory to the top of the heap, we move the
   * offset to the next free position.
   */
  ;

  _proto2.compact = function compact() {
    var compactedSize = 0;
    var handleTable = this.handleTable,
        handleState = this.handleState,
        heap = this.heap;

    for (var i = 0; i < length; i++) {
      var offset = handleTable[i];
      var size = handleTable[i + 1] - offset;
      var state = handleState[i];

      if (state === 2
      /* Purged */
      ) {
          continue;
        } else if (state === 1
      /* Freed */
      ) {
          // transition to "already freed" aka "purged"
          // a good improvement would be to reuse
          // these slots
          handleState[i] = 2
          /* Purged */
          ;
          compactedSize += size;
        } else if (state === 0
      /* Allocated */
      ) {
          for (var j = offset; j <= i + size; j++) {
            heap[j - compactedSize] = heap[j];
          }

          handleTable[i] = offset - compactedSize;
        } else if (state === 3
      /* Pointer */
      ) {
          handleTable[i] = offset - compactedSize;
        }
    }

    this.offset = this.offset - compactedSize;
  };

  _proto2.capture = function capture(offset) {
    if (offset === void 0) {
      offset = this.offset;
    } // Only called in eager mode


    var buffer = slice(this.heap, 0, offset).buffer;
    return {
      handle: this.handle,
      table: this.handleTable,
      buffer: buffer
    };
  };

  return HeapImpl;
}();

exports.HeapImpl = HeapImpl;

var RuntimeProgramImpl = /*#__PURE__*/function () {
  function RuntimeProgramImpl(constants, heap) {
    this.constants = constants;
    this.heap = heap;
    this._opcode = new _opcode.RuntimeOpImpl(this.heap);
  }

  var _proto3 = RuntimeProgramImpl.prototype;

  _proto3.opcode = function opcode(offset) {
    this._opcode.offset = offset;
    return this._opcode;
  };

  return RuntimeProgramImpl;
}();

exports.RuntimeProgramImpl = RuntimeProgramImpl;

function slice(arr, start, end) {
  if (arr.slice !== undefined) {
    return arr.slice(start, end);
  }

  var ret = new Int32Array(end);

  for (; start < end; start++) {
    ret[start] = arr[start];
  }

  return ret;
}

function _sizeof(table, handle) {
  if (false
  /* LOCAL_DEBUG */
  ) {
      return table[handle + 1] - table[handle];
    } else {
    return -1;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3Byb2dyYW0vbGliL3Byb2dyYW0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFVQTs7QUFDQTs7QUFZQSxJQUFNLFNBQVMsR0FBZixRQUFBOztBQUVBLElBQU0sZUFBTixHQUFBLGFBQUEsWUFBQTtBQUlFLFdBQUEsZUFBQSxDQUFBLGNBQUEsRUFBMEM7QUFBQSxRQUNwQyxNQURvQyxHQUN4QyxjQUR3QyxDQUFBLE1BQUE7QUFBQSxRQUMxQixLQUQwQixHQUN4QyxjQUR3QyxDQUFBLEtBQUE7QUFFeEMsU0FBQSxJQUFBLEdBQVksSUFBQSxVQUFBLENBQVosTUFBWSxDQUFaO0FBQ0EsU0FBQSxLQUFBLEdBQUEsS0FBQTtBQVBKLEdBQUEsQ0FVRTtBQUNBO0FBQ0E7OztBQVpGLE1BQUEsTUFBQSxHQUFBLGVBQUEsQ0FBQSxTQUFBOztBQUFBLEVBQUEsTUFBQSxDQUFBLE9BQUEsR0FhRSxTQUFBLE9BQUEsQ0FBQSxNQUFBLEVBQXNCO0FBQ3BCLFdBQU8sS0FBQSxLQUFBLENBQVAsTUFBTyxDQUFQO0FBZEosR0FBQTs7QUFBQSxFQUFBLE1BQUEsQ0FBQSxTQUFBLEdBaUJFLFNBQUEsU0FBQSxDQUFBLE9BQUEsRUFBeUI7QUFBQSxhQUN2QixrQkFBTyxLQUFBLElBQUEsQ0FBQSxPQUFBLE1BQUQsU0FBTixFQUR1Qix5Q0FDdkIsQ0FEdUI7QUFFdkIsV0FBTyxLQUFBLElBQUEsQ0FBUCxPQUFPLENBQVA7QUFuQkosR0FBQTs7QUFBQSxFQUFBLE1BQUEsQ0FBQSxNQUFBLEdBc0JFLFNBQUEsTUFBQSxDQUFBLE1BQUEsRUFBcUI7QUFDbkIsV0FBTyxPQUFNLENBQUMsS0FBRCxLQUFBLEVBQWIsTUFBYSxDQUFiO0FBdkJKLEdBQUE7O0FBQUEsU0FBQSxlQUFBO0FBQUEsQ0FBQSxFQUFBOzs7O0FBMkJNLFNBQUEsV0FBQSxDQUFBLGNBQUEsRUFBb0Q7QUFDeEQsU0FBTyxJQUFBLGVBQUEsQ0FBUCxjQUFPLENBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBLElBQU0sUUFBTixHQUFBLGFBQUEsWUFBQTtBQVFFLFdBQUEsUUFBQSxHQUFBO0FBUEEsU0FBQSxNQUFBLEdBQUEsQ0FBQTtBQUtRLFNBQUEsTUFBQSxHQUFBLENBQUE7QUFHTixTQUFBLElBQUEsR0FBWSxJQUFBLFVBQUEsQ0FBWixTQUFZLENBQVo7QUFDQSxTQUFBLFdBQUEsR0FBQSxFQUFBO0FBQ0EsU0FBQSxXQUFBLEdBQUEsRUFBQTtBQUNEOztBQVpILE1BQUEsT0FBQSxHQUFBLFFBQUEsQ0FBQSxTQUFBOztBQUFBLEVBQUEsT0FBQSxDQUFBLElBQUEsR0FjRSxTQUFBLElBQUEsQ0FBQSxJQUFBLEVBQWlCO0FBQ2YsU0FBQSxTQUFBO0FBQ0EsU0FBQSxJQUFBLENBQVUsS0FBVixNQUFVLEVBQVYsSUFBQSxJQUFBO0FBaEJKLEdBQUE7O0FBQUEsRUFBQSxPQUFBLENBQUEsU0FBQSxHQW1CVSxTQUFBLFNBQUEsR0FBUztBQUFBLFFBQ1QsSUFEUyxHQUFBLEtBQUEsSUFBQTs7QUFHZixRQUFJLEtBQUEsTUFBQSxLQUFnQixLQUFBLElBQUEsQ0FBcEIsTUFBQSxFQUFzQztBQUNwQyxVQUFJLE9BQU8sR0FBRyxJQUFBLFVBQUEsQ0FBZSxJQUFJLENBQUosTUFBQSxHQUE3QixTQUFjLENBQWQ7QUFDQSxNQUFBLE9BQU8sQ0FBUCxHQUFBLENBQUEsSUFBQSxFQUFBLENBQUE7QUFDQSxXQUFBLElBQUEsR0FBQSxPQUFBO0FBQ0Q7QUExQkwsR0FBQTs7QUFBQSxFQUFBLE9BQUEsQ0FBQSxTQUFBLEdBNkJFLFNBQUEsU0FBQSxDQUFBLE9BQUEsRUFBeUI7QUFDdkIsV0FBTyxLQUFBLElBQUEsQ0FBUCxPQUFPLENBQVA7QUE5QkosR0FBQTs7QUFBQSxFQUFBLE9BQUEsQ0FBQSxTQUFBLEdBaUNFLFNBQUEsU0FBQSxDQUFBLE9BQUEsRUFBQSxLQUFBLEVBQXdDO0FBQ3RDLFNBQUEsSUFBQSxDQUFBLE9BQUEsSUFBQSxLQUFBO0FBbENKLEdBQUE7O0FBQUEsRUFBQSxPQUFBLENBQUEsTUFBQSxHQXFDRSxTQUFBLE1BQUEsR0FBTTtBQUNKO0FBQ0EsU0FBQSxXQUFBLENBQUEsSUFBQSxDQUFzQixLQUF0QixNQUFBO0FBQ0EsV0FBTyxLQUFBLFdBQUEsQ0FBQSxNQUFBLEdBQVAsQ0FBQTtBQXhDSixHQUFBOztBQUFBLEVBQUEsT0FBQSxDQUFBLFlBQUEsR0EyQ0UsU0FBQSxZQUFBLENBQUEsTUFBQSxFQUEyQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxRQUFBO0FBQUE7QUFBQSxNQUFpQjtBQUNmLGFBQUEsV0FBQSxDQUFBLE1BQUEsSUFBd0I7QUFBQTtBQUF4QjtBQUNEO0FBakRMLEdBQUE7O0FBQUEsRUFBQSxPQUFBLENBQUEsSUFBQSxHQW9ERSxTQUFBLElBQUEsR0FBSTtBQUNGLFdBQU8sS0FBUCxNQUFBO0FBckRKLEdBQUEsQ0F3REU7QUFDQTtBQUNBO0FBMURGOztBQUFBLEVBQUEsT0FBQSxDQUFBLE9BQUEsR0EyREUsU0FBQSxPQUFBLENBQUEsTUFBQSxFQUFzQjtBQUNwQixXQUFPLEtBQUEsV0FBQSxDQUFQLE1BQU8sQ0FBUDtBQTVESixHQUFBOztBQUFBLEVBQUEsT0FBQSxDQUFBLE1BQUEsR0ErREUsU0FBQSxNQUFBLENBQUEsTUFBQSxFQUFxQjtBQUNuQixXQUFPLE9BQU0sQ0FBQyxLQUFELFdBQUEsRUFBYixNQUFhLENBQWI7QUFoRUosR0FBQTs7QUFBQSxFQUFBLE9BQUEsQ0FBQSxJQUFBLEdBbUVFLFNBQUEsSUFBQSxDQUFBLE1BQUEsRUFBbUI7QUFDakIsU0FBQSxXQUFBLENBQUEsTUFBQSxJQUF3QjtBQUFBO0FBQXhCO0FBQ0Q7QUFFRDs7Ozs7OztBQXZFRjs7QUFBQSxFQUFBLE9BQUEsQ0FBQSxPQUFBLEdBOEVFLFNBQUEsT0FBQSxHQUFPO0FBQ0wsUUFBSSxhQUFhLEdBQWpCLENBQUE7QUFESyxRQUVELFdBRkMsR0FBQSxLQUFBLFdBQUE7QUFBQSxRQUVELFdBRkMsR0FBQSxLQUFBLFdBQUE7QUFBQSxRQUUyQixJQUYzQixHQUFBLEtBQUEsSUFBQTs7QUFJTCxTQUFLLElBQUksQ0FBQyxHQUFWLENBQUEsRUFBZ0IsQ0FBQyxHQUFqQixNQUFBLEVBQTRCLENBQTVCLEVBQUEsRUFBaUM7QUFDL0IsVUFBSSxNQUFNLEdBQUcsV0FBVyxDQUF4QixDQUF3QixDQUF4QjtBQUNBLFVBQUksSUFBSSxHQUFHLFdBQVcsQ0FBQyxDQUFDLEdBQWIsQ0FBVyxDQUFYLEdBQVgsTUFBQTtBQUNBLFVBQUksS0FBSyxHQUFHLFdBQVcsQ0FBdkIsQ0FBdUIsQ0FBdkI7O0FBRUEsVUFBSSxLQUFLLEtBQUE7QUFBQTtBQUFULFFBQXFDO0FBQ25DO0FBREYsU0FBQSxNQUVPLElBQUksS0FBSyxLQUFBO0FBQUE7QUFBVCxRQUFvQztBQUN6QztBQUNBO0FBQ0E7QUFDQSxVQUFBLFdBQVcsQ0FBWCxDQUFXLENBQVgsR0FBYztBQUFBO0FBQWQ7QUFDQSxVQUFBLGFBQWEsSUFBYixJQUFBO0FBTEssU0FBQSxNQU1BLElBQUksS0FBSyxLQUFBO0FBQUE7QUFBVCxRQUF3QztBQUM3QyxlQUFLLElBQUksQ0FBQyxHQUFWLE1BQUEsRUFBcUIsQ0FBQyxJQUFJLENBQUMsR0FBM0IsSUFBQSxFQUFvQyxDQUFwQyxFQUFBLEVBQXlDO0FBQ3ZDLFlBQUEsSUFBSSxDQUFDLENBQUMsR0FBTixhQUFJLENBQUosR0FBMEIsSUFBSSxDQUE5QixDQUE4QixDQUE5QjtBQUNEOztBQUVELFVBQUEsV0FBVyxDQUFYLENBQVcsQ0FBWCxHQUFpQixNQUFNLEdBQXZCLGFBQUE7QUFMSyxTQUFBLE1BTUEsSUFBSSxLQUFLLEtBQUE7QUFBQTtBQUFULFFBQXNDO0FBQzNDLFVBQUEsV0FBVyxDQUFYLENBQVcsQ0FBWCxHQUFpQixNQUFNLEdBQXZCLGFBQUE7QUFDRDtBQUNGOztBQUVELFNBQUEsTUFBQSxHQUFjLEtBQUEsTUFBQSxHQUFkLGFBQUE7QUExR0osR0FBQTs7QUFBQSxFQUFBLE9BQUEsQ0FBQSxPQUFBLEdBNkdFLFNBQUEsT0FBQSxDQUFBLE1BQUEsRUFBNEI7QUFBQSxRQUFwQixNQUFvQixLQUFBLEtBQUEsQ0FBQSxFQUFBO0FBQXBCLE1BQUEsTUFBb0IsR0FBWCxLQUFWLE1BQUM7QUFBb0IsS0FBQSxDQUMxQjs7O0FBQ0EsUUFBSSxNQUFNLEdBQUcsS0FBSyxDQUFDLEtBQUQsSUFBQSxFQUFBLENBQUEsRUFBTCxNQUFLLENBQUwsQ0FBYixNQUFBO0FBQ0EsV0FBTztBQUNMLE1BQUEsTUFBTSxFQUFFLEtBREgsTUFBQTtBQUVMLE1BQUEsS0FBSyxFQUFFLEtBRkYsV0FBQTtBQUdMLE1BQUEsTUFBTSxFQUFFO0FBSEgsS0FBUDtBQWhISixHQUFBOztBQUFBLFNBQUEsUUFBQTtBQUFBLENBQUEsRUFBQTs7OztBQXdIQSxJQUFNLGtCQUFOLEdBQUEsYUFBQSxZQUFBO0FBS0UsV0FBQSxrQkFBQSxDQUFBLFNBQUEsRUFBQSxJQUFBLEVBRTBCO0FBRGpCLFNBQUEsU0FBQSxHQUFBLFNBQUE7QUFDQSxTQUFBLElBQUEsR0FBQSxJQUFBO0FBRVAsU0FBQSxPQUFBLEdBQWUsSUFBQSxxQkFBQSxDQUFrQixLQUFqQyxJQUFlLENBQWY7QUFDRDs7QUFWSCxNQUFBLE9BQUEsR0FBQSxrQkFBQSxDQUFBLFNBQUE7O0FBQUEsRUFBQSxPQUFBLENBQUEsTUFBQSxHQVlFLFNBQUEsTUFBQSxDQUFBLE1BQUEsRUFBcUI7QUFDbkIsU0FBQSxPQUFBLENBQUEsTUFBQSxHQUFBLE1BQUE7QUFDQSxXQUFPLEtBQVAsT0FBQTtBQWRKLEdBQUE7O0FBQUEsU0FBQSxrQkFBQTtBQUFBLENBQUEsRUFBQTs7OztBQWtCQSxTQUFBLEtBQUEsQ0FBQSxHQUFBLEVBQUEsS0FBQSxFQUFBLEdBQUEsRUFBMEQ7QUFDeEQsTUFBSSxHQUFHLENBQUgsS0FBQSxLQUFKLFNBQUEsRUFBNkI7QUFDM0IsV0FBTyxHQUFHLENBQUgsS0FBQSxDQUFBLEtBQUEsRUFBUCxHQUFPLENBQVA7QUFDRDs7QUFFRCxNQUFJLEdBQUcsR0FBRyxJQUFBLFVBQUEsQ0FBVixHQUFVLENBQVY7O0FBRUEsU0FBTyxLQUFLLEdBQVosR0FBQSxFQUFvQixLQUFwQixFQUFBLEVBQTZCO0FBQzNCLElBQUEsR0FBRyxDQUFILEtBQUcsQ0FBSCxHQUFhLEdBQUcsQ0FBaEIsS0FBZ0IsQ0FBaEI7QUFDRDs7QUFFRCxTQUFBLEdBQUE7QUFDRDs7QUFFRCxTQUFBLE9BQUEsQ0FBQSxLQUFBLEVBQUEsTUFBQSxFQUErQztBQUM3QyxNQUFBO0FBQUE7QUFBQSxJQUFpQjtBQUNmLGFBQU8sS0FBSyxDQUFDLE1BQU0sR0FBWixDQUFLLENBQUwsR0FBb0IsS0FBSyxDQUFoQyxNQUFnQyxDQUFoQztBQURGLEtBQUEsTUFFTztBQUNMLFdBQU8sQ0FBUCxDQUFBO0FBQ0Q7QUFDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBpbGVUaW1lSGVhcCxcbiAgU2VyaWFsaXplZEhlYXAsXG4gIFJ1bnRpbWVIZWFwLFxuICBTdGRMaWJPcGVyYW5kLFxuICBSdW50aW1lQ29uc3RhbnRzLFxuICBSdW50aW1lUHJvZ3JhbSxcbiAgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTE9DQUxfREVCVUcgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBSdW50aW1lT3BJbXBsIH0gZnJvbSAnLi9vcGNvZGUnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmNvbnN0IGVudW0gVGFibGVTbG90U3RhdGUge1xuICBBbGxvY2F0ZWQsXG4gIEZyZWVkLFxuICBQdXJnZWQsXG4gIFBvaW50ZXIsXG59XG5cbmV4cG9ydCB0eXBlIFBsYWNlaG9sZGVyID0gW251bWJlciwgKCkgPT4gbnVtYmVyXTtcbmV4cG9ydCB0eXBlIFN0ZGxpYlBsYWNlaG9sZGVyID0gW251bWJlciwgU3RkTGliT3BlcmFuZF07XG5cbmNvbnN0IFBBR0VfU0laRSA9IDB4MTAwMDAwO1xuXG5leHBvcnQgY2xhc3MgUnVudGltZUhlYXBJbXBsIGltcGxlbWVudHMgUnVudGltZUhlYXAge1xuICBwcml2YXRlIGhlYXA6IEludDMyQXJyYXk7XG4gIHByaXZhdGUgdGFibGU6IG51bWJlcltdO1xuXG4gIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZWRIZWFwOiBTZXJpYWxpemVkSGVhcCkge1xuICAgIGxldCB7IGJ1ZmZlciwgdGFibGUgfSA9IHNlcmlhbGl6ZWRIZWFwO1xuICAgIHRoaXMuaGVhcCA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgdGhpcy50YWJsZSA9IHRhYmxlO1xuICB9XG5cbiAgLy8gSXQgaXMgaWxsZWdhbCB0byBjbG9zZSBvdmVyIHRoaXMgYWRkcmVzcywgYXMgY29tcGFjdGlvblxuICAvLyBtYXkgbW92ZSBpdC4gSG93ZXZlciwgaXQgaXMgbGVnYWwgdG8gdXNlIHRoaXMgYWRkcmVzc1xuICAvLyBtdWx0aXBsZSB0aW1lcyBiZXR3ZWVuIGNvbXBhY3Rpb25zLlxuICBnZXRhZGRyKGhhbmRsZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZVtoYW5kbGVdO1xuICB9XG5cbiAgZ2V0YnlhZGRyKGFkZHJlc3M6IG51bWJlcik6IG51bWJlciB7XG4gICAgYXNzZXJ0KHRoaXMuaGVhcFthZGRyZXNzXSAhPT0gdW5kZWZpbmVkLCAnQWNjZXNzIG1lbW9yeSBvdXQgb2YgYm91bmRzIG9mIHRoZSBoZWFwJyk7XG4gICAgcmV0dXJuIHRoaXMuaGVhcFthZGRyZXNzXTtcbiAgfVxuXG4gIHNpemVvZihoYW5kbGU6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHNpemVvZih0aGlzLnRhYmxlLCBoYW5kbGUpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlSGVhcChzZXJpYWxpemVkSGVhcDogU2VyaWFsaXplZEhlYXApOiBSdW50aW1lSGVhcCB7XG4gIHJldHVybiBuZXcgUnVudGltZUhlYXBJbXBsKHNlcmlhbGl6ZWRIZWFwKTtcbn1cblxuLyoqXG4gKiBUaGUgSGVhcCBpcyByZXNwb25zaWJsZSBmb3IgZHluYW1pY2FsbHkgYWxsb2NhdGluZ1xuICogbWVtb3J5IGluIHdoaWNoIHdlIHJlYWQvd3JpdGUgdGhlIFZNJ3MgaW5zdHJ1Y3Rpb25zXG4gKiBmcm9tL3RvLiBXaGVuIHdlIG1hbGxvYyB3ZSBwYXNzIG91dCBhIFZNSGFuZGxlLCB3aGljaFxuICogaXMgdXNlZCBhcyBhbiBpbmRpcmVjdCB3YXkgb2YgYWNjZXNzaW5nIHRoZSBtZW1vcnkgZHVyaW5nXG4gKiBleGVjdXRpb24gb2YgdGhlIFZNLiBJbnRlcm5hbGx5IHdlIHRyYWNrIHRoZSBkaWZmZXJlbnRcbiAqIHJlZ2lvbnMgb2YgdGhlIG1lbW9yeSBpbiBhbiBpbnQgYXJyYXkga25vd24gYXMgdGhlIHRhYmxlLlxuICpcbiAqIFRoZSB0YWJsZSAzMi1iaXQgYWxpZ25lZCBhbmQgaGFzIHRoZSBmb2xsb3dpbmcgbGF5b3V0OlxuICpcbiAqIHwgLi4uIHwgaHAgKHUzMikgfCAgICAgICBpbmZvICh1MzIpICAgfCBzaXplICh1MzIpIHxcbiAqIHwgLi4uIHwgIEhhbmRsZSAgfCBTY29wZSBTaXplIHwgU3RhdGUgfCBTaXplICAgICAgIHxcbiAqIHwgLi4uIHwgMzJiaXRzICAgfCAzMGJpdHMgICAgIHwgMmJpdHMgfCAzMmJpdCAgICAgIHxcbiAqXG4gKiBXaXRoIHRoaXMgaW5mb3JtYXRpb24gd2UgZWZmZWN0aXZlbHkgaGF2ZSB0aGUgYWJpbGl0eSB0b1xuICogY29udHJvbCB3aGVuIHdlIHdhbnQgdG8gZnJlZSBtZW1vcnkuIFRoYXQgYmVpbmcgc2FpZCB5b3VcbiAqIGNhbiBub3QgZnJlZSBkdXJpbmcgZXhlY3V0aW9uIGFzIHJhdyBhZGRyZXNzIGFyZSBvbmx5XG4gKiB2YWxpZCBkdXJpbmcgdGhlIGV4ZWN1dGlvbi4gVGhpcyBtZWFucyB5b3UgY2Fubm90IGNsb3NlXG4gKiBvdmVyIHRoZW0gYXMgeW91IHdpbGwgaGF2ZSBhIGJhZCBtZW1vcnkgYWNjZXNzIGV4Y2VwdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEhlYXBJbXBsIGltcGxlbWVudHMgQ29tcGlsZVRpbWVIZWFwLCBSdW50aW1lSGVhcCB7XG4gIG9mZnNldCA9IDA7XG5cbiAgcHJpdmF0ZSBoZWFwOiBJbnQzMkFycmF5O1xuICBwcml2YXRlIGhhbmRsZVRhYmxlOiBudW1iZXJbXTtcbiAgcHJpdmF0ZSBoYW5kbGVTdGF0ZTogVGFibGVTbG90U3RhdGVbXTtcbiAgcHJpdmF0ZSBoYW5kbGUgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGVhcCA9IG5ldyBJbnQzMkFycmF5KFBBR0VfU0laRSk7XG4gICAgdGhpcy5oYW5kbGVUYWJsZSA9IFtdO1xuICAgIHRoaXMuaGFuZGxlU3RhdGUgPSBbXTtcbiAgfVxuXG4gIHB1c2goaXRlbTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zaXplQ2hlY2soKTtcbiAgICB0aGlzLmhlYXBbdGhpcy5vZmZzZXQrK10gPSBpdGVtO1xuICB9XG5cbiAgcHJpdmF0ZSBzaXplQ2hlY2soKSB7XG4gICAgbGV0IHsgaGVhcCB9ID0gdGhpcztcblxuICAgIGlmICh0aGlzLm9mZnNldCA9PT0gdGhpcy5oZWFwLmxlbmd0aCkge1xuICAgICAgbGV0IG5ld0hlYXAgPSBuZXcgSW50MzJBcnJheShoZWFwLmxlbmd0aCArIFBBR0VfU0laRSk7XG4gICAgICBuZXdIZWFwLnNldChoZWFwLCAwKTtcbiAgICAgIHRoaXMuaGVhcCA9IG5ld0hlYXA7XG4gICAgfVxuICB9XG5cbiAgZ2V0YnlhZGRyKGFkZHJlc3M6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuaGVhcFthZGRyZXNzXTtcbiAgfVxuXG4gIHNldGJ5YWRkcihhZGRyZXNzOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmhlYXBbYWRkcmVzc10gPSB2YWx1ZTtcbiAgfVxuXG4gIG1hbGxvYygpOiBudW1iZXIge1xuICAgIC8vIHB1c2ggb2Zmc2V0LCBpbmZvLCBzaXplXG4gICAgdGhpcy5oYW5kbGVUYWJsZS5wdXNoKHRoaXMub2Zmc2V0KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVUYWJsZS5sZW5ndGggLSAxO1xuICB9XG5cbiAgZmluaXNoTWFsbG9jKGhhbmRsZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gQFRPRE86IEF0IHRoZSBtb21lbnQsIGdhcmJhZ2UgY29sbGVjdGlvbiBpc24ndCBhY3R1YWxseSB1c2VkLCBzbyB0aGlzIGlzXG4gICAgLy8gd3JhcHBlZCB0byBwcmV2ZW50IHVzIGZyb20gYWxsb2NhdGluZyBleHRyYSBzcGFjZSBpbiBwcm9kLiBJbiB0aGUgZnV0dXJlLFxuICAgIC8vIGlmIHdlIHN0YXJ0IHVzaW5nIHRoZSBjb21wYWN0IEFQSSwgd2Ugc2hvdWxkIGNoYW5nZSB0aGlzLlxuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgdGhpcy5oYW5kbGVTdGF0ZVtoYW5kbGVdID0gVGFibGVTbG90U3RhdGUuQWxsb2NhdGVkO1xuICAgIH1cbiAgfVxuXG4gIHNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XG4gIH1cblxuICAvLyBJdCBpcyBpbGxlZ2FsIHRvIGNsb3NlIG92ZXIgdGhpcyBhZGRyZXNzLCBhcyBjb21wYWN0aW9uXG4gIC8vIG1heSBtb3ZlIGl0LiBIb3dldmVyLCBpdCBpcyBsZWdhbCB0byB1c2UgdGhpcyBhZGRyZXNzXG4gIC8vIG11bHRpcGxlIHRpbWVzIGJldHdlZW4gY29tcGFjdGlvbnMuXG4gIGdldGFkZHIoaGFuZGxlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVRhYmxlW2hhbmRsZV07XG4gIH1cblxuICBzaXplb2YoaGFuZGxlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBzaXplb2YodGhpcy5oYW5kbGVUYWJsZSwgaGFuZGxlKTtcbiAgfVxuXG4gIGZyZWUoaGFuZGxlOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZVN0YXRlW2hhbmRsZV0gPSBUYWJsZVNsb3RTdGF0ZS5GcmVlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaGVhcCB1c2VzIHRoZSBbTWFyay1Db21wYWN0IEFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFyay1jb21wYWN0X2FsZ29yaXRobSkgdG8gc2hpZnRcbiAgICogcmVhY2hhYmxlIG1lbW9yeSB0byB0aGUgYm90dG9tIG9mIHRoZSBoZWFwIGFuZCBmcmVlYWJsZVxuICAgKiBtZW1vcnkgdG8gdGhlIHRvcCBvZiB0aGUgaGVhcC4gV2hlbiB3ZSBoYXZlIHNoaWZ0ZWQgYWxsXG4gICAqIHRoZSByZWFjaGFibGUgbWVtb3J5IHRvIHRoZSB0b3Agb2YgdGhlIGhlYXAsIHdlIG1vdmUgdGhlXG4gICAqIG9mZnNldCB0byB0aGUgbmV4dCBmcmVlIHBvc2l0aW9uLlxuICAgKi9cbiAgY29tcGFjdCgpOiB2b2lkIHtcbiAgICBsZXQgY29tcGFjdGVkU2l6ZSA9IDA7XG4gICAgbGV0IHsgaGFuZGxlVGFibGUsIGhhbmRsZVN0YXRlLCBoZWFwIH0gPSB0aGlzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG9mZnNldCA9IGhhbmRsZVRhYmxlW2ldO1xuICAgICAgbGV0IHNpemUgPSBoYW5kbGVUYWJsZVtpICsgMV0gLSBvZmZzZXQ7XG4gICAgICBsZXQgc3RhdGUgPSBoYW5kbGVTdGF0ZVtpXTtcblxuICAgICAgaWYgKHN0YXRlID09PSBUYWJsZVNsb3RTdGF0ZS5QdXJnZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBUYWJsZVNsb3RTdGF0ZS5GcmVlZCkge1xuICAgICAgICAvLyB0cmFuc2l0aW9uIHRvIFwiYWxyZWFkeSBmcmVlZFwiIGFrYSBcInB1cmdlZFwiXG4gICAgICAgIC8vIGEgZ29vZCBpbXByb3ZlbWVudCB3b3VsZCBiZSB0byByZXVzZVxuICAgICAgICAvLyB0aGVzZSBzbG90c1xuICAgICAgICBoYW5kbGVTdGF0ZVtpXSA9IFRhYmxlU2xvdFN0YXRlLlB1cmdlZDtcbiAgICAgICAgY29tcGFjdGVkU2l6ZSArPSBzaXplO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gVGFibGVTbG90U3RhdGUuQWxsb2NhdGVkKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBvZmZzZXQ7IGogPD0gaSArIHNpemU7IGorKykge1xuICAgICAgICAgIGhlYXBbaiAtIGNvbXBhY3RlZFNpemVdID0gaGVhcFtqXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZVRhYmxlW2ldID0gb2Zmc2V0IC0gY29tcGFjdGVkU2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFRhYmxlU2xvdFN0YXRlLlBvaW50ZXIpIHtcbiAgICAgICAgaGFuZGxlVGFibGVbaV0gPSBvZmZzZXQgLSBjb21wYWN0ZWRTaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5vZmZzZXQgLSBjb21wYWN0ZWRTaXplO1xuICB9XG5cbiAgY2FwdHVyZShvZmZzZXQgPSB0aGlzLm9mZnNldCk6IFNlcmlhbGl6ZWRIZWFwIHtcbiAgICAvLyBPbmx5IGNhbGxlZCBpbiBlYWdlciBtb2RlXG4gICAgbGV0IGJ1ZmZlciA9IHNsaWNlKHRoaXMuaGVhcCwgMCwgb2Zmc2V0KS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZTogdGhpcy5oYW5kbGUsXG4gICAgICB0YWJsZTogdGhpcy5oYW5kbGVUYWJsZSxcbiAgICAgIGJ1ZmZlcjogYnVmZmVyIGFzIEFycmF5QnVmZmVyLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJ1bnRpbWVQcm9ncmFtSW1wbCBpbXBsZW1lbnRzIFJ1bnRpbWVQcm9ncmFtIHtcbiAgW2tleTogbnVtYmVyXTogbmV2ZXI7XG5cbiAgcHJpdmF0ZSBfb3Bjb2RlOiBSdW50aW1lT3BJbXBsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjb25zdGFudHM6IFJ1bnRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgICBwdWJsaWMgaGVhcDogUnVudGltZUhlYXBcbiAgKSB7XG4gICAgdGhpcy5fb3Bjb2RlID0gbmV3IFJ1bnRpbWVPcEltcGwodGhpcy5oZWFwKTtcbiAgfVxuXG4gIG9wY29kZShvZmZzZXQ6IG51bWJlcik6IFJ1bnRpbWVPcEltcGwge1xuICAgIHRoaXMuX29wY29kZS5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHRoaXMuX29wY29kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzbGljZShhcnI6IEludDMyQXJyYXksIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogSW50MzJBcnJheSB7XG4gIGlmIChhcnIuc2xpY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIH1cblxuICBsZXQgcmV0ID0gbmV3IEludDMyQXJyYXkoZW5kKTtcblxuICBmb3IgKDsgc3RhcnQgPCBlbmQ7IHN0YXJ0KyspIHtcbiAgICByZXRbc3RhcnRdID0gYXJyW3N0YXJ0XTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNpemVvZih0YWJsZTogbnVtYmVyW10sIGhhbmRsZTogbnVtYmVyKSB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIHJldHVybiB0YWJsZVtoYW5kbGUgKyAxXSAtIHRhYmxlW2hhbmRsZV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9