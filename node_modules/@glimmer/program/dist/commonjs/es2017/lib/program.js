"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hydrateHeap = hydrateHeap;
exports.RuntimeProgramImpl = exports.HeapImpl = exports.RuntimeHeapImpl = void 0;

var _opcode = require("./opcode");

var _util = require("@glimmer/util");

const PAGE_SIZE = 0x100000;

class RuntimeHeapImpl {
  constructor(serializedHeap) {
    let {
      buffer,
      table
    } = serializedHeap;
    this.heap = new Int32Array(buffer);
    this.table = table;
  } // It is illegal to close over this address, as compaction
  // may move it. However, it is legal to use this address
  // multiple times between compactions.


  getaddr(handle) {
    return this.table[handle];
  }

  getbyaddr(address) {
    false && (0, _util.assert)(this.heap[address] !== undefined, 'Access memory out of bounds of the heap');
    return this.heap[address];
  }

  sizeof(handle) {
    return sizeof(this.table, handle);
  }

}

exports.RuntimeHeapImpl = RuntimeHeapImpl;

function hydrateHeap(serializedHeap) {
  return new RuntimeHeapImpl(serializedHeap);
}
/**
 * The Heap is responsible for dynamically allocating
 * memory in which we read/write the VM's instructions
 * from/to. When we malloc we pass out a VMHandle, which
 * is used as an indirect way of accessing the memory during
 * execution of the VM. Internally we track the different
 * regions of the memory in an int array known as the table.
 *
 * The table 32-bit aligned and has the following layout:
 *
 * | ... | hp (u32) |       info (u32)   | size (u32) |
 * | ... |  Handle  | Scope Size | State | Size       |
 * | ... | 32bits   | 30bits     | 2bits | 32bit      |
 *
 * With this information we effectively have the ability to
 * control when we want to free memory. That being said you
 * can not free during execution as raw address are only
 * valid during the execution. This means you cannot close
 * over them as you will have a bad memory access exception.
 */


class HeapImpl {
  constructor() {
    this.offset = 0;
    this.handle = 0;
    this.heap = new Int32Array(PAGE_SIZE);
    this.handleTable = [];
    this.handleState = [];
  }

  push(item) {
    this.sizeCheck();
    this.heap[this.offset++] = item;
  }

  sizeCheck() {
    let {
      heap
    } = this;

    if (this.offset === this.heap.length) {
      let newHeap = new Int32Array(heap.length + PAGE_SIZE);
      newHeap.set(heap, 0);
      this.heap = newHeap;
    }
  }

  getbyaddr(address) {
    return this.heap[address];
  }

  setbyaddr(address, value) {
    this.heap[address] = value;
  }

  malloc() {
    // push offset, info, size
    this.handleTable.push(this.offset);
    return this.handleTable.length - 1;
  }

  finishMalloc(handle) {
    // @TODO: At the moment, garbage collection isn't actually used, so this is
    // wrapped to prevent us from allocating extra space in prod. In the future,
    // if we start using the compact API, we should change this.
    if (false
    /* LOCAL_DEBUG */
    ) {
        this.handleState[handle] = 0
        /* Allocated */
        ;
      }
  }

  size() {
    return this.offset;
  } // It is illegal to close over this address, as compaction
  // may move it. However, it is legal to use this address
  // multiple times between compactions.


  getaddr(handle) {
    return this.handleTable[handle];
  }

  sizeof(handle) {
    return sizeof(this.handleTable, handle);
  }

  free(handle) {
    this.handleState[handle] = 1
    /* Freed */
    ;
  }
  /**
   * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift
   * reachable memory to the bottom of the heap and freeable
   * memory to the top of the heap. When we have shifted all
   * the reachable memory to the top of the heap, we move the
   * offset to the next free position.
   */


  compact() {
    let compactedSize = 0;
    let {
      handleTable,
      handleState,
      heap
    } = this;

    for (let i = 0; i < length; i++) {
      let offset = handleTable[i];
      let size = handleTable[i + 1] - offset;
      let state = handleState[i];

      if (state === 2
      /* Purged */
      ) {
          continue;
        } else if (state === 1
      /* Freed */
      ) {
          // transition to "already freed" aka "purged"
          // a good improvement would be to reuse
          // these slots
          handleState[i] = 2
          /* Purged */
          ;
          compactedSize += size;
        } else if (state === 0
      /* Allocated */
      ) {
          for (let j = offset; j <= i + size; j++) {
            heap[j - compactedSize] = heap[j];
          }

          handleTable[i] = offset - compactedSize;
        } else if (state === 3
      /* Pointer */
      ) {
          handleTable[i] = offset - compactedSize;
        }
    }

    this.offset = this.offset - compactedSize;
  }

  capture(offset = this.offset) {
    // Only called in eager mode
    let buffer = slice(this.heap, 0, offset).buffer;
    return {
      handle: this.handle,
      table: this.handleTable,
      buffer: buffer
    };
  }

}

exports.HeapImpl = HeapImpl;

class RuntimeProgramImpl {
  constructor(constants, heap) {
    this.constants = constants;
    this.heap = heap;
    this._opcode = new _opcode.RuntimeOpImpl(this.heap);
  }

  opcode(offset) {
    this._opcode.offset = offset;
    return this._opcode;
  }

}

exports.RuntimeProgramImpl = RuntimeProgramImpl;

function slice(arr, start, end) {
  if (arr.slice !== undefined) {
    return arr.slice(start, end);
  }

  let ret = new Int32Array(end);

  for (; start < end; start++) {
    ret[start] = arr[start];
  }

  return ret;
}

function sizeof(table, handle) {
  if (false
  /* LOCAL_DEBUG */
  ) {
      return table[handle + 1] - table[handle];
    } else {
    return -1;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3Byb2dyYW0vbGliL3Byb2dyYW0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFVQTs7QUFDQTs7QUFZQSxNQUFNLFNBQVMsR0FBZixRQUFBOztBQUVNLE1BQUEsZUFBQSxDQUFzQjtBQUkxQixFQUFBLFdBQUEsQ0FBQSxjQUFBLEVBQTBDO0FBQ3hDLFFBQUk7QUFBQSxNQUFBLE1BQUE7QUFBVSxNQUFBO0FBQVYsUUFBSixjQUFBO0FBQ0EsU0FBQSxJQUFBLEdBQVksSUFBQSxVQUFBLENBQVosTUFBWSxDQUFaO0FBQ0EsU0FBQSxLQUFBLEdBQUEsS0FBQTtBQVB3QixHQUFBLENBVTFCO0FBQ0E7QUFDQTs7O0FBQ0EsRUFBQSxPQUFPLENBQUEsTUFBQSxFQUFlO0FBQ3BCLFdBQU8sS0FBQSxLQUFBLENBQVAsTUFBTyxDQUFQO0FBQ0Q7O0FBRUQsRUFBQSxTQUFTLENBQUEsT0FBQSxFQUFnQjtBQUFBLGFBQ3ZCLGtCQUFPLEtBQUEsSUFBQSxDQUFBLE9BQUEsTUFBRCxTQUFOLEVBRHVCLHlDQUN2QixDQUR1QjtBQUV2QixXQUFPLEtBQUEsSUFBQSxDQUFQLE9BQU8sQ0FBUDtBQUNEOztBQUVELEVBQUEsTUFBTSxDQUFBLE1BQUEsRUFBZTtBQUNuQixXQUFPLE1BQU0sQ0FBQyxLQUFELEtBQUEsRUFBYixNQUFhLENBQWI7QUFDRDs7QUF4QnlCOzs7O0FBMkJ0QixTQUFBLFdBQUEsQ0FBQSxjQUFBLEVBQW9EO0FBQ3hELFNBQU8sSUFBQSxlQUFBLENBQVAsY0FBTyxDQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CTSxNQUFBLFFBQUEsQ0FBZTtBQVFuQixFQUFBLFdBQUEsR0FBQTtBQVBBLFNBQUEsTUFBQSxHQUFBLENBQUE7QUFLUSxTQUFBLE1BQUEsR0FBQSxDQUFBO0FBR04sU0FBQSxJQUFBLEdBQVksSUFBQSxVQUFBLENBQVosU0FBWSxDQUFaO0FBQ0EsU0FB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QVA7QUFDRDs7QUFFRCxNQUFJLEdBQUcsR0FBRyxJQUFBLFVBQUEsQ0FBVixHQUFVLENBQVY7O0FBRUEsU0FBTyxLQUFLLEdBQVosR0FBQSxFQUFvQixLQUFwQixFQUFBLEVBQTZCO0FBQzNCLElBQUEsR0FBRyxDQUFILEtBQUcsQ0FBSCxHQUFhLEdBQUcsQ0FBaEIsS0FBZ0IsQ0FBaEI7QUFDRDs7QUFFRCxTQUFBLEdBQUE7QUFDRDs7QUFFRCxTQUFBLE1BQUEsQ0FBQSxLQUFBLEVBQUEsTUFBQSxFQUErQztBQUM3QyxNQUFBO0FBQUE7QUFBQSxJQUFpQjtBQUNmLGFBQU8sS0FBSyxDQUFDLE1BQU0sR0FBWixDQUFLLENBQUwsR0FBb0IsS0FBSyxDQUFoQyxNQUFnQyxDQUFoQztBQURGLEtBQUEsTUFFTztBQUNMLFdBQU8sQ0FBUCxDQUFBO0FBQ0Q7QUFDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBpbGVUaW1lSGVhcCxcbiAgU2VyaWFsaXplZEhlYXAsXG4gIFJ1bnRpbWVIZWFwLFxuICBTdGRMaWJPcGVyYW5kLFxuICBSdW50aW1lQ29uc3RhbnRzLFxuICBSdW50aW1lUHJvZ3JhbSxcbiAgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTE9DQUxfREVCVUcgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBSdW50aW1lT3BJbXBsIH0gZnJvbSAnLi9vcGNvZGUnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmNvbnN0IGVudW0gVGFibGVTbG90U3RhdGUge1xuICBBbGxvY2F0ZWQsXG4gIEZyZWVkLFxuICBQdXJnZWQsXG4gIFBvaW50ZXIsXG59XG5cbmV4cG9ydCB0eXBlIFBsYWNlaG9sZGVyID0gW251bWJlciwgKCkgPT4gbnVtYmVyXTtcbmV4cG9ydCB0eXBlIFN0ZGxpYlBsYWNlaG9sZGVyID0gW251bWJlciwgU3RkTGliT3BlcmFuZF07XG5cbmNvbnN0IFBBR0VfU0laRSA9IDB4MTAwMDAwO1xuXG5leHBvcnQgY2xhc3MgUnVudGltZUhlYXBJbXBsIGltcGxlbWVudHMgUnVudGltZUhlYXAge1xuICBwcml2YXRlIGhlYXA6IEludDMyQXJyYXk7XG4gIHByaXZhdGUgdGFibGU6IG51bWJlcltdO1xuXG4gIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZWRIZWFwOiBTZXJpYWxpemVkSGVhcCkge1xuICAgIGxldCB7IGJ1ZmZlciwgdGFibGUgfSA9IHNlcmlhbGl6ZWRIZWFwO1xuICAgIHRoaXMuaGVhcCA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgdGhpcy50YWJsZSA9IHRhYmxlO1xuICB9XG5cbiAgLy8gSXQgaXMgaWxsZWdhbCB0byBjbG9zZSBvdmVyIHRoaXMgYWRkcmVzcywgYXMgY29tcGFjdGlvblxuICAvLyBtYXkgbW92ZSBpdC4gSG93ZXZlciwgaXQgaXMgbGVnYWwgdG8gdXNlIHRoaXMgYWRkcmVzc1xuICAvLyBtdWx0aXBsZSB0aW1lcyBiZXR3ZWVuIGNvbXBhY3Rpb25zLlxuICBnZXRhZGRyKGhhbmRsZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZVtoYW5kbGVdO1xuICB9XG5cbiAgZ2V0YnlhZGRyKGFkZHJlc3M6IG51bWJlcik6IG51bWJlciB7XG4gICAgYXNzZXJ0KHRoaXMuaGVhcFthZGRyZXNzXSAhPT0gdW5kZWZpbmVkLCAnQWNjZXNzIG1lbW9yeSBvdXQgb2YgYm91bmRzIG9mIHRoZSBoZWFwJyk7XG4gICAgcmV0dXJuIHRoaXMuaGVhcFthZGRyZXNzXTtcbiAgfVxuXG4gIHNpemVvZihoYW5kbGU6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHNpemVvZih0aGlzLnRhYmxlLCBoYW5kbGUpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlSGVhcChzZXJpYWxpemVkSGVhcDogU2VyaWFsaXplZEhlYXApOiBSdW50aW1lSGVhcCB7XG4gIHJldHVybiBuZXcgUnVudGltZUhlYXBJbXBsKHNlcmlhbGl6ZWRIZWFwKTtcbn1cblxuLyoqXG4gKiBUaGUgSGVhcCBpcyByZXNwb25zaWJsZSBmb3IgZHluYW1pY2FsbHkgYWxsb2NhdGluZ1xuICogbWVtb3J5IGluIHdoaWNoIHdlIHJlYWQvd3JpdGUgdGhlIFZNJ3MgaW5zdHJ1Y3Rpb25zXG4gKiBmcm9tL3RvLiBXaGVuIHdlIG1hbGxvYyB3ZSBwYXNzIG91dCBhIFZNSGFuZGxlLCB3aGljaFxuICogaXMgdXNlZCBhcyBhbiBpbmRpcmVjdCB3YXkgb2YgYWNjZXNzaW5nIHRoZSBtZW1vcnkgZHVyaW5nXG4gKiBleGVjdXRpb24gb2YgdGhlIFZNLiBJbnRlcm5hbGx5IHdlIHRyYWNrIHRoZSBkaWZmZXJlbnRcbiAqIHJlZ2lvbnMgb2YgdGhlIG1lbW9yeSBpbiBhbiBpbnQgYXJyYXkga25vd24gYXMgdGhlIHRhYmxlLlxuICpcbiAqIFRoZSB0YWJsZSAzMi1iaXQgYWxpZ25lZCBhbmQgaGFzIHRoZSBmb2xsb3dpbmcgbGF5b3V0OlxuICpcbiAqIHwgLi4uIHwgaHAgKHUzMikgfCAgICAgICBpbmZvICh1MzIpICAgfCBzaXplICh1MzIpIHxcbiAqIHwgLi4uIHwgIEhhbmRsZSAgfCBTY29wZSBTaXplIHwgU3RhdGUgfCBTaXplICAgICAgIHxcbiAqIHwgLi4uIHwgMzJiaXRzICAgfCAzMGJpdHMgICAgIHwgMmJpdHMgfCAzMmJpdCAgICAgIHxcbiAqXG4gKiBXaXRoIHRoaXMgaW5mb3JtYXRpb24gd2UgZWZmZWN0aXZlbHkgaGF2ZSB0aGUgYWJpbGl0eSB0b1xuICogY29udHJvbCB3aGVuIHdlIHdhbnQgdG8gZnJlZSBtZW1vcnkuIFRoYXQgYmVpbmcgc2FpZCB5b3VcbiAqIGNhbiBub3QgZnJlZSBkdXJpbmcgZXhlY3V0aW9uIGFzIHJhdyBhZGRyZXNzIGFyZSBvbmx5XG4gKiB2YWxpZCBkdXJpbmcgdGhlIGV4ZWN1dGlvbi4gVGhpcyBtZWFucyB5b3UgY2Fubm90IGNsb3NlXG4gKiBvdmVyIHRoZW0gYXMgeW91IHdpbGwgaGF2ZSBhIGJhZCBtZW1vcnkgYWNjZXNzIGV4Y2VwdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEhlYXBJbXBsIGltcGxlbWVudHMgQ29tcGlsZVRpbWVIZWFwLCBSdW50aW1lSGVhcCB7XG4gIG9mZnNldCA9IDA7XG5cbiAgcHJpdmF0ZSBoZWFwOiBJbnQzMkFycmF5O1xuICBwcml2YXRlIGhhbmRsZVRhYmxlOiBudW1iZXJbXTtcbiAgcHJpdmF0ZSBoYW5kbGVTdGF0ZTogVGFibGVTbG90U3RhdGVbXTtcbiAgcHJpdmF0ZSBoYW5kbGUgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGVhcCA9IG5ldyBJbnQzMkFycmF5KFBBR0VfU0laRSk7XG4gICAgdGhpcy5oYW5kbGVUYWJsZSA9IFtdO1xuICAgIHRoaXMuaGFuZGxlU3RhdGUgPSBbXTtcbiAgfVxuXG4gIHB1c2goaXRlbTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zaXplQ2hlY2soKTtcbiAgICB0aGlzLmhlYXBbdGhpcy5vZmZzZXQrK10gPSBpdGVtO1xuICB9XG5cbiAgcHJpdmF0ZSBzaXplQ2hlY2soKSB7XG4gICAgbGV0IHsgaGVhcCB9ID0gdGhpcztcblxuICAgIGlmICh0aGlzLm9mZnNldCA9PT0gdGhpcy5oZWFwLmxlbmd0aCkge1xuICAgICAgbGV0IG5ld0hlYXAgPSBuZXcgSW50MzJBcnJheShoZWFwLmxlbmd0aCArIFBBR0VfU0laRSk7XG4gICAgICBuZXdIZWFwLnNldChoZWFwLCAwKTtcbiAgICAgIHRoaXMuaGVhcCA9IG5ld0hlYXA7XG4gICAgfVxuICB9XG5cbiAgZ2V0YnlhZGRyKGFkZHJlc3M6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuaGVhcFthZGRyZXNzXTtcbiAgfVxuXG4gIHNldGJ5YWRkcihhZGRyZXNzOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmhlYXBbYWRkcmVzc10gPSB2YWx1ZTtcbiAgfVxuXG4gIG1hbGxvYygpOiBudW1iZXIge1xuICAgIC8vIHB1c2ggb2Zmc2V0LCBpbmZvLCBzaXplXG4gICAgdGhpcy5oYW5kbGVUYWJsZS5wdXNoKHRoaXMub2Zmc2V0KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVUYWJsZS5sZW5ndGggLSAxO1xuICB9XG5cbiAgZmluaXNoTWFsbG9jKGhhbmRsZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gQFRPRE86IEF0IHRoZSBtb21lbnQsIGdhcmJhZ2UgY29sbGVjdGlvbiBpc24ndCBhY3R1YWxseSB1c2VkLCBzbyB0aGlzIGlzXG4gICAgLy8gd3JhcHBlZCB0byBwcmV2ZW50IHVzIGZyb20gYWxsb2NhdGluZyBleHRyYSBzcGFjZSBpbiBwcm9kLiBJbiB0aGUgZnV0dXJlLFxuICAgIC8vIGlmIHdlIHN0YXJ0IHVzaW5nIHRoZSBjb21wYWN0IEFQSSwgd2Ugc2hvdWxkIGNoYW5nZSB0aGlzLlxuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgdGhpcy5oYW5kbGVTdGF0ZVtoYW5kbGVdID0gVGFibGVTbG90U3RhdGUuQWxsb2NhdGVkO1xuICAgIH1cbiAgfVxuXG4gIHNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XG4gIH1cblxuICAvLyBJdCBpcyBpbGxlZ2FsIHRvIGNsb3NlIG92ZXIgdGhpcyBhZGRyZXNzLCBhcyBjb21wYWN0aW9uXG4gIC8vIG1heSBtb3ZlIGl0LiBIb3dldmVyLCBpdCBpcyBsZWdhbCB0byB1c2UgdGhpcyBhZGRyZXNzXG4gIC8vIG11bHRpcGxlIHRpbWVzIGJldHdlZW4gY29tcGFjdGlvbnMuXG4gIGdldGFkZHIoaGFuZGxlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVRhYmxlW2hhbmRsZV07XG4gIH1cblxuICBzaXplb2YoaGFuZGxlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBzaXplb2YodGhpcy5oYW5kbGVUYWJsZSwgaGFuZGxlKTtcbiAgfVxuXG4gIGZyZWUoaGFuZGxlOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZVN0YXRlW2hhbmRsZV0gPSBUYWJsZVNsb3RTdGF0ZS5GcmVlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaGVhcCB1c2VzIHRoZSBbTWFyay1Db21wYWN0IEFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFyay1jb21wYWN0X2FsZ29yaXRobSkgdG8gc2hpZnRcbiAgICogcmVhY2hhYmxlIG1lbW9yeSB0byB0aGUgYm90dG9tIG9mIHRoZSBoZWFwIGFuZCBmcmVlYWJsZVxuICAgKiBtZW1vcnkgdG8gdGhlIHRvcCBvZiB0aGUgaGVhcC4gV2hlbiB3ZSBoYXZlIHNoaWZ0ZWQgYWxsXG4gICAqIHRoZSByZWFjaGFibGUgbWVtb3J5IHRvIHRoZSB0b3Agb2YgdGhlIGhlYXAsIHdlIG1vdmUgdGhlXG4gICAqIG9mZnNldCB0byB0aGUgbmV4dCBmcmVlIHBvc2l0aW9uLlxuICAgKi9cbiAgY29tcGFjdCgpOiB2b2lkIHtcbiAgICBsZXQgY29tcGFjdGVkU2l6ZSA9IDA7XG4gICAgbGV0IHsgaGFuZGxlVGFibGUsIGhhbmRsZVN0YXRlLCBoZWFwIH0gPSB0aGlzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG9mZnNldCA9IGhhbmRsZVRhYmxlW2ldO1xuICAgICAgbGV0IHNpemUgPSBoYW5kbGVUYWJsZVtpICsgMV0gLSBvZmZzZXQ7XG4gICAgICBsZXQgc3RhdGUgPSBoYW5kbGVTdGF0ZVtpXTtcblxuICAgICAgaWYgKHN0YXRlID09PSBUYWJsZVNsb3RTdGF0ZS5QdXJnZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBUYWJsZVNsb3RTdGF0ZS5GcmVlZCkge1xuICAgICAgICAvLyB0cmFuc2l0aW9uIHRvIFwiYWxyZWFkeSBmcmVlZFwiIGFrYSBcInB1cmdlZFwiXG4gICAgICAgIC8vIGEgZ29vZCBpbXByb3ZlbWVudCB3b3VsZCBiZSB0byByZXVzZVxuICAgICAgICAvLyB0aGVzZSBzbG90c1xuICAgICAgICBoYW5kbGVTdGF0ZVtpXSA9IFRhYmxlU2xvdFN0YXRlLlB1cmdlZDtcbiAgICAgICAgY29tcGFjdGVkU2l6ZSArPSBzaXplO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gVGFibGVTbG90U3RhdGUuQWxsb2NhdGVkKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBvZmZzZXQ7IGogPD0gaSArIHNpemU7IGorKykge1xuICAgICAgICAgIGhlYXBbaiAtIGNvbXBhY3RlZFNpemVdID0gaGVhcFtqXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZVRhYmxlW2ldID0gb2Zmc2V0IC0gY29tcGFjdGVkU2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFRhYmxlU2xvdFN0YXRlLlBvaW50ZXIpIHtcbiAgICAgICAgaGFuZGxlVGFibGVbaV0gPSBvZmZzZXQgLSBjb21wYWN0ZWRTaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5vZmZzZXQgLSBjb21wYWN0ZWRTaXplO1xuICB9XG5cbiAgY2FwdHVyZShvZmZzZXQgPSB0aGlzLm9mZnNldCk6IFNlcmlhbGl6ZWRIZWFwIHtcbiAgICAvLyBPbmx5IGNhbGxlZCBpbiBlYWdlciBtb2RlXG4gICAgbGV0IGJ1ZmZlciA9IHNsaWNlKHRoaXMuaGVhcCwgMCwgb2Zmc2V0KS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZTogdGhpcy5oYW5kbGUsXG4gICAgICB0YWJsZTogdGhpcy5oYW5kbGVUYWJsZSxcbiAgICAgIGJ1ZmZlcjogYnVmZmVyIGFzIEFycmF5QnVmZmVyLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJ1bnRpbWVQcm9ncmFtSW1wbCBpbXBsZW1lbnRzIFJ1bnRpbWVQcm9ncmFtIHtcbiAgW2tleTogbnVtYmVyXTogbmV2ZXI7XG5cbiAgcHJpdmF0ZSBfb3Bjb2RlOiBSdW50aW1lT3BJbXBsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjb25zdGFudHM6IFJ1bnRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgICBwdWJsaWMgaGVhcDogUnVudGltZUhlYXBcbiAgKSB7XG4gICAgdGhpcy5fb3Bjb2RlID0gbmV3IFJ1bnRpbWVPcEltcGwodGhpcy5oZWFwKTtcbiAgfVxuXG4gIG9wY29kZShvZmZzZXQ6IG51bWJlcik6IFJ1bnRpbWVPcEltcGwge1xuICAgIHRoaXMuX29wY29kZS5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHRoaXMuX29wY29kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzbGljZShhcnI6IEludDMyQXJyYXksIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogSW50MzJBcnJheSB7XG4gIGlmIChhcnIuc2xpY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIH1cblxuICBsZXQgcmV0ID0gbmV3IEludDMyQXJyYXkoZW5kKTtcblxuICBmb3IgKDsgc3RhcnQgPCBlbmQ7IHN0YXJ0KyspIHtcbiAgICByZXRbc3RhcnRdID0gYXJyW3N0YXJ0XTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNpemVvZih0YWJsZTogbnVtYmVyW10sIGhhbmRsZTogbnVtYmVyKSB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIHJldHVybiB0YWJsZVtoYW5kbGUgKyAxXSAtIHRhYmxlW2hhbmRsZV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9