define('@glimmer/program', ['exports', '@glimmer/util', '@glimmer/manager', '@glimmer/opcode-compiler'], function (exports, util, manager, opcodeCompiler) { 'use strict';

  /**
   * Default component template, which is a plain yield
   */
  var DEFAULT_TEMPLATE_BLOCK = [[[18
  /* Yield */
  , 1, null]], ['&default'], false, []];
  var DEFAULT_TEMPLATE = {
    // random uuid
    id: '1b32f5c2-7623-43d6-a0ad-9672898920a1',
    moduleName: '__default__.hbs',
    block: JSON.stringify(DEFAULT_TEMPLATE_BLOCK),
    scope: null,
    isStrictMode: true
  };

  function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
  var WELL_KNOWN_EMPTY_ARRAY = Object.freeze([]);
  var STARTER_CONSTANTS = util.constants(WELL_KNOWN_EMPTY_ARRAY);
  var WELL_KNOWN_EMPTY_ARRAY_POSITION = STARTER_CONSTANTS.indexOf(WELL_KNOWN_EMPTY_ARRAY);
  var CompileTimeConstantImpl = /*#__PURE__*/function () {
    function CompileTimeConstantImpl() {
      // `0` means NULL
      this.values = STARTER_CONSTANTS.slice();
      this.indexMap = new Map(this.values.map(function (value, index) {
        return [value, index];
      }));
    }

    var _proto = CompileTimeConstantImpl.prototype;

    _proto.value = function value(_value) {
      var indexMap = this.indexMap;
      var index = indexMap.get(_value);

      if (index === undefined) {
        index = this.values.push(_value) - 1;
        indexMap.set(_value, index);
      }

      return index;
    };

    _proto.array = function array(values) {
      if (values.length === 0) {
        return WELL_KNOWN_EMPTY_ARRAY_POSITION;
      }

      var handles = new Array(values.length);

      for (var i = 0; i < values.length; i++) {
        handles[i] = this.value(values[i]);
      }

      return this.value(handles);
    };

    _proto.toPool = function toPool() {
      return this.values;
    };

    return CompileTimeConstantImpl;
  }();
  var RuntimeConstantsImpl = /*#__PURE__*/function () {
    function RuntimeConstantsImpl(pool) {
      this.values = pool;
    }

    var _proto2 = RuntimeConstantsImpl.prototype;

    _proto2.getValue = function getValue(handle) {
      return this.values[handle];
    };

    _proto2.getArray = function getArray(value) {
      var handles = this.getValue(value);
      var reified = new Array(handles.length);

      for (var i = 0; i < handles.length; i++) {
        var n = handles[i];
        reified[i] = this.getValue(n);
      }

      return reified;
    };

    return RuntimeConstantsImpl;
  }();
  var ConstantsImpl = /*#__PURE__*/function (_CompileTimeConstantI) {
    _inheritsLoose(ConstantsImpl, _CompileTimeConstantI);

    function ConstantsImpl() {
      var _this$reifiedArrs;

      var _this;

      _this = _CompileTimeConstantI.apply(this, arguments) || this;
      _this.reifiedArrs = (_this$reifiedArrs = {}, _this$reifiedArrs[WELL_KNOWN_EMPTY_ARRAY_POSITION] = WELL_KNOWN_EMPTY_ARRAY, _this$reifiedArrs);
      _this.defaultTemplate = opcodeCompiler.templateFactory(DEFAULT_TEMPLATE)(); // Used for tests and debugging purposes, and to be able to analyze large apps
      // This is why it's enabled even in production

      _this.helperDefinitionCount = 0;
      _this.modifierDefinitionCount = 0;
      _this.componentDefinitionCount = 0;
      _this.helperDefinitionCache = new WeakMap();
      _this.modifierDefinitionCache = new WeakMap();
      _this.componentDefinitionCache = new WeakMap();
      return _this;
    }

    var _proto3 = ConstantsImpl.prototype;

    _proto3.helper = function helper(definitionState, // TODO: Add a way to expose resolved name for debugging
    _resolvedName, isOptional) {

      var handle = this.helperDefinitionCache.get(definitionState);

      if (handle === undefined) {
        var managerOrHelper = manager.getInternalHelperManager(definitionState, isOptional);

        if (managerOrHelper === null) {
          this.helperDefinitionCache.set(definitionState, null);
          return null;
        }
        var helper = typeof managerOrHelper === 'function' ? managerOrHelper : managerOrHelper.getHelper(definitionState);
        handle = this.value(helper);
        this.helperDefinitionCache.set(definitionState, handle);
        this.helperDefinitionCount++;
      }

      return handle;
    };

    _proto3.modifier = function modifier(definitionState, resolvedName, isOptional) {
      if (resolvedName === void 0) {
        resolvedName = null;
      }

      var handle = this.modifierDefinitionCache.get(definitionState);

      if (handle === undefined) {
        var manager$1 = manager.getInternalModifierManager(definitionState, isOptional);

        if (manager$1 === null) {
          this.modifierDefinitionCache.set(definitionState, null);
          return null;
        }

        var definition = {
          resolvedName: resolvedName,
          manager: manager$1,
          state: definitionState
        };
        handle = this.value(definition);
        this.modifierDefinitionCache.set(definitionState, handle);
        this.modifierDefinitionCount++;
      }

      return handle;
    };

    _proto3.component = function component(definitionState, owner, isOptional) {
      var _a;

      var definition = this.componentDefinitionCache.get(definitionState);

      if (definition === undefined) {
        var manager$1 = manager.getInternalComponentManager(definitionState, isOptional);

        if (manager$1 === null) {
          this.componentDefinitionCache.set(definitionState, null);
          return null;
        }
        var capabilities = manager.capabilityFlagsFrom(manager$1.getCapabilities(definitionState));

        var _templateFactory = manager.getComponentTemplate(definitionState);

        var compilable = null;
        var template;

        if (!manager.managerHasCapability(manager$1, capabilities, 1
        /* DynamicLayout */
        )) {
          template = (_a = _templateFactory === null || _templateFactory === void 0 ? void 0 : _templateFactory(owner)) !== null && _a !== void 0 ? _a : this.defaultTemplate;
        } else {
          template = _templateFactory === null || _templateFactory === void 0 ? void 0 : _templateFactory(owner);
        }

        if (template !== undefined) {
          template = util.unwrapTemplate(template);
          compilable = manager.managerHasCapability(manager$1, capabilities, 1024
          /* Wrapped */
          ) ? template.asWrappedLayout() : template.asLayout();
        }

        definition = {
          resolvedName: null,
          handle: -1,
          manager: manager$1,
          capabilities: capabilities,
          state: definitionState,
          compilable: compilable
        };
        definition.handle = this.value(definition);
        this.componentDefinitionCache.set(definitionState, definition);
        this.componentDefinitionCount++;
      }

      return definition;
    };

    _proto3.resolvedComponent = function resolvedComponent(resolvedDefinition, resolvedName) {
      var definition = this.componentDefinitionCache.get(resolvedDefinition);

      if (definition === undefined) {
        var manager$1 = resolvedDefinition.manager,
            state = resolvedDefinition.state,
            template = resolvedDefinition.template;
        var capabilities = manager.capabilityFlagsFrom(manager$1.getCapabilities(resolvedDefinition));
        var compilable = null;

        if (!manager.managerHasCapability(manager$1, capabilities, 1
        /* DynamicLayout */
        )) {
          template = template !== null && template !== void 0 ? template : this.defaultTemplate;
        }

        if (template !== null) {
          template = util.unwrapTemplate(template);
          compilable = manager.managerHasCapability(manager$1, capabilities, 1024
          /* Wrapped */
          ) ? template.asWrappedLayout() : template.asLayout();
        }

        definition = {
          resolvedName: resolvedName,
          handle: -1,
          manager: manager$1,
          capabilities: capabilities,
          state: state,
          compilable: compilable
        };
        definition.handle = this.value(definition);
        this.componentDefinitionCache.set(resolvedDefinition, definition);
        this.componentDefinitionCount++;
      }

      return definition;
    };

    _proto3.getValue = function getValue(index) {
      return this.values[index];
    };

    _proto3.getArray = function getArray(index) {
      var reifiedArrs = this.reifiedArrs;
      var reified = reifiedArrs[index];

      if (reified === undefined) {
        var names = this.getValue(index);
        reified = new Array(names.length);

        for (var i = 0; i < names.length; i++) {
          reified[i] = this.getValue(names[i]);
        }

        reifiedArrs[index] = reified;
      }

      return reified;
    };

    return ConstantsImpl;
  }(CompileTimeConstantImpl);

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  var RuntimeOpImpl = /*#__PURE__*/function () {
    function RuntimeOpImpl(heap) {
      this.heap = heap;
      this.offset = 0;
    }

    _createClass(RuntimeOpImpl, [{
      key: "size",
      get: function get() {
        var rawType = this.heap.getbyaddr(this.offset);
        return ((rawType & 768
        /* OPERAND_LEN_MASK */
        ) >> 8
        /* ARG_SHIFT */
        ) + 1;
      }
    }, {
      key: "isMachine",
      get: function get() {
        var rawType = this.heap.getbyaddr(this.offset);
        return rawType & 1024
        /* MACHINE_MASK */
        ? 1 : 0;
      }
    }, {
      key: "type",
      get: function get() {
        return this.heap.getbyaddr(this.offset) & 255
        /* TYPE_MASK */
        ;
      }
    }, {
      key: "op1",
      get: function get() {
        return this.heap.getbyaddr(this.offset + 1);
      }
    }, {
      key: "op2",
      get: function get() {
        return this.heap.getbyaddr(this.offset + 2);
      }
    }, {
      key: "op3",
      get: function get() {
        return this.heap.getbyaddr(this.offset + 3);
      }
    }]);

    return RuntimeOpImpl;
  }();

  var PAGE_SIZE = 0x100000;
  var RuntimeHeapImpl = /*#__PURE__*/function () {
    function RuntimeHeapImpl(serializedHeap) {
      var buffer = serializedHeap.buffer,
          table = serializedHeap.table;
      this.heap = new Int32Array(buffer);
      this.table = table;
    } // It is illegal to close over this address, as compaction
    // may move it. However, it is legal to use this address
    // multiple times between compactions.


    var _proto = RuntimeHeapImpl.prototype;

    _proto.getaddr = function getaddr(handle) {
      return this.table[handle];
    };

    _proto.getbyaddr = function getbyaddr(address) {
      return this.heap[address];
    };

    _proto.sizeof = function sizeof(handle) {
      return _sizeof(this.table);
    };

    return RuntimeHeapImpl;
  }();
  function hydrateHeap(serializedHeap) {
    return new RuntimeHeapImpl(serializedHeap);
  }
  /**
   * The Heap is responsible for dynamically allocating
   * memory in which we read/write the VM's instructions
   * from/to. When we malloc we pass out a VMHandle, which
   * is used as an indirect way of accessing the memory during
   * execution of the VM. Internally we track the different
   * regions of the memory in an int array known as the table.
   *
   * The table 32-bit aligned and has the following layout:
   *
   * | ... | hp (u32) |       info (u32)   | size (u32) |
   * | ... |  Handle  | Scope Size | State | Size       |
   * | ... | 32bits   | 30bits     | 2bits | 32bit      |
   *
   * With this information we effectively have the ability to
   * control when we want to free memory. That being said you
   * can not free during execution as raw address are only
   * valid during the execution. This means you cannot close
   * over them as you will have a bad memory access exception.
   */

  var HeapImpl = /*#__PURE__*/function () {
    function HeapImpl() {
      this.offset = 0;
      this.handle = 0;
      this.heap = new Int32Array(PAGE_SIZE);
      this.handleTable = [];
      this.handleState = [];
    }

    var _proto2 = HeapImpl.prototype;

    _proto2.push = function push(item) {
      this.sizeCheck();
      this.heap[this.offset++] = item;
    };

    _proto2.sizeCheck = function sizeCheck() {
      var heap = this.heap;

      if (this.offset === this.heap.length) {
        var newHeap = new Int32Array(heap.length + PAGE_SIZE);
        newHeap.set(heap, 0);
        this.heap = newHeap;
      }
    };

    _proto2.getbyaddr = function getbyaddr(address) {
      return this.heap[address];
    };

    _proto2.setbyaddr = function setbyaddr(address, value) {
      this.heap[address] = value;
    };

    _proto2.malloc = function malloc() {
      // push offset, info, size
      this.handleTable.push(this.offset);
      return this.handleTable.length - 1;
    };

    _proto2.finishMalloc = function finishMalloc(handle) {
    };

    _proto2.size = function size() {
      return this.offset;
    } // It is illegal to close over this address, as compaction
    // may move it. However, it is legal to use this address
    // multiple times between compactions.
    ;

    _proto2.getaddr = function getaddr(handle) {
      return this.handleTable[handle];
    };

    _proto2.sizeof = function sizeof(handle) {
      return _sizeof(this.handleTable);
    };

    _proto2.free = function free(handle) {
      this.handleState[handle] = 1
      /* Freed */
      ;
    }
    /**
     * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift
     * reachable memory to the bottom of the heap and freeable
     * memory to the top of the heap. When we have shifted all
     * the reachable memory to the top of the heap, we move the
     * offset to the next free position.
     */
    ;

    _proto2.compact = function compact() {
      var compactedSize = 0;
      var handleTable = this.handleTable,
          handleState = this.handleState,
          heap = this.heap;

      for (var i = 0; i < length; i++) {
        var offset = handleTable[i];
        var size = handleTable[i + 1] - offset;
        var state = handleState[i];

        if (state === 2
        /* Purged */
        ) {
            continue;
          } else if (state === 1
        /* Freed */
        ) {
            // transition to "already freed" aka "purged"
            // a good improvement would be to reuse
            // these slots
            handleState[i] = 2
            /* Purged */
            ;
            compactedSize += size;
          } else if (state === 0
        /* Allocated */
        ) {
            for (var j = offset; j <= i + size; j++) {
              heap[j - compactedSize] = heap[j];
            }

            handleTable[i] = offset - compactedSize;
          } else if (state === 3
        /* Pointer */
        ) {
            handleTable[i] = offset - compactedSize;
          }
      }

      this.offset = this.offset - compactedSize;
    };

    _proto2.capture = function capture(offset) {
      if (offset === void 0) {
        offset = this.offset;
      }

      // Only called in eager mode
      var buffer = slice(this.heap, 0, offset).buffer;
      return {
        handle: this.handle,
        table: this.handleTable,
        buffer: buffer
      };
    };

    return HeapImpl;
  }();
  var RuntimeProgramImpl = /*#__PURE__*/function () {
    function RuntimeProgramImpl(constants, heap) {
      this.constants = constants;
      this.heap = heap;
      this._opcode = new RuntimeOpImpl(this.heap);
    }

    var _proto3 = RuntimeProgramImpl.prototype;

    _proto3.opcode = function opcode(offset) {
      this._opcode.offset = offset;
      return this._opcode;
    };

    return RuntimeProgramImpl;
  }();

  function slice(arr, start, end) {
    if (arr.slice !== undefined) {
      return arr.slice(start, end);
    }

    var ret = new Int32Array(end);

    for (; start < end; start++) {
      ret[start] = arr[start];
    }

    return ret;
  }

  function _sizeof(table, handle) {
    {
      return -1;
    }
  }

  function artifacts() {
    return {
      constants: new ConstantsImpl(),
      heap: new HeapImpl()
    };
  }

  exports.CompileTimeConstantImpl = CompileTimeConstantImpl;
  exports.ConstantsImpl = ConstantsImpl;
  exports.HeapImpl = HeapImpl;
  exports.RuntimeConstantsImpl = RuntimeConstantsImpl;
  exports.RuntimeHeapImpl = RuntimeHeapImpl;
  exports.RuntimeOpImpl = RuntimeOpImpl;
  exports.RuntimeProgramImpl = RuntimeProgramImpl;
  exports.artifacts = artifacts;
  exports.hydrateHeap = hydrateHeap;

  Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci1wcm9ncmFtLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9wcm9ncmFtL2xpYi91dGlsL2RlZmF1bHQtdGVtcGxhdGUudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9wcm9ncmFtL2xpYi9jb25zdGFudHMudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9wcm9ncmFtL2xpYi9vcGNvZGUudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9wcm9ncmFtL2xpYi9wcm9ncmFtLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvcHJvZ3JhbS9saWIvaGVscGVycy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBTZXJpYWxpemVkVGVtcGxhdGVCbG9jayxcbiAgU2VyaWFsaXplZFRlbXBsYXRlV2l0aExhenlCbG9jayxcbiAgU2V4cE9wY29kZXMsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuXG4vKipcbiAqIERlZmF1bHQgY29tcG9uZW50IHRlbXBsYXRlLCB3aGljaCBpcyBhIHBsYWluIHlpZWxkXG4gKi9cbmNvbnN0IERFRkFVTFRfVEVNUExBVEVfQkxPQ0s6IFNlcmlhbGl6ZWRUZW1wbGF0ZUJsb2NrID0gW1xuICBbW1NleHBPcGNvZGVzLllpZWxkLCAxLCBudWxsXV0sXG4gIFsnJmRlZmF1bHQnXSxcbiAgZmFsc2UsXG4gIFtdLFxuXTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVEVNUExBVEU6IFNlcmlhbGl6ZWRUZW1wbGF0ZVdpdGhMYXp5QmxvY2sgPSB7XG4gIC8vIHJhbmRvbSB1dWlkXG4gIGlkOiAnMWIzMmY1YzItNzYyMy00M2Q2LWEwYWQtOTY3Mjg5ODkyMGExJyxcbiAgbW9kdWxlTmFtZTogJ19fZGVmYXVsdF9fLmhicycsXG4gIGJsb2NrOiBKU09OLnN0cmluZ2lmeShERUZBVUxUX1RFTVBMQVRFX0JMT0NLKSxcbiAgc2NvcGU6IG51bGwsXG4gIGlzU3RyaWN0TW9kZTogdHJ1ZSxcbn07XG4iLCJpbXBvcnQge1xuICBDb21waWxlVGltZUNvbnN0YW50cyxcbiAgQ29tcG9uZW50RGVmaW5pdGlvblN0YXRlLFxuICBDb25zdGFudFBvb2wsXG4gIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eSxcbiAgQ29tcG9uZW50RGVmaW5pdGlvbixcbiAgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG4gIFJlc29sdmVkQ29tcG9uZW50RGVmaW5pdGlvbixcbiAgUnVudGltZUNvbnN0YW50cyxcbiAgTW9kaWZpZXJEZWZpbml0aW9uU3RhdGUsXG4gIEhlbHBlckRlZmluaXRpb25TdGF0ZSxcbiAgVGVtcGxhdGUsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0LCBjb25zdGFudHMsIGV4cGVjdCwgdW53cmFwVGVtcGxhdGUgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7XG4gIGNhcGFiaWxpdHlGbGFnc0Zyb20sXG4gIGdldENvbXBvbmVudFRlbXBsYXRlLFxuICBnZXRJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIsXG4gIGdldEludGVybmFsSGVscGVyTWFuYWdlcixcbiAgZ2V0SW50ZXJuYWxNb2RpZmllck1hbmFnZXIsXG4gIG1hbmFnZXJIYXNDYXBhYmlsaXR5LFxufSBmcm9tICdAZ2xpbW1lci9tYW5hZ2VyJztcbmltcG9ydCB7IHRlbXBsYXRlRmFjdG9yeSB9IGZyb20gJ0BnbGltbWVyL29wY29kZS1jb21waWxlcic7XG5pbXBvcnQgeyBERUZBVUxUX1RFTVBMQVRFIH0gZnJvbSAnLi91dGlsL2RlZmF1bHQtdGVtcGxhdGUnO1xuXG5jb25zdCBXRUxMX0tOT1dOX0VNUFRZX0FSUkFZOiB1bmtub3duID0gT2JqZWN0LmZyZWV6ZShbXSk7XG5jb25zdCBTVEFSVEVSX0NPTlNUQU5UUyA9IGNvbnN0YW50cyhXRUxMX0tOT1dOX0VNUFRZX0FSUkFZKTtcbmNvbnN0IFdFTExfS05PV05fRU1QVFlfQVJSQVlfUE9TSVRJT046IG51bWJlciA9IFNUQVJURVJfQ09OU1RBTlRTLmluZGV4T2YoV0VMTF9LTk9XTl9FTVBUWV9BUlJBWSk7XG5cbmV4cG9ydCBjbGFzcyBDb21waWxlVGltZUNvbnN0YW50SW1wbCBpbXBsZW1lbnRzIENvbXBpbGVUaW1lQ29uc3RhbnRzIHtcbiAgLy8gYDBgIG1lYW5zIE5VTExcblxuICBwcm90ZWN0ZWQgdmFsdWVzOiB1bmtub3duW10gPSBTVEFSVEVSX0NPTlNUQU5UUy5zbGljZSgpO1xuICBwcm90ZWN0ZWQgaW5kZXhNYXA6IE1hcDx1bmtub3duLCBudW1iZXI+ID0gbmV3IE1hcChcbiAgICB0aGlzLnZhbHVlcy5tYXAoKHZhbHVlLCBpbmRleCkgPT4gW3ZhbHVlLCBpbmRleF0pXG4gICk7XG5cbiAgdmFsdWUodmFsdWU6IHVua25vd24pIHtcbiAgICBsZXQgaW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwO1xuICAgIGxldCBpbmRleCA9IGluZGV4TWFwLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5kZXggPSB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKSAtIDE7XG4gICAgICBpbmRleE1hcC5zZXQodmFsdWUsIGluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICBhcnJheSh2YWx1ZXM6IHVua25vd25bXSk6IG51bWJlciB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBXRUxMX0tOT1dOX0VNUFRZX0FSUkFZX1BPU0lUSU9OO1xuICAgIH1cblxuICAgIGxldCBoYW5kbGVzOiBudW1iZXJbXSA9IG5ldyBBcnJheSh2YWx1ZXMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYW5kbGVzW2ldID0gdGhpcy52YWx1ZSh2YWx1ZXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnZhbHVlKGhhbmRsZXMpO1xuICB9XG5cbiAgdG9Qb29sKCk6IENvbnN0YW50UG9vbCB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVzO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBSdW50aW1lQ29uc3RhbnRzSW1wbCBpbXBsZW1lbnRzIFJ1bnRpbWVDb25zdGFudHMge1xuICBwcm90ZWN0ZWQgdmFsdWVzOiB1bmtub3duW107XG5cbiAgY29uc3RydWN0b3IocG9vbDogQ29uc3RhbnRQb29sKSB7XG4gICAgdGhpcy52YWx1ZXMgPSBwb29sO1xuICB9XG5cbiAgZ2V0VmFsdWU8VD4oaGFuZGxlOiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbaGFuZGxlXSBhcyBUO1xuICB9XG5cbiAgZ2V0QXJyYXk8VD4odmFsdWU6IG51bWJlcik6IFRbXSB7XG4gICAgbGV0IGhhbmRsZXMgPSB0aGlzLmdldFZhbHVlKHZhbHVlKSBhcyBudW1iZXJbXTtcbiAgICBsZXQgcmVpZmllZDogVFtdID0gbmV3IEFycmF5KGhhbmRsZXMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFuZGxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG4gPSBoYW5kbGVzW2ldO1xuICAgICAgcmVpZmllZFtpXSA9IHRoaXMuZ2V0VmFsdWUobik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlaWZpZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIENvbnN0YW50c0ltcGxcbiAgZXh0ZW5kcyBDb21waWxlVGltZUNvbnN0YW50SW1wbFxuICBpbXBsZW1lbnRzIFJ1bnRpbWVDb25zdGFudHMsIFJlc29sdXRpb25UaW1lQ29uc3RhbnRzIHtcbiAgcHJvdGVjdGVkIHJlaWZpZWRBcnJzOiB7IFtrZXk6IG51bWJlcl06IHVua25vd25bXSB9ID0ge1xuICAgIFtXRUxMX0tOT1dOX0VNUFRZX0FSUkFZX1BPU0lUSU9OXTogV0VMTF9LTk9XTl9FTVBUWV9BUlJBWSBhcyB1bmtub3duW10sXG4gIH07XG5cbiAgZGVmYXVsdFRlbXBsYXRlOiBUZW1wbGF0ZSA9IHRlbXBsYXRlRmFjdG9yeShERUZBVUxUX1RFTVBMQVRFKSgpO1xuXG4gIC8vIFVzZWQgZm9yIHRlc3RzIGFuZCBkZWJ1Z2dpbmcgcHVycG9zZXMsIGFuZCB0byBiZSBhYmxlIHRvIGFuYWx5emUgbGFyZ2UgYXBwc1xuICAvLyBUaGlzIGlzIHdoeSBpdCdzIGVuYWJsZWQgZXZlbiBpbiBwcm9kdWN0aW9uXG4gIGhlbHBlckRlZmluaXRpb25Db3VudCA9IDA7XG4gIG1vZGlmaWVyRGVmaW5pdGlvbkNvdW50ID0gMDtcbiAgY29tcG9uZW50RGVmaW5pdGlvbkNvdW50ID0gMDtcblxuICBwcml2YXRlIGhlbHBlckRlZmluaXRpb25DYWNoZSA9IG5ldyBXZWFrTWFwPEhlbHBlckRlZmluaXRpb25TdGF0ZSwgbnVtYmVyIHwgbnVsbD4oKTtcblxuICBwcml2YXRlIG1vZGlmaWVyRGVmaW5pdGlvbkNhY2hlID0gbmV3IFdlYWtNYXA8TW9kaWZpZXJEZWZpbml0aW9uU3RhdGUsIG51bWJlciB8IG51bGw+KCk7XG5cbiAgcHJpdmF0ZSBjb21wb25lbnREZWZpbml0aW9uQ2FjaGUgPSBuZXcgV2Vha01hcDxcbiAgICBDb21wb25lbnREZWZpbml0aW9uU3RhdGUgfCBSZXNvbHZlZENvbXBvbmVudERlZmluaXRpb24sXG4gICAgQ29tcG9uZW50RGVmaW5pdGlvbiB8IG51bGxcbiAgPigpO1xuXG4gIGhlbHBlcihcbiAgICBkZWZpbml0aW9uU3RhdGU6IEhlbHBlckRlZmluaXRpb25TdGF0ZSxcblxuICAgIC8vIFRPRE86IEFkZCBhIHdheSB0byBleHBvc2UgcmVzb2x2ZWQgbmFtZSBmb3IgZGVidWdnaW5nXG4gICAgX3Jlc29sdmVkTmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgICBpc09wdGlvbmFsOiB0cnVlXG4gICk6IG51bWJlciB8IG51bGw7XG4gIGhlbHBlcihcbiAgICBkZWZpbml0aW9uU3RhdGU6IEhlbHBlckRlZmluaXRpb25TdGF0ZSxcblxuICAgIC8vIFRPRE86IEFkZCBhIHdheSB0byBleHBvc2UgcmVzb2x2ZWQgbmFtZSBmb3IgZGVidWdnaW5nXG4gICAgX3Jlc29sdmVkTmFtZT86IHN0cmluZyB8IG51bGxcbiAgKTogbnVtYmVyO1xuICBoZWxwZXIoXG4gICAgZGVmaW5pdGlvblN0YXRlOiBIZWxwZXJEZWZpbml0aW9uU3RhdGUsXG5cbiAgICAvLyBUT0RPOiBBZGQgYSB3YXkgdG8gZXhwb3NlIHJlc29sdmVkIG5hbWUgZm9yIGRlYnVnZ2luZ1xuICAgIF9yZXNvbHZlZE5hbWU6IHN0cmluZyB8IG51bGwgPSBudWxsLFxuICAgIGlzT3B0aW9uYWw/OiB0cnVlXG4gICk6IG51bWJlciB8IG51bGwge1xuICAgIGxldCBoYW5kbGUgPSB0aGlzLmhlbHBlckRlZmluaXRpb25DYWNoZS5nZXQoZGVmaW5pdGlvblN0YXRlKTtcblxuICAgIGlmIChoYW5kbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IG1hbmFnZXJPckhlbHBlciA9IGdldEludGVybmFsSGVscGVyTWFuYWdlcihkZWZpbml0aW9uU3RhdGUsIGlzT3B0aW9uYWwpO1xuXG4gICAgICBpZiAobWFuYWdlck9ySGVscGVyID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaGVscGVyRGVmaW5pdGlvbkNhY2hlLnNldChkZWZpbml0aW9uU3RhdGUsIG51bGwpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KG1hbmFnZXJPckhlbHBlciwgJ0JVRzogZXhwZWN0ZWQgbWFuYWdlciBvciBoZWxwZXInKTtcblxuICAgICAgbGV0IGhlbHBlciA9XG4gICAgICAgIHR5cGVvZiBtYW5hZ2VyT3JIZWxwZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IG1hbmFnZXJPckhlbHBlclxuICAgICAgICAgIDogbWFuYWdlck9ySGVscGVyLmdldEhlbHBlcihkZWZpbml0aW9uU3RhdGUpO1xuXG4gICAgICBoYW5kbGUgPSB0aGlzLnZhbHVlKGhlbHBlcik7XG5cbiAgICAgIHRoaXMuaGVscGVyRGVmaW5pdGlvbkNhY2hlLnNldChkZWZpbml0aW9uU3RhdGUsIGhhbmRsZSk7XG4gICAgICB0aGlzLmhlbHBlckRlZmluaXRpb25Db3VudCsrO1xuICAgIH1cblxuICAgIHJldHVybiBoYW5kbGU7XG4gIH1cblxuICBtb2RpZmllcihcbiAgICBkZWZpbml0aW9uU3RhdGU6IE1vZGlmaWVyRGVmaW5pdGlvblN0YXRlLFxuICAgIHJlc29sdmVkTmFtZTogc3RyaW5nIHwgbnVsbCxcbiAgICBpc09wdGlvbmFsOiB0cnVlXG4gICk6IG51bWJlciB8IG51bGw7XG4gIG1vZGlmaWVyKGRlZmluaXRpb25TdGF0ZTogTW9kaWZpZXJEZWZpbml0aW9uU3RhdGUsIHJlc29sdmVkTmFtZT86IHN0cmluZyB8IG51bGwpOiBudW1iZXI7XG4gIG1vZGlmaWVyKFxuICAgIGRlZmluaXRpb25TdGF0ZTogTW9kaWZpZXJEZWZpbml0aW9uU3RhdGUsXG4gICAgcmVzb2x2ZWROYW1lOiBzdHJpbmcgfCBudWxsID0gbnVsbCxcbiAgICBpc09wdGlvbmFsPzogdHJ1ZVxuICApOiBudW1iZXIgfCBudWxsIHtcbiAgICBsZXQgaGFuZGxlID0gdGhpcy5tb2RpZmllckRlZmluaXRpb25DYWNoZS5nZXQoZGVmaW5pdGlvblN0YXRlKTtcblxuICAgIGlmIChoYW5kbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IG1hbmFnZXIgPSBnZXRJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcihkZWZpbml0aW9uU3RhdGUsIGlzT3B0aW9uYWwpO1xuXG4gICAgICBpZiAobWFuYWdlciA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLm1vZGlmaWVyRGVmaW5pdGlvbkNhY2hlLnNldChkZWZpbml0aW9uU3RhdGUsIG51bGwpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbGV0IGRlZmluaXRpb24gPSB7XG4gICAgICAgIHJlc29sdmVkTmFtZSxcbiAgICAgICAgbWFuYWdlcixcbiAgICAgICAgc3RhdGU6IGRlZmluaXRpb25TdGF0ZSxcbiAgICAgIH07XG5cbiAgICAgIGhhbmRsZSA9IHRoaXMudmFsdWUoZGVmaW5pdGlvbik7XG5cbiAgICAgIHRoaXMubW9kaWZpZXJEZWZpbml0aW9uQ2FjaGUuc2V0KGRlZmluaXRpb25TdGF0ZSwgaGFuZGxlKTtcbiAgICAgIHRoaXMubW9kaWZpZXJEZWZpbml0aW9uQ291bnQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlO1xuICB9XG5cbiAgY29tcG9uZW50KGRlZmluaXRpb25TdGF0ZTogQ29tcG9uZW50RGVmaW5pdGlvblN0YXRlLCBvd25lcjogb2JqZWN0KTogQ29tcG9uZW50RGVmaW5pdGlvbjtcbiAgY29tcG9uZW50KFxuICAgIGRlZmluaXRpb25TdGF0ZTogQ29tcG9uZW50RGVmaW5pdGlvblN0YXRlLFxuICAgIG93bmVyOiBvYmplY3QsXG4gICAgaXNPcHRpb25hbD86IHRydWVcbiAgKTogQ29tcG9uZW50RGVmaW5pdGlvbiB8IG51bGwge1xuICAgIGxldCBkZWZpbml0aW9uID0gdGhpcy5jb21wb25lbnREZWZpbml0aW9uQ2FjaGUuZ2V0KGRlZmluaXRpb25TdGF0ZSk7XG5cbiAgICBpZiAoZGVmaW5pdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgbWFuYWdlciA9IGdldEludGVybmFsQ29tcG9uZW50TWFuYWdlcihkZWZpbml0aW9uU3RhdGUsIGlzT3B0aW9uYWwpO1xuXG4gICAgICBpZiAobWFuYWdlciA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudERlZmluaXRpb25DYWNoZS5zZXQoZGVmaW5pdGlvblN0YXRlLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGFzc2VydChtYW5hZ2VyLCAnQlVHOiBleHBlY3RlZCBtYW5hZ2VyJyk7XG5cbiAgICAgIGxldCBjYXBhYmlsaXRpZXMgPSBjYXBhYmlsaXR5RmxhZ3NGcm9tKG1hbmFnZXIuZ2V0Q2FwYWJpbGl0aWVzKGRlZmluaXRpb25TdGF0ZSkpO1xuXG4gICAgICBsZXQgdGVtcGxhdGVGYWN0b3J5ID0gZ2V0Q29tcG9uZW50VGVtcGxhdGUoZGVmaW5pdGlvblN0YXRlKTtcblxuICAgICAgbGV0IGNvbXBpbGFibGUgPSBudWxsO1xuICAgICAgbGV0IHRlbXBsYXRlO1xuXG4gICAgICBpZiAoIW1hbmFnZXJIYXNDYXBhYmlsaXR5KG1hbmFnZXIsIGNhcGFiaWxpdGllcywgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LkR5bmFtaWNMYXlvdXQpKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGVGYWN0b3J5Py4ob3duZXIpID8/IHRoaXMuZGVmYXVsdFRlbXBsYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZUZhY3Rvcnk/Lihvd25lcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZW1wbGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRlbXBsYXRlID0gdW53cmFwVGVtcGxhdGUodGVtcGxhdGUpO1xuXG4gICAgICAgIGNvbXBpbGFibGUgPSBtYW5hZ2VySGFzQ2FwYWJpbGl0eShcbiAgICAgICAgICBtYW5hZ2VyLFxuICAgICAgICAgIGNhcGFiaWxpdGllcyxcbiAgICAgICAgICBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuV3JhcHBlZFxuICAgICAgICApXG4gICAgICAgICAgPyB0ZW1wbGF0ZS5hc1dyYXBwZWRMYXlvdXQoKVxuICAgICAgICAgIDogdGVtcGxhdGUuYXNMYXlvdXQoKTtcbiAgICAgIH1cblxuICAgICAgZGVmaW5pdGlvbiA9IHtcbiAgICAgICAgcmVzb2x2ZWROYW1lOiBudWxsLFxuICAgICAgICBoYW5kbGU6IC0xLCAvLyByZXBsYWNlZCBtb21lbnRhcmlseVxuICAgICAgICBtYW5hZ2VyLFxuICAgICAgICBjYXBhYmlsaXRpZXMsXG4gICAgICAgIHN0YXRlOiBkZWZpbml0aW9uU3RhdGUsXG4gICAgICAgIGNvbXBpbGFibGUsXG4gICAgICB9O1xuXG4gICAgICBkZWZpbml0aW9uIS5oYW5kbGUgPSB0aGlzLnZhbHVlKGRlZmluaXRpb24pO1xuICAgICAgdGhpcy5jb21wb25lbnREZWZpbml0aW9uQ2FjaGUuc2V0KGRlZmluaXRpb25TdGF0ZSwgZGVmaW5pdGlvbik7XG4gICAgICB0aGlzLmNvbXBvbmVudERlZmluaXRpb25Db3VudCsrO1xuICAgIH1cblxuICAgIHJldHVybiBkZWZpbml0aW9uO1xuICB9XG5cbiAgcmVzb2x2ZWRDb21wb25lbnQoXG4gICAgcmVzb2x2ZWREZWZpbml0aW9uOiBSZXNvbHZlZENvbXBvbmVudERlZmluaXRpb24sXG4gICAgcmVzb2x2ZWROYW1lOiBzdHJpbmdcbiAgKTogQ29tcG9uZW50RGVmaW5pdGlvbiB7XG4gICAgbGV0IGRlZmluaXRpb24gPSB0aGlzLmNvbXBvbmVudERlZmluaXRpb25DYWNoZS5nZXQocmVzb2x2ZWREZWZpbml0aW9uKTtcblxuICAgIGlmIChkZWZpbml0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCB7IG1hbmFnZXIsIHN0YXRlLCB0ZW1wbGF0ZSB9ID0gcmVzb2x2ZWREZWZpbml0aW9uO1xuICAgICAgbGV0IGNhcGFiaWxpdGllcyA9IGNhcGFiaWxpdHlGbGFnc0Zyb20obWFuYWdlci5nZXRDYXBhYmlsaXRpZXMocmVzb2x2ZWREZWZpbml0aW9uKSk7XG5cbiAgICAgIGxldCBjb21waWxhYmxlID0gbnVsbDtcblxuICAgICAgaWYgKCFtYW5hZ2VySGFzQ2FwYWJpbGl0eShtYW5hZ2VyLCBjYXBhYmlsaXRpZXMsIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5EeW5hbWljTGF5b3V0KSkge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlID8/IHRoaXMuZGVmYXVsdFRlbXBsYXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGVtcGxhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB1bndyYXBUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG5cbiAgICAgICAgY29tcGlsYWJsZSA9IG1hbmFnZXJIYXNDYXBhYmlsaXR5KFxuICAgICAgICAgIG1hbmFnZXIsXG4gICAgICAgICAgY2FwYWJpbGl0aWVzLFxuICAgICAgICAgIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5XcmFwcGVkXG4gICAgICAgIClcbiAgICAgICAgICA/IHRlbXBsYXRlLmFzV3JhcHBlZExheW91dCgpXG4gICAgICAgICAgOiB0ZW1wbGF0ZS5hc0xheW91dCgpO1xuICAgICAgfVxuXG4gICAgICBkZWZpbml0aW9uID0ge1xuICAgICAgICByZXNvbHZlZE5hbWUsXG4gICAgICAgIGhhbmRsZTogLTEsIC8vIHJlcGxhY2VkIG1vbWVudGFyaWx5XG4gICAgICAgIG1hbmFnZXIsXG4gICAgICAgIGNhcGFiaWxpdGllcyxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIGNvbXBpbGFibGUsXG4gICAgICB9O1xuXG4gICAgICBkZWZpbml0aW9uIS5oYW5kbGUgPSB0aGlzLnZhbHVlKGRlZmluaXRpb24pO1xuICAgICAgdGhpcy5jb21wb25lbnREZWZpbml0aW9uQ2FjaGUuc2V0KHJlc29sdmVkRGVmaW5pdGlvbiwgZGVmaW5pdGlvbik7XG4gICAgICB0aGlzLmNvbXBvbmVudERlZmluaXRpb25Db3VudCsrO1xuICAgIH1cblxuICAgIHJldHVybiBleHBlY3QoZGVmaW5pdGlvbiwgJ0JVRzogcmVzb2x2ZWQgY29tcG9uZW50IGRlZmluaXRpb25zIGNhbm5vdCBiZSBudWxsJyk7XG4gIH1cblxuICBnZXRWYWx1ZTxUPihpbmRleDogbnVtYmVyKSB7XG4gICAgYXNzZXJ0KGluZGV4ID49IDAsIGBjYW5ub3QgZ2V0IHZhbHVlIGZvciBoYW5kbGU6ICR7aW5kZXh9YCk7XG5cbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbaW5kZXhdIGFzIFQ7XG4gIH1cblxuICBnZXRBcnJheTxUPihpbmRleDogbnVtYmVyKTogVFtdIHtcbiAgICBsZXQgcmVpZmllZEFycnMgPSB0aGlzLnJlaWZpZWRBcnJzO1xuICAgIGxldCByZWlmaWVkID0gcmVpZmllZEFycnNbaW5kZXhdIGFzIFRbXTtcblxuICAgIGlmIChyZWlmaWVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBuYW1lczogbnVtYmVyW10gPSB0aGlzLmdldFZhbHVlKGluZGV4KTtcbiAgICAgIHJlaWZpZWQgPSBuZXcgQXJyYXkobmFtZXMubGVuZ3RoKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZWlmaWVkW2ldID0gdGhpcy5nZXRWYWx1ZShuYW1lc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJlaWZpZWRBcnJzW2luZGV4XSA9IHJlaWZpZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlaWZpZWQ7XG4gIH1cbn1cbiIsImltcG9ydCB7IE9wY29kZVNpemUsIFJ1bnRpbWVPcCwgT3Bjb2RlSGVhcCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuXG5leHBvcnQgY2xhc3MgUnVudGltZU9wSW1wbCBpbXBsZW1lbnRzIFJ1bnRpbWVPcCB7XG4gIHB1YmxpYyBvZmZzZXQgPSAwO1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBoZWFwOiBPcGNvZGVIZWFwKSB7fVxuXG4gIGdldCBzaXplKCkge1xuICAgIGxldCByYXdUeXBlID0gdGhpcy5oZWFwLmdldGJ5YWRkcih0aGlzLm9mZnNldCk7XG4gICAgcmV0dXJuICgocmF3VHlwZSAmIE9wY29kZVNpemUuT1BFUkFORF9MRU5fTUFTSykgPj4gT3Bjb2RlU2l6ZS5BUkdfU0hJRlQpICsgMTtcbiAgfVxuXG4gIGdldCBpc01hY2hpbmUoKTogMCB8IDEge1xuICAgIGxldCByYXdUeXBlID0gdGhpcy5oZWFwLmdldGJ5YWRkcih0aGlzLm9mZnNldCk7XG4gICAgcmV0dXJuIHJhd1R5cGUgJiBPcGNvZGVTaXplLk1BQ0hJTkVfTUFTSyA/IDEgOiAwO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhcC5nZXRieWFkZHIodGhpcy5vZmZzZXQpICYgT3Bjb2RlU2l6ZS5UWVBFX01BU0s7XG4gIH1cblxuICBnZXQgb3AxKCkge1xuICAgIHJldHVybiB0aGlzLmhlYXAuZ2V0YnlhZGRyKHRoaXMub2Zmc2V0ICsgMSk7XG4gIH1cblxuICBnZXQgb3AyKCkge1xuICAgIHJldHVybiB0aGlzLmhlYXAuZ2V0YnlhZGRyKHRoaXMub2Zmc2V0ICsgMik7XG4gIH1cblxuICBnZXQgb3AzKCkge1xuICAgIHJldHVybiB0aGlzLmhlYXAuZ2V0YnlhZGRyKHRoaXMub2Zmc2V0ICsgMyk7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIENvbXBpbGVUaW1lSGVhcCxcbiAgU2VyaWFsaXplZEhlYXAsXG4gIFJ1bnRpbWVIZWFwLFxuICBTdGRMaWJPcGVyYW5kLFxuICBSdW50aW1lQ29uc3RhbnRzLFxuICBSdW50aW1lUHJvZ3JhbSxcbiAgUmVzb2x1dGlvblRpbWVDb25zdGFudHMsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgTE9DQUxfREVCVUcgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBSdW50aW1lT3BJbXBsIH0gZnJvbSAnLi9vcGNvZGUnO1xuaW1wb3J0IHsgYXNzZXJ0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmNvbnN0IGVudW0gVGFibGVTbG90U3RhdGUge1xuICBBbGxvY2F0ZWQsXG4gIEZyZWVkLFxuICBQdXJnZWQsXG4gIFBvaW50ZXIsXG59XG5cbmV4cG9ydCB0eXBlIFBsYWNlaG9sZGVyID0gW251bWJlciwgKCkgPT4gbnVtYmVyXTtcbmV4cG9ydCB0eXBlIFN0ZGxpYlBsYWNlaG9sZGVyID0gW251bWJlciwgU3RkTGliT3BlcmFuZF07XG5cbmNvbnN0IFBBR0VfU0laRSA9IDB4MTAwMDAwO1xuXG5leHBvcnQgY2xhc3MgUnVudGltZUhlYXBJbXBsIGltcGxlbWVudHMgUnVudGltZUhlYXAge1xuICBwcml2YXRlIGhlYXA6IEludDMyQXJyYXk7XG4gIHByaXZhdGUgdGFibGU6IG51bWJlcltdO1xuXG4gIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZWRIZWFwOiBTZXJpYWxpemVkSGVhcCkge1xuICAgIGxldCB7IGJ1ZmZlciwgdGFibGUgfSA9IHNlcmlhbGl6ZWRIZWFwO1xuICAgIHRoaXMuaGVhcCA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlcik7XG4gICAgdGhpcy50YWJsZSA9IHRhYmxlO1xuICB9XG5cbiAgLy8gSXQgaXMgaWxsZWdhbCB0byBjbG9zZSBvdmVyIHRoaXMgYWRkcmVzcywgYXMgY29tcGFjdGlvblxuICAvLyBtYXkgbW92ZSBpdC4gSG93ZXZlciwgaXQgaXMgbGVnYWwgdG8gdXNlIHRoaXMgYWRkcmVzc1xuICAvLyBtdWx0aXBsZSB0aW1lcyBiZXR3ZWVuIGNvbXBhY3Rpb25zLlxuICBnZXRhZGRyKGhhbmRsZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZVtoYW5kbGVdO1xuICB9XG5cbiAgZ2V0YnlhZGRyKGFkZHJlc3M6IG51bWJlcik6IG51bWJlciB7XG4gICAgYXNzZXJ0KHRoaXMuaGVhcFthZGRyZXNzXSAhPT0gdW5kZWZpbmVkLCAnQWNjZXNzIG1lbW9yeSBvdXQgb2YgYm91bmRzIG9mIHRoZSBoZWFwJyk7XG4gICAgcmV0dXJuIHRoaXMuaGVhcFthZGRyZXNzXTtcbiAgfVxuXG4gIHNpemVvZihoYW5kbGU6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHNpemVvZih0aGlzLnRhYmxlLCBoYW5kbGUpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlSGVhcChzZXJpYWxpemVkSGVhcDogU2VyaWFsaXplZEhlYXApOiBSdW50aW1lSGVhcCB7XG4gIHJldHVybiBuZXcgUnVudGltZUhlYXBJbXBsKHNlcmlhbGl6ZWRIZWFwKTtcbn1cblxuLyoqXG4gKiBUaGUgSGVhcCBpcyByZXNwb25zaWJsZSBmb3IgZHluYW1pY2FsbHkgYWxsb2NhdGluZ1xuICogbWVtb3J5IGluIHdoaWNoIHdlIHJlYWQvd3JpdGUgdGhlIFZNJ3MgaW5zdHJ1Y3Rpb25zXG4gKiBmcm9tL3RvLiBXaGVuIHdlIG1hbGxvYyB3ZSBwYXNzIG91dCBhIFZNSGFuZGxlLCB3aGljaFxuICogaXMgdXNlZCBhcyBhbiBpbmRpcmVjdCB3YXkgb2YgYWNjZXNzaW5nIHRoZSBtZW1vcnkgZHVyaW5nXG4gKiBleGVjdXRpb24gb2YgdGhlIFZNLiBJbnRlcm5hbGx5IHdlIHRyYWNrIHRoZSBkaWZmZXJlbnRcbiAqIHJlZ2lvbnMgb2YgdGhlIG1lbW9yeSBpbiBhbiBpbnQgYXJyYXkga25vd24gYXMgdGhlIHRhYmxlLlxuICpcbiAqIFRoZSB0YWJsZSAzMi1iaXQgYWxpZ25lZCBhbmQgaGFzIHRoZSBmb2xsb3dpbmcgbGF5b3V0OlxuICpcbiAqIHwgLi4uIHwgaHAgKHUzMikgfCAgICAgICBpbmZvICh1MzIpICAgfCBzaXplICh1MzIpIHxcbiAqIHwgLi4uIHwgIEhhbmRsZSAgfCBTY29wZSBTaXplIHwgU3RhdGUgfCBTaXplICAgICAgIHxcbiAqIHwgLi4uIHwgMzJiaXRzICAgfCAzMGJpdHMgICAgIHwgMmJpdHMgfCAzMmJpdCAgICAgIHxcbiAqXG4gKiBXaXRoIHRoaXMgaW5mb3JtYXRpb24gd2UgZWZmZWN0aXZlbHkgaGF2ZSB0aGUgYWJpbGl0eSB0b1xuICogY29udHJvbCB3aGVuIHdlIHdhbnQgdG8gZnJlZSBtZW1vcnkuIFRoYXQgYmVpbmcgc2FpZCB5b3VcbiAqIGNhbiBub3QgZnJlZSBkdXJpbmcgZXhlY3V0aW9uIGFzIHJhdyBhZGRyZXNzIGFyZSBvbmx5XG4gKiB2YWxpZCBkdXJpbmcgdGhlIGV4ZWN1dGlvbi4gVGhpcyBtZWFucyB5b3UgY2Fubm90IGNsb3NlXG4gKiBvdmVyIHRoZW0gYXMgeW91IHdpbGwgaGF2ZSBhIGJhZCBtZW1vcnkgYWNjZXNzIGV4Y2VwdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEhlYXBJbXBsIGltcGxlbWVudHMgQ29tcGlsZVRpbWVIZWFwLCBSdW50aW1lSGVhcCB7XG4gIG9mZnNldCA9IDA7XG5cbiAgcHJpdmF0ZSBoZWFwOiBJbnQzMkFycmF5O1xuICBwcml2YXRlIGhhbmRsZVRhYmxlOiBudW1iZXJbXTtcbiAgcHJpdmF0ZSBoYW5kbGVTdGF0ZTogVGFibGVTbG90U3RhdGVbXTtcbiAgcHJpdmF0ZSBoYW5kbGUgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGVhcCA9IG5ldyBJbnQzMkFycmF5KFBBR0VfU0laRSk7XG4gICAgdGhpcy5oYW5kbGVUYWJsZSA9IFtdO1xuICAgIHRoaXMuaGFuZGxlU3RhdGUgPSBbXTtcbiAgfVxuXG4gIHB1c2goaXRlbTogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zaXplQ2hlY2soKTtcbiAgICB0aGlzLmhlYXBbdGhpcy5vZmZzZXQrK10gPSBpdGVtO1xuICB9XG5cbiAgcHJpdmF0ZSBzaXplQ2hlY2soKSB7XG4gICAgbGV0IHsgaGVhcCB9ID0gdGhpcztcblxuICAgIGlmICh0aGlzLm9mZnNldCA9PT0gdGhpcy5oZWFwLmxlbmd0aCkge1xuICAgICAgbGV0IG5ld0hlYXAgPSBuZXcgSW50MzJBcnJheShoZWFwLmxlbmd0aCArIFBBR0VfU0laRSk7XG4gICAgICBuZXdIZWFwLnNldChoZWFwLCAwKTtcbiAgICAgIHRoaXMuaGVhcCA9IG5ld0hlYXA7XG4gICAgfVxuICB9XG5cbiAgZ2V0YnlhZGRyKGFkZHJlc3M6IG51bWJlcik6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuaGVhcFthZGRyZXNzXTtcbiAgfVxuXG4gIHNldGJ5YWRkcihhZGRyZXNzOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLmhlYXBbYWRkcmVzc10gPSB2YWx1ZTtcbiAgfVxuXG4gIG1hbGxvYygpOiBudW1iZXIge1xuICAgIC8vIHB1c2ggb2Zmc2V0LCBpbmZvLCBzaXplXG4gICAgdGhpcy5oYW5kbGVUYWJsZS5wdXNoKHRoaXMub2Zmc2V0KTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVUYWJsZS5sZW5ndGggLSAxO1xuICB9XG5cbiAgZmluaXNoTWFsbG9jKGhhbmRsZTogbnVtYmVyKTogdm9pZCB7XG4gICAgLy8gQFRPRE86IEF0IHRoZSBtb21lbnQsIGdhcmJhZ2UgY29sbGVjdGlvbiBpc24ndCBhY3R1YWxseSB1c2VkLCBzbyB0aGlzIGlzXG4gICAgLy8gd3JhcHBlZCB0byBwcmV2ZW50IHVzIGZyb20gYWxsb2NhdGluZyBleHRyYSBzcGFjZSBpbiBwcm9kLiBJbiB0aGUgZnV0dXJlLFxuICAgIC8vIGlmIHdlIHN0YXJ0IHVzaW5nIHRoZSBjb21wYWN0IEFQSSwgd2Ugc2hvdWxkIGNoYW5nZSB0aGlzLlxuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgdGhpcy5oYW5kbGVTdGF0ZVtoYW5kbGVdID0gVGFibGVTbG90U3RhdGUuQWxsb2NhdGVkO1xuICAgIH1cbiAgfVxuXG4gIHNpemUoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5vZmZzZXQ7XG4gIH1cblxuICAvLyBJdCBpcyBpbGxlZ2FsIHRvIGNsb3NlIG92ZXIgdGhpcyBhZGRyZXNzLCBhcyBjb21wYWN0aW9uXG4gIC8vIG1heSBtb3ZlIGl0LiBIb3dldmVyLCBpdCBpcyBsZWdhbCB0byB1c2UgdGhpcyBhZGRyZXNzXG4gIC8vIG11bHRpcGxlIHRpbWVzIGJldHdlZW4gY29tcGFjdGlvbnMuXG4gIGdldGFkZHIoaGFuZGxlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZVRhYmxlW2hhbmRsZV07XG4gIH1cblxuICBzaXplb2YoaGFuZGxlOiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBzaXplb2YodGhpcy5oYW5kbGVUYWJsZSwgaGFuZGxlKTtcbiAgfVxuXG4gIGZyZWUoaGFuZGxlOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmhhbmRsZVN0YXRlW2hhbmRsZV0gPSBUYWJsZVNsb3RTdGF0ZS5GcmVlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgaGVhcCB1c2VzIHRoZSBbTWFyay1Db21wYWN0IEFsZ29yaXRobV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFyay1jb21wYWN0X2FsZ29yaXRobSkgdG8gc2hpZnRcbiAgICogcmVhY2hhYmxlIG1lbW9yeSB0byB0aGUgYm90dG9tIG9mIHRoZSBoZWFwIGFuZCBmcmVlYWJsZVxuICAgKiBtZW1vcnkgdG8gdGhlIHRvcCBvZiB0aGUgaGVhcC4gV2hlbiB3ZSBoYXZlIHNoaWZ0ZWQgYWxsXG4gICAqIHRoZSByZWFjaGFibGUgbWVtb3J5IHRvIHRoZSB0b3Agb2YgdGhlIGhlYXAsIHdlIG1vdmUgdGhlXG4gICAqIG9mZnNldCB0byB0aGUgbmV4dCBmcmVlIHBvc2l0aW9uLlxuICAgKi9cbiAgY29tcGFjdCgpOiB2b2lkIHtcbiAgICBsZXQgY29tcGFjdGVkU2l6ZSA9IDA7XG4gICAgbGV0IHsgaGFuZGxlVGFibGUsIGhhbmRsZVN0YXRlLCBoZWFwIH0gPSB0aGlzO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG9mZnNldCA9IGhhbmRsZVRhYmxlW2ldO1xuICAgICAgbGV0IHNpemUgPSBoYW5kbGVUYWJsZVtpICsgMV0gLSBvZmZzZXQ7XG4gICAgICBsZXQgc3RhdGUgPSBoYW5kbGVTdGF0ZVtpXTtcblxuICAgICAgaWYgKHN0YXRlID09PSBUYWJsZVNsb3RTdGF0ZS5QdXJnZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlID09PSBUYWJsZVNsb3RTdGF0ZS5GcmVlZCkge1xuICAgICAgICAvLyB0cmFuc2l0aW9uIHRvIFwiYWxyZWFkeSBmcmVlZFwiIGFrYSBcInB1cmdlZFwiXG4gICAgICAgIC8vIGEgZ29vZCBpbXByb3ZlbWVudCB3b3VsZCBiZSB0byByZXVzZVxuICAgICAgICAvLyB0aGVzZSBzbG90c1xuICAgICAgICBoYW5kbGVTdGF0ZVtpXSA9IFRhYmxlU2xvdFN0YXRlLlB1cmdlZDtcbiAgICAgICAgY29tcGFjdGVkU2l6ZSArPSBzaXplO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gVGFibGVTbG90U3RhdGUuQWxsb2NhdGVkKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBvZmZzZXQ7IGogPD0gaSArIHNpemU7IGorKykge1xuICAgICAgICAgIGhlYXBbaiAtIGNvbXBhY3RlZFNpemVdID0gaGVhcFtqXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZVRhYmxlW2ldID0gb2Zmc2V0IC0gY29tcGFjdGVkU2l6ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09IFRhYmxlU2xvdFN0YXRlLlBvaW50ZXIpIHtcbiAgICAgICAgaGFuZGxlVGFibGVbaV0gPSBvZmZzZXQgLSBjb21wYWN0ZWRTaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub2Zmc2V0ID0gdGhpcy5vZmZzZXQgLSBjb21wYWN0ZWRTaXplO1xuICB9XG5cbiAgY2FwdHVyZShvZmZzZXQgPSB0aGlzLm9mZnNldCk6IFNlcmlhbGl6ZWRIZWFwIHtcbiAgICAvLyBPbmx5IGNhbGxlZCBpbiBlYWdlciBtb2RlXG4gICAgbGV0IGJ1ZmZlciA9IHNsaWNlKHRoaXMuaGVhcCwgMCwgb2Zmc2V0KS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhbmRsZTogdGhpcy5oYW5kbGUsXG4gICAgICB0YWJsZTogdGhpcy5oYW5kbGVUYWJsZSxcbiAgICAgIGJ1ZmZlcjogYnVmZmVyIGFzIEFycmF5QnVmZmVyLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJ1bnRpbWVQcm9ncmFtSW1wbCBpbXBsZW1lbnRzIFJ1bnRpbWVQcm9ncmFtIHtcbiAgW2tleTogbnVtYmVyXTogbmV2ZXI7XG5cbiAgcHJpdmF0ZSBfb3Bjb2RlOiBSdW50aW1lT3BJbXBsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjb25zdGFudHM6IFJ1bnRpbWVDb25zdGFudHMgJiBSZXNvbHV0aW9uVGltZUNvbnN0YW50cyxcbiAgICBwdWJsaWMgaGVhcDogUnVudGltZUhlYXBcbiAgKSB7XG4gICAgdGhpcy5fb3Bjb2RlID0gbmV3IFJ1bnRpbWVPcEltcGwodGhpcy5oZWFwKTtcbiAgfVxuXG4gIG9wY29kZShvZmZzZXQ6IG51bWJlcik6IFJ1bnRpbWVPcEltcGwge1xuICAgIHRoaXMuX29wY29kZS5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHRoaXMuX29wY29kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzbGljZShhcnI6IEludDMyQXJyYXksIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyKTogSW50MzJBcnJheSB7XG4gIGlmIChhcnIuc2xpY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIH1cblxuICBsZXQgcmV0ID0gbmV3IEludDMyQXJyYXkoZW5kKTtcblxuICBmb3IgKDsgc3RhcnQgPCBlbmQ7IHN0YXJ0KyspIHtcbiAgICByZXRbc3RhcnRdID0gYXJyW3N0YXJ0XTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNpemVvZih0YWJsZTogbnVtYmVyW10sIGhhbmRsZTogbnVtYmVyKSB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIHJldHVybiB0YWJsZVtoYW5kbGUgKyAxXSAtIHRhYmxlW2hhbmRsZV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG59XG4iLCJpbXBvcnQgeyBDb21waWxlVGltZUFydGlmYWN0cywgUnVudGltZUFydGlmYWN0cyB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgQ29uc3RhbnRzSW1wbCB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IEhlYXBJbXBsIH0gZnJvbSAnLi9wcm9ncmFtJztcblxuZXhwb3J0IGZ1bmN0aW9uIGFydGlmYWN0cygpOiBDb21waWxlVGltZUFydGlmYWN0cyAmIFJ1bnRpbWVBcnRpZmFjdHMge1xuICByZXR1cm4ge1xuICAgIGNvbnN0YW50czogbmV3IENvbnN0YW50c0ltcGwoKSxcbiAgICBoZWFwOiBuZXcgSGVhcEltcGwoKSxcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJjb25zdGFudHMiLCJ0ZW1wbGF0ZUZhY3RvcnkiLCJnZXRJbnRlcm5hbEhlbHBlck1hbmFnZXIiLCJtYW5hZ2VyIiwiZ2V0SW50ZXJuYWxNb2RpZmllck1hbmFnZXIiLCJnZXRJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIiLCJjYXBhYmlsaXR5RmxhZ3NGcm9tIiwiZ2V0Q29tcG9uZW50VGVtcGxhdGUiLCJtYW5hZ2VySGFzQ2FwYWJpbGl0eSIsInVud3JhcFRlbXBsYXRlIl0sIm1hcHBpbmdzIjoiOztFQU1BOzs7RUFHQSxJQUFNLHNCQUFzQixHQUE0QixDQUN0RCxDQUFDLENBQUE7RUFBQTtFQUFBLEVBQUEsQ0FBQSxFQURxRCxJQUNyRCxDQUFELENBRHNELEVBRXRELENBRnNELFVBRXRELENBRnNELEVBQUEsS0FBQSxFQUF4RCxFQUF3RCxDQUF4RDtFQU9PLElBQU0sZ0JBQWdCLEdBQW9DO0VBQy9EO0VBQ0EsRUFBQSxFQUFFLEVBRjZELHNDQUFBO0VBRy9ELEVBQUEsVUFBVSxFQUhxRCxpQkFBQTtFQUkvRCxFQUFBLEtBQUssRUFBRSxJQUFJLENBQUosU0FBQSxDQUp3RCxzQkFJeEQsQ0FKd0Q7RUFLL0QsRUFBQSxLQUFLLEVBTDBELElBQUE7RUFNL0QsRUFBQSxZQUFZLEVBQUU7RUFOaUQsQ0FBMUQ7OztFQ1NQLElBQU0sc0JBQXNCLEdBQVksTUFBTSxDQUFOLE1BQUEsQ0FBeEMsRUFBd0MsQ0FBeEM7RUFDQSxJQUFNLGlCQUFpQixHQUFHQSxjQUFTLENBQW5DLHNCQUFtQyxDQUFuQztFQUNBLElBQU0sK0JBQStCLEdBQVcsaUJBQWlCLENBQWpCLE9BQUEsQ0FBaEQsc0JBQWdELENBQWhEO0FBRUEsTUFBTSx1QkFBTjtFQUFBLHFDQUFBO0VBQ0U7RUFFVSxTQUFBLE1BQUEsR0FBb0IsaUJBQWlCLENBQXJDLEtBQW9CLEVBQXBCO0VBQ0EsU0FBQSxRQUFB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
