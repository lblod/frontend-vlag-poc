import { DEBUG } from '@glimmer/env';
import { valueForRef } from '@glimmer/reference';
import { HAS_NATIVE_PROXY } from '@glimmer/util';
import { track } from '@glimmer/validator';
var CUSTOM_TAG_FOR = new WeakMap();
export function getCustomTagFor(obj) {
  return CUSTOM_TAG_FOR.get(obj);
}
export function setCustomTagFor(obj, customTagFn) {
  CUSTOM_TAG_FOR.set(obj, customTagFn);
}

function convertToInt(prop) {
  if (typeof prop === 'symbol') return null;
  var num = Number(prop);
  if (isNaN(num)) return null;
  return num % 1 === 0 ? num : null;
}

function tagForNamedArg(namedArgs, key) {
  return track(function () {
    if (key in namedArgs) {
      valueForRef(namedArgs[key]);
    }
  });
}

function tagForPositionalArg(positionalArgs, key) {
  return track(function () {
    if (key === '[]') {
      // consume all of the tags in the positional array
      positionalArgs.forEach(valueForRef);
    }

    var parsed = convertToInt(key);

    if (parsed !== null && parsed < positionalArgs.length) {
      // consume the tag of the referenced index
      valueForRef(positionalArgs[parsed]);
    }
  });
}

export var argsProxyFor;

var NamedArgsProxy = /*#__PURE__*/function () {
  function NamedArgsProxy(named) {
    this.named = named;
  }

  var _proto = NamedArgsProxy.prototype;

  _proto.get = function get(_target, prop) {
    var ref = this.named[prop];

    if (ref !== undefined) {
      return valueForRef(ref);
    }
  };

  _proto.has = function has(_target, prop) {
    return prop in this.named;
  };

  _proto.ownKeys = function ownKeys() {
    return Object.keys(this.named);
  };

  _proto.isExtensible = function isExtensible() {
    return false;
  };

  _proto.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(_target, prop) {
    if (DEBUG && !(prop in this.named)) {
      throw new Error("args proxies do not have real property descriptors, so you should never need to call getOwnPropertyDescriptor yourself. This code exists for enumerability, such as in for-in loops and Object.keys(). Attempted to get the descriptor for `" + String(prop) + "`");
    }

    return {
      enumerable: true,
      configurable: true
    };
  };

  return NamedArgsProxy;
}();

var PositionalArgsProxy = /*#__PURE__*/function () {
  function PositionalArgsProxy(positional) {
    this.positional = positional;
  }

  var _proto2 = PositionalArgsProxy.prototype;

  _proto2.get = function get(target, prop) {
    var positional = this.positional;

    if (prop === 'length') {
      return positional.length;
    }

    var parsed = convertToInt(prop);

    if (parsed !== null && parsed < positional.length) {
      return valueForRef(positional[parsed]);
    }

    return target[prop];
  };

  _proto2.isExtensible = function isExtensible() {
    return false;
  };

  _proto2.has = function has(_target, prop) {
    var parsed = convertToInt(prop);
    return parsed !== null && parsed < this.positional.length;
  };

  return PositionalArgsProxy;
}();

if (HAS_NATIVE_PROXY) {
  argsProxyFor = function argsProxyFor(capturedArgs, type) {
    var named = capturedArgs.named,
        positional = capturedArgs.positional;

    var getNamedTag = function getNamedTag(_obj, key) {
      return tagForNamedArg(named, key);
    };

    var getPositionalTag = function getPositionalTag(_obj, key) {
      return tagForPositionalArg(positional, key);
    };

    var namedHandler = new NamedArgsProxy(named);
    var positionalHandler = new PositionalArgsProxy(positional);
    var namedTarget = Object.create(null);
    var positionalTarget = [];

    if (DEBUG) {
      var setHandler = function setHandler(_target, prop) {
        throw new Error("You attempted to set " + String(prop) + " on the arguments of a component, helper, or modifier. Arguments are immutable and cannot be updated directly; they always represent the values that are passed down. If you want to set default values, you should use a getter and local tracked state instead.");
      };

      var forInDebugHandler = function forInDebugHandler() {
        throw new Error("Object.keys() was called on the positional arguments array for a " + type + ", which is not supported. This function is a low-level function that should not need to be called for positional argument arrays. You may be attempting to iterate over the array using for...in instead of for...of.");
      };

      namedHandler.set = setHandler;
      positionalHandler.set = setHandler;
      positionalHandler.ownKeys = forInDebugHandler;
    }

    var namedProxy = new Proxy(namedTarget, namedHandler);
    var positionalProxy = new Proxy(positionalTarget, positionalHandler);
    setCustomTagFor(namedProxy, getNamedTag);
    setCustomTagFor(positionalProxy, getPositionalTag);
    return {
      named: namedProxy,
      positional: positionalProxy
    };
  };
} else {
  argsProxyFor = function argsProxyFor(capturedArgs, _type) {
    var named = capturedArgs.named,
        positional = capturedArgs.positional;

    var getNamedTag = function getNamedTag(_obj, key) {
      return tagForNamedArg(named, key);
    };

    var getPositionalTag = function getPositionalTag(_obj, key) {
      return tagForPositionalArg(positional, key);
    };

    var namedProxy = {};
    var positionalProxy = [];
    setCustomTagFor(namedProxy, getNamedTag);
    setCustomTagFor(positionalProxy, getPositionalTag);
    Object.keys(named).forEach(function (name) {
      Object.defineProperty(namedProxy, name, {
        enumerable: true,
        configurable: true,
        get: function get() {
          return valueForRef(named[name]);
        }
      });
    });
    positional.forEach(function (ref, index) {
      Object.defineProperty(positionalProxy, index, {
        enumerable: true,
        configurable: true,
        get: function get() {
          return valueForRef(ref);
        }
      });
    });

    if (DEBUG) {
      // Prevent mutations in development mode. This will not prevent the
      // proxy from updating, but will prevent assigning new values or pushing
      // for instance.
      Object.freeze(namedProxy);
      Object.freeze(positionalProxy);
    }

    return {
      named: namedProxy,
      positional: positionalProxy
    };
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL3V0aWwvYXJncy1wcm94eS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFBLEtBQUEsUUFBQSxjQUFBO0FBT0EsU0FBQSxXQUFBLFFBQUEsb0JBQUE7QUFDQSxTQUFBLGdCQUFBLFFBQUEsZUFBQTtBQUNBLFNBQUEsS0FBQSxRQUFBLG9CQUFBO0FBRUEsSUFBTSxjQUFjLEdBQUcsSUFBdkIsT0FBdUIsRUFBdkI7QUFFQSxPQUFNLFNBQUEsZUFBQSxDQUFBLEdBQUEsRUFBcUM7QUFDekMsU0FBTyxjQUFjLENBQWQsR0FBQSxDQUFQLEdBQU8sQ0FBUDtBQUNEO0FBRUQsT0FBTSxTQUFBLGVBQUEsQ0FBQSxHQUFBLEVBQUEsV0FBQSxFQUFxRjtBQUN6RixFQUFBLGNBQWMsQ0FBZCxHQUFBLENBQUEsR0FBQSxFQUFBLFdBQUE7QUFDRDs7QUFFRCxTQUFBLFlBQUEsQ0FBQSxJQUFBLEVBQW9EO0FBQ2xELE1BQUksT0FBQSxJQUFBLEtBQUosUUFBQSxFQUE4QixPQUFBLElBQUE7QUFFOUIsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFsQixJQUFrQixDQUFsQjtBQUVBLE1BQUksS0FBSyxDQUFULEdBQVMsQ0FBVCxFQUFnQixPQUFBLElBQUE7QUFFaEIsU0FBTyxHQUFHLEdBQUgsQ0FBQSxLQUFBLENBQUEsR0FBQSxHQUFBLEdBQVAsSUFBQTtBQUNEOztBQUVELFNBQUEsY0FBQSxDQUFBLFNBQUEsRUFBQSxHQUFBLEVBQXNFO0FBQ3BFLFNBQU8sS0FBSyxDQUFDLFlBQUs7QUFDaEIsUUFBSSxHQUFHLElBQVAsU0FBQSxFQUFzQjtBQUNwQixNQUFBLFdBQVcsQ0FBQyxTQUFTLENBQXJCLEdBQXFCLENBQVYsQ0FBWDtBQUNEO0FBSEgsR0FBWSxDQUFaO0FBS0Q7O0FBRUQsU0FBQSxtQkFBQSxDQUFBLGNBQUEsRUFBQSxHQUFBLEVBQXFGO0FBQ25GLFNBQU8sS0FBSyxDQUFD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QUEsRUFBQSxLQUFBLEVBQThDO0FBQzVDLFFBQUEsVUFBVSxFQURrQyxJQUFBO0FBRTVDLFFBQUEsWUFBWSxFQUZnQyxJQUFBO0FBRzVDLFFBQUEsR0FINEMsaUJBR3pDO0FBQ0QsaUJBQU8sV0FBVyxDQUFsQixHQUFrQixDQUFsQjtBQUNEO0FBTDJDLE9BQTlDO0FBREYsS0FBQTs7QUFVQSxRQUFBLEtBQUEsRUFBVztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQUEsTUFBTSxDQUFOLE1BQUEsQ0FBQSxVQUFBO0FBQ0EsTUFBQSxNQUFNLENBQU4sTUFBQSxDQUFBLGVBQUE7QUFDRDs7QUFFRCxXQUFPO0FBQ0wsTUFBQSxLQUFLLEVBREEsVUFBQTtBQUVMLE1BQUEsVUFBVSxFQUFFO0FBRlAsS0FBUDtBQXhDRixHQUFBO0FBNkNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHtcbiAgQXJndW1lbnRzLFxuICBDYXB0dXJlZEFyZ3VtZW50cyxcbiAgQ2FwdHVyZWROYW1lZEFyZ3VtZW50cyxcbiAgQ2FwdHVyZWRQb3NpdGlvbmFsQXJndW1lbnRzLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFJlZmVyZW5jZSwgdmFsdWVGb3JSZWYgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgSEFTX05BVElWRV9QUk9YWSB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgVGFnLCB0cmFjayB9IGZyb20gJ0BnbGltbWVyL3ZhbGlkYXRvcic7XG5cbmNvbnN0IENVU1RPTV9UQUdfRk9SID0gbmV3IFdlYWtNYXA8b2JqZWN0LCAob2JqOiBvYmplY3QsIGtleTogc3RyaW5nKSA9PiBUYWc+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXN0b21UYWdGb3Iob2JqOiBvYmplY3QpOiAoKG9iajogb2JqZWN0LCBrZXk6IHN0cmluZykgPT4gVGFnKSB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiBDVVNUT01fVEFHX0ZPUi5nZXQob2JqKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEN1c3RvbVRhZ0ZvcihvYmo6IG9iamVjdCwgY3VzdG9tVGFnRm46IChvYmo6IG9iamVjdCwga2V5OiBzdHJpbmcpID0+IFRhZykge1xuICBDVVNUT01fVEFHX0ZPUi5zZXQob2JqLCBjdXN0b21UYWdGbik7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb0ludChwcm9wOiBudW1iZXIgfCBzdHJpbmcgfCBzeW1ib2wpOiBudW1iZXIgfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3ltYm9sJykgcmV0dXJuIG51bGw7XG5cbiAgY29uc3QgbnVtID0gTnVtYmVyKHByb3ApO1xuXG4gIGlmIChpc05hTihudW0pKSByZXR1cm4gbnVsbDtcblxuICByZXR1cm4gbnVtICUgMSA9PT0gMCA/IG51bSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHRhZ0Zvck5hbWVkQXJnKG5hbWVkQXJnczogQ2FwdHVyZWROYW1lZEFyZ3VtZW50cywga2V5OiBzdHJpbmcpOiBUYWcge1xuICByZXR1cm4gdHJhY2soKCkgPT4ge1xuICAgIGlmIChrZXkgaW4gbmFtZWRBcmdzKSB7XG4gICAgICB2YWx1ZUZvclJlZihuYW1lZEFyZ3Nba2V5XSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdGFnRm9yUG9zaXRpb25hbEFyZyhwb3NpdGlvbmFsQXJnczogQ2FwdHVyZWRQb3NpdGlvbmFsQXJndW1lbnRzLCBrZXk6IHN0cmluZyk6IFRhZyB7XG4gIHJldHVybiB0cmFjaygoKSA9PiB7XG4gICAgaWYgKGtleSA9PT0gJ1tdJykge1xuICAgICAgLy8gY29uc3VtZSBhbGwgb2YgdGhlIHRhZ3MgaW4gdGhlIHBvc2l0aW9uYWwgYXJyYXlcbiAgICAgIHBvc2l0aW9uYWxBcmdzLmZvckVhY2godmFsdWVGb3JSZWYpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlZCA9IGNvbnZlcnRUb0ludChrZXkpO1xuXG4gICAgaWYgKHBhcnNlZCAhPT0gbnVsbCAmJiBwYXJzZWQgPCBwb3NpdGlvbmFsQXJncy5sZW5ndGgpIHtcbiAgICAgIC8vIGNvbnN1bWUgdGhlIHRhZyBvZiB0aGUgcmVmZXJlbmNlZCBpbmRleFxuICAgICAgdmFsdWVGb3JSZWYocG9zaXRpb25hbEFyZ3NbcGFyc2VkXSk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGxldCBhcmdzUHJveHlGb3I6IChcbiAgY2FwdHVyZWRBcmdzOiBDYXB0dXJlZEFyZ3VtZW50cyxcbiAgdHlwZTogJ2NvbXBvbmVudCcgfCAnaGVscGVyJyB8ICdtb2RpZmllcidcbikgPT4gQXJndW1lbnRzO1xuXG5jbGFzcyBOYW1lZEFyZ3NQcm94eSBpbXBsZW1lbnRzIFByb3h5SGFuZGxlcjx7fT4ge1xuICBkZWNsYXJlIHNldD86ICh0YXJnZXQ6IHt9LCBwcm9wOiBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpID0+IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBuYW1lZDogQ2FwdHVyZWROYW1lZEFyZ3VtZW50cykge31cblxuICBnZXQoX3RhcmdldDoge30sIHByb3A6IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCkge1xuICAgIGNvbnN0IHJlZiA9IHRoaXMubmFtZWRbcHJvcCBhcyBzdHJpbmddO1xuXG4gICAgaWYgKHJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdmFsdWVGb3JSZWYocmVmKTtcbiAgICB9XG4gIH1cblxuICBoYXMoX3RhcmdldDoge30sIHByb3A6IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wIGluIHRoaXMubmFtZWQ7XG4gIH1cblxuICBvd25LZXlzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm5hbWVkKTtcbiAgfVxuXG4gIGlzRXh0ZW5zaWJsZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoX3RhcmdldDoge30sIHByb3A6IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCkge1xuICAgIGlmIChERUJVRyAmJiAhKHByb3AgaW4gdGhpcy5uYW1lZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYGFyZ3MgcHJveGllcyBkbyBub3QgaGF2ZSByZWFsIHByb3BlcnR5IGRlc2NyaXB0b3JzLCBzbyB5b3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gY2FsbCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgeW91cnNlbGYuIFRoaXMgY29kZSBleGlzdHMgZm9yIGVudW1lcmFiaWxpdHksIHN1Y2ggYXMgaW4gZm9yLWluIGxvb3BzIGFuZCBPYmplY3Qua2V5cygpLiBBdHRlbXB0ZWQgdG8gZ2V0IHRoZSBkZXNjcmlwdG9yIGZvciBcXGAke1N0cmluZyhcbiAgICAgICAgICBwcm9wXG4gICAgICAgICl9XFxgYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9O1xuICB9XG59XG5cbmNsYXNzIFBvc2l0aW9uYWxBcmdzUHJveHkgaW1wbGVtZW50cyBQcm94eUhhbmRsZXI8W10+IHtcbiAgZGVjbGFyZSBzZXQ/OiAodGFyZ2V0OiBbXSwgcHJvcDogc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sKSA9PiBib29sZWFuO1xuICBkZWNsYXJlIG93bktleXM/OiAodGFyZ2V0OiBbXSkgPT4gc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwb3NpdGlvbmFsOiBDYXB0dXJlZFBvc2l0aW9uYWxBcmd1bWVudHMpIHt9XG5cbiAgZ2V0KHRhcmdldDogW10sIHByb3A6IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCkge1xuICAgIGxldCB7IHBvc2l0aW9uYWwgfSA9IHRoaXM7XG5cbiAgICBpZiAocHJvcCA9PT0gJ2xlbmd0aCcpIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbmFsLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWQgPSBjb252ZXJ0VG9JbnQocHJvcCk7XG5cbiAgICBpZiAocGFyc2VkICE9PSBudWxsICYmIHBhcnNlZCA8IHBvc2l0aW9uYWwubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdmFsdWVGb3JSZWYocG9zaXRpb25hbFtwYXJzZWRdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHRhcmdldCBhcyBhbnkpW3Byb3BdO1xuICB9XG5cbiAgaXNFeHRlbnNpYmxlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhcyhfdGFyZ2V0OiBbXSwgcHJvcDogc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sKSB7XG4gICAgY29uc3QgcGFyc2VkID0gY29udmVydFRvSW50KHByb3ApO1xuXG4gICAgcmV0dXJuIHBhcnNlZCAhPT0gbnVsbCAmJiBwYXJzZWQgPCB0aGlzLnBvc2l0aW9uYWwubGVuZ3RoO1xuICB9XG59XG5cbmlmIChIQVNfTkFUSVZFX1BST1hZKSB7XG4gIGFyZ3NQcm94eUZvciA9IChjYXB0dXJlZEFyZ3MsIHR5cGUpID0+IHtcbiAgICBjb25zdCB7IG5hbWVkLCBwb3NpdGlvbmFsIH0gPSBjYXB0dXJlZEFyZ3M7XG5cbiAgICBsZXQgZ2V0TmFtZWRUYWcgPSAoX29iajogb2JqZWN0LCBrZXk6IHN0cmluZykgPT4gdGFnRm9yTmFtZWRBcmcobmFtZWQsIGtleSk7XG4gICAgbGV0IGdldFBvc2l0aW9uYWxUYWcgPSAoX29iajogb2JqZWN0LCBrZXk6IHN0cmluZykgPT4gdGFnRm9yUG9zaXRpb25hbEFyZyhwb3NpdGlvbmFsLCBrZXkpO1xuXG4gICAgY29uc3QgbmFtZWRIYW5kbGVyID0gbmV3IE5hbWVkQXJnc1Byb3h5KG5hbWVkKTtcbiAgICBjb25zdCBwb3NpdGlvbmFsSGFuZGxlciA9IG5ldyBQb3NpdGlvbmFsQXJnc1Byb3h5KHBvc2l0aW9uYWwpO1xuXG4gICAgY29uc3QgbmFtZWRUYXJnZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IHBvc2l0aW9uYWxUYXJnZXQ6IHVua25vd25bXSA9IFtdO1xuXG4gICAgaWYgKERFQlVHKSB7XG4gICAgICBjb25zdCBzZXRIYW5kbGVyID0gZnVuY3Rpb24gKF90YXJnZXQ6IHVua25vd24sIHByb3A6IHN5bWJvbCB8IHN0cmluZyB8IG51bWJlcik6IG5ldmVyIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBZb3UgYXR0ZW1wdGVkIHRvIHNldCAke1N0cmluZyhcbiAgICAgICAgICAgIHByb3BcbiAgICAgICAgICApfSBvbiB0aGUgYXJndW1lbnRzIG9mIGEgY29tcG9uZW50LCBoZWxwZXIsIG9yIG1vZGlmaWVyLiBBcmd1bWVudHMgYXJlIGltbXV0YWJsZSBhbmQgY2Fubm90IGJlIHVwZGF0ZWQgZGlyZWN0bHk7IHRoZXkgYWx3YXlzIHJlcHJlc2VudCB0aGUgdmFsdWVzIHRoYXQgYXJlIHBhc3NlZCBkb3duLiBJZiB5b3Ugd2FudCB0byBzZXQgZGVmYXVsdCB2YWx1ZXMsIHlvdSBzaG91bGQgdXNlIGEgZ2V0dGVyIGFuZCBsb2NhbCB0cmFja2VkIHN0YXRlIGluc3RlYWQuYFxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZm9ySW5EZWJ1Z0hhbmRsZXIgPSAoKTogbmV2ZXIgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYE9iamVjdC5rZXlzKCkgd2FzIGNhbGxlZCBvbiB0aGUgcG9zaXRpb25hbCBhcmd1bWVudHMgYXJyYXkgZm9yIGEgJHt0eXBlfSwgd2hpY2ggaXMgbm90IHN1cHBvcnRlZC4gVGhpcyBmdW5jdGlvbiBpcyBhIGxvdy1sZXZlbCBmdW5jdGlvbiB0aGF0IHNob3VsZCBub3QgbmVlZCB0byBiZSBjYWxsZWQgZm9yIHBvc2l0aW9uYWwgYXJndW1lbnQgYXJyYXlzLiBZb3UgbWF5IGJlIGF0dGVtcHRpbmcgdG8gaXRlcmF0ZSBvdmVyIHRoZSBhcnJheSB1c2luZyBmb3IuLi5pbiBpbnN0ZWFkIG9mIGZvci4uLm9mLmBcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIG5hbWVkSGFuZGxlci5zZXQgPSBzZXRIYW5kbGVyO1xuICAgICAgcG9zaXRpb25hbEhhbmRsZXIuc2V0ID0gc2V0SGFuZGxlcjtcbiAgICAgIHBvc2l0aW9uYWxIYW5kbGVyLm93bktleXMgPSBmb3JJbkRlYnVnSGFuZGxlcjtcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lZFByb3h5ID0gbmV3IFByb3h5KG5hbWVkVGFyZ2V0LCBuYW1lZEhhbmRsZXIpO1xuICAgIGNvbnN0IHBvc2l0aW9uYWxQcm94eSA9IG5ldyBQcm94eShwb3NpdGlvbmFsVGFyZ2V0LCBwb3NpdGlvbmFsSGFuZGxlcik7XG5cbiAgICBzZXRDdXN0b21UYWdGb3IobmFtZWRQcm94eSwgZ2V0TmFtZWRUYWcpO1xuICAgIHNldEN1c3RvbVRhZ0Zvcihwb3NpdGlvbmFsUHJveHksIGdldFBvc2l0aW9uYWxUYWcpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVkOiBuYW1lZFByb3h5LFxuICAgICAgcG9zaXRpb25hbDogcG9zaXRpb25hbFByb3h5LFxuICAgIH07XG4gIH07XG59IGVsc2Uge1xuICBhcmdzUHJveHlGb3IgPSAoY2FwdHVyZWRBcmdzLCBfdHlwZSkgPT4ge1xuICAgIGNvbnN0IHsgbmFtZWQsIHBvc2l0aW9uYWwgfSA9IGNhcHR1cmVkQXJncztcblxuICAgIGxldCBnZXROYW1lZFRhZyA9IChfb2JqOiBvYmplY3QsIGtleTogc3RyaW5nKSA9PiB0YWdGb3JOYW1lZEFyZyhuYW1lZCwga2V5KTtcbiAgICBsZXQgZ2V0UG9zaXRpb25hbFRhZyA9IChfb2JqOiBvYmplY3QsIGtleTogc3RyaW5nKSA9PiB0YWdGb3JQb3NpdGlvbmFsQXJnKHBvc2l0aW9uYWwsIGtleSk7XG5cbiAgICBsZXQgbmFtZWRQcm94eSA9IHt9O1xuICAgIGxldCBwb3NpdGlvbmFsUHJveHk6IHVua25vd25bXSA9IFtdO1xuXG4gICAgc2V0Q3VzdG9tVGFnRm9yKG5hbWVkUHJveHksIGdldE5hbWVkVGFnKTtcbiAgICBzZXRDdXN0b21UYWdGb3IocG9zaXRpb25hbFByb3h5LCBnZXRQb3NpdGlvbmFsVGFnKTtcblxuICAgIE9iamVjdC5rZXlzKG5hbWVkKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmFtZWRQcm94eSwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVGb3JSZWYobmFtZWRbbmFtZV0pO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBwb3NpdGlvbmFsLmZvckVhY2goKHJlZjogUmVmZXJlbmNlLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocG9zaXRpb25hbFByb3h5LCBpbmRleCwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWVGb3JSZWYocmVmKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKERFQlVHKSB7XG4gICAgICAvLyBQcmV2ZW50IG11dGF0aW9ucyBpbiBkZXZlbG9wbWVudCBtb2RlLiBUaGlzIHdpbGwgbm90IHByZXZlbnQgdGhlXG4gICAgICAvLyBwcm94eSBmcm9tIHVwZGF0aW5nLCBidXQgd2lsbCBwcmV2ZW50IGFzc2lnbmluZyBuZXcgdmFsdWVzIG9yIHB1c2hpbmdcbiAgICAgIC8vIGZvciBpbnN0YW5jZS5cbiAgICAgIE9iamVjdC5mcmVlemUobmFtZWRQcm94eSk7XG4gICAgICBPYmplY3QuZnJlZXplKHBvc2l0aW9uYWxQcm94eSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVkOiBuYW1lZFByb3h5LFxuICAgICAgcG9zaXRpb25hbDogcG9zaXRpb25hbFByb3h5LFxuICAgIH07XG4gIH07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9