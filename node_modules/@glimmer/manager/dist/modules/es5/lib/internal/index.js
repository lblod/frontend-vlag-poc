import { DEBUG } from '@glimmer/env';
import { debugToString } from '@glimmer/util';
import { FEATURE_DEFAULT_HELPER_MANAGER } from '@glimmer/global-context';
import { CustomHelperManager } from '../public/helper';
import { FunctionHelperManager } from './defaults';
var COMPONENT_MANAGERS = new WeakMap();
var MODIFIER_MANAGERS = new WeakMap();
var HELPER_MANAGERS = new WeakMap(); ///////////

var getPrototypeOf = Object.getPrototypeOf;

function setManager(map, manager, obj) {
  if (DEBUG && (typeof obj !== 'object' || obj === null) && typeof obj !== 'function') {
    throw new Error("Attempted to set a manager on a non-object value. Managers can only be associated with objects or functions. Value was " + debugToString(obj));
  }

  if (DEBUG && map.has(obj)) {
    throw new Error("Attempted to set the same type of manager multiple times on a value. You can only associate one manager of each type with a given value. Value was " + debugToString(obj));
  }

  map.set(obj, manager);
  return obj;
}

function getManager(map, obj) {
  var pointer = obj;

  while (pointer !== undefined && pointer !== null) {
    var manager = map.get(pointer);

    if (manager !== undefined) {
      return manager;
    }

    pointer = getPrototypeOf(pointer);
  }

  return undefined;
} ///////////


export function setInternalModifierManager(manager, definition) {
  return setManager(MODIFIER_MANAGERS, manager, definition);
}
export function getInternalModifierManager(definition, isOptional) {
  if (DEBUG && typeof definition !== 'function' && (typeof definition !== 'object' || definition === null)) {
    throw new Error("Attempted to use a value as a modifier, but it was not an object or function. Modifier definitions must be objects or functions with an associated modifier manager. The value was: " + definition);
  }

  var manager = getManager(MODIFIER_MANAGERS, definition);

  if (manager === undefined) {
    if (isOptional === true) {
      return null;
    } else if (DEBUG) {
      throw new Error("Attempted to load a modifier, but there wasn't a modifier manager associated with the definition. The definition was: " + debugToString(definition));
    }
  }

  return manager;
}
export function setInternalHelperManager(manager, definition) {
  return setManager(HELPER_MANAGERS, manager, definition);
}
var DEFAULT_MANAGER = new CustomHelperManager(function () {
  return new FunctionHelperManager();
});
export function getInternalHelperManager(definition, isOptional) {
  if (DEBUG && typeof definition !== 'function' && (typeof definition !== 'object' || definition === null)) {
    throw new Error("Attempted to use a value as a helper, but it was not an object or function. Helper definitions must be objects or functions with an associated helper manager. The value was: " + definition);
  }

  var manager = getManager(HELPER_MANAGERS, definition);

  if (FEATURE_DEFAULT_HELPER_MANAGER) {
    // Functions are special-cased because functions are defined
    // as the "default" helper, per: https://github.com/emberjs/rfcs/pull/756
    if (manager === undefined && typeof definition === 'function') {
      manager = DEFAULT_MANAGER;
    }
  }

  if (manager) {
    return manager;
  } else if (isOptional === true) {
    return null;
  } else if (DEBUG) {
    throw new Error("Attempted to load a helper, but there wasn't a helper manager associated with the definition. The definition was: " + debugToString(definition));
  }

  return null;
}
export function setInternalComponentManager(factory, obj) {
  return setManager(COMPONENT_MANAGERS, factory, obj);
}
export function getInternalComponentManager(definition, isOptional) {
  if (DEBUG && typeof definition !== 'function' && (typeof definition !== 'object' || definition === null)) {
    throw new Error("Attempted to use a value as a component, but it was not an object or function. Component definitions must be objects or functions with an associated component manager. The value was: " + definition);
  }

  var manager = getManager(COMPONENT_MANAGERS, definition);

  if (manager === undefined) {
    if (isOptional === true) {
      return null;
    } else if (DEBUG) {
      throw new Error("Attempted to load a component, but there wasn't a component manager associated with the definition. The definition was: " + debugToString(definition));
    }
  }

  return manager;
} ///////////

export function hasInternalComponentManager(definition) {
  return hasDefaultComponentManager(definition) || getManager(COMPONENT_MANAGERS, definition) !== undefined;
}
export function hasInternalHelperManager(definition) {
  return hasDefaultHelperManager(definition) || getManager(HELPER_MANAGERS, definition) !== undefined;
}
export function hasInternalModifierManager(definition) {
  return hasDefaultModifierManager(definition) || getManager(MODIFIER_MANAGERS, definition) !== undefined;
}

function hasDefaultComponentManager(_definition) {
  return false;
}

function hasDefaultHelperManager(definition) {
  if (FEATURE_DEFAULT_HELPER_MANAGER) {
    return typeof definition === 'function';
  }

  return false;
}

function hasDefaultModifierManager(_definition) {
  return false;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL2ludGVybmFsL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFNBQUEsS0FBQSxRQUFBLGNBQUE7QUFDQSxTQUFBLGFBQUEsUUFBQSxlQUFBO0FBQ0EsU0FBQSw4QkFBQSxRQUFBLHlCQUFBO0FBT0EsU0FBQSxtQkFBQSxRQUFBLGtCQUFBO0FBQ0EsU0FBQSxxQkFBQSxRQUFBLFlBQUE7QUFRQSxJQUFNLGtCQUFrQixHQUFHLElBQTNCLE9BQTJCLEVBQTNCO0FBRUEsSUFBTSxpQkFBaUIsR0FBRyxJQUExQixPQUEwQixFQUExQjtBQUVBLElBQU0sZUFBZSxHQUFHLElBQXhCLE9BQXdCLEVBQXhCLEMsQ0FFQTs7QUFFQSxJQUFNLGNBQWMsR0FBRyxNQUFNLENBQTdCLGNBQUE7O0FBRUEsU0FBQSxVQUFBLENBQUEsR0FBQSxFQUFBLE9BQUEsRUFBQSxHQUFBLEVBR1U7QUFFUixNQUFJLEtBQUssS0FBSyxPQUFBLEdBQUEsS0FBQSxRQUFBLElBQTJCLEdBQUcsS0FBeEMsSUFBSyxDQUFMLElBQXNELE9BQUEsR0FBQSxLQUExRCxVQUFBLEVBQXFGO0FBQ25GLFVBQU0sSUFBQSxLQUFBLDZIQUNzSCxhQUFjLENBRDFJLEdBQzBJLENBRHBJLENBQU47QUFLRDs7QUFFRCxNQUFJLEtBQUssSUFBSSxHQUFHLENBQUgsR0FBQSxDQUFiLEdBQWEsQ0FBYixFQUEyQjtBQUN6QixVQUFNLElBQUEsS0FBQSx5SkFDa0osYUFBYyxDQUR0SyxHQUNzSyxDQURoSyxDQUFOO0FBS0Q7O0FBRUQsRUFBQSxHQUFHLENBQUgsR0FBQSxDQUFBLEdBQUEsRUFBQSxPQUFBO0FBQ0EsU0FBQSxHQUFBO0FBQ0Q7O0FBRUQsU0FBQSxVQUFBLENBQUEsR0FBQSxFQUFBLEdBQUEsRUFFYTtBQUVYLE1BQUksT0FBTyxHQUFYLEdBQUE7O0FBQ0EsU0FBTyxPQUFPLEtBQVAsU0FBQSxJQUF5QixP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bmltcG9ydCB7IGRlYnVnVG9TdHJpbmcsIF9XZWFrU2V0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBGRUFUVVJFX0RFRkFVTFRfSEVMUEVSX01BTkFHRVIgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5pbXBvcnQge1xuICBJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIsXG4gIEludGVybmFsTW9kaWZpZXJNYW5hZ2VyLFxuICBIZWxwZXIsXG4gIE93bmVyLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IEN1c3RvbUhlbHBlck1hbmFnZXIgfSBmcm9tICcuLi9wdWJsaWMvaGVscGVyJztcbmltcG9ydCB7IEZ1bmN0aW9uSGVscGVyTWFuYWdlciB9IGZyb20gJy4vZGVmYXVsdHMnO1xuXG50eXBlIEludGVybmFsTWFuYWdlciA9XG4gIHwgSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyXG4gIHwgSW50ZXJuYWxNb2RpZmllck1hbmFnZXJcbiAgfCBDdXN0b21IZWxwZXJNYW5hZ2VyXG4gIHwgSGVscGVyO1xuXG5jb25zdCBDT01QT05FTlRfTUFOQUdFUlMgPSBuZXcgV2Vha01hcDxvYmplY3QsIEludGVybmFsQ29tcG9uZW50TWFuYWdlcj4oKTtcblxuY29uc3QgTU9ESUZJRVJfTUFOQUdFUlMgPSBuZXcgV2Vha01hcDxvYmplY3QsIEludGVybmFsTW9kaWZpZXJNYW5hZ2VyPigpO1xuXG5jb25zdCBIRUxQRVJfTUFOQUdFUlMgPSBuZXcgV2Vha01hcDxvYmplY3QsIEN1c3RvbUhlbHBlck1hbmFnZXIgfCBIZWxwZXI+KCk7XG5cbi8vLy8vLy8vLy8vXG5cbmNvbnN0IGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG5mdW5jdGlvbiBzZXRNYW5hZ2VyPERlZiBleHRlbmRzIG9iamVjdD4oXG4gIG1hcDogV2Vha01hcDxvYmplY3QsIG9iamVjdD4sXG4gIG1hbmFnZXI6IG9iamVjdCxcbiAgb2JqOiBEZWZcbik6IERlZiB7XG4gIGlmIChERUJVRyAmJiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRlZCB0byBzZXQgYSBtYW5hZ2VyIG9uIGEgbm9uLW9iamVjdCB2YWx1ZS4gTWFuYWdlcnMgY2FuIG9ubHkgYmUgYXNzb2NpYXRlZCB3aXRoIG9iamVjdHMgb3IgZnVuY3Rpb25zLiBWYWx1ZSB3YXMgJHtkZWJ1Z1RvU3RyaW5nIShcbiAgICAgICAgb2JqXG4gICAgICApfWBcbiAgICApO1xuICB9XG5cbiAgaWYgKERFQlVHICYmIG1hcC5oYXMob2JqKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBdHRlbXB0ZWQgdG8gc2V0IHRoZSBzYW1lIHR5cGUgb2YgbWFuYWdlciBtdWx0aXBsZSB0aW1lcyBvbiBhIHZhbHVlLiBZb3UgY2FuIG9ubHkgYXNzb2NpYXRlIG9uZSBtYW5hZ2VyIG9mIGVhY2ggdHlwZSB3aXRoIGEgZ2l2ZW4gdmFsdWUuIFZhbHVlIHdhcyAke2RlYnVnVG9TdHJpbmchKFxuICAgICAgICBvYmpcbiAgICAgICl9YFxuICAgICk7XG4gIH1cblxuICBtYXAuc2V0KG9iaiwgbWFuYWdlcik7XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGdldE1hbmFnZXI8TSBleHRlbmRzIEludGVybmFsTWFuYWdlcj4oXG4gIG1hcDogV2Vha01hcDxvYmplY3QsIE0+LFxuICBvYmo6IG9iamVjdFxuKTogTSB8IHVuZGVmaW5lZCB7XG4gIGxldCBwb2ludGVyID0gb2JqO1xuICB3aGlsZSAocG9pbnRlciAhPT0gdW5kZWZpbmVkICYmIHBvaW50ZXIgIT09IG51bGwpIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gbWFwLmdldChwb2ludGVyKTtcblxuICAgIGlmIChtYW5hZ2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cblxuICAgIHBvaW50ZXIgPSBnZXRQcm90b3R5cGVPZihwb2ludGVyKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8vLy8vLy8vLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcjxUIGV4dGVuZHMgb2JqZWN0PihcbiAgbWFuYWdlcjogSW50ZXJuYWxNb2RpZmllck1hbmFnZXIsXG4gIGRlZmluaXRpb246IFRcbik6IFQge1xuICByZXR1cm4gc2V0TWFuYWdlcihNT0RJRklFUl9NQU5BR0VSUywgbWFuYWdlciwgZGVmaW5pdGlvbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcihkZWZpbml0aW9uOiBvYmplY3QpOiBJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcihcbiAgZGVmaW5pdGlvbjogb2JqZWN0LFxuICBpc09wdGlvbmFsOiB0cnVlIHwgdW5kZWZpbmVkXG4pOiBJbnRlcm5hbE1vZGlmaWVyTWFuYWdlciB8IG51bGw7XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJuYWxNb2RpZmllck1hbmFnZXIoXG4gIGRlZmluaXRpb246IG9iamVjdCxcbiAgaXNPcHRpb25hbD86IHRydWUgfCB1bmRlZmluZWRcbik6IEludGVybmFsTW9kaWZpZXJNYW5hZ2VyIHwgbnVsbCB7XG4gIGlmIChcbiAgICBERUJVRyAmJlxuICAgIHR5cGVvZiBkZWZpbml0aW9uICE9PSAnZnVuY3Rpb24nICYmXG4gICAgKHR5cGVvZiBkZWZpbml0aW9uICE9PSAnb2JqZWN0JyB8fCBkZWZpbml0aW9uID09PSBudWxsKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQXR0ZW1wdGVkIHRvIHVzZSBhIHZhbHVlIGFzIGEgbW9kaWZpZXIsIGJ1dCBpdCB3YXMgbm90IGFuIG9iamVjdCBvciBmdW5jdGlvbi4gTW9kaWZpZXIgZGVmaW5pdGlvbnMgbXVzdCBiZSBvYmplY3RzIG9yIGZ1bmN0aW9ucyB3aXRoIGFuIGFzc29jaWF0ZWQgbW9kaWZpZXIgbWFuYWdlci4gVGhlIHZhbHVlIHdhczogJHtkZWZpbml0aW9ufWBcbiAgICApO1xuICB9XG5cbiAgY29uc3QgbWFuYWdlciA9IGdldE1hbmFnZXIoTU9ESUZJRVJfTUFOQUdFUlMsIGRlZmluaXRpb24pITtcblxuICBpZiAobWFuYWdlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlzT3B0aW9uYWwgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoREVCVUcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEF0dGVtcHRlZCB0byBsb2FkIGEgbW9kaWZpZXIsIGJ1dCB0aGVyZSB3YXNuJ3QgYSBtb2RpZmllciBtYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgZGVmaW5pdGlvbi4gVGhlIGRlZmluaXRpb24gd2FzOiAke2RlYnVnVG9TdHJpbmchKFxuICAgICAgICAgIGRlZmluaXRpb25cbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYW5hZ2VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0SW50ZXJuYWxIZWxwZXJNYW5hZ2VyPFQgZXh0ZW5kcyBvYmplY3QsIE8gZXh0ZW5kcyBPd25lcj4oXG4gIG1hbmFnZXI6IEN1c3RvbUhlbHBlck1hbmFnZXI8Tz4gfCBIZWxwZXI8Tz4sXG4gIGRlZmluaXRpb246IFRcbik6IFQge1xuICByZXR1cm4gc2V0TWFuYWdlcihIRUxQRVJfTUFOQUdFUlMsIG1hbmFnZXIsIGRlZmluaXRpb24pO1xufVxuXG5jb25zdCBERUZBVUxUX01BTkFHRVIgPSBuZXcgQ3VzdG9tSGVscGVyTWFuYWdlcigoKSA9PiBuZXcgRnVuY3Rpb25IZWxwZXJNYW5hZ2VyKCkpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJuYWxIZWxwZXJNYW5hZ2VyKGRlZmluaXRpb246IG9iamVjdCk6IEN1c3RvbUhlbHBlck1hbmFnZXIgfCBIZWxwZXI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJuYWxIZWxwZXJNYW5hZ2VyKFxuICBkZWZpbml0aW9uOiBvYmplY3QsXG4gIGlzT3B0aW9uYWw6IHRydWUgfCB1bmRlZmluZWRcbik6IEN1c3RvbUhlbHBlck1hbmFnZXIgfCBIZWxwZXIgfCBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVybmFsSGVscGVyTWFuYWdlcihcbiAgZGVmaW5pdGlvbjogb2JqZWN0LFxuICBpc09wdGlvbmFsPzogdHJ1ZSB8IHVuZGVmaW5lZFxuKTogQ3VzdG9tSGVscGVyTWFuYWdlciB8IEhlbHBlciB8IG51bGwge1xuICBpZiAoXG4gICAgREVCVUcgJiZcbiAgICB0eXBlb2YgZGVmaW5pdGlvbiAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICh0eXBlb2YgZGVmaW5pdGlvbiAhPT0gJ29iamVjdCcgfHwgZGVmaW5pdGlvbiA9PT0gbnVsbClcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRlZCB0byB1c2UgYSB2YWx1ZSBhcyBhIGhlbHBlciwgYnV0IGl0IHdhcyBub3QgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uLiBIZWxwZXIgZGVmaW5pdGlvbnMgbXVzdCBiZSBvYmplY3RzIG9yIGZ1bmN0aW9ucyB3aXRoIGFuIGFzc29jaWF0ZWQgaGVscGVyIG1hbmFnZXIuIFRoZSB2YWx1ZSB3YXM6ICR7ZGVmaW5pdGlvbn1gXG4gICAgKTtcbiAgfVxuXG4gIGxldCBtYW5hZ2VyID0gZ2V0TWFuYWdlcihIRUxQRVJfTUFOQUdFUlMsIGRlZmluaXRpb24pO1xuXG4gIGlmIChGRUFUVVJFX0RFRkFVTFRfSEVMUEVSX01BTkFHRVIpIHtcbiAgICAvLyBGdW5jdGlvbnMgYXJlIHNwZWNpYWwtY2FzZWQgYmVjYXVzZSBmdW5jdGlvbnMgYXJlIGRlZmluZWRcbiAgICAvLyBhcyB0aGUgXCJkZWZhdWx0XCIgaGVscGVyLCBwZXI6IGh0dHBzOi8vZ2l0aHViLmNvbS9lbWJlcmpzL3JmY3MvcHVsbC83NTZcbiAgICBpZiAobWFuYWdlciA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtYW5hZ2VyID0gREVGQVVMVF9NQU5BR0VSO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIG1hbmFnZXI7XG4gIH0gZWxzZSBpZiAoaXNPcHRpb25hbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKERFQlVHKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRlZCB0byBsb2FkIGEgaGVscGVyLCBidXQgdGhlcmUgd2Fzbid0IGEgaGVscGVyIG1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBkZWZpbml0aW9uLiBUaGUgZGVmaW5pdGlvbiB3YXM6ICR7ZGVidWdUb1N0cmluZyEoXG4gICAgICAgIGRlZmluaXRpb25cbiAgICAgICl9YFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEludGVybmFsQ29tcG9uZW50TWFuYWdlcjxUIGV4dGVuZHMgb2JqZWN0PihcbiAgZmFjdG9yeTogSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyLFxuICBvYmo6IFRcbik6IFQge1xuICByZXR1cm4gc2V0TWFuYWdlcihDT01QT05FTlRfTUFOQUdFUlMsIGZhY3RvcnksIG9iaik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIoZGVmaW5pdGlvbjogb2JqZWN0KTogSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVybmFsQ29tcG9uZW50TWFuYWdlcihcbiAgZGVmaW5pdGlvbjogb2JqZWN0LFxuICBpc09wdGlvbmFsOiB0cnVlIHwgdW5kZWZpbmVkXG4pOiBJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIgfCBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVybmFsQ29tcG9uZW50TWFuYWdlcihcbiAgZGVmaW5pdGlvbjogb2JqZWN0LFxuICBpc09wdGlvbmFsPzogdHJ1ZSB8IHVuZGVmaW5lZFxuKTogSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyIHwgbnVsbCB7XG4gIGlmIChcbiAgICBERUJVRyAmJlxuICAgIHR5cGVvZiBkZWZpbml0aW9uICE9PSAnZnVuY3Rpb24nICYmXG4gICAgKHR5cGVvZiBkZWZpbml0aW9uICE9PSAnb2JqZWN0JyB8fCBkZWZpbml0aW9uID09PSBudWxsKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQXR0ZW1wdGVkIHRvIHVzZSBhIHZhbHVlIGFzIGEgY29tcG9uZW50LCBidXQgaXQgd2FzIG5vdCBhbiBvYmplY3Qgb3IgZnVuY3Rpb24uIENvbXBvbmVudCBkZWZpbml0aW9ucyBtdXN0IGJlIG9iamVjdHMgb3IgZnVuY3Rpb25zIHdpdGggYW4gYXNzb2NpYXRlZCBjb21wb25lbnQgbWFuYWdlci4gVGhlIHZhbHVlIHdhczogJHtkZWZpbml0aW9ufWBcbiAgICApO1xuICB9XG5cbiAgY29uc3QgbWFuYWdlciA9IGdldE1hbmFnZXIoQ09NUE9ORU5UX01BTkFHRVJTLCBkZWZpbml0aW9uKSE7XG5cbiAgaWYgKG1hbmFnZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpc09wdGlvbmFsID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKERFQlVHKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBdHRlbXB0ZWQgdG8gbG9hZCBhIGNvbXBvbmVudCwgYnV0IHRoZXJlIHdhc24ndCBhIGNvbXBvbmVudCBtYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgZGVmaW5pdGlvbi4gVGhlIGRlZmluaXRpb24gd2FzOiAke2RlYnVnVG9TdHJpbmchKFxuICAgICAgICAgIGRlZmluaXRpb25cbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYW5hZ2VyO1xufVxuXG4vLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyKGRlZmluaXRpb246IG9iamVjdCk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGhhc0RlZmF1bHRDb21wb25lbnRNYW5hZ2VyKGRlZmluaXRpb24pIHx8XG4gICAgZ2V0TWFuYWdlcihDT01QT05FTlRfTUFOQUdFUlMsIGRlZmluaXRpb24pICE9PSB1bmRlZmluZWRcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludGVybmFsSGVscGVyTWFuYWdlcihkZWZpbml0aW9uOiBvYmplY3QpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBoYXNEZWZhdWx0SGVscGVyTWFuYWdlcihkZWZpbml0aW9uKSB8fCBnZXRNYW5hZ2VyKEhFTFBFUl9NQU5BR0VSUywgZGVmaW5pdGlvbikgIT09IHVuZGVmaW5lZFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW50ZXJuYWxNb2RpZmllck1hbmFnZXIoZGVmaW5pdGlvbjogb2JqZWN0KTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgaGFzRGVmYXVsdE1vZGlmaWVyTWFuYWdlcihkZWZpbml0aW9uKSB8fCBnZXRNYW5hZ2VyKE1PRElGSUVSX01BTkFHRVJTLCBkZWZpbml0aW9uKSAhPT0gdW5kZWZpbmVkXG4gICk7XG59XG5cbmZ1bmN0aW9uIGhhc0RlZmF1bHRDb21wb25lbnRNYW5hZ2VyKF9kZWZpbml0aW9uOiBvYmplY3QpOiBib29sZWFuIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBoYXNEZWZhdWx0SGVscGVyTWFuYWdlcihkZWZpbml0aW9uOiBvYmplY3QpOiBib29sZWFuIHtcbiAgaWYgKEZFQVRVUkVfREVGQVVMVF9IRUxQRVJfTUFOQUdFUikge1xuICAgIHJldHVybiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaGFzRGVmYXVsdE1vZGlmaWVyTWFuYWdlcihfZGVmaW5pdGlvbjogb2JqZWN0KTogYm9vbGVhbiB7XG4gIHJldHVybiBmYWxzZTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=