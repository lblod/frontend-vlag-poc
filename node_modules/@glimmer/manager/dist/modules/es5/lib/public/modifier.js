import { DEBUG } from '@glimmer/env';
import { registerDestructor } from '@glimmer/destroyable';
import { valueForRef } from '@glimmer/reference';
import { dict } from '@glimmer/util';
import { createUpdatableTag, untrack } from '@glimmer/validator';
import { buildCapabilities, FROM_CAPABILITIES } from '../util/capabilities';
import { argsProxyFor } from '../util/args-proxy';
export function modifierCapabilities(managerAPI, optionalFeatures) {
  if (optionalFeatures === void 0) {
    optionalFeatures = {};
  }

  if (DEBUG && managerAPI !== '3.22') {
    throw new Error('Invalid modifier manager compatibility specified');
  }

  return buildCapabilities({
    disableAutoTracking: Boolean(optionalFeatures.disableAutoTracking)
  });
}
/**
  The CustomModifierManager allows addons to provide custom modifier
  implementations that integrate seamlessly into Ember. This is accomplished
  through a delegate, registered with the custom modifier manager, which
  implements a set of hooks that determine modifier behavior.
  To create a custom modifier manager, instantiate a new CustomModifierManager
  class and pass the delegate as the first argument:

  ```js
  let manager = new CustomModifierManager({
    // ...delegate implementation...
  });
  ```

  ## Delegate Hooks

  Throughout the lifecycle of a modifier, the modifier manager will invoke
  delegate hooks that are responsible for surfacing those lifecycle changes to
  the end developer.
  * `createModifier()` - invoked when a new instance of a modifier should be created
  * `installModifier()` - invoked when the modifier is installed on the element
  * `updateModifier()` - invoked when the arguments passed to a modifier change
  * `destroyModifier()` - invoked when the modifier is about to be destroyed
*/

export var CustomModifierManager = /*#__PURE__*/function () {
  function CustomModifierManager(factory) {
    this.factory = factory;
    this.componentManagerDelegates = new WeakMap();
  }

  var _proto = CustomModifierManager.prototype;

  _proto.getDelegateFor = function getDelegateFor(owner) {
    var componentManagerDelegates = this.componentManagerDelegates;
    var delegate = componentManagerDelegates.get(owner);

    if (delegate === undefined) {
      var factory = this.factory;
      delegate = factory(owner);

      if (DEBUG && !FROM_CAPABILITIES.has(delegate.capabilities)) {
        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200
        throw new Error("Custom modifier managers must have a `capabilities` property that is the result of calling the `capabilities('3.22')` (imported via `import { capabilities } from '@ember/modifier';`). Received: `" + JSON.stringify(delegate.capabilities) + "` for: `" + delegate + "`");
      }

      componentManagerDelegates.set(owner, delegate);
    }

    return delegate;
  };

  _proto.create = function create(owner, element, definition, capturedArgs) {
    var delegate = this.getDelegateFor(owner);
    var args = argsProxyFor(capturedArgs, 'modifier');
    var instance = delegate.createModifier(definition, args);
    var tag = createUpdatableTag();
    var state;
    state = {
      tag: tag,
      element: element,
      delegate: delegate,
      args: args,
      modifier: instance
    };

    if (DEBUG) {
      state.debugName = typeof definition === 'function' ? definition.name : definition.toString();
    }

    registerDestructor(state, function () {
      return delegate.destroyModifier(instance, args);
    });
    return state;
  };

  _proto.getDebugName = function getDebugName(_ref) {
    var debugName = _ref.debugName;
    return debugName;
  };

  _proto.getTag = function getTag(_ref2) {
    var tag = _ref2.tag;
    return tag;
  };

  _proto.install = function install(_ref3) {
    var element = _ref3.element,
        args = _ref3.args,
        modifier = _ref3.modifier,
        delegate = _ref3.delegate;
    var capabilities = delegate.capabilities;

    if (capabilities.disableAutoTracking === true) {
      untrack(function () {
        return delegate.installModifier(modifier, element, args);
      });
    } else {
      delegate.installModifier(modifier, element, args);
    }
  };

  _proto.update = function update(_ref4) {
    var args = _ref4.args,
        modifier = _ref4.modifier,
        delegate = _ref4.delegate;
    var capabilities = delegate.capabilities;

    if (capabilities.disableAutoTracking === true) {
      untrack(function () {
        return delegate.updateModifier(modifier, args);
      });
    } else {
      delegate.updateModifier(modifier, args);
    }
  };

  _proto.getDestroyable = function getDestroyable(state) {
    return state;
  };

  return CustomModifierManager;
}();
export function reifyArgs(_ref5) {
  var named = _ref5.named,
      positional = _ref5.positional;
  var reifiedNamed = dict();

  for (var key in named) {
    reifiedNamed[key] = valueForRef(named[key]);
  }

  var reifiedPositional = positional.map(valueForRef);
  return {
    named: reifiedNamed,
    positional: reifiedPositional
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL3B1YmxpYy9tb2RpZmllci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFBLEtBQUEsUUFBQSxjQUFBO0FBVUEsU0FBQSxrQkFBQSxRQUFBLHNCQUFBO0FBQ0EsU0FBQSxXQUFBLFFBQUEsb0JBQUE7QUFDQSxTQUFBLElBQUEsUUFBQSxlQUFBO0FBQ0EsU0FBQSxrQkFBQSxFQUFBLE9BQUEsUUFBQSxvQkFBQTtBQUVBLFNBQUEsaUJBQUEsRUFBQSxpQkFBQSxRQUFBLHNCQUFBO0FBQ0EsU0FBQSxZQUFBLFFBQUEsb0JBQUE7QUFHQSxPQUFNLFNBQUEsb0JBQUEsQ0FBQSxVQUFBLEVBRUosZ0JBRkksRUFFd0Q7QUFBQSxNQUE1RCxnQkFBNEQ7QUFBNUQsSUFBQSxnQkFBNEQsR0FGeEQsRUFFd0Q7QUFBQTs7QUFFNUQsTUFBSSxLQUFLLElBQUksVUFBVSxLQUF2QixNQUFBLEVBQW9DO0FBQ2xDLFVBQU0sSUFBQSxLQUFBLENBQU4sa0RBQU0sQ0FBTjtBQUNEOztBQUVELFNBQU8saUJBQWlCLENBQUM7QUFDdkIsSUFBQSxtQkFBbUIsRUFBRSxPQUFPLENBQUMsZ0JBQWdCLENBQWpCLG1CQUFBO0FBREwsR0FBRCxDQUF4QjtBQUdEO0FBV0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3QkEsV0FBTSxxQkFBTjtBQUlFLGlDQUFBLE9BQUEsRUFBaUY7QUFBN0QsU0FBQSxPQUFBLEdBQUEsT0FBQTtBQUZaLFNBQUEseUJBQUEsR0FBNEIsSUFBNUIsT0FBNEIsRUFBNUI7QUFFNkU7O0FBSnZGOztBQUFBLFNBTVUsY0FOVixHQU1VLHdCQUFjLEtBQWQsRUFBdUI7QUFBQSxRQUN2Qix5QkFEdUIsR0FDN0IsSUFENkIsQ0FDdkIseUJBRHVCO0FBRTdCLFFBQUksUUFBUSxHQUFHLHlCQUF5QixDQUF6QixHQUFBLENBQWYsS0FBZSxDQUFmOztBQUVBLFFBQUksUUFBUSxL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QUFZLENBQVosbUJBQUEsS0FBSixJQUFBLEVBQStDO0FBQzdDLE1BQUEsT0FBTyxDQUFDO0FBQUEsZUFBTSxRQUFRLENBQVIsY0FBQSxDQUFBLFFBQUEsRUFBZCxJQUFjLENBQU47QUFBQSxPQUFELENBQVA7QUFERixLQUFBLE1BRU87QUFDTCxNQUFBLFFBQVEsQ0FBUixjQUFBLENBQUEsUUFBQSxFQUFBLElBQUE7QUFDRDtBQUNGLEdBakZIOztBQUFBLFNBbUZFLGNBbkZGLEdBbUZFLHdCQUFjLEtBQWQsRUFBMkQ7QUFDekQsV0FBQSxLQUFBO0FBQ0QsR0FyRkg7O0FBQUE7QUFBQTtBQXdGQSxPQUFNLFNBQUEsU0FBQSxRQUdjO0FBQUEsTUFITSxLQUdOLFNBSE0sS0FHTjtBQUFBLE1BRGxCLFVBQ2tCLFNBRGxCLFVBQ2tCO0FBQ2xCLE1BQUksWUFBWSxHQUFHLElBQW5CLEVBQUE7O0FBRUEsT0FBSyxJQUFMLEdBQUEsSUFBQSxLQUFBLEVBQXVCO0FBQ3JCLElBQUEsWUFBWSxDQUFaLEdBQVksQ0FBWixHQUFvQixXQUFXLENBQUMsS0FBSyxDQUFyQyxHQUFxQyxDQUFOLENBQS9CO0FBQ0Q7O0FBRUQsTUFBSSxpQkFBaUIsR0FBRyxVQUFVLENBQVYsR0FBQSxDQUF4QixXQUF3QixDQUF4QjtBQUVBLFNBQU87QUFDTCxJQUFBLEtBQUssRUFEQSxZQUFBO0FBRUwsSUFBQSxVQUFVLEVBQUU7QUFGUCxHQUFQO0FBSUQiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQge1xuICBBcmd1bWVudHMsXG4gIENhcHR1cmVkQXJndW1lbnRzLFxuICBJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcixcbiAgTW9kaWZpZXJDYXBhYmlsaXRpZXMsXG4gIE1vZGlmaWVyQ2FwYWJpbGl0aWVzVmVyc2lvbnMsXG4gIE1vZGlmaWVyTWFuYWdlcixcbiAgT3duZXIsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgcmVnaXN0ZXJEZXN0cnVjdG9yIH0gZnJvbSAnQGdsaW1tZXIvZGVzdHJveWFibGUnO1xuaW1wb3J0IHsgdmFsdWVGb3JSZWYgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuaW1wb3J0IHsgY2FzdFRvQnJvd3NlciwgZGljdCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgY3JlYXRlVXBkYXRhYmxlVGFnLCB1bnRyYWNrLCBVcGRhdGFibGVUYWcgfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuaW1wb3J0IHsgU2ltcGxlRWxlbWVudCB9IGZyb20gJ0BzaW1wbGUtZG9tL2ludGVyZmFjZSc7XG5pbXBvcnQgeyBidWlsZENhcGFiaWxpdGllcywgRlJPTV9DQVBBQklMSVRJRVMgfSBmcm9tICcuLi91dGlsL2NhcGFiaWxpdGllcyc7XG5pbXBvcnQgeyBhcmdzUHJveHlGb3IgfSBmcm9tICcuLi91dGlsL2FyZ3MtcHJveHknO1xuaW1wb3J0IHsgTWFuYWdlckZhY3RvcnkgfSBmcm9tICcuJztcblxuZXhwb3J0IGZ1bmN0aW9uIG1vZGlmaWVyQ2FwYWJpbGl0aWVzPFZlcnNpb24gZXh0ZW5kcyBrZXlvZiBNb2RpZmllckNhcGFiaWxpdGllc1ZlcnNpb25zPihcbiAgbWFuYWdlckFQSTogVmVyc2lvbixcbiAgb3B0aW9uYWxGZWF0dXJlczogTW9kaWZpZXJDYXBhYmlsaXRpZXNWZXJzaW9uc1tWZXJzaW9uXSA9IHt9XG4pOiBNb2RpZmllckNhcGFiaWxpdGllcyB7XG4gIGlmIChERUJVRyAmJiBtYW5hZ2VyQVBJICE9PSAnMy4yMicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbW9kaWZpZXIgbWFuYWdlciBjb21wYXRpYmlsaXR5IHNwZWNpZmllZCcpO1xuICB9XG5cbiAgcmV0dXJuIGJ1aWxkQ2FwYWJpbGl0aWVzKHtcbiAgICBkaXNhYmxlQXV0b1RyYWNraW5nOiBCb29sZWFuKG9wdGlvbmFsRmVhdHVyZXMuZGlzYWJsZUF1dG9UcmFja2luZyksXG4gIH0pO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEN1c3RvbU1vZGlmaWVyU3RhdGU8TW9kaWZpZXJJbnN0YW5jZT4ge1xuICB0YWc6IFVwZGF0YWJsZVRhZztcbiAgZWxlbWVudDogU2ltcGxlRWxlbWVudDtcbiAgbW9kaWZpZXI6IE1vZGlmaWVySW5zdGFuY2U7XG4gIGRlbGVnYXRlOiBNb2RpZmllck1hbmFnZXI8TW9kaWZpZXJJbnN0YW5jZT47XG4gIGFyZ3M6IEFyZ3VtZW50cztcbiAgZGVidWdOYW1lPzogc3RyaW5nO1xufVxuXG4vKipcbiAgVGhlIEN1c3RvbU1vZGlmaWVyTWFuYWdlciBhbGxvd3MgYWRkb25zIHRvIHByb3ZpZGUgY3VzdG9tIG1vZGlmaWVyXG4gIGltcGxlbWVudGF0aW9ucyB0aGF0IGludGVncmF0ZSBzZWFtbGVzc2x5IGludG8gRW1iZXIuIFRoaXMgaXMgYWNjb21wbGlzaGVkXG4gIHRocm91Z2ggYSBkZWxlZ2F0ZSwgcmVnaXN0ZXJlZCB3aXRoIHRoZSBjdXN0b20gbW9kaWZpZXIgbWFuYWdlciwgd2hpY2hcbiAgaW1wbGVtZW50cyBhIHNldCBvZiBob29rcyB0aGF0IGRldGVybWluZSBtb2RpZmllciBiZWhhdmlvci5cbiAgVG8gY3JlYXRlIGEgY3VzdG9tIG1vZGlmaWVyIG1hbmFnZXIsIGluc3RhbnRpYXRlIGEgbmV3IEN1c3RvbU1vZGlmaWVyTWFuYWdlclxuICBjbGFzcyBhbmQgcGFzcyB0aGUgZGVsZWdhdGUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50OlxuXG4gIGBgYGpzXG4gIGxldCBtYW5hZ2VyID0gbmV3IEN1c3RvbU1vZGlmaWVyTWFuYWdlcih7XG4gICAgLy8gLi4uZGVsZWdhdGUgaW1wbGVtZW50YXRpb24uLi5cbiAgfSk7XG4gIGBgYFxuXG4gICMjIERlbGVnYXRlIEhvb2tzXG5cbiAgVGhyb3VnaG91dCB0aGUgbGlmZWN5Y2xlIG9mIGEgbW9kaWZpZXIsIHRoZSBtb2RpZmllciBtYW5hZ2VyIHdpbGwgaW52b2tlXG4gIGRlbGVnYXRlIGhvb2tzIHRoYXQgYXJlIHJlc3BvbnNpYmxlIGZvciBzdXJmYWNpbmcgdGhvc2UgbGlmZWN5Y2xlIGNoYW5nZXMgdG9cbiAgdGhlIGVuZCBkZXZlbG9wZXIuXG4gICogYGNyZWF0ZU1vZGlmaWVyKClgIC0gaW52b2tlZCB3aGVuIGEgbmV3IGluc3RhbmNlIG9mIGEgbW9kaWZpZXIgc2hvdWxkIGJlIGNyZWF0ZWRcbiAgKiBgaW5zdGFsbE1vZGlmaWVyKClgIC0gaW52b2tlZCB3aGVuIHRoZSBtb2RpZmllciBpcyBpbnN0YWxsZWQgb24gdGhlIGVsZW1lbnRcbiAgKiBgdXBkYXRlTW9kaWZpZXIoKWAgLSBpbnZva2VkIHdoZW4gdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gYSBtb2RpZmllciBjaGFuZ2VcbiAgKiBgZGVzdHJveU1vZGlmaWVyKClgIC0gaW52b2tlZCB3aGVuIHRoZSBtb2RpZmllciBpcyBhYm91dCB0byBiZSBkZXN0cm95ZWRcbiovXG5leHBvcnQgY2xhc3MgQ3VzdG9tTW9kaWZpZXJNYW5hZ2VyPE8gZXh0ZW5kcyBPd25lciwgTW9kaWZpZXJJbnN0YW5jZT5cbiAgaW1wbGVtZW50cyBJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcjxDdXN0b21Nb2RpZmllclN0YXRlPE1vZGlmaWVySW5zdGFuY2U+PiB7XG4gIHByaXZhdGUgY29tcG9uZW50TWFuYWdlckRlbGVnYXRlcyA9IG5ldyBXZWFrTWFwPE8sIE1vZGlmaWVyTWFuYWdlcjxNb2RpZmllckluc3RhbmNlPj4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGZhY3Rvcnk6IE1hbmFnZXJGYWN0b3J5PE8sIE1vZGlmaWVyTWFuYWdlcjxNb2RpZmllckluc3RhbmNlPj4pIHt9XG5cbiAgcHJpdmF0ZSBnZXREZWxlZ2F0ZUZvcihvd25lcjogTykge1xuICAgIGxldCB7IGNvbXBvbmVudE1hbmFnZXJEZWxlZ2F0ZXMgfSA9IHRoaXM7XG4gICAgbGV0IGRlbGVnYXRlID0gY29tcG9uZW50TWFuYWdlckRlbGVnYXRlcy5nZXQob3duZXIpO1xuXG4gICAgaWYgKGRlbGVnYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCB7IGZhY3RvcnkgfSA9IHRoaXM7XG4gICAgICBkZWxlZ2F0ZSA9IGZhY3Rvcnkob3duZXIpO1xuXG4gICAgICBpZiAoREVCVUcgJiYgIUZST01fQ0FQQUJJTElUSUVTIS5oYXMoZGVsZWdhdGUuY2FwYWJpbGl0aWVzKSkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGVycm9yIG1lc3NhZ2Ugc2hvdWxkIG1ha2Ugc2Vuc2UgaW4gYm90aCBFbWJlciBhbmQgR2xpbW1lciBodHRwczovL2dpdGh1Yi5jb20vZ2xpbW1lcmpzL2dsaW1tZXItdm0vaXNzdWVzLzEyMDBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDdXN0b20gbW9kaWZpZXIgbWFuYWdlcnMgbXVzdCBoYXZlIGEgXFxgY2FwYWJpbGl0aWVzXFxgIHByb3BlcnR5IHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBcXGBjYXBhYmlsaXRpZXMoJzMuMjInKVxcYCAoaW1wb3J0ZWQgdmlhIFxcYGltcG9ydCB7IGNhcGFiaWxpdGllcyB9IGZyb20gJ0BlbWJlci9tb2RpZmllcic7XFxgKS4gUmVjZWl2ZWQ6IFxcYCR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBkZWxlZ2F0ZS5jYXBhYmlsaXRpZXNcbiAgICAgICAgICApfVxcYCBmb3I6IFxcYCR7ZGVsZWdhdGV9XFxgYFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb21wb25lbnRNYW5hZ2VyRGVsZWdhdGVzLnNldChvd25lciwgZGVsZWdhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWxlZ2F0ZTtcbiAgfVxuXG4gIGNyZWF0ZShvd25lcjogTywgZWxlbWVudDogU2ltcGxlRWxlbWVudCwgZGVmaW5pdGlvbjogb2JqZWN0LCBjYXB0dXJlZEFyZ3M6IENhcHR1cmVkQXJndW1lbnRzKSB7XG4gICAgbGV0IGRlbGVnYXRlID0gdGhpcy5nZXREZWxlZ2F0ZUZvcihvd25lcik7XG5cbiAgICBsZXQgYXJncyA9IGFyZ3NQcm94eUZvcihjYXB0dXJlZEFyZ3MsICdtb2RpZmllcicpO1xuICAgIGxldCBpbnN0YW5jZTogTW9kaWZpZXJJbnN0YW5jZSA9IGRlbGVnYXRlLmNyZWF0ZU1vZGlmaWVyKGRlZmluaXRpb24sIGFyZ3MpO1xuXG4gICAgbGV0IHRhZyA9IGNyZWF0ZVVwZGF0YWJsZVRhZygpO1xuICAgIGxldCBzdGF0ZTogQ3VzdG9tTW9kaWZpZXJTdGF0ZTxNb2RpZmllckluc3RhbmNlPjtcblxuICAgIHN0YXRlID0ge1xuICAgICAgdGFnLFxuICAgICAgZWxlbWVudCxcbiAgICAgIGRlbGVnYXRlLFxuICAgICAgYXJncyxcbiAgICAgIG1vZGlmaWVyOiBpbnN0YW5jZSEsXG4gICAgfTtcblxuICAgIGlmIChERUJVRykge1xuICAgICAgc3RhdGUuZGVidWdOYW1lID0gdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicgPyBkZWZpbml0aW9uLm5hbWUgOiBkZWZpbml0aW9uLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJEZXN0cnVjdG9yKHN0YXRlLCAoKSA9PiBkZWxlZ2F0ZS5kZXN0cm95TW9kaWZpZXIoaW5zdGFuY2UsIGFyZ3MpKTtcblxuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGdldERlYnVnTmFtZSh7IGRlYnVnTmFtZSB9OiBDdXN0b21Nb2RpZmllclN0YXRlPE1vZGlmaWVySW5zdGFuY2U+KSB7XG4gICAgcmV0dXJuIGRlYnVnTmFtZSE7XG4gIH1cblxuICBnZXRUYWcoeyB0YWcgfTogQ3VzdG9tTW9kaWZpZXJTdGF0ZTxNb2RpZmllckluc3RhbmNlPikge1xuICAgIHJldHVybiB0YWc7XG4gIH1cblxuICBpbnN0YWxsKHsgZWxlbWVudCwgYXJncywgbW9kaWZpZXIsIGRlbGVnYXRlIH06IEN1c3RvbU1vZGlmaWVyU3RhdGU8TW9kaWZpZXJJbnN0YW5jZT4pIHtcbiAgICBsZXQgeyBjYXBhYmlsaXRpZXMgfSA9IGRlbGVnYXRlO1xuXG4gICAgaWYgKGNhcGFiaWxpdGllcy5kaXNhYmxlQXV0b1RyYWNraW5nID09PSB0cnVlKSB7XG4gICAgICB1bnRyYWNrKCgpID0+IGRlbGVnYXRlLmluc3RhbGxNb2RpZmllcihtb2RpZmllciwgY2FzdFRvQnJvd3NlcihlbGVtZW50LCAnRUxFTUVOVCcpLCBhcmdzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGVnYXRlLmluc3RhbGxNb2RpZmllcihtb2RpZmllciwgY2FzdFRvQnJvd3NlcihlbGVtZW50LCAnRUxFTUVOVCcpLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGUoeyBhcmdzLCBtb2RpZmllciwgZGVsZWdhdGUgfTogQ3VzdG9tTW9kaWZpZXJTdGF0ZTxNb2RpZmllckluc3RhbmNlPikge1xuICAgIGxldCB7IGNhcGFiaWxpdGllcyB9ID0gZGVsZWdhdGU7XG5cbiAgICBpZiAoY2FwYWJpbGl0aWVzLmRpc2FibGVBdXRvVHJhY2tpbmcgPT09IHRydWUpIHtcbiAgICAgIHVudHJhY2soKCkgPT4gZGVsZWdhdGUudXBkYXRlTW9kaWZpZXIobW9kaWZpZXIsIGFyZ3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZWdhdGUudXBkYXRlTW9kaWZpZXIobW9kaWZpZXIsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIGdldERlc3Ryb3lhYmxlKHN0YXRlOiBDdXN0b21Nb2RpZmllclN0YXRlPE1vZGlmaWVySW5zdGFuY2U+KSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWlmeUFyZ3Moe1xuICBuYW1lZCxcbiAgcG9zaXRpb25hbCxcbn06IENhcHR1cmVkQXJndW1lbnRzKTogeyBuYW1lZDogUmVjb3JkPHN0cmluZywgdW5rbm93bj47IHBvc2l0aW9uYWw6IHVua25vd25bXSB9IHtcbiAgbGV0IHJlaWZpZWROYW1lZCA9IGRpY3QoKTtcblxuICBmb3IgKGxldCBrZXkgaW4gbmFtZWQpIHtcbiAgICByZWlmaWVkTmFtZWRba2V5XSA9IHZhbHVlRm9yUmVmKG5hbWVkW2tleV0pO1xuICB9XG5cbiAgbGV0IHJlaWZpZWRQb3NpdGlvbmFsID0gcG9zaXRpb25hbC5tYXAodmFsdWVGb3JSZWYpO1xuXG4gIHJldHVybiB7XG4gICAgbmFtZWQ6IHJlaWZpZWROYW1lZCxcbiAgICBwb3NpdGlvbmFsOiByZWlmaWVkUG9zaXRpb25hbCxcbiAgfTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=