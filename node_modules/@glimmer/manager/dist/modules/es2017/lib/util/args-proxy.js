import { DEBUG } from '@glimmer/env';
import { valueForRef } from '@glimmer/reference';
import { HAS_NATIVE_PROXY } from '@glimmer/util';
import { track } from '@glimmer/validator';
const CUSTOM_TAG_FOR = new WeakMap();
export function getCustomTagFor(obj) {
  return CUSTOM_TAG_FOR.get(obj);
}
export function setCustomTagFor(obj, customTagFn) {
  CUSTOM_TAG_FOR.set(obj, customTagFn);
}

function convertToInt(prop) {
  if (typeof prop === 'symbol') return null;
  const num = Number(prop);
  if (isNaN(num)) return null;
  return num % 1 === 0 ? num : null;
}

function tagForNamedArg(namedArgs, key) {
  return track(() => {
    if (key in namedArgs) {
      valueForRef(namedArgs[key]);
    }
  });
}

function tagForPositionalArg(positionalArgs, key) {
  return track(() => {
    if (key === '[]') {
      // consume all of the tags in the positional array
      positionalArgs.forEach(valueForRef);
    }

    const parsed = convertToInt(key);

    if (parsed !== null && parsed < positionalArgs.length) {
      // consume the tag of the referenced index
      valueForRef(positionalArgs[parsed]);
    }
  });
}

export let argsProxyFor;

class NamedArgsProxy {
  constructor(named) {
    this.named = named;
  }

  get(_target, prop) {
    const ref = this.named[prop];

    if (ref !== undefined) {
      return valueForRef(ref);
    }
  }

  has(_target, prop) {
    return prop in this.named;
  }

  ownKeys() {
    return Object.keys(this.named);
  }

  isExtensible() {
    return false;
  }

  getOwnPropertyDescriptor(_target, prop) {
    if (DEBUG && !(prop in this.named)) {
      throw new Error(`args proxies do not have real property descriptors, so you should never need to call getOwnPropertyDescriptor yourself. This code exists for enumerability, such as in for-in loops and Object.keys(). Attempted to get the descriptor for \`${String(prop)}\``);
    }

    return {
      enumerable: true,
      configurable: true
    };
  }

}

class PositionalArgsProxy {
  constructor(positional) {
    this.positional = positional;
  }

  get(target, prop) {
    let {
      positional
    } = this;

    if (prop === 'length') {
      return positional.length;
    }

    const parsed = convertToInt(prop);

    if (parsed !== null && parsed < positional.length) {
      return valueForRef(positional[parsed]);
    }

    return target[prop];
  }

  isExtensible() {
    return false;
  }

  has(_target, prop) {
    const parsed = convertToInt(prop);
    return parsed !== null && parsed < this.positional.length;
  }

}

if (HAS_NATIVE_PROXY) {
  argsProxyFor = (capturedArgs, type) => {
    const {
      named,
      positional
    } = capturedArgs;

    let getNamedTag = (_obj, key) => tagForNamedArg(named, key);

    let getPositionalTag = (_obj, key) => tagForPositionalArg(positional, key);

    const namedHandler = new NamedArgsProxy(named);
    const positionalHandler = new PositionalArgsProxy(positional);
    const namedTarget = Object.create(null);
    const positionalTarget = [];

    if (DEBUG) {
      const setHandler = function (_target, prop) {
        throw new Error(`You attempted to set ${String(prop)} on the arguments of a component, helper, or modifier. Arguments are immutable and cannot be updated directly; they always represent the values that are passed down. If you want to set default values, you should use a getter and local tracked state instead.`);
      };

      const forInDebugHandler = () => {
        throw new Error(`Object.keys() was called on the positional arguments array for a ${type}, which is not supported. This function is a low-level function that should not need to be called for positional argument arrays. You may be attempting to iterate over the array using for...in instead of for...of.`);
      };

      namedHandler.set = setHandler;
      positionalHandler.set = setHandler;
      positionalHandler.ownKeys = forInDebugHandler;
    }

    const namedProxy = new Proxy(namedTarget, namedHandler);
    const positionalProxy = new Proxy(positionalTarget, positionalHandler);
    setCustomTagFor(namedProxy, getNamedTag);
    setCustomTagFor(positionalProxy, getPositionalTag);
    return {
      named: namedProxy,
      positional: positionalProxy
    };
  };
} else {
  argsProxyFor = (capturedArgs, _type) => {
    const {
      named,
      positional
    } = capturedArgs;

    let getNamedTag = (_obj, key) => tagForNamedArg(named, key);

    let getPositionalTag = (_obj, key) => tagForPositionalArg(positional, key);

    let namedProxy = {};
    let positionalProxy = [];
    setCustomTagFor(namedProxy, getNamedTag);
    setCustomTagFor(positionalProxy, getPositionalTag);
    Object.keys(named).forEach(name => {
      Object.defineProperty(namedProxy, name, {
        enumerable: true,
        configurable: true,

        get() {
          return valueForRef(named[name]);
        }

      });
    });
    positional.forEach((ref, index) => {
      Object.defineProperty(positionalProxy, index, {
        enumerable: true,
        configurable: true,

        get() {
          return valueForRef(ref);
        }

      });
    });

    if (DEBUG) {
      // Prevent mutations in development mode. This will not prevent the
      // proxy from updating, but will prevent assigning new values or pushing
      // for instance.
      Object.freeze(namedProxy);
      Object.freeze(positionalProxy);
    }

    return {
      named: namedProxy,
      positional: positionalProxy
    };
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL3V0aWwvYXJncy1wcm94eS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLEtBQVQsUUFBc0IsY0FBdEI7QUFPQSxTQUFvQixXQUFwQixRQUF1QyxvQkFBdkM7QUFDQSxTQUFTLGdCQUFULFFBQWlDLGVBQWpDO0FBQ0EsU0FBYyxLQUFkLFFBQTJCLG9CQUEzQjtBQUVBLE1BQU0sY0FBYyxHQUFHLElBQUksT0FBSixFQUF2QjtBQUVBLE9BQU0sU0FBVSxlQUFWLENBQTBCLEdBQTFCLEVBQXFDO0FBQ3pDLFNBQU8sY0FBYyxDQUFDLEdBQWYsQ0FBbUIsR0FBbkIsQ0FBUDtBQUNEO0FBRUQsT0FBTSxTQUFVLGVBQVYsQ0FBMEIsR0FBMUIsRUFBdUMsV0FBdkMsRUFBcUY7QUFDekYsRUFBQSxjQUFjLENBQUMsR0FBZixDQUFtQixHQUFuQixFQUF3QixXQUF4QjtBQUNEOztBQUVELFNBQVMsWUFBVCxDQUFzQixJQUF0QixFQUFvRDtBQUNsRCxNQUFJLE9BQU8sSUFBUCxLQUFnQixRQUFwQixFQUE4QixPQUFPLElBQVA7QUFFOUIsUUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLElBQUQsQ0FBbEI7QUFFQSxNQUFJLEtBQUssQ0FBQyxHQUFELENBQVQsRUFBZ0IsT0FBTyxJQUFQO0FBRWhCLFNBQU8sR0FBRyxHQUFHLENBQU4sS0FBWSxDQUFaLEdBQWdCLEdBQWhCLEdBQXNCLElBQTdCO0FBQ0Q7O0FBRUQsU0FBUyxjQUFULENBQXdCLFNBQXhCLEVBQTJELEdBQTNELEVBQXNFO0FBQ3BFLFNBQU8sS0FBSyxDQUFDLE1BQUs7QUFDaEIsUUFBSSxHQUFHLElBQUksU0FBWCxFQUFzQjtBQUNwQixNQUFBLFdBQVcsQ0FBQyxTQUFTLENBQUMsR0FBRCxDQUFWLENBQVg7QUFDRDtBQUNGLEdBSlcsQ0FBWjtBQUtEOztBQUVELFNBQVMsbUJBQVQsQ0FBNkIsY0FBN0IsRUFBMEUs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QUFHNUMsUUFBQSxHQUFHLEdBQUE7QUFDRCxpQkFBTyxXQUFXLENBQUMsR0FBRCxDQUFsQjtBQUNEOztBQUwyQyxPQUE5QztBQU9ELEtBUkQ7O0FBVUEsUUFBSSxLQUFKLEVBQVc7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFBLE1BQU0sQ0FBQyxNQUFQLENBQWMsVUFBZDtBQUNBLE1BQUEsTUFBTSxDQUFDLE1BQVAsQ0FBYyxlQUFkO0FBQ0Q7O0FBRUQsV0FBTztBQUNMLE1BQUEsS0FBSyxFQUFFLFVBREY7QUFFTCxNQUFBLFVBQVUsRUFBRTtBQUZQLEtBQVA7QUFJRCxHQTVDRDtBQTZDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7XG4gIEFyZ3VtZW50cyxcbiAgQ2FwdHVyZWRBcmd1bWVudHMsXG4gIENhcHR1cmVkTmFtZWRBcmd1bWVudHMsXG4gIENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cyxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBSZWZlcmVuY2UsIHZhbHVlRm9yUmVmIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IEhBU19OQVRJVkVfUFJPWFkgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IFRhZywgdHJhY2sgfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuXG5jb25zdCBDVVNUT01fVEFHX0ZPUiA9IG5ldyBXZWFrTWFwPG9iamVjdCwgKG9iajogb2JqZWN0LCBrZXk6IHN0cmluZykgPT4gVGFnPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VzdG9tVGFnRm9yKG9iajogb2JqZWN0KTogKChvYmo6IG9iamVjdCwga2V5OiBzdHJpbmcpID0+IFRhZykgfCB1bmRlZmluZWQge1xuICByZXR1cm4gQ1VTVE9NX1RBR19GT1IuZ2V0KG9iaik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDdXN0b21UYWdGb3Iob2JqOiBvYmplY3QsIGN1c3RvbVRhZ0ZuOiAob2JqOiBvYmplY3QsIGtleTogc3RyaW5nKSA9PiBUYWcpIHtcbiAgQ1VTVE9NX1RBR19GT1Iuc2V0KG9iaiwgY3VzdG9tVGFnRm4pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9JbnQocHJvcDogbnVtYmVyIHwgc3RyaW5nIHwgc3ltYm9sKTogbnVtYmVyIHwgbnVsbCB7XG4gIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N5bWJvbCcpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IG51bSA9IE51bWJlcihwcm9wKTtcblxuICBpZiAoaXNOYU4obnVtKSkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIG51bSAlIDEgPT09IDAgPyBudW0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0YWdGb3JOYW1lZEFyZyhuYW1lZEFyZ3M6IENhcHR1cmVkTmFtZWRBcmd1bWVudHMsIGtleTogc3RyaW5nKTogVGFnIHtcbiAgcmV0dXJuIHRyYWNrKCgpID0+IHtcbiAgICBpZiAoa2V5IGluIG5hbWVkQXJncykge1xuICAgICAgdmFsdWVGb3JSZWYobmFtZWRBcmdzW2tleV0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRhZ0ZvclBvc2l0aW9uYWxBcmcocG9zaXRpb25hbEFyZ3M6IENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cywga2V5OiBzdHJpbmcpOiBUYWcge1xuICByZXR1cm4gdHJhY2soKCkgPT4ge1xuICAgIGlmIChrZXkgPT09ICdbXScpIHtcbiAgICAgIC8vIGNvbnN1bWUgYWxsIG9mIHRoZSB0YWdzIGluIHRoZSBwb3NpdGlvbmFsIGFycmF5XG4gICAgICBwb3NpdGlvbmFsQXJncy5mb3JFYWNoKHZhbHVlRm9yUmVmKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWQgPSBjb252ZXJ0VG9JbnQoa2V5KTtcblxuICAgIGlmIChwYXJzZWQgIT09IG51bGwgJiYgcGFyc2VkIDwgcG9zaXRpb25hbEFyZ3MubGVuZ3RoKSB7XG4gICAgICAvLyBjb25zdW1lIHRoZSB0YWcgb2YgdGhlIHJlZmVyZW5jZWQgaW5kZXhcbiAgICAgIHZhbHVlRm9yUmVmKHBvc2l0aW9uYWxBcmdzW3BhcnNlZF0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBsZXQgYXJnc1Byb3h5Rm9yOiAoXG4gIGNhcHR1cmVkQXJnczogQ2FwdHVyZWRBcmd1bWVudHMsXG4gIHR5cGU6ICdjb21wb25lbnQnIHwgJ2hlbHBlcicgfCAnbW9kaWZpZXInXG4pID0+IEFyZ3VtZW50cztcblxuY2xhc3MgTmFtZWRBcmdzUHJveHkgaW1wbGVtZW50cyBQcm94eUhhbmRsZXI8e30+IHtcbiAgZGVjbGFyZSBzZXQ/OiAodGFyZ2V0OiB7fSwgcHJvcDogc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sKSA9PiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbmFtZWQ6IENhcHR1cmVkTmFtZWRBcmd1bWVudHMpIHt9XG5cbiAgZ2V0KF90YXJnZXQ6IHt9LCBwcm9wOiBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpIHtcbiAgICBjb25zdCByZWYgPSB0aGlzLm5hbWVkW3Byb3AgYXMgc3RyaW5nXTtcblxuICAgIGlmIChyZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbHVlRm9yUmVmKHJlZik7XG4gICAgfVxuICB9XG5cbiAgaGFzKF90YXJnZXQ6IHt9LCBwcm9wOiBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcCBpbiB0aGlzLm5hbWVkO1xuICB9XG5cbiAgb3duS2V5cygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5uYW1lZCk7XG4gIH1cblxuICBpc0V4dGVuc2libGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF90YXJnZXQ6IHt9LCBwcm9wOiBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpIHtcbiAgICBpZiAoREVCVUcgJiYgIShwcm9wIGluIHRoaXMubmFtZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBhcmdzIHByb3hpZXMgZG8gbm90IGhhdmUgcmVhbCBwcm9wZXJ0eSBkZXNjcmlwdG9ycywgc28geW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGNhbGwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIHlvdXJzZWxmLiBUaGlzIGNvZGUgZXhpc3RzIGZvciBlbnVtZXJhYmlsaXR5LCBzdWNoIGFzIGluIGZvci1pbiBsb29wcyBhbmQgT2JqZWN0LmtleXMoKS4gQXR0ZW1wdGVkIHRvIGdldCB0aGUgZGVzY3JpcHRvciBmb3IgXFxgJHtTdHJpbmcoXG4gICAgICAgICAgcHJvcFxuICAgICAgICApfVxcYGBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfTtcbiAgfVxufVxuXG5jbGFzcyBQb3NpdGlvbmFsQXJnc1Byb3h5IGltcGxlbWVudHMgUHJveHlIYW5kbGVyPFtdPiB7XG4gIGRlY2xhcmUgc2V0PzogKHRhcmdldDogW10sIHByb3A6IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCkgPT4gYm9vbGVhbjtcbiAgZGVjbGFyZSBvd25LZXlzPzogKHRhcmdldDogW10pID0+IHN0cmluZ1tdO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcG9zaXRpb25hbDogQ2FwdHVyZWRQb3NpdGlvbmFsQXJndW1lbnRzKSB7fVxuXG4gIGdldCh0YXJnZXQ6IFtdLCBwcm9wOiBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpIHtcbiAgICBsZXQgeyBwb3NpdGlvbmFsIH0gPSB0aGlzO1xuXG4gICAgaWYgKHByb3AgPT09ICdsZW5ndGgnKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb25hbC5sZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkID0gY29udmVydFRvSW50KHByb3ApO1xuXG4gICAgaWYgKHBhcnNlZCAhPT0gbnVsbCAmJiBwYXJzZWQgPCBwb3NpdGlvbmFsLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZhbHVlRm9yUmVmKHBvc2l0aW9uYWxbcGFyc2VkXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0YXJnZXQgYXMgYW55KVtwcm9wXTtcbiAgfVxuXG4gIGlzRXh0ZW5zaWJsZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYXMoX3RhcmdldDogW10sIHByb3A6IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IGNvbnZlcnRUb0ludChwcm9wKTtcblxuICAgIHJldHVybiBwYXJzZWQgIT09IG51bGwgJiYgcGFyc2VkIDwgdGhpcy5wb3NpdGlvbmFsLmxlbmd0aDtcbiAgfVxufVxuXG5pZiAoSEFTX05BVElWRV9QUk9YWSkge1xuICBhcmdzUHJveHlGb3IgPSAoY2FwdHVyZWRBcmdzLCB0eXBlKSA9PiB7XG4gICAgY29uc3QgeyBuYW1lZCwgcG9zaXRpb25hbCB9ID0gY2FwdHVyZWRBcmdzO1xuXG4gICAgbGV0IGdldE5hbWVkVGFnID0gKF9vYmo6IG9iamVjdCwga2V5OiBzdHJpbmcpID0+IHRhZ0Zvck5hbWVkQXJnKG5hbWVkLCBrZXkpO1xuICAgIGxldCBnZXRQb3NpdGlvbmFsVGFnID0gKF9vYmo6IG9iamVjdCwga2V5OiBzdHJpbmcpID0+IHRhZ0ZvclBvc2l0aW9uYWxBcmcocG9zaXRpb25hbCwga2V5KTtcblxuICAgIGNvbnN0IG5hbWVkSGFuZGxlciA9IG5ldyBOYW1lZEFyZ3NQcm94eShuYW1lZCk7XG4gICAgY29uc3QgcG9zaXRpb25hbEhhbmRsZXIgPSBuZXcgUG9zaXRpb25hbEFyZ3NQcm94eShwb3NpdGlvbmFsKTtcblxuICAgIGNvbnN0IG5hbWVkVGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBwb3NpdGlvbmFsVGFyZ2V0OiB1bmtub3duW10gPSBbXTtcblxuICAgIGlmIChERUJVRykge1xuICAgICAgY29uc3Qgc2V0SGFuZGxlciA9IGZ1bmN0aW9uIChfdGFyZ2V0OiB1bmtub3duLCBwcm9wOiBzeW1ib2wgfCBzdHJpbmcgfCBudW1iZXIpOiBuZXZlciB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IGF0dGVtcHRlZCB0byBzZXQgJHtTdHJpbmcoXG4gICAgICAgICAgICBwcm9wXG4gICAgICAgICAgKX0gb24gdGhlIGFyZ3VtZW50cyBvZiBhIGNvbXBvbmVudCwgaGVscGVyLCBvciBtb2RpZmllci4gQXJndW1lbnRzIGFyZSBpbW11dGFibGUgYW5kIGNhbm5vdCBiZSB1cGRhdGVkIGRpcmVjdGx5OyB0aGV5IGFsd2F5cyByZXByZXNlbnQgdGhlIHZhbHVlcyB0aGF0IGFyZSBwYXNzZWQgZG93bi4gSWYgeW91IHdhbnQgdG8gc2V0IGRlZmF1bHQgdmFsdWVzLCB5b3Ugc2hvdWxkIHVzZSBhIGdldHRlciBhbmQgbG9jYWwgdHJhY2tlZCBzdGF0ZSBpbnN0ZWFkLmBcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGZvckluRGVidWdIYW5kbGVyID0gKCk6IG5ldmVyID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBPYmplY3Qua2V5cygpIHdhcyBjYWxsZWQgb24gdGhlIHBvc2l0aW9uYWwgYXJndW1lbnRzIGFycmF5IGZvciBhICR7dHlwZX0sIHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQuIFRoaXMgZnVuY3Rpb24gaXMgYSBsb3ctbGV2ZWwgZnVuY3Rpb24gdGhhdCBzaG91bGQgbm90IG5lZWQgdG8gYmUgY2FsbGVkIGZvciBwb3NpdGlvbmFsIGFyZ3VtZW50IGFycmF5cy4gWW91IG1heSBiZSBhdHRlbXB0aW5nIHRvIGl0ZXJhdGUgb3ZlciB0aGUgYXJyYXkgdXNpbmcgZm9yLi4uaW4gaW5zdGVhZCBvZiBmb3IuLi5vZi5gXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICBuYW1lZEhhbmRsZXIuc2V0ID0gc2V0SGFuZGxlcjtcbiAgICAgIHBvc2l0aW9uYWxIYW5kbGVyLnNldCA9IHNldEhhbmRsZXI7XG4gICAgICBwb3NpdGlvbmFsSGFuZGxlci5vd25LZXlzID0gZm9ySW5EZWJ1Z0hhbmRsZXI7XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZWRQcm94eSA9IG5ldyBQcm94eShuYW1lZFRhcmdldCwgbmFtZWRIYW5kbGVyKTtcbiAgICBjb25zdCBwb3NpdGlvbmFsUHJveHkgPSBuZXcgUHJveHkocG9zaXRpb25hbFRhcmdldCwgcG9zaXRpb25hbEhhbmRsZXIpO1xuXG4gICAgc2V0Q3VzdG9tVGFnRm9yKG5hbWVkUHJveHksIGdldE5hbWVkVGFnKTtcbiAgICBzZXRDdXN0b21UYWdGb3IocG9zaXRpb25hbFByb3h5LCBnZXRQb3NpdGlvbmFsVGFnKTtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lZDogbmFtZWRQcm94eSxcbiAgICAgIHBvc2l0aW9uYWw6IHBvc2l0aW9uYWxQcm94eSxcbiAgICB9O1xuICB9O1xufSBlbHNlIHtcbiAgYXJnc1Byb3h5Rm9yID0gKGNhcHR1cmVkQXJncywgX3R5cGUpID0+IHtcbiAgICBjb25zdCB7IG5hbWVkLCBwb3NpdGlvbmFsIH0gPSBjYXB0dXJlZEFyZ3M7XG5cbiAgICBsZXQgZ2V0TmFtZWRUYWcgPSAoX29iajogb2JqZWN0LCBrZXk6IHN0cmluZykgPT4gdGFnRm9yTmFtZWRBcmcobmFtZWQsIGtleSk7XG4gICAgbGV0IGdldFBvc2l0aW9uYWxUYWcgPSAoX29iajogb2JqZWN0LCBrZXk6IHN0cmluZykgPT4gdGFnRm9yUG9zaXRpb25hbEFyZyhwb3NpdGlvbmFsLCBrZXkpO1xuXG4gICAgbGV0IG5hbWVkUHJveHkgPSB7fTtcbiAgICBsZXQgcG9zaXRpb25hbFByb3h5OiB1bmtub3duW10gPSBbXTtcblxuICAgIHNldEN1c3RvbVRhZ0ZvcihuYW1lZFByb3h5LCBnZXROYW1lZFRhZyk7XG4gICAgc2V0Q3VzdG9tVGFnRm9yKHBvc2l0aW9uYWxQcm94eSwgZ2V0UG9zaXRpb25hbFRhZyk7XG5cbiAgICBPYmplY3Qua2V5cyhuYW1lZCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hbWVkUHJveHksIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlRm9yUmVmKG5hbWVkW25hbWVdKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcG9zaXRpb25hbC5mb3JFYWNoKChyZWY6IFJlZmVyZW5jZSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBvc2l0aW9uYWxQcm94eSwgaW5kZXgsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlRm9yUmVmKHJlZik7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmIChERUJVRykge1xuICAgICAgLy8gUHJldmVudCBtdXRhdGlvbnMgaW4gZGV2ZWxvcG1lbnQgbW9kZS4gVGhpcyB3aWxsIG5vdCBwcmV2ZW50IHRoZVxuICAgICAgLy8gcHJveHkgZnJvbSB1cGRhdGluZywgYnV0IHdpbGwgcHJldmVudCBhc3NpZ25pbmcgbmV3IHZhbHVlcyBvciBwdXNoaW5nXG4gICAgICAvLyBmb3IgaW5zdGFuY2UuXG4gICAgICBPYmplY3QuZnJlZXplKG5hbWVkUHJveHkpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShwb3NpdGlvbmFsUHJveHkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lZDogbmFtZWRQcm94eSxcbiAgICAgIHBvc2l0aW9uYWw6IHBvc2l0aW9uYWxQcm94eSxcbiAgICB9O1xuICB9O1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==