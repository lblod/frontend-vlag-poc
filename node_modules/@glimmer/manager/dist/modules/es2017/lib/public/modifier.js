import { DEBUG } from '@glimmer/env';
import { registerDestructor } from '@glimmer/destroyable';
import { valueForRef } from '@glimmer/reference';
import { dict } from '@glimmer/util';
import { createUpdatableTag, untrack } from '@glimmer/validator';
import { buildCapabilities, FROM_CAPABILITIES } from '../util/capabilities';
import { argsProxyFor } from '../util/args-proxy';
export function modifierCapabilities(managerAPI, optionalFeatures = {}) {
  if (DEBUG && managerAPI !== '3.22') {
    throw new Error('Invalid modifier manager compatibility specified');
  }

  return buildCapabilities({
    disableAutoTracking: Boolean(optionalFeatures.disableAutoTracking)
  });
}
/**
  The CustomModifierManager allows addons to provide custom modifier
  implementations that integrate seamlessly into Ember. This is accomplished
  through a delegate, registered with the custom modifier manager, which
  implements a set of hooks that determine modifier behavior.
  To create a custom modifier manager, instantiate a new CustomModifierManager
  class and pass the delegate as the first argument:

  ```js
  let manager = new CustomModifierManager({
    // ...delegate implementation...
  });
  ```

  ## Delegate Hooks

  Throughout the lifecycle of a modifier, the modifier manager will invoke
  delegate hooks that are responsible for surfacing those lifecycle changes to
  the end developer.
  * `createModifier()` - invoked when a new instance of a modifier should be created
  * `installModifier()` - invoked when the modifier is installed on the element
  * `updateModifier()` - invoked when the arguments passed to a modifier change
  * `destroyModifier()` - invoked when the modifier is about to be destroyed
*/

export class CustomModifierManager {
  constructor(factory) {
    this.factory = factory;
    this.componentManagerDelegates = new WeakMap();
  }

  getDelegateFor(owner) {
    let {
      componentManagerDelegates
    } = this;
    let delegate = componentManagerDelegates.get(owner);

    if (delegate === undefined) {
      let {
        factory
      } = this;
      delegate = factory(owner);

      if (DEBUG && !FROM_CAPABILITIES.has(delegate.capabilities)) {
        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200
        throw new Error(`Custom modifier managers must have a \`capabilities\` property that is the result of calling the \`capabilities('3.22')\` (imported via \`import { capabilities } from '@ember/modifier';\`). Received: \`${JSON.stringify(delegate.capabilities)}\` for: \`${delegate}\``);
      }

      componentManagerDelegates.set(owner, delegate);
    }

    return delegate;
  }

  create(owner, element, definition, capturedArgs) {
    let delegate = this.getDelegateFor(owner);
    let args = argsProxyFor(capturedArgs, 'modifier');
    let instance = delegate.createModifier(definition, args);
    let tag = createUpdatableTag();
    let state;
    state = {
      tag,
      element,
      delegate,
      args,
      modifier: instance
    };

    if (DEBUG) {
      state.debugName = typeof definition === 'function' ? definition.name : definition.toString();
    }

    registerDestructor(state, () => delegate.destroyModifier(instance, args));
    return state;
  }

  getDebugName({
    debugName
  }) {
    return debugName;
  }

  getTag({
    tag
  }) {
    return tag;
  }

  install({
    element,
    args,
    modifier,
    delegate
  }) {
    let {
      capabilities
    } = delegate;

    if (capabilities.disableAutoTracking === true) {
      untrack(() => delegate.installModifier(modifier, element, args));
    } else {
      delegate.installModifier(modifier, element, args);
    }
  }

  update({
    args,
    modifier,
    delegate
  }) {
    let {
      capabilities
    } = delegate;

    if (capabilities.disableAutoTracking === true) {
      untrack(() => delegate.updateModifier(modifier, args));
    } else {
      delegate.updateModifier(modifier, args);
    }
  }

  getDestroyable(state) {
    return state;
  }

}
export function reifyArgs({
  named,
  positional
}) {
  let reifiedNamed = dict();

  for (let key in named) {
    reifiedNamed[key] = valueForRef(named[key]);
  }

  let reifiedPositional = positional.map(valueForRef);
  return {
    named: reifiedNamed,
    positional: reifiedPositional
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL3B1YmxpYy9tb2RpZmllci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxTQUFTLEtBQVQsUUFBc0IsY0FBdEI7QUFVQSxTQUFTLGtCQUFULFFBQW1DLHNCQUFuQztBQUNBLFNBQVMsV0FBVCxRQUE0QixvQkFBNUI7QUFDQSxTQUF3QixJQUF4QixRQUFvQyxlQUFwQztBQUNBLFNBQVMsa0JBQVQsRUFBNkIsT0FBN0IsUUFBMEQsb0JBQTFEO0FBRUEsU0FBUyxpQkFBVCxFQUE0QixpQkFBNUIsUUFBcUQsc0JBQXJEO0FBQ0EsU0FBUyxZQUFULFFBQTZCLG9CQUE3QjtBQUdBLE9BQU0sU0FBVSxvQkFBVixDQUNKLFVBREksRUFFSixnQkFBQSxHQUEwRCxFQUZ0RCxFQUV3RDtBQUU1RCxNQUFJLEtBQUssSUFBSSxVQUFVLEtBQUssTUFBNUIsRUFBb0M7QUFDbEMsVUFBTSxJQUFJLEtBQUosQ0FBVSxrREFBVixDQUFOO0FBQ0Q7O0FBRUQsU0FBTyxpQkFBaUIsQ0FBQztBQUN2QixJQUFBLG1CQUFtQixFQUFFLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxtQkFBbEI7QUFETCxHQUFELENBQXhCO0FBR0Q7QUFXRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQSxPQUFNLE1BQU8scUJBQVAsQ0FBNEI7QUFJaEMsRUFBQSxXQUFBLENBQW9CLE9BQXBCLEVBQWlGO0FBQTdELFNBQUEsT0FBQSxHQUFBLE9BQUE7QUFGWixTQUFBLHlCQUFBLEdBQTRCLElBQUksT0FBSixFQUE1QjtBQUU2RTs7QUFFN0UsRUFBQSxjQUFjLENBQUMsS0FBRCxFQUFTO0FBQzdCLFFBQUk7QUFBRSxNQUFBO0FBQUYsUUFBZ0MsSUFBcEM7QUFDQSxRQUFJLFFBQVEsR0FBRyx5QkFBeUIsQ0FBQyxHQUExQixDQUE4QixLQUE5QixDQUFmOztBQUVBLFFBQUksUUFBUSxLQUFLLFNBQWpCLEVBQTRCO0FB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LFdBQU8sS0FBUDtBQUNEOztBQXJGK0I7QUF3RmxDLE9BQU0sU0FBVSxTQUFWLENBQW9CO0FBQ3hCLEVBQUEsS0FEd0I7QUFFeEIsRUFBQTtBQUZ3QixDQUFwQixFQUdjO0FBQ2xCLE1BQUksWUFBWSxHQUFHLElBQUksRUFBdkI7O0FBRUEsT0FBSyxJQUFJLEdBQVQsSUFBZ0IsS0FBaEIsRUFBdUI7QUFDckIsSUFBQSxZQUFZLENBQUMsR0FBRCxDQUFaLEdBQW9CLFdBQVcsQ0FBQyxLQUFLLENBQUMsR0FBRCxDQUFOLENBQS9CO0FBQ0Q7O0FBRUQsTUFBSSxpQkFBaUIsR0FBRyxVQUFVLENBQUMsR0FBWCxDQUFlLFdBQWYsQ0FBeEI7QUFFQSxTQUFPO0FBQ0wsSUFBQSxLQUFLLEVBQUUsWUFERjtBQUVMLElBQUEsVUFBVSxFQUFFO0FBRlAsR0FBUDtBQUlEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHtcbiAgQXJndW1lbnRzLFxuICBDYXB0dXJlZEFyZ3VtZW50cyxcbiAgSW50ZXJuYWxNb2RpZmllck1hbmFnZXIsXG4gIE1vZGlmaWVyQ2FwYWJpbGl0aWVzLFxuICBNb2RpZmllckNhcGFiaWxpdGllc1ZlcnNpb25zLFxuICBNb2RpZmllck1hbmFnZXIsXG4gIE93bmVyLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IHJlZ2lzdGVyRGVzdHJ1Y3RvciB9IGZyb20gJ0BnbGltbWVyL2Rlc3Ryb3lhYmxlJztcbmltcG9ydCB7IHZhbHVlRm9yUmVmIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IGNhc3RUb0Jyb3dzZXIsIGRpY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IGNyZWF0ZVVwZGF0YWJsZVRhZywgdW50cmFjaywgVXBkYXRhYmxlVGFnIH0gZnJvbSAnQGdsaW1tZXIvdmFsaWRhdG9yJztcbmltcG9ydCB7IFNpbXBsZUVsZW1lbnQgfSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgYnVpbGRDYXBhYmlsaXRpZXMsIEZST01fQ0FQQUJJTElUSUVTIH0gZnJvbSAnLi4vdXRpbC9jYXBhYmlsaXRpZXMnO1xuaW1wb3J0IHsgYXJnc1Byb3h5Rm9yIH0gZnJvbSAnLi4vdXRpbC9hcmdzLXByb3h5JztcbmltcG9ydCB7IE1hbmFnZXJGYWN0b3J5IH0gZnJvbSAnLic7XG5cbmV4cG9ydCBmdW5jdGlvbiBtb2RpZmllckNhcGFiaWxpdGllczxWZXJzaW9uIGV4dGVuZHMga2V5b2YgTW9kaWZpZXJDYXBhYmlsaXRpZXNWZXJzaW9ucz4oXG4gIG1hbmFnZXJBUEk6IFZlcnNpb24sXG4gIG9wdGlvbmFsRmVhdHVyZXM6IE1vZGlmaWVyQ2FwYWJpbGl0aWVzVmVyc2lvbnNbVmVyc2lvbl0gPSB7fVxuKTogTW9kaWZpZXJDYXBhYmlsaXRpZXMge1xuICBpZiAoREVCVUcgJiYgbWFuYWdlckFQSSAhPT0gJzMuMjInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vZGlmaWVyIG1hbmFnZXIgY29tcGF0aWJpbGl0eSBzcGVjaWZpZWQnKTtcbiAgfVxuXG4gIHJldHVybiBidWlsZENhcGFiaWxpdGllcyh7XG4gICAgZGlzYWJsZUF1dG9UcmFja2luZzogQm9vbGVhbihvcHRpb25hbEZlYXR1cmVzLmRpc2FibGVBdXRvVHJhY2tpbmcpLFxuICB9KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDdXN0b21Nb2RpZmllclN0YXRlPE1vZGlmaWVySW5zdGFuY2U+IHtcbiAgdGFnOiBVcGRhdGFibGVUYWc7XG4gIGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQ7XG4gIG1vZGlmaWVyOiBNb2RpZmllckluc3RhbmNlO1xuICBkZWxlZ2F0ZTogTW9kaWZpZXJNYW5hZ2VyPE1vZGlmaWVySW5zdGFuY2U+O1xuICBhcmdzOiBBcmd1bWVudHM7XG4gIGRlYnVnTmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gIFRoZSBDdXN0b21Nb2RpZmllck1hbmFnZXIgYWxsb3dzIGFkZG9ucyB0byBwcm92aWRlIGN1c3RvbSBtb2RpZmllclxuICBpbXBsZW1lbnRhdGlvbnMgdGhhdCBpbnRlZ3JhdGUgc2VhbWxlc3NseSBpbnRvIEVtYmVyLiBUaGlzIGlzIGFjY29tcGxpc2hlZFxuICB0aHJvdWdoIGEgZGVsZWdhdGUsIHJlZ2lzdGVyZWQgd2l0aCB0aGUgY3VzdG9tIG1vZGlmaWVyIG1hbmFnZXIsIHdoaWNoXG4gIGltcGxlbWVudHMgYSBzZXQgb2YgaG9va3MgdGhhdCBkZXRlcm1pbmUgbW9kaWZpZXIgYmVoYXZpb3IuXG4gIFRvIGNyZWF0ZSBhIGN1c3RvbSBtb2RpZmllciBtYW5hZ2VyLCBpbnN0YW50aWF0ZSBhIG5ldyBDdXN0b21Nb2RpZmllck1hbmFnZXJcbiAgY2xhc3MgYW5kIHBhc3MgdGhlIGRlbGVnYXRlIGFzIHRoZSBmaXJzdCBhcmd1bWVudDpcblxuICBgYGBqc1xuICBsZXQgbWFuYWdlciA9IG5ldyBDdXN0b21Nb2RpZmllck1hbmFnZXIoe1xuICAgIC8vIC4uLmRlbGVnYXRlIGltcGxlbWVudGF0aW9uLi4uXG4gIH0pO1xuICBgYGBcblxuICAjIyBEZWxlZ2F0ZSBIb29rc1xuXG4gIFRocm91Z2hvdXQgdGhlIGxpZmVjeWNsZSBvZiBhIG1vZGlmaWVyLCB0aGUgbW9kaWZpZXIgbWFuYWdlciB3aWxsIGludm9rZVxuICBkZWxlZ2F0ZSBob29rcyB0aGF0IGFyZSByZXNwb25zaWJsZSBmb3Igc3VyZmFjaW5nIHRob3NlIGxpZmVjeWNsZSBjaGFuZ2VzIHRvXG4gIHRoZSBlbmQgZGV2ZWxvcGVyLlxuICAqIGBjcmVhdGVNb2RpZmllcigpYCAtIGludm9rZWQgd2hlbiBhIG5ldyBpbnN0YW5jZSBvZiBhIG1vZGlmaWVyIHNob3VsZCBiZSBjcmVhdGVkXG4gICogYGluc3RhbGxNb2RpZmllcigpYCAtIGludm9rZWQgd2hlbiB0aGUgbW9kaWZpZXIgaXMgaW5zdGFsbGVkIG9uIHRoZSBlbGVtZW50XG4gICogYHVwZGF0ZU1vZGlmaWVyKClgIC0gaW52b2tlZCB3aGVuIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIGEgbW9kaWZpZXIgY2hhbmdlXG4gICogYGRlc3Ryb3lNb2RpZmllcigpYCAtIGludm9rZWQgd2hlbiB0aGUgbW9kaWZpZXIgaXMgYWJvdXQgdG8gYmUgZGVzdHJveWVkXG4qL1xuZXhwb3J0IGNsYXNzIEN1c3RvbU1vZGlmaWVyTWFuYWdlcjxPIGV4dGVuZHMgT3duZXIsIE1vZGlmaWVySW5zdGFuY2U+XG4gIGltcGxlbWVudHMgSW50ZXJuYWxNb2RpZmllck1hbmFnZXI8Q3VzdG9tTW9kaWZpZXJTdGF0ZTxNb2RpZmllckluc3RhbmNlPj4ge1xuICBwcml2YXRlIGNvbXBvbmVudE1hbmFnZXJEZWxlZ2F0ZXMgPSBuZXcgV2Vha01hcDxPLCBNb2RpZmllck1hbmFnZXI8TW9kaWZpZXJJbnN0YW5jZT4+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBmYWN0b3J5OiBNYW5hZ2VyRmFjdG9yeTxPLCBNb2RpZmllck1hbmFnZXI8TW9kaWZpZXJJbnN0YW5jZT4+KSB7fVxuXG4gIHByaXZhdGUgZ2V0RGVsZWdhdGVGb3Iob3duZXI6IE8pIHtcbiAgICBsZXQgeyBjb21wb25lbnRNYW5hZ2VyRGVsZWdhdGVzIH0gPSB0aGlzO1xuICAgIGxldCBkZWxlZ2F0ZSA9IGNvbXBvbmVudE1hbmFnZXJEZWxlZ2F0ZXMuZ2V0KG93bmVyKTtcblxuICAgIGlmIChkZWxlZ2F0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgeyBmYWN0b3J5IH0gPSB0aGlzO1xuICAgICAgZGVsZWdhdGUgPSBmYWN0b3J5KG93bmVyKTtcblxuICAgICAgaWYgKERFQlVHICYmICFGUk9NX0NBUEFCSUxJVElFUyEuaGFzKGRlbGVnYXRlLmNhcGFiaWxpdGllcykpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBlcnJvciBtZXNzYWdlIHNob3VsZCBtYWtlIHNlbnNlIGluIGJvdGggRW1iZXIgYW5kIEdsaW1tZXIgaHR0cHM6Ly9naXRodWIuY29tL2dsaW1tZXJqcy9nbGltbWVyLXZtL2lzc3Vlcy8xMjAwXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ3VzdG9tIG1vZGlmaWVyIG1hbmFnZXJzIG11c3QgaGF2ZSBhIFxcYGNhcGFiaWxpdGllc1xcYCBwcm9wZXJ0eSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgXFxgY2FwYWJpbGl0aWVzKCczLjIyJylcXGAgKGltcG9ydGVkIHZpYSBcXGBpbXBvcnQgeyBjYXBhYmlsaXRpZXMgfSBmcm9tICdAZW1iZXIvbW9kaWZpZXInO1xcYCkuIFJlY2VpdmVkOiBcXGAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgZGVsZWdhdGUuY2FwYWJpbGl0aWVzXG4gICAgICAgICAgKX1cXGAgZm9yOiBcXGAke2RlbGVnYXRlfVxcYGBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50TWFuYWdlckRlbGVnYXRlcy5zZXQob3duZXIsIGRlbGVnYXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZWdhdGU7XG4gIH1cblxuICBjcmVhdGUob3duZXI6IE8sIGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsIGRlZmluaXRpb246IG9iamVjdCwgY2FwdHVyZWRBcmdzOiBDYXB0dXJlZEFyZ3VtZW50cykge1xuICAgIGxldCBkZWxlZ2F0ZSA9IHRoaXMuZ2V0RGVsZWdhdGVGb3Iob3duZXIpO1xuXG4gICAgbGV0IGFyZ3MgPSBhcmdzUHJveHlGb3IoY2FwdHVyZWRBcmdzLCAnbW9kaWZpZXInKTtcbiAgICBsZXQgaW5zdGFuY2U6IE1vZGlmaWVySW5zdGFuY2UgPSBkZWxlZ2F0ZS5jcmVhdGVNb2RpZmllcihkZWZpbml0aW9uLCBhcmdzKTtcblxuICAgIGxldCB0YWcgPSBjcmVhdGVVcGRhdGFibGVUYWcoKTtcbiAgICBsZXQgc3RhdGU6IEN1c3RvbU1vZGlmaWVyU3RhdGU8TW9kaWZpZXJJbnN0YW5jZT47XG5cbiAgICBzdGF0ZSA9IHtcbiAgICAgIHRhZyxcbiAgICAgIGVsZW1lbnQsXG4gICAgICBkZWxlZ2F0ZSxcbiAgICAgIGFyZ3MsXG4gICAgICBtb2RpZmllcjogaW5zdGFuY2UhLFxuICAgIH07XG5cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIHN0YXRlLmRlYnVnTmFtZSA9IHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nID8gZGVmaW5pdGlvbi5uYW1lIDogZGVmaW5pdGlvbi50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyRGVzdHJ1Y3RvcihzdGF0ZSwgKCkgPT4gZGVsZWdhdGUuZGVzdHJveU1vZGlmaWVyKGluc3RhbmNlLCBhcmdzKSk7XG5cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBnZXREZWJ1Z05hbWUoeyBkZWJ1Z05hbWUgfTogQ3VzdG9tTW9kaWZpZXJTdGF0ZTxNb2RpZmllckluc3RhbmNlPikge1xuICAgIHJldHVybiBkZWJ1Z05hbWUhO1xuICB9XG5cbiAgZ2V0VGFnKHsgdGFnIH06IEN1c3RvbU1vZGlmaWVyU3RhdGU8TW9kaWZpZXJJbnN0YW5jZT4pIHtcbiAgICByZXR1cm4gdGFnO1xuICB9XG5cbiAgaW5zdGFsbCh7IGVsZW1lbnQsIGFyZ3MsIG1vZGlmaWVyLCBkZWxlZ2F0ZSB9OiBDdXN0b21Nb2RpZmllclN0YXRlPE1vZGlmaWVySW5zdGFuY2U+KSB7XG4gICAgbGV0IHsgY2FwYWJpbGl0aWVzIH0gPSBkZWxlZ2F0ZTtcblxuICAgIGlmIChjYXBhYmlsaXRpZXMuZGlzYWJsZUF1dG9UcmFja2luZyA9PT0gdHJ1ZSkge1xuICAgICAgdW50cmFjaygoKSA9PiBkZWxlZ2F0ZS5pbnN0YWxsTW9kaWZpZXIobW9kaWZpZXIsIGNhc3RUb0Jyb3dzZXIoZWxlbWVudCwgJ0VMRU1FTlQnKSwgYXJncykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxlZ2F0ZS5pbnN0YWxsTW9kaWZpZXIobW9kaWZpZXIsIGNhc3RUb0Jyb3dzZXIoZWxlbWVudCwgJ0VMRU1FTlQnKSwgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKHsgYXJncywgbW9kaWZpZXIsIGRlbGVnYXRlIH06IEN1c3RvbU1vZGlmaWVyU3RhdGU8TW9kaWZpZXJJbnN0YW5jZT4pIHtcbiAgICBsZXQgeyBjYXBhYmlsaXRpZXMgfSA9IGRlbGVnYXRlO1xuXG4gICAgaWYgKGNhcGFiaWxpdGllcy5kaXNhYmxlQXV0b1RyYWNraW5nID09PSB0cnVlKSB7XG4gICAgICB1bnRyYWNrKCgpID0+IGRlbGVnYXRlLnVwZGF0ZU1vZGlmaWVyKG1vZGlmaWVyLCBhcmdzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGVnYXRlLnVwZGF0ZU1vZGlmaWVyKG1vZGlmaWVyLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICBnZXREZXN0cm95YWJsZShzdGF0ZTogQ3VzdG9tTW9kaWZpZXJTdGF0ZTxNb2RpZmllckluc3RhbmNlPikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVpZnlBcmdzKHtcbiAgbmFtZWQsXG4gIHBvc2l0aW9uYWwsXG59OiBDYXB0dXJlZEFyZ3VtZW50cyk6IHsgbmFtZWQ6IFJlY29yZDxzdHJpbmcsIHVua25vd24+OyBwb3NpdGlvbmFsOiB1bmtub3duW10gfSB7XG4gIGxldCByZWlmaWVkTmFtZWQgPSBkaWN0KCk7XG5cbiAgZm9yIChsZXQga2V5IGluIG5hbWVkKSB7XG4gICAgcmVpZmllZE5hbWVkW2tleV0gPSB2YWx1ZUZvclJlZihuYW1lZFtrZXldKTtcbiAgfVxuXG4gIGxldCByZWlmaWVkUG9zaXRpb25hbCA9IHBvc2l0aW9uYWwubWFwKHZhbHVlRm9yUmVmKTtcblxuICByZXR1cm4ge1xuICAgIG5hbWVkOiByZWlmaWVkTmFtZWQsXG4gICAgcG9zaXRpb25hbDogcmVpZmllZFBvc2l0aW9uYWwsXG4gIH07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9