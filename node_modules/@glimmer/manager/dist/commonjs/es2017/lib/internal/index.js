"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setInternalModifierManager = setInternalModifierManager;
exports.getInternalModifierManager = getInternalModifierManager;
exports.setInternalHelperManager = setInternalHelperManager;
exports.getInternalHelperManager = getInternalHelperManager;
exports.setInternalComponentManager = setInternalComponentManager;
exports.getInternalComponentManager = getInternalComponentManager;
exports.hasInternalComponentManager = hasInternalComponentManager;
exports.hasInternalHelperManager = hasInternalHelperManager;
exports.hasInternalModifierManager = hasInternalModifierManager;

var _env = require("@glimmer/env");

var _util = require("@glimmer/util");

var _globalContext = require("@glimmer/global-context");

var _helper = require("../public/helper");

var _defaults = require("./defaults");

const COMPONENT_MANAGERS = new WeakMap();
const MODIFIER_MANAGERS = new WeakMap();
const HELPER_MANAGERS = new WeakMap(); ///////////

const getPrototypeOf = Object.getPrototypeOf;

function setManager(map, manager, obj) {
  if (_env.DEBUG && (typeof obj !== 'object' || obj === null) && typeof obj !== 'function') {
    throw new Error(`Attempted to set a manager on a non-object value. Managers can only be associated with objects or functions. Value was ${(0, _util.debugToString)(obj)}`);
  }

  if (_env.DEBUG && map.has(obj)) {
    throw new Error(`Attempted to set the same type of manager multiple times on a value. You can only associate one manager of each type with a given value. Value was ${(0, _util.debugToString)(obj)}`);
  }

  map.set(obj, manager);
  return obj;
}

function getManager(map, obj) {
  let pointer = obj;

  while (pointer !== undefined && pointer !== null) {
    const manager = map.get(pointer);

    if (manager !== undefined) {
      return manager;
    }

    pointer = getPrototypeOf(pointer);
  }

  return undefined;
} ///////////


function setInternalModifierManager(manager, definition) {
  return setManager(MODIFIER_MANAGERS, manager, definition);
}

function getInternalModifierManager(definition, isOptional) {
  if (_env.DEBUG && typeof definition !== 'function' && (typeof definition !== 'object' || definition === null)) {
    throw new Error(`Attempted to use a value as a modifier, but it was not an object or function. Modifier definitions must be objects or functions with an associated modifier manager. The value was: ${definition}`);
  }

  const manager = getManager(MODIFIER_MANAGERS, definition);

  if (manager === undefined) {
    if (isOptional === true) {
      return null;
    } else if (_env.DEBUG) {
      throw new Error(`Attempted to load a modifier, but there wasn't a modifier manager associated with the definition. The definition was: ${(0, _util.debugToString)(definition)}`);
    }
  }

  return manager;
}

function setInternalHelperManager(manager, definition) {
  return setManager(HELPER_MANAGERS, manager, definition);
}

const DEFAULT_MANAGER = new _helper.CustomHelperManager(() => new _defaults.FunctionHelperManager());

function getInternalHelperManager(definition, isOptional) {
  if (_env.DEBUG && typeof definition !== 'function' && (typeof definition !== 'object' || definition === null)) {
    throw new Error(`Attempted to use a value as a helper, but it was not an object or function. Helper definitions must be objects or functions with an associated helper manager. The value was: ${definition}`);
  }

  let manager = getManager(HELPER_MANAGERS, definition);

  if (_globalContext.FEATURE_DEFAULT_HELPER_MANAGER) {
    // Functions are special-cased because functions are defined
    // as the "default" helper, per: https://github.com/emberjs/rfcs/pull/756
    if (manager === undefined && typeof definition === 'function') {
      manager = DEFAULT_MANAGER;
    }
  }

  if (manager) {
    return manager;
  } else if (isOptional === true) {
    return null;
  } else if (_env.DEBUG) {
    throw new Error(`Attempted to load a helper, but there wasn't a helper manager associated with the definition. The definition was: ${(0, _util.debugToString)(definition)}`);
  }

  return null;
}

function setInternalComponentManager(factory, obj) {
  return setManager(COMPONENT_MANAGERS, factory, obj);
}

function getInternalComponentManager(definition, isOptional) {
  if (_env.DEBUG && typeof definition !== 'function' && (typeof definition !== 'object' || definition === null)) {
    throw new Error(`Attempted to use a value as a component, but it was not an object or function. Component definitions must be objects or functions with an associated component manager. The value was: ${definition}`);
  }

  const manager = getManager(COMPONENT_MANAGERS, definition);

  if (manager === undefined) {
    if (isOptional === true) {
      return null;
    } else if (_env.DEBUG) {
      throw new Error(`Attempted to load a component, but there wasn't a component manager associated with the definition. The definition was: ${(0, _util.debugToString)(definition)}`);
    }
  }

  return manager;
} ///////////


function hasInternalComponentManager(definition) {
  return hasDefaultComponentManager(definition) || getManager(COMPONENT_MANAGERS, definition) !== undefined;
}

function hasInternalHelperManager(definition) {
  return hasDefaultHelperManager(definition) || getManager(HELPER_MANAGERS, definition) !== undefined;
}

function hasInternalModifierManager(definition) {
  return hasDefaultModifierManager(definition) || getManager(MODIFIER_MANAGERS, definition) !== undefined;
}

function hasDefaultComponentManager(_definition) {
  return false;
}

function hasDefaultHelperManager(definition) {
  if (_globalContext.FEATURE_DEFAULT_HELPER_MANAGER) {
    return typeof definition === 'function';
  }

  return false;
}

function hasDefaultModifierManager(_definition) {
  return false;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL2ludGVybmFsL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQU9BOztBQUNBOztBQVFBLE1BQU0sa0JBQWtCLEdBQUcsSUFBM0IsT0FBMkIsRUFBM0I7QUFFQSxNQUFNLGlCQUFpQixHQUFHLElBQTFCLE9BQTBCLEVBQTFCO0FBRUEsTUFBTSxlQUFlLEdBQUcsSUFBeEIsT0FBd0IsRUFBeEIsQyxDQUVBOztBQUVBLE1BQU0sY0FBYyxHQUFHLE1BQU0sQ0FBN0IsY0FBQTs7QUFFQSxTQUFBLFVBQUEsQ0FBQSxHQUFBLEVBQUEsT0FBQSxFQUFBLEdBQUEsRUFHVTtBQUVSLE1BQUksZUFBVSxPQUFBLEdBQUEsS0FBQSxRQUFBLElBQTJCLEdBQUcsS0FBeEMsSUFBQSxLQUFzRCxPQUFBLEdBQUEsS0FBMUQsVUFBQSxFQUFxRjtBQUNuRixVQUFNLElBQUEsS0FBQSxDQUNKLDBIQUEwSCx5QkFBYyxHQUFkLENBRDVILEVBQU0sQ0FBTjtBQUtEOztBQUVELE1BQUksY0FBUyxHQUFHLENBQUgsR0FBQSxDQUFiLEdBQWEsQ0FBYixFQUEyQjtBQUN6QixVQUFNLElBQUEsS0FBQSxDQUNKLHNKQUFzSix5QkFBYyxHQUFkLENBRHhKLEVBQU0sQ0FBTjtBQUtEOztBQUVELEVBQUEsR0FBRyxDQUFILEdBQUEsQ0FBQSxHQUFBLEVBQUEsT0FBQTtBQUNBLFNBQUEsR0FBQTtBQUNEOztBQUVELFNBQUEsVUFBQSxDQUFBLEdBQUEsRUFBQSxHQUFBLEVBRWE7QUFFWCxNQUFJLE9BQU8sR0FBWCxHQUFBOztBQUNBLFNBQU8sT0FBTyxLQUFQLFNBQUEsSUFBeUIsT0FBTyxLQUF2QyxJQUFBLEVBQWtEO0FBQ2hELFVBQU0sT0FBTyxHQUFHLEdBQUcsQ0FBSCxHQUFBLENBQWhCLE9BQWdCLENBQWhCOztBQUVBLFFBQUksT0FBTyxLQUFYLFNBQUEsRUFBMkI7QUFDekIsYUFBQSxPQUFBO0FBQ0Q7O0FBRUQsSUFBQSxPQUFPLEdBQUcsY0FBYyxDQUF4QixPQUF3QixDQUF4QjtBQUNEOztBQUVELFNBQUEsU0FBQTtFQUdGOzs7QUFFTSxTQUFBLDBCQUFBLENBQUEsT0FBQSxFQUFBLFVBQUEsRUFFUztBQUViLFNBQU8sVUFBVSxDQUFBLGlCQUFBLEVBQUEsT0FBQSxFQUFqQixVQUFpQixDQUFqQjtBQUNEOztBQU9LLFNBQUEsMEJBQUEsQ0FBQSxVQUFBLEVBQUEsVUFBQSxFQUV5QjtBQUU3QixNQUNFLGNBQ0EsT0FBQSxVQUFBLEtBREEsVUFBQSxLQUVDLE9BQUEsVUFBQSxLQUFBLFFBQUEsSUFBa0MsVUFBVSxLQUgvQyxJQUNFLENBREYsRUFJRTtBQUNBLFVBQU0sSUFBQSxLQUFBLENBQ0osdUxBQXVMLFVBRHpMLEVBQU0sQ0FBTjtBQUdEOztBQUVELFFBQU0sT0FBTyxHQUFHLFVBQVUsQ0FBQSxpQkFBQSxFQUExQixVQUEwQixDQUExQjs7QUFFQSxNQUFJLE9BQU8sS0FBWCxTQUFBLEVBQTJCO0FBQ3pCLFFBQUksVUFBVSxLQUFkLElBQUEsRUFBeUI7QUFDdkIsYUFBQSxJQUFBO0FBREYsS0FBQSxNQUVPLElBQUEsVUFBQSxFQUFXO0FBQ2hCLFlBQU0sSUFBQSxLQUFBLENBQ0oseUhBQXlILHlCQUFjLFVBQWQsQ0FEM0gsRUFBTSxDQUFOO0FBS0Q7QUFDRjs7QUFFRCxTQUFBLE9BQUE7QUFDRDs7QUFFSyxTQUFBLHdCQUFBLENBQUEsT0FBQSxFQUFBLFVBQUEsRUFFUztBQUViLFNBQU8sVUFBVSxDQUFBLGVBQUEsRUFBQSxPQUFBLEVBQWpCLFVBQWlCLENBQWpCO0FBQ0Q7O0FBRUQsTUFBTSxlQUFlLEdBQUcsSUFBQSwyQkFBQSxDQUF3QixNQUFNLElBQXRELCtCQUFzRCxFQUE5QixDQUF4Qjs7QUFPTSxTQUFBLHdCQUFBLENBQUEsVUFBQSxFQUFBLFVBQUEsRUFFeUI7QUFFN0IsTUFDRSxjQUNBLE9BQUEsVUFBQSxLQURBLFVBQUEsS0FFQyxPQUFBLFVBQUEsS0FBQSxRQUFBLElBQWtDLFVBQVUsS0FIL0MsSUFDRSxDQURGLEVBSUU7QUFDQSxVQUFNLElBQUEsS0FBQSxDQUNKLGlMQUFpTCxVQURuTCxFQUFNLENBQU47QUFHRDs7QUFFRCxNQUFJLE9BQU8sR0FBRyxVQUFVLENBQUEsZUFBQSxFQUF4QixVQUF3QixDQUF4Qjs7QUFFQSxNQUFBLDZDQUFBLEVBQW9DO0FBQ2xDO0FBQ0E7QUFDQSxRQUFJLE9BQU8sS0FBUCxTQUFBLElBQXlCLE9BQUEsVUFBQSxLQUE3QixVQUFBLEVBQStEO0FBQzdELE1BQUEsT0FBTyxHQUFQLGVBQUE7QUFDRDtBQUNGOztBQUVELE1BQUEsT0FBQSxFQUFhO0FBQ1gsV0FBQSxPQUFBO0FBREYsR0FBQSxNQUVPLElBQUksVUFBVSxLQUFkLElBQUEsRUFBeUI7QUFDOUIsV0FBQSxJQUFBO0FBREssR0FBQSxNQUVBLElBQUEsVUFBQSxFQUFXO0FBQ2hCLFVBQU0sSUFBQSxLQUFBLENBQ0oscUhBQXFILHlCQUFjLFVBQWQsQ0FEdkgsRUFBTSxDQUFOO0FBS0Q7O0FBRUQsU0FBQSxJQUFBO0FBQ0Q7O0FBRUssU0FBQSwyQkFBQSxDQUFBLE9BQUEsRUFBQSxHQUFBLEVBRUU7QUFFTixTQUFPLFVBQVUsQ0FBQSxrQkFBQSxFQUFBLE9BQUEsRUFBakIsR0FBaUIsQ0FBakI7QUFDRDs7QUFPSyxTQUFBLDJCQUFBLENBQUEsVUFBQSxFQUFBLFVBQUEsRUFFeUI7QUFFN0IsTUFDRSxjQUNBLE9BQUEsVUFBQSxLQURBLFVBQUEsS0FFQyxPQUFBLFVBQUEsS0FBQSxRQUFBLElBQWtDLFVBQVUsS0FIL0MsSUFDRSxDQURGLEVBSUU7QUFDQSxVQUFNLElBQUEsS0FBQSxDQUNKLDBMQUEwTCxVQUQ1TCxFQUFNLENBQU47QUFHRDs7QUFFRCxRQUFNLE9BQU8sR0FBRyxVQUFVLENBQUEsa0JBQUEsRUFBMUIsVUFBMEIsQ0FBMUI7O0FBRUEsTUFBSSxPQUFPLEtBQVgsU0FBQSxFQUEyQjtBQUN6QixRQUFJLFVBQVUsS0FBZCxJQUFBLEVBQXlCO0FBQ3ZCLGFBQUEsSUFBQTtBQURGLEtBQUEsTUFFTyxJQUFBLFVBQUEsRUFBVztBQUNoQixZQUFNLElBQUEsS0FBQSxDQUNKLDJIQUEySCx5QkFBYyxVQUFkLENBRDdILEVBQU0sQ0FBTjtBQUtEO0FBQ0Y7O0FBRUQsU0FBQSxPQUFBO0VBR0Y7OztBQUVNLFNBQUEsMkJBQUEsQ0FBQSxVQUFBLEVBQXdEO0FBQzVELFNBQ0UsMEJBQTBCLENBQTFCLFVBQTBCLENBQTFCLElBQ0EsVUFBVSxDQUFBLGtCQUFBLEVBQVYsVUFBVSxDQUFWLEtBRkYsU0FBQTtBQUlEOztBQUVLLFNBQUEsd0JBQUEsQ0FBQSxVQUFBLEVBQXFEO0FBQ3pELFNBQ0UsdUJBQXVCLENBQXZCLFVBQXVCLENBQXZCLElBQXVDLFVBQVUsQ0FBQSxlQUFBLEVBQVYsVUFBVSxDQUFWLEtBRHpDLFNBQUE7QUFHRDs7QUFFSyxTQUFBLDBCQUFBLENBQUEsVUFBQSxFQUF1RDtBQUMzRCxTQUNFLHlCQUF5QixDQUF6QixVQUF5QixDQUF6QixJQUF5QyxVQUFVLENBQUEsaUJBQUEsRUFBVixVQUFVLENBQVYsS0FEM0MsU0FBQTtBQUdEOztBQUVELFNBQUEsMEJBQUEsQ0FBQSxXQUFBLEVBQXVEO0FBQ3JELFNBQUEsS0FBQTtBQUNEOztBQUVELFNBQUEsdUJBQUEsQ0FBQSxVQUFBLEVBQW1EO0FBQ2pELE1BQUEsNkNBQUEsRUFBb0M7QUFDbEMsV0FBTyxPQUFBLFVBQUEsS0FBUCxVQUFBO0FBQ0Q7O0FBRUQsU0FBQSxLQUFBO0FBQ0Q7O0FBRUQsU0FBQSx5QkFBQSxDQUFBLFdBQUEsRUFBc0Q7QUFDcEQsU0FBQSxLQUFBO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQgeyBkZWJ1Z1RvU3RyaW5nLCBfV2Vha1NldCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgRkVBVFVSRV9ERUZBVUxUX0hFTFBFUl9NQU5BR0VSIH0gZnJvbSAnQGdsaW1tZXIvZ2xvYmFsLWNvbnRleHQnO1xuaW1wb3J0IHtcbiAgSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyLFxuICBJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcixcbiAgSGVscGVyLFxuICBPd25lcixcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBDdXN0b21IZWxwZXJNYW5hZ2VyIH0gZnJvbSAnLi4vcHVibGljL2hlbHBlcic7XG5pbXBvcnQgeyBGdW5jdGlvbkhlbHBlck1hbmFnZXIgfSBmcm9tICcuL2RlZmF1bHRzJztcblxudHlwZSBJbnRlcm5hbE1hbmFnZXIgPVxuICB8IEludGVybmFsQ29tcG9uZW50TWFuYWdlclxuICB8IEludGVybmFsTW9kaWZpZXJNYW5hZ2VyXG4gIHwgQ3VzdG9tSGVscGVyTWFuYWdlclxuICB8IEhlbHBlcjtcblxuY29uc3QgQ09NUE9ORU5UX01BTkFHRVJTID0gbmV3IFdlYWtNYXA8b2JqZWN0LCBJbnRlcm5hbENvbXBvbmVudE1hbmFnZXI+KCk7XG5cbmNvbnN0IE1PRElGSUVSX01BTkFHRVJTID0gbmV3IFdlYWtNYXA8b2JqZWN0LCBJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcj4oKTtcblxuY29uc3QgSEVMUEVSX01BTkFHRVJTID0gbmV3IFdlYWtNYXA8b2JqZWN0LCBDdXN0b21IZWxwZXJNYW5hZ2VyIHwgSGVscGVyPigpO1xuXG4vLy8vLy8vLy8vL1xuXG5jb25zdCBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxuZnVuY3Rpb24gc2V0TWFuYWdlcjxEZWYgZXh0ZW5kcyBvYmplY3Q+KFxuICBtYXA6IFdlYWtNYXA8b2JqZWN0LCBvYmplY3Q+LFxuICBtYW5hZ2VyOiBvYmplY3QsXG4gIG9iajogRGVmXG4pOiBEZWYge1xuICBpZiAoREVCVUcgJiYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbCkgJiYgdHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBdHRlbXB0ZWQgdG8gc2V0IGEgbWFuYWdlciBvbiBhIG5vbi1vYmplY3QgdmFsdWUuIE1hbmFnZXJzIGNhbiBvbmx5IGJlIGFzc29jaWF0ZWQgd2l0aCBvYmplY3RzIG9yIGZ1bmN0aW9ucy4gVmFsdWUgd2FzICR7ZGVidWdUb1N0cmluZyEoXG4gICAgICAgIG9ialxuICAgICAgKX1gXG4gICAgKTtcbiAgfVxuXG4gIGlmIChERUJVRyAmJiBtYXAuaGFzKG9iaikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQXR0ZW1wdGVkIHRvIHNldCB0aGUgc2FtZSB0eXBlIG9mIG1hbmFnZXIgbXVsdGlwbGUgdGltZXMgb24gYSB2YWx1ZS4gWW91IGNhbiBvbmx5IGFzc29jaWF0ZSBvbmUgbWFuYWdlciBvZiBlYWNoIHR5cGUgd2l0aCBhIGdpdmVuIHZhbHVlLiBWYWx1ZSB3YXMgJHtkZWJ1Z1RvU3RyaW5nIShcbiAgICAgICAgb2JqXG4gICAgICApfWBcbiAgICApO1xuICB9XG5cbiAgbWFwLnNldChvYmosIG1hbmFnZXIpO1xuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBnZXRNYW5hZ2VyPE0gZXh0ZW5kcyBJbnRlcm5hbE1hbmFnZXI+KFxuICBtYXA6IFdlYWtNYXA8b2JqZWN0LCBNPixcbiAgb2JqOiBvYmplY3Rcbik6IE0gfCB1bmRlZmluZWQge1xuICBsZXQgcG9pbnRlciA9IG9iajtcbiAgd2hpbGUgKHBvaW50ZXIgIT09IHVuZGVmaW5lZCAmJiBwb2ludGVyICE9PSBudWxsKSB7XG4gICAgY29uc3QgbWFuYWdlciA9IG1hcC5nZXQocG9pbnRlcik7XG5cbiAgICBpZiAobWFuYWdlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbWFuYWdlcjtcbiAgICB9XG5cbiAgICBwb2ludGVyID0gZ2V0UHJvdG90eXBlT2YocG9pbnRlcik7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0SW50ZXJuYWxNb2RpZmllck1hbmFnZXI8VCBleHRlbmRzIG9iamVjdD4oXG4gIG1hbmFnZXI6IEludGVybmFsTW9kaWZpZXJNYW5hZ2VyLFxuICBkZWZpbml0aW9uOiBUXG4pOiBUIHtcbiAgcmV0dXJuIHNldE1hbmFnZXIoTU9ESUZJRVJfTUFOQUdFUlMsIG1hbmFnZXIsIGRlZmluaXRpb24pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJuYWxNb2RpZmllck1hbmFnZXIoZGVmaW5pdGlvbjogb2JqZWN0KTogSW50ZXJuYWxNb2RpZmllck1hbmFnZXI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJuYWxNb2RpZmllck1hbmFnZXIoXG4gIGRlZmluaXRpb246IG9iamVjdCxcbiAgaXNPcHRpb25hbDogdHJ1ZSB8IHVuZGVmaW5lZFxuKTogSW50ZXJuYWxNb2RpZmllck1hbmFnZXIgfCBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVybmFsTW9kaWZpZXJNYW5hZ2VyKFxuICBkZWZpbml0aW9uOiBvYmplY3QsXG4gIGlzT3B0aW9uYWw/OiB0cnVlIHwgdW5kZWZpbmVkXG4pOiBJbnRlcm5hbE1vZGlmaWVyTWFuYWdlciB8IG51bGwge1xuICBpZiAoXG4gICAgREVCVUcgJiZcbiAgICB0eXBlb2YgZGVmaW5pdGlvbiAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICh0eXBlb2YgZGVmaW5pdGlvbiAhPT0gJ29iamVjdCcgfHwgZGVmaW5pdGlvbiA9PT0gbnVsbClcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRlZCB0byB1c2UgYSB2YWx1ZSBhcyBhIG1vZGlmaWVyLCBidXQgaXQgd2FzIG5vdCBhbiBvYmplY3Qgb3IgZnVuY3Rpb24uIE1vZGlmaWVyIGRlZmluaXRpb25zIG11c3QgYmUgb2JqZWN0cyBvciBmdW5jdGlvbnMgd2l0aCBhbiBhc3NvY2lhdGVkIG1vZGlmaWVyIG1hbmFnZXIuIFRoZSB2YWx1ZSB3YXM6ICR7ZGVmaW5pdGlvbn1gXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IG1hbmFnZXIgPSBnZXRNYW5hZ2VyKE1PRElGSUVSX01BTkFHRVJTLCBkZWZpbml0aW9uKSE7XG5cbiAgaWYgKG1hbmFnZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpc09wdGlvbmFsID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKERFQlVHKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBdHRlbXB0ZWQgdG8gbG9hZCBhIG1vZGlmaWVyLCBidXQgdGhlcmUgd2Fzbid0IGEgbW9kaWZpZXIgbWFuYWdlciBhc3NvY2lhdGVkIHdpdGggdGhlIGRlZmluaXRpb24uIFRoZSBkZWZpbml0aW9uIHdhczogJHtkZWJ1Z1RvU3RyaW5nIShcbiAgICAgICAgICBkZWZpbml0aW9uXG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWFuYWdlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEludGVybmFsSGVscGVyTWFuYWdlcjxUIGV4dGVuZHMgb2JqZWN0LCBPIGV4dGVuZHMgT3duZXI+KFxuICBtYW5hZ2VyOiBDdXN0b21IZWxwZXJNYW5hZ2VyPE8+IHwgSGVscGVyPE8+LFxuICBkZWZpbml0aW9uOiBUXG4pOiBUIHtcbiAgcmV0dXJuIHNldE1hbmFnZXIoSEVMUEVSX01BTkFHRVJTLCBtYW5hZ2VyLCBkZWZpbml0aW9uKTtcbn1cblxuY29uc3QgREVGQVVMVF9NQU5BR0VSID0gbmV3IEN1c3RvbUhlbHBlck1hbmFnZXIoKCkgPT4gbmV3IEZ1bmN0aW9uSGVscGVyTWFuYWdlcigpKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVybmFsSGVscGVyTWFuYWdlcihkZWZpbml0aW9uOiBvYmplY3QpOiBDdXN0b21IZWxwZXJNYW5hZ2VyIHwgSGVscGVyO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVybmFsSGVscGVyTWFuYWdlcihcbiAgZGVmaW5pdGlvbjogb2JqZWN0LFxuICBpc09wdGlvbmFsOiB0cnVlIHwgdW5kZWZpbmVkXG4pOiBDdXN0b21IZWxwZXJNYW5hZ2VyIHwgSGVscGVyIHwgbnVsbDtcbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcm5hbEhlbHBlck1hbmFnZXIoXG4gIGRlZmluaXRpb246IG9iamVjdCxcbiAgaXNPcHRpb25hbD86IHRydWUgfCB1bmRlZmluZWRcbik6IEN1c3RvbUhlbHBlck1hbmFnZXIgfCBIZWxwZXIgfCBudWxsIHtcbiAgaWYgKFxuICAgIERFQlVHICYmXG4gICAgdHlwZW9mIGRlZmluaXRpb24gIT09ICdmdW5jdGlvbicgJiZcbiAgICAodHlwZW9mIGRlZmluaXRpb24gIT09ICdvYmplY3QnIHx8IGRlZmluaXRpb24gPT09IG51bGwpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBdHRlbXB0ZWQgdG8gdXNlIGEgdmFsdWUgYXMgYSBoZWxwZXIsIGJ1dCBpdCB3YXMgbm90IGFuIG9iamVjdCBvciBmdW5jdGlvbi4gSGVscGVyIGRlZmluaXRpb25zIG11c3QgYmUgb2JqZWN0cyBvciBmdW5jdGlvbnMgd2l0aCBhbiBhc3NvY2lhdGVkIGhlbHBlciBtYW5hZ2VyLiBUaGUgdmFsdWUgd2FzOiAke2RlZmluaXRpb259YFxuICAgICk7XG4gIH1cblxuICBsZXQgbWFuYWdlciA9IGdldE1hbmFnZXIoSEVMUEVSX01BTkFHRVJTLCBkZWZpbml0aW9uKTtcblxuICBpZiAoRkVBVFVSRV9ERUZBVUxUX0hFTFBFUl9NQU5BR0VSKSB7XG4gICAgLy8gRnVuY3Rpb25zIGFyZSBzcGVjaWFsLWNhc2VkIGJlY2F1c2UgZnVuY3Rpb25zIGFyZSBkZWZpbmVkXG4gICAgLy8gYXMgdGhlIFwiZGVmYXVsdFwiIGhlbHBlciwgcGVyOiBodHRwczovL2dpdGh1Yi5jb20vZW1iZXJqcy9yZmNzL3B1bGwvNzU2XG4gICAgaWYgKG1hbmFnZXIgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgbWFuYWdlciA9IERFRkFVTFRfTUFOQUdFUjtcbiAgICB9XG4gIH1cblxuICBpZiAobWFuYWdlcikge1xuICAgIHJldHVybiBtYW5hZ2VyO1xuICB9IGVsc2UgaWYgKGlzT3B0aW9uYWwgPT09IHRydWUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChERUJVRykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBdHRlbXB0ZWQgdG8gbG9hZCBhIGhlbHBlciwgYnV0IHRoZXJlIHdhc24ndCBhIGhlbHBlciBtYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgZGVmaW5pdGlvbi4gVGhlIGRlZmluaXRpb24gd2FzOiAke2RlYnVnVG9TdHJpbmchKFxuICAgICAgICBkZWZpbml0aW9uXG4gICAgICApfWBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRJbnRlcm5hbENvbXBvbmVudE1hbmFnZXI8VCBleHRlbmRzIG9iamVjdD4oXG4gIGZhY3Rvcnk6IEludGVybmFsQ29tcG9uZW50TWFuYWdlcixcbiAgb2JqOiBUXG4pOiBUIHtcbiAgcmV0dXJuIHNldE1hbmFnZXIoQ09NUE9ORU5UX01BTkFHRVJTLCBmYWN0b3J5LCBvYmopO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyKGRlZmluaXRpb246IG9iamVjdCk6IEludGVybmFsQ29tcG9uZW50TWFuYWdlcjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIoXG4gIGRlZmluaXRpb246IG9iamVjdCxcbiAgaXNPcHRpb25hbDogdHJ1ZSB8IHVuZGVmaW5lZFxuKTogSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyIHwgbnVsbDtcbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIoXG4gIGRlZmluaXRpb246IG9iamVjdCxcbiAgaXNPcHRpb25hbD86IHRydWUgfCB1bmRlZmluZWRcbik6IEludGVybmFsQ29tcG9uZW50TWFuYWdlciB8IG51bGwge1xuICBpZiAoXG4gICAgREVCVUcgJiZcbiAgICB0eXBlb2YgZGVmaW5pdGlvbiAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICh0eXBlb2YgZGVmaW5pdGlvbiAhPT0gJ29iamVjdCcgfHwgZGVmaW5pdGlvbiA9PT0gbnVsbClcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRlZCB0byB1c2UgYSB2YWx1ZSBhcyBhIGNvbXBvbmVudCwgYnV0IGl0IHdhcyBub3QgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uLiBDb21wb25lbnQgZGVmaW5pdGlvbnMgbXVzdCBiZSBvYmplY3RzIG9yIGZ1bmN0aW9ucyB3aXRoIGFuIGFzc29jaWF0ZWQgY29tcG9uZW50IG1hbmFnZXIuIFRoZSB2YWx1ZSB3YXM6ICR7ZGVmaW5pdGlvbn1gXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IG1hbmFnZXIgPSBnZXRNYW5hZ2VyKENPTVBPTkVOVF9NQU5BR0VSUywgZGVmaW5pdGlvbikhO1xuXG4gIGlmIChtYW5hZ2VyID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaXNPcHRpb25hbCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChERUJVRykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQXR0ZW1wdGVkIHRvIGxvYWQgYSBjb21wb25lbnQsIGJ1dCB0aGVyZSB3YXNuJ3QgYSBjb21wb25lbnQgbWFuYWdlciBhc3NvY2lhdGVkIHdpdGggdGhlIGRlZmluaXRpb24uIFRoZSBkZWZpbml0aW9uIHdhczogJHtkZWJ1Z1RvU3RyaW5nIShcbiAgICAgICAgICBkZWZpbml0aW9uXG4gICAgICAgICl9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWFuYWdlcjtcbn1cblxuLy8vLy8vLy8vLy9cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludGVybmFsQ29tcG9uZW50TWFuYWdlcihkZWZpbml0aW9uOiBvYmplY3QpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBoYXNEZWZhdWx0Q29tcG9uZW50TWFuYWdlcihkZWZpbml0aW9uKSB8fFxuICAgIGdldE1hbmFnZXIoQ09NUE9ORU5UX01BTkFHRVJTLCBkZWZpbml0aW9uKSAhPT0gdW5kZWZpbmVkXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNJbnRlcm5hbEhlbHBlck1hbmFnZXIoZGVmaW5pdGlvbjogb2JqZWN0KTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgaGFzRGVmYXVsdEhlbHBlck1hbmFnZXIoZGVmaW5pdGlvbikgfHwgZ2V0TWFuYWdlcihIRUxQRVJfTUFOQUdFUlMsIGRlZmluaXRpb24pICE9PSB1bmRlZmluZWRcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludGVybmFsTW9kaWZpZXJNYW5hZ2VyKGRlZmluaXRpb246IG9iamVjdCk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGhhc0RlZmF1bHRNb2RpZmllck1hbmFnZXIoZGVmaW5pdGlvbikgfHwgZ2V0TWFuYWdlcihNT0RJRklFUl9NQU5BR0VSUywgZGVmaW5pdGlvbikgIT09IHVuZGVmaW5lZFxuICApO1xufVxuXG5mdW5jdGlvbiBoYXNEZWZhdWx0Q29tcG9uZW50TWFuYWdlcihfZGVmaW5pdGlvbjogb2JqZWN0KTogYm9vbGVhbiB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaGFzRGVmYXVsdEhlbHBlck1hbmFnZXIoZGVmaW5pdGlvbjogb2JqZWN0KTogYm9vbGVhbiB7XG4gIGlmIChGRUFUVVJFX0RFRkFVTFRfSEVMUEVSX01BTkFHRVIpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGhhc0RlZmF1bHRNb2RpZmllck1hbmFnZXIoX2RlZmluaXRpb246IG9iamVjdCk6IGJvb2xlYW4ge1xuICByZXR1cm4gZmFsc2U7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9