"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCustomTagFor = getCustomTagFor;
exports.setCustomTagFor = setCustomTagFor;
exports.argsProxyFor = void 0;

var _env = require("@glimmer/env");

var _reference = require("@glimmer/reference");

var _util = require("@glimmer/util");

var _validator = require("@glimmer/validator");

const CUSTOM_TAG_FOR = new WeakMap();

function getCustomTagFor(obj) {
  return CUSTOM_TAG_FOR.get(obj);
}

function setCustomTagFor(obj, customTagFn) {
  CUSTOM_TAG_FOR.set(obj, customTagFn);
}

function convertToInt(prop) {
  if (typeof prop === 'symbol') return null;
  const num = Number(prop);
  if (isNaN(num)) return null;
  return num % 1 === 0 ? num : null;
}

function tagForNamedArg(namedArgs, key) {
  return (0, _validator.track)(() => {
    if (key in namedArgs) {
      (0, _reference.valueForRef)(namedArgs[key]);
    }
  });
}

function tagForPositionalArg(positionalArgs, key) {
  return (0, _validator.track)(() => {
    if (key === '[]') {
      // consume all of the tags in the positional array
      positionalArgs.forEach(_reference.valueForRef);
    }

    const parsed = convertToInt(key);

    if (parsed !== null && parsed < positionalArgs.length) {
      // consume the tag of the referenced index
      (0, _reference.valueForRef)(positionalArgs[parsed]);
    }
  });
}

let argsProxyFor;
exports.argsProxyFor = argsProxyFor;

class NamedArgsProxy {
  constructor(named) {
    this.named = named;
  }

  get(_target, prop) {
    const ref = this.named[prop];

    if (ref !== undefined) {
      return (0, _reference.valueForRef)(ref);
    }
  }

  has(_target, prop) {
    return prop in this.named;
  }

  ownKeys() {
    return Object.keys(this.named);
  }

  isExtensible() {
    return false;
  }

  getOwnPropertyDescriptor(_target, prop) {
    if (_env.DEBUG && !(prop in this.named)) {
      throw new Error(`args proxies do not have real property descriptors, so you should never need to call getOwnPropertyDescriptor yourself. This code exists for enumerability, such as in for-in loops and Object.keys(). Attempted to get the descriptor for \`${String(prop)}\``);
    }

    return {
      enumerable: true,
      configurable: true
    };
  }

}

class PositionalArgsProxy {
  constructor(positional) {
    this.positional = positional;
  }

  get(target, prop) {
    let {
      positional
    } = this;

    if (prop === 'length') {
      return positional.length;
    }

    const parsed = convertToInt(prop);

    if (parsed !== null && parsed < positional.length) {
      return (0, _reference.valueForRef)(positional[parsed]);
    }

    return target[prop];
  }

  isExtensible() {
    return false;
  }

  has(_target, prop) {
    const parsed = convertToInt(prop);
    return parsed !== null && parsed < this.positional.length;
  }

}

if (_util.HAS_NATIVE_PROXY) {
  exports.argsProxyFor = argsProxyFor = (capturedArgs, type) => {
    const {
      named,
      positional
    } = capturedArgs;

    let getNamedTag = (_obj, key) => tagForNamedArg(named, key);

    let getPositionalTag = (_obj, key) => tagForPositionalArg(positional, key);

    const namedHandler = new NamedArgsProxy(named);
    const positionalHandler = new PositionalArgsProxy(positional);
    const namedTarget = Object.create(null);
    const positionalTarget = [];

    if (_env.DEBUG) {
      const setHandler = function (_target, prop) {
        throw new Error(`You attempted to set ${String(prop)} on the arguments of a component, helper, or modifier. Arguments are immutable and cannot be updated directly; they always represent the values that are passed down. If you want to set default values, you should use a getter and local tracked state instead.`);
      };

      const forInDebugHandler = () => {
        throw new Error(`Object.keys() was called on the positional arguments array for a ${type}, which is not supported. This function is a low-level function that should not need to be called for positional argument arrays. You may be attempting to iterate over the array using for...in instead of for...of.`);
      };

      namedHandler.set = setHandler;
      positionalHandler.set = setHandler;
      positionalHandler.ownKeys = forInDebugHandler;
    }

    const namedProxy = new Proxy(namedTarget, namedHandler);
    const positionalProxy = new Proxy(positionalTarget, positionalHandler);
    setCustomTagFor(namedProxy, getNamedTag);
    setCustomTagFor(positionalProxy, getPositionalTag);
    return {
      named: namedProxy,
      positional: positionalProxy
    };
  };
} else {
  exports.argsProxyFor = argsProxyFor = (capturedArgs, _type) => {
    const {
      named,
      positional
    } = capturedArgs;

    let getNamedTag = (_obj, key) => tagForNamedArg(named, key);

    let getPositionalTag = (_obj, key) => tagForPositionalArg(positional, key);

    let namedProxy = {};
    let positionalProxy = [];
    setCustomTagFor(namedProxy, getNamedTag);
    setCustomTagFor(positionalProxy, getPositionalTag);
    Object.keys(named).forEach(name => {
      Object.defineProperty(namedProxy, name, {
        enumerable: true,
        configurable: true,

        get() {
          return (0, _reference.valueForRef)(named[name]);
        }

      });
    });
    positional.forEach((ref, index) => {
      Object.defineProperty(positionalProxy, index, {
        enumerable: true,
        configurable: true,

        get() {
          return (0, _reference.valueForRef)(ref);
        }

      });
    });

    if (_env.DEBUG) {
      // Prevent mutations in development mode. This will not prevent the
      // proxy from updating, but will prevent assigning new values or pushing
      // for instance.
      Object.freeze(namedProxy);
      Object.freeze(positionalProxy);
    }

    return {
      named: namedProxy,
      positional: positionalProxy
    };
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL3V0aWwvYXJncy1wcm94eS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFPQTs7QUFDQTs7QUFDQTs7QUFFQSxNQUFNLGNBQWMsR0FBRyxJQUF2QixPQUF1QixFQUF2Qjs7QUFFTSxTQUFBLGVBQUEsQ0FBQSxHQUFBLEVBQXFDO0FBQ3pDLFNBQU8sY0FBYyxDQUFkLEdBQUEsQ0FBUCxHQUFPLENBQVA7QUFDRDs7QUFFSyxTQUFBLGVBQUEsQ0FBQSxHQUFBLEVBQUEsV0FBQSxFQUFxRjtBQUN6RixFQUFBLGNBQWMsQ0FBZCxHQUFBLENBQUEsR0FBQSxFQUFBLFdBQUE7QUFDRDs7QUFFRCxTQUFBLFlBQUEsQ0FBQSxJQUFBLEVBQW9EO0FBQ2xELE1BQUksT0FBQSxJQUFBLEtBQUosUUFBQSxFQUE4QixPQUFBLElBQUE7QUFFOUIsUUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFsQixJQUFrQixDQUFsQjtBQUVBLE1BQUksS0FBSyxDQUFULEdBQVMsQ0FBVCxFQUFnQixPQUFBLElBQUE7QUFFaEIsU0FBTyxHQUFHLEdBQUgsQ0FBQSxLQUFBLENBQUEsR0FBQSxHQUFBLEdBQVAsSUFBQTtBQUNEOztBQUVELFNBQUEsY0FBQSxDQUFBLFNBQUEsRUFBQSxHQUFBLEVBQXNFO0FBQ3BFLFNBQU8sc0JBQU0sTUFBSztBQUNoQixRQUFJLEdBQUcsSUFBUCxTQUFBLEVBQXNCO0FBQ3BCLGtDQUFZLFNBQVMsQ0FBckIsR0FBcUIsQ0FBckI7QUFDRDtBQUhILEdBQU8sQ0FBUDtBQUtEOztBQUVELFNBQUEsbUJBQUEsQ0FBQSxjQUFBLEVBQUEsR0FBQSxFQUFxRjtBQUNuRixTQUFPLHNCQUFNLE1BQUs7QUFDaEIsUUFBSSxHQUFHLEtBQVAsSUFBQSxFQUFrQjtBQUNoQjtBQUNBLE1BQUEsY0FBYyxDQUFkLE9BQUEsQ0FBQSxzQkFBQTtBQUNEOztBQUVELFVBQU0sTUFB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QUNEOztBQUVELFdBQU87QUFDTCxNQUFBLEtBQUssRUFEQSxVQUFBO0FBRUwsTUFBQSxVQUFVLEVBQUU7QUFGUCxLQUFQO0FBeENGLEdBQUE7QUE2Q0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQge1xuICBBcmd1bWVudHMsXG4gIENhcHR1cmVkQXJndW1lbnRzLFxuICBDYXB0dXJlZE5hbWVkQXJndW1lbnRzLFxuICBDYXB0dXJlZFBvc2l0aW9uYWxBcmd1bWVudHMsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgUmVmZXJlbmNlLCB2YWx1ZUZvclJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBIQVNfTkFUSVZFX1BST1hZIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBUYWcsIHRyYWNrIH0gZnJvbSAnQGdsaW1tZXIvdmFsaWRhdG9yJztcblxuY29uc3QgQ1VTVE9NX1RBR19GT1IgPSBuZXcgV2Vha01hcDxvYmplY3QsIChvYmo6IG9iamVjdCwga2V5OiBzdHJpbmcpID0+IFRhZz4oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEN1c3RvbVRhZ0ZvcihvYmo6IG9iamVjdCk6ICgob2JqOiBvYmplY3QsIGtleTogc3RyaW5nKSA9PiBUYWcpIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIENVU1RPTV9UQUdfRk9SLmdldChvYmopO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0Q3VzdG9tVGFnRm9yKG9iajogb2JqZWN0LCBjdXN0b21UYWdGbjogKG9iajogb2JqZWN0LCBrZXk6IHN0cmluZykgPT4gVGFnKSB7XG4gIENVU1RPTV9UQUdfRk9SLnNldChvYmosIGN1c3RvbVRhZ0ZuKTtcbn1cblxuZnVuY3Rpb24gY29udmVydFRvSW50KHByb3A6IG51bWJlciB8IHN0cmluZyB8IHN5bWJvbCk6IG51bWJlciB8IG51bGwge1xuICBpZiAodHlwZW9mIHByb3AgPT09ICdzeW1ib2wnKSByZXR1cm4gbnVsbDtcblxuICBjb25zdCBudW0gPSBOdW1iZXIocHJvcCk7XG5cbiAgaWYgKGlzTmFOKG51bSkpIHJldHVybiBudWxsO1xuXG4gIHJldHVybiBudW0gJSAxID09PSAwID8gbnVtIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdGFnRm9yTmFtZWRBcmcobmFtZWRBcmdzOiBDYXB0dXJlZE5hbWVkQXJndW1lbnRzLCBrZXk6IHN0cmluZyk6IFRhZyB7XG4gIHJldHVybiB0cmFjaygoKSA9PiB7XG4gICAgaWYgKGtleSBpbiBuYW1lZEFyZ3MpIHtcbiAgICAgIHZhbHVlRm9yUmVmKG5hbWVkQXJnc1trZXldKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0YWdGb3JQb3NpdGlvbmFsQXJnKHBvc2l0aW9uYWxBcmdzOiBDYXB0dXJlZFBvc2l0aW9uYWxBcmd1bWVudHMsIGtleTogc3RyaW5nKTogVGFnIHtcbiAgcmV0dXJuIHRyYWNrKCgpID0+IHtcbiAgICBpZiAoa2V5ID09PSAnW10nKSB7XG4gICAgICAvLyBjb25zdW1lIGFsbCBvZiB0aGUgdGFncyBpbiB0aGUgcG9zaXRpb25hbCBhcnJheVxuICAgICAgcG9zaXRpb25hbEFyZ3MuZm9yRWFjaCh2YWx1ZUZvclJlZik7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkID0gY29udmVydFRvSW50KGtleSk7XG5cbiAgICBpZiAocGFyc2VkICE9PSBudWxsICYmIHBhcnNlZCA8IHBvc2l0aW9uYWxBcmdzLmxlbmd0aCkge1xuICAgICAgLy8gY29uc3VtZSB0aGUgdGFnIG9mIHRoZSByZWZlcmVuY2VkIGluZGV4XG4gICAgICB2YWx1ZUZvclJlZihwb3NpdGlvbmFsQXJnc1twYXJzZWRdKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgbGV0IGFyZ3NQcm94eUZvcjogKFxuICBjYXB0dXJlZEFyZ3M6IENhcHR1cmVkQXJndW1lbnRzLFxuICB0eXBlOiAnY29tcG9uZW50JyB8ICdoZWxwZXInIHwgJ21vZGlmaWVyJ1xuKSA9PiBBcmd1bWVudHM7XG5cbmNsYXNzIE5hbWVkQXJnc1Byb3h5IGltcGxlbWVudHMgUHJveHlIYW5kbGVyPHt9PiB7XG4gIGRlY2xhcmUgc2V0PzogKHRhcmdldDoge30sIHByb3A6IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCkgPT4gYm9vbGVhbjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5hbWVkOiBDYXB0dXJlZE5hbWVkQXJndW1lbnRzKSB7fVxuXG4gIGdldChfdGFyZ2V0OiB7fSwgcHJvcDogc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sKSB7XG4gICAgY29uc3QgcmVmID0gdGhpcy5uYW1lZFtwcm9wIGFzIHN0cmluZ107XG5cbiAgICBpZiAocmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB2YWx1ZUZvclJlZihyZWYpO1xuICAgIH1cbiAgfVxuXG4gIGhhcyhfdGFyZ2V0OiB7fSwgcHJvcDogc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3AgaW4gdGhpcy5uYW1lZDtcbiAgfVxuXG4gIG93bktleXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubmFtZWQpO1xuICB9XG5cbiAgaXNFeHRlbnNpYmxlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihfdGFyZ2V0OiB7fSwgcHJvcDogc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sKSB7XG4gICAgaWYgKERFQlVHICYmICEocHJvcCBpbiB0aGlzLm5hbWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgYXJncyBwcm94aWVzIGRvIG5vdCBoYXZlIHJlYWwgcHJvcGVydHkgZGVzY3JpcHRvcnMsIHNvIHlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBjYWxsIGdldE93blByb3BlcnR5RGVzY3JpcHRvciB5b3Vyc2VsZi4gVGhpcyBjb2RlIGV4aXN0cyBmb3IgZW51bWVyYWJpbGl0eSwgc3VjaCBhcyBpbiBmb3ItaW4gbG9vcHMgYW5kIE9iamVjdC5rZXlzKCkuIEF0dGVtcHRlZCB0byBnZXQgdGhlIGRlc2NyaXB0b3IgZm9yIFxcYCR7U3RyaW5nKFxuICAgICAgICAgIHByb3BcbiAgICAgICAgKX1cXGBgXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH07XG4gIH1cbn1cblxuY2xhc3MgUG9zaXRpb25hbEFyZ3NQcm94eSBpbXBsZW1lbnRzIFByb3h5SGFuZGxlcjxbXT4ge1xuICBkZWNsYXJlIHNldD86ICh0YXJnZXQ6IFtdLCBwcm9wOiBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpID0+IGJvb2xlYW47XG4gIGRlY2xhcmUgb3duS2V5cz86ICh0YXJnZXQ6IFtdKSA9PiBzdHJpbmdbXTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHBvc2l0aW9uYWw6IENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cykge31cblxuICBnZXQodGFyZ2V0OiBbXSwgcHJvcDogc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sKSB7XG4gICAgbGV0IHsgcG9zaXRpb25hbCB9ID0gdGhpcztcblxuICAgIGlmIChwcm9wID09PSAnbGVuZ3RoJykge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uYWwubGVuZ3RoO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcnNlZCA9IGNvbnZlcnRUb0ludChwcm9wKTtcblxuICAgIGlmIChwYXJzZWQgIT09IG51bGwgJiYgcGFyc2VkIDwgcG9zaXRpb25hbC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2YWx1ZUZvclJlZihwb3NpdGlvbmFsW3BhcnNlZF0pO1xuICAgIH1cblxuICAgIHJldHVybiAodGFyZ2V0IGFzIGFueSlbcHJvcF07XG4gIH1cblxuICBpc0V4dGVuc2libGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFzKF90YXJnZXQ6IFtdLCBwcm9wOiBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBjb252ZXJ0VG9JbnQocHJvcCk7XG5cbiAgICByZXR1cm4gcGFyc2VkICE9PSBudWxsICYmIHBhcnNlZCA8IHRoaXMucG9zaXRpb25hbC5sZW5ndGg7XG4gIH1cbn1cblxuaWYgKEhBU19OQVRJVkVfUFJPWFkpIHtcbiAgYXJnc1Byb3h5Rm9yID0gKGNhcHR1cmVkQXJncywgdHlwZSkgPT4ge1xuICAgIGNvbnN0IHsgbmFtZWQsIHBvc2l0aW9uYWwgfSA9IGNhcHR1cmVkQXJncztcblxuICAgIGxldCBnZXROYW1lZFRhZyA9IChfb2JqOiBvYmplY3QsIGtleTogc3RyaW5nKSA9PiB0YWdGb3JOYW1lZEFyZyhuYW1lZCwga2V5KTtcbiAgICBsZXQgZ2V0UG9zaXRpb25hbFRhZyA9IChfb2JqOiBvYmplY3QsIGtleTogc3RyaW5nKSA9PiB0YWdGb3JQb3NpdGlvbmFsQXJnKHBvc2l0aW9uYWwsIGtleSk7XG5cbiAgICBjb25zdCBuYW1lZEhhbmRsZXIgPSBuZXcgTmFtZWRBcmdzUHJveHkobmFtZWQpO1xuICAgIGNvbnN0IHBvc2l0aW9uYWxIYW5kbGVyID0gbmV3IFBvc2l0aW9uYWxBcmdzUHJveHkocG9zaXRpb25hbCk7XG5cbiAgICBjb25zdCBuYW1lZFRhcmdldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3QgcG9zaXRpb25hbFRhcmdldDogdW5rbm93bltdID0gW107XG5cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIGNvbnN0IHNldEhhbmRsZXIgPSBmdW5jdGlvbiAoX3RhcmdldDogdW5rbm93biwgcHJvcDogc3ltYm9sIHwgc3RyaW5nIHwgbnVtYmVyKTogbmV2ZXIge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBhdHRlbXB0ZWQgdG8gc2V0ICR7U3RyaW5nKFxuICAgICAgICAgICAgcHJvcFxuICAgICAgICAgICl9IG9uIHRoZSBhcmd1bWVudHMgb2YgYSBjb21wb25lbnQsIGhlbHBlciwgb3IgbW9kaWZpZXIuIEFyZ3VtZW50cyBhcmUgaW1tdXRhYmxlIGFuZCBjYW5ub3QgYmUgdXBkYXRlZCBkaXJlY3RseTsgdGhleSBhbHdheXMgcmVwcmVzZW50IHRoZSB2YWx1ZXMgdGhhdCBhcmUgcGFzc2VkIGRvd24uIElmIHlvdSB3YW50IHRvIHNldCBkZWZhdWx0IHZhbHVlcywgeW91IHNob3VsZCB1c2UgYSBnZXR0ZXIgYW5kIGxvY2FsIHRyYWNrZWQgc3RhdGUgaW5zdGVhZC5gXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBmb3JJbkRlYnVnSGFuZGxlciA9ICgpOiBuZXZlciA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgT2JqZWN0LmtleXMoKSB3YXMgY2FsbGVkIG9uIHRoZSBwb3NpdGlvbmFsIGFyZ3VtZW50cyBhcnJheSBmb3IgYSAke3R5cGV9LCB3aGljaCBpcyBub3Qgc3VwcG9ydGVkLiBUaGlzIGZ1bmN0aW9uIGlzIGEgbG93LWxldmVsIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIG5vdCBuZWVkIHRvIGJlIGNhbGxlZCBmb3IgcG9zaXRpb25hbCBhcmd1bWVudCBhcnJheXMuIFlvdSBtYXkgYmUgYXR0ZW1wdGluZyB0byBpdGVyYXRlIG92ZXIgdGhlIGFycmF5IHVzaW5nIGZvci4uLmluIGluc3RlYWQgb2YgZm9yLi4ub2YuYFxuICAgICAgICApO1xuICAgICAgfTtcblxuICAgICAgbmFtZWRIYW5kbGVyLnNldCA9IHNldEhhbmRsZXI7XG4gICAgICBwb3NpdGlvbmFsSGFuZGxlci5zZXQgPSBzZXRIYW5kbGVyO1xuICAgICAgcG9zaXRpb25hbEhhbmRsZXIub3duS2V5cyA9IGZvckluRGVidWdIYW5kbGVyO1xuICAgIH1cblxuICAgIGNvbnN0IG5hbWVkUHJveHkgPSBuZXcgUHJveHkobmFtZWRUYXJnZXQsIG5hbWVkSGFuZGxlcik7XG4gICAgY29uc3QgcG9zaXRpb25hbFByb3h5ID0gbmV3IFByb3h5KHBvc2l0aW9uYWxUYXJnZXQsIHBvc2l0aW9uYWxIYW5kbGVyKTtcblxuICAgIHNldEN1c3RvbVRhZ0ZvcihuYW1lZFByb3h5LCBnZXROYW1lZFRhZyk7XG4gICAgc2V0Q3VzdG9tVGFnRm9yKHBvc2l0aW9uYWxQcm94eSwgZ2V0UG9zaXRpb25hbFRhZyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZWQ6IG5hbWVkUHJveHksXG4gICAgICBwb3NpdGlvbmFsOiBwb3NpdGlvbmFsUHJveHksXG4gICAgfTtcbiAgfTtcbn0gZWxzZSB7XG4gIGFyZ3NQcm94eUZvciA9IChjYXB0dXJlZEFyZ3MsIF90eXBlKSA9PiB7XG4gICAgY29uc3QgeyBuYW1lZCwgcG9zaXRpb25hbCB9ID0gY2FwdHVyZWRBcmdzO1xuXG4gICAgbGV0IGdldE5hbWVkVGFnID0gKF9vYmo6IG9iamVjdCwga2V5OiBzdHJpbmcpID0+IHRhZ0Zvck5hbWVkQXJnKG5hbWVkLCBrZXkpO1xuICAgIGxldCBnZXRQb3NpdGlvbmFsVGFnID0gKF9vYmo6IG9iamVjdCwga2V5OiBzdHJpbmcpID0+IHRhZ0ZvclBvc2l0aW9uYWxBcmcocG9zaXRpb25hbCwga2V5KTtcblxuICAgIGxldCBuYW1lZFByb3h5ID0ge307XG4gICAgbGV0IHBvc2l0aW9uYWxQcm94eTogdW5rbm93bltdID0gW107XG5cbiAgICBzZXRDdXN0b21UYWdGb3IobmFtZWRQcm94eSwgZ2V0TmFtZWRUYWcpO1xuICAgIHNldEN1c3RvbVRhZ0Zvcihwb3NpdGlvbmFsUHJveHksIGdldFBvc2l0aW9uYWxUYWcpO1xuXG4gICAgT2JqZWN0LmtleXMobmFtZWQpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYW1lZFByb3h5LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZUZvclJlZihuYW1lZFtuYW1lXSk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHBvc2l0aW9uYWwuZm9yRWFjaCgocmVmOiBSZWZlcmVuY2UsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwb3NpdGlvbmFsUHJveHksIGluZGV4LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZUZvclJlZihyZWYpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIC8vIFByZXZlbnQgbXV0YXRpb25zIGluIGRldmVsb3BtZW50IG1vZGUuIFRoaXMgd2lsbCBub3QgcHJldmVudCB0aGVcbiAgICAgIC8vIHByb3h5IGZyb20gdXBkYXRpbmcsIGJ1dCB3aWxsIHByZXZlbnQgYXNzaWduaW5nIG5ldyB2YWx1ZXMgb3IgcHVzaGluZ1xuICAgICAgLy8gZm9yIGluc3RhbmNlLlxuICAgICAgT2JqZWN0LmZyZWV6ZShuYW1lZFByb3h5KTtcbiAgICAgIE9iamVjdC5mcmVlemUocG9zaXRpb25hbFByb3h5KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZWQ6IG5hbWVkUHJveHksXG4gICAgICBwb3NpdGlvbmFsOiBwb3NpdGlvbmFsUHJveHksXG4gICAgfTtcbiAgfTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=