"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.modifierCapabilities = modifierCapabilities;
exports.reifyArgs = reifyArgs;
exports.CustomModifierManager = void 0;

var _env = require("@glimmer/env");

var _destroyable = require("@glimmer/destroyable");

var _reference = require("@glimmer/reference");

var _util = require("@glimmer/util");

var _validator = require("@glimmer/validator");

var _capabilities = require("../util/capabilities");

var _argsProxy = require("../util/args-proxy");

function modifierCapabilities(managerAPI, optionalFeatures = {}) {
  if (_env.DEBUG && managerAPI !== '3.22') {
    throw new Error('Invalid modifier manager compatibility specified');
  }

  return (0, _capabilities.buildCapabilities)({
    disableAutoTracking: Boolean(optionalFeatures.disableAutoTracking)
  });
}
/**
  The CustomModifierManager allows addons to provide custom modifier
  implementations that integrate seamlessly into Ember. This is accomplished
  through a delegate, registered with the custom modifier manager, which
  implements a set of hooks that determine modifier behavior.
  To create a custom modifier manager, instantiate a new CustomModifierManager
  class and pass the delegate as the first argument:

  ```js
  let manager = new CustomModifierManager({
    // ...delegate implementation...
  });
  ```

  ## Delegate Hooks

  Throughout the lifecycle of a modifier, the modifier manager will invoke
  delegate hooks that are responsible for surfacing those lifecycle changes to
  the end developer.
  * `createModifier()` - invoked when a new instance of a modifier should be created
  * `installModifier()` - invoked when the modifier is installed on the element
  * `updateModifier()` - invoked when the arguments passed to a modifier change
  * `destroyModifier()` - invoked when the modifier is about to be destroyed
*/


class CustomModifierManager {
  constructor(factory) {
    this.factory = factory;
    this.componentManagerDelegates = new WeakMap();
  }

  getDelegateFor(owner) {
    let {
      componentManagerDelegates
    } = this;
    let delegate = componentManagerDelegates.get(owner);

    if (delegate === undefined) {
      let {
        factory
      } = this;
      delegate = factory(owner);

      if (_env.DEBUG && !_capabilities.FROM_CAPABILITIES.has(delegate.capabilities)) {
        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200
        throw new Error(`Custom modifier managers must have a \`capabilities\` property that is the result of calling the \`capabilities('3.22')\` (imported via \`import { capabilities } from '@ember/modifier';\`). Received: \`${JSON.stringify(delegate.capabilities)}\` for: \`${delegate}\``);
      }

      componentManagerDelegates.set(owner, delegate);
    }

    return delegate;
  }

  create(owner, element, definition, capturedArgs) {
    let delegate = this.getDelegateFor(owner);
    let args = (0, _argsProxy.argsProxyFor)(capturedArgs, 'modifier');
    let instance = delegate.createModifier(definition, args);
    let tag = (0, _validator.createUpdatableTag)();
    let state;
    state = {
      tag,
      element,
      delegate,
      args,
      modifier: instance
    };

    if (_env.DEBUG) {
      state.debugName = typeof definition === 'function' ? definition.name : definition.toString();
    }

    (0, _destroyable.registerDestructor)(state, () => delegate.destroyModifier(instance, args));
    return state;
  }

  getDebugName({
    debugName
  }) {
    return debugName;
  }

  getTag({
    tag
  }) {
    return tag;
  }

  install({
    element,
    args,
    modifier,
    delegate
  }) {
    let {
      capabilities
    } = delegate;

    if (capabilities.disableAutoTracking === true) {
      (0, _validator.untrack)(() => delegate.installModifier(modifier, element, args));
    } else {
      delegate.installModifier(modifier, element, args);
    }
  }

  update({
    args,
    modifier,
    delegate
  }) {
    let {
      capabilities
    } = delegate;

    if (capabilities.disableAutoTracking === true) {
      (0, _validator.untrack)(() => delegate.updateModifier(modifier, args));
    } else {
      delegate.updateModifier(modifier, args);
    }
  }

  getDestroyable(state) {
    return state;
  }

}

exports.CustomModifierManager = CustomModifierManager;

function reifyArgs({
  named,
  positional
}) {
  let reifiedNamed = (0, _util.dict)();

  for (let key in named) {
    reifiedNamed[key] = (0, _reference.valueForRef)(named[key]);
  }

  let reifiedPositional = positional.map(_reference.valueForRef);
  return {
    named: reifiedNamed,
    positional: reifiedPositional
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL3B1YmxpYy9tb2RpZmllci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFVQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFHTSxTQUFBLG9CQUFBLENBQUEsVUFBQSxFQUVKLGdCQUFBLEdBRkksRUFBQSxFQUV3RDtBQUU1RCxNQUFJLGNBQVMsVUFBVSxLQUF2QixNQUFBLEVBQW9DO0FBQ2xDLFVBQU0sSUFBQSxLQUFBLENBQU4sa0RBQU0sQ0FBTjtBQUNEOztBQUVELFNBQU8scUNBQWtCO0FBQ3ZCLElBQUEsbUJBQW1CLEVBQUUsT0FBTyxDQUFDLGdCQUFnQixDQUFqQixtQkFBQTtBQURMLEdBQWxCLENBQVA7QUFHRDtBQVdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCTSxNQUFBLHFCQUFBLENBQTRCO0FBSWhDLEVBQUEsV0FBQSxDQUFBLE9BQUEsRUFBaUY7QUFBN0QsU0FBQSxPQUFBLEdBQUEsT0FBQTtBQUZaLFNBQUEseUJBQUEsR0FBNEIsSUFBNUIsT0FBNEIsRUFBNUI7QUFFNkU7O0FBRTdFLEVBQUEsY0FBYyxDQUFBLEtBQUEsRUFBUztBQUM3QixRQUFJO0FBQUUsTUFBQTtBQUFGLFFBQUosSUFBQTtBQUNBLFFBQUksUUFBUSxHQUFHLHlCQUF5QixDQUF6QixHQUFBLENBQWYsS0FBZSxDQUFmOztBQUVBLFFBQUksUUFBUSxLQUFaLFNBQUEsRUFBNEI7QUFDMUIsVUFBSTtBQUFFLFFBQUE7QUFBRixVQUFKLElBQUE7QUFDQSxNQUFBLFFBQVEsR0FBRyxPQUFPLENBQWxCLEtBQWtCLENBQWxCOztBQUVBLFVBQUksY0FBUyxDQUFDLGdDQUFBLEdBQUEsQ0FBdUIsUUFBUSxDQUE3QyxZQUFjLENBQWQsRUFBNkQ7QUFDM0Q7QUFDQSxjQUFNLElBQUEsS0FBQSxDQUNKLDZNQUE2TSxJQUFJLENBQUosU0FBQSxDQUMz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SUFBQSxLQUFLLEVBREEsWUFBQTtBQUVMLElBQUEsVUFBVSxFQUFFO0FBRlAsR0FBUDtBQUlEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHtcbiAgQXJndW1lbnRzLFxuICBDYXB0dXJlZEFyZ3VtZW50cyxcbiAgSW50ZXJuYWxNb2RpZmllck1hbmFnZXIsXG4gIE1vZGlmaWVyQ2FwYWJpbGl0aWVzLFxuICBNb2RpZmllckNhcGFiaWxpdGllc1ZlcnNpb25zLFxuICBNb2RpZmllck1hbmFnZXIsXG4gIE93bmVyLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IHJlZ2lzdGVyRGVzdHJ1Y3RvciB9IGZyb20gJ0BnbGltbWVyL2Rlc3Ryb3lhYmxlJztcbmltcG9ydCB7IHZhbHVlRm9yUmVmIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IGNhc3RUb0Jyb3dzZXIsIGRpY3QgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IGNyZWF0ZVVwZGF0YWJsZVRhZywgdW50cmFjaywgVXBkYXRhYmxlVGFnIH0gZnJvbSAnQGdsaW1tZXIvdmFsaWRhdG9yJztcbmltcG9ydCB7IFNpbXBsZUVsZW1lbnQgfSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuaW1wb3J0IHsgYnVpbGRDYXBhYmlsaXRpZXMsIEZST01fQ0FQQUJJTElUSUVTIH0gZnJvbSAnLi4vdXRpbC9jYXBhYmlsaXRpZXMnO1xuaW1wb3J0IHsgYXJnc1Byb3h5Rm9yIH0gZnJvbSAnLi4vdXRpbC9hcmdzLXByb3h5JztcbmltcG9ydCB7IE1hbmFnZXJGYWN0b3J5IH0gZnJvbSAnLic7XG5cbmV4cG9ydCBmdW5jdGlvbiBtb2RpZmllckNhcGFiaWxpdGllczxWZXJzaW9uIGV4dGVuZHMga2V5b2YgTW9kaWZpZXJDYXBhYmlsaXRpZXNWZXJzaW9ucz4oXG4gIG1hbmFnZXJBUEk6IFZlcnNpb24sXG4gIG9wdGlvbmFsRmVhdHVyZXM6IE1vZGlmaWVyQ2FwYWJpbGl0aWVzVmVyc2lvbnNbVmVyc2lvbl0gPSB7fVxuKTogTW9kaWZpZXJDYXBhYmlsaXRpZXMge1xuICBpZiAoREVCVUcgJiYgbWFuYWdlckFQSSAhPT0gJzMuMjInKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vZGlmaWVyIG1hbmFnZXIgY29tcGF0aWJpbGl0eSBzcGVjaWZpZWQnKTtcbiAgfVxuXG4gIHJldHVybiBidWlsZENhcGFiaWxpdGllcyh7XG4gICAgZGlzYWJsZUF1dG9UcmFja2luZzogQm9vbGVhbihvcHRpb25hbEZlYXR1cmVzLmRpc2FibGVBdXRvVHJhY2tpbmcpLFxuICB9KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDdXN0b21Nb2RpZmllclN0YXRlPE1vZGlmaWVySW5zdGFuY2U+IHtcbiAgdGFnOiBVcGRhdGFibGVUYWc7XG4gIGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQ7XG4gIG1vZGlmaWVyOiBNb2RpZmllckluc3RhbmNlO1xuICBkZWxlZ2F0ZTogTW9kaWZpZXJNYW5hZ2VyPE1vZGlmaWVySW5zdGFuY2U+O1xuICBhcmdzOiBBcmd1bWVudHM7XG4gIGRlYnVnTmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gIFRoZSBDdXN0b21Nb2RpZmllck1hbmFnZXIgYWxsb3dzIGFkZG9ucyB0byBwcm92aWRlIGN1c3RvbSBtb2RpZmllclxuICBpbXBsZW1lbnRhdGlvbnMgdGhhdCBpbnRlZ3JhdGUgc2VhbWxlc3NseSBpbnRvIEVtYmVyLiBUaGlzIGlzIGFjY29tcGxpc2hlZFxuICB0aHJvdWdoIGEgZGVsZWdhdGUsIHJlZ2lzdGVyZWQgd2l0aCB0aGUgY3VzdG9tIG1vZGlmaWVyIG1hbmFnZXIsIHdoaWNoXG4gIGltcGxlbWVudHMgYSBzZXQgb2YgaG9va3MgdGhhdCBkZXRlcm1pbmUgbW9kaWZpZXIgYmVoYXZpb3IuXG4gIFRvIGNyZWF0ZSBhIGN1c3RvbSBtb2RpZmllciBtYW5hZ2VyLCBpbnN0YW50aWF0ZSBhIG5ldyBDdXN0b21Nb2RpZmllck1hbmFnZXJcbiAgY2xhc3MgYW5kIHBhc3MgdGhlIGRlbGVnYXRlIGFzIHRoZSBmaXJzdCBhcmd1bWVudDpcblxuICBgYGBqc1xuICBsZXQgbWFuYWdlciA9IG5ldyBDdXN0b21Nb2RpZmllck1hbmFnZXIoe1xuICAgIC8vIC4uLmRlbGVnYXRlIGltcGxlbWVudGF0aW9uLi4uXG4gIH0pO1xuICBgYGBcblxuICAjIyBEZWxlZ2F0ZSBIb29rc1xuXG4gIFRocm91Z2hvdXQgdGhlIGxpZmVjeWNsZSBvZiBhIG1vZGlmaWVyLCB0aGUgbW9kaWZpZXIgbWFuYWdlciB3aWxsIGludm9rZVxuICBkZWxlZ2F0ZSBob29rcyB0aGF0IGFyZSByZXNwb25zaWJsZSBmb3Igc3VyZmFjaW5nIHRob3NlIGxpZmVjeWNsZSBjaGFuZ2VzIHRvXG4gIHRoZSBlbmQgZGV2ZWxvcGVyLlxuICAqIGBjcmVhdGVNb2RpZmllcigpYCAtIGludm9rZWQgd2hlbiBhIG5ldyBpbnN0YW5jZSBvZiBhIG1vZGlmaWVyIHNob3VsZCBiZSBjcmVhdGVkXG4gICogYGluc3RhbGxNb2RpZmllcigpYCAtIGludm9rZWQgd2hlbiB0aGUgbW9kaWZpZXIgaXMgaW5zdGFsbGVkIG9uIHRoZSBlbGVtZW50XG4gICogYHVwZGF0ZU1vZGlmaWVyKClgIC0gaW52b2tlZCB3aGVuIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIGEgbW9kaWZpZXIgY2hhbmdlXG4gICogYGRlc3Ryb3lNb2RpZmllcigpYCAtIGludm9rZWQgd2hlbiB0aGUgbW9kaWZpZXIgaXMgYWJvdXQgdG8gYmUgZGVzdHJveWVkXG4qL1xuZXhwb3J0IGNsYXNzIEN1c3RvbU1vZGlmaWVyTWFuYWdlcjxPIGV4dGVuZHMgT3duZXIsIE1vZGlmaWVySW5zdGFuY2U+XG4gIGltcGxlbWVudHMgSW50ZXJuYWxNb2RpZmllck1hbmFnZXI8Q3VzdG9tTW9kaWZpZXJTdGF0ZTxNb2RpZmllckluc3RhbmNlPj4ge1xuICBwcml2YXRlIGNvbXBvbmVudE1hbmFnZXJEZWxlZ2F0ZXMgPSBuZXcgV2Vha01hcDxPLCBNb2RpZmllck1hbmFnZXI8TW9kaWZpZXJJbnN0YW5jZT4+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBmYWN0b3J5OiBNYW5hZ2VyRmFjdG9yeTxPLCBNb2RpZmllck1hbmFnZXI8TW9kaWZpZXJJbnN0YW5jZT4+KSB7fVxuXG4gIHByaXZhdGUgZ2V0RGVsZWdhdGVGb3Iob3duZXI6IE8pIHtcbiAgICBsZXQgeyBjb21wb25lbnRNYW5hZ2VyRGVsZWdhdGVzIH0gPSB0aGlzO1xuICAgIGxldCBkZWxlZ2F0ZSA9IGNvbXBvbmVudE1hbmFnZXJEZWxlZ2F0ZXMuZ2V0KG93bmVyKTtcblxuICAgIGlmIChkZWxlZ2F0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgeyBmYWN0b3J5IH0gPSB0aGlzO1xuICAgICAgZGVsZWdhdGUgPSBmYWN0b3J5KG93bmVyKTtcblxuICAgICAgaWYgKERFQlVHICYmICFGUk9NX0NBUEFCSUxJVElFUyEuaGFzKGRlbGVnYXRlLmNhcGFiaWxpdGllcykpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBlcnJvciBtZXNzYWdlIHNob3VsZCBtYWtlIHNlbnNlIGluIGJvdGggRW1iZXIgYW5kIEdsaW1tZXIgaHR0cHM6Ly9naXRodWIuY29tL2dsaW1tZXJqcy9nbGltbWVyLXZtL2lzc3Vlcy8xMjAwXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQ3VzdG9tIG1vZGlmaWVyIG1hbmFnZXJzIG11c3QgaGF2ZSBhIFxcYGNhcGFiaWxpdGllc1xcYCBwcm9wZXJ0eSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgXFxgY2FwYWJpbGl0aWVzKCczLjIyJylcXGAgKGltcG9ydGVkIHZpYSBcXGBpbXBvcnQgeyBjYXBhYmlsaXRpZXMgfSBmcm9tICdAZW1iZXIvbW9kaWZpZXInO1xcYCkuIFJlY2VpdmVkOiBcXGAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgZGVsZWdhdGUuY2FwYWJpbGl0aWVzXG4gICAgICAgICAgKX1cXGAgZm9yOiBcXGAke2RlbGVnYXRlfVxcYGBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50TWFuYWdlckRlbGVnYXRlcy5zZXQob3duZXIsIGRlbGVnYXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZWdhdGU7XG4gIH1cblxuICBjcmVhdGUob3duZXI6IE8sIGVsZW1lbnQ6IFNpbXBsZUVsZW1lbnQsIGRlZmluaXRpb246IG9iamVjdCwgY2FwdHVyZWRBcmdzOiBDYXB0dXJlZEFyZ3VtZW50cykge1xuICAgIGxldCBkZWxlZ2F0ZSA9IHRoaXMuZ2V0RGVsZWdhdGVGb3Iob3duZXIpO1xuXG4gICAgbGV0IGFyZ3MgPSBhcmdzUHJveHlGb3IoY2FwdHVyZWRBcmdzLCAnbW9kaWZpZXInKTtcbiAgICBsZXQgaW5zdGFuY2U6IE1vZGlmaWVySW5zdGFuY2UgPSBkZWxlZ2F0ZS5jcmVhdGVNb2RpZmllcihkZWZpbml0aW9uLCBhcmdzKTtcblxuICAgIGxldCB0YWcgPSBjcmVhdGVVcGRhdGFibGVUYWcoKTtcbiAgICBsZXQgc3RhdGU6IEN1c3RvbU1vZGlmaWVyU3RhdGU8TW9kaWZpZXJJbnN0YW5jZT47XG5cbiAgICBzdGF0ZSA9IHtcbiAgICAgIHRhZyxcbiAgICAgIGVsZW1lbnQsXG4gICAgICBkZWxlZ2F0ZSxcbiAgICAgIGFyZ3MsXG4gICAgICBtb2RpZmllcjogaW5zdGFuY2UhLFxuICAgIH07XG5cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIHN0YXRlLmRlYnVnTmFtZSA9IHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nID8gZGVmaW5pdGlvbi5uYW1lIDogZGVmaW5pdGlvbi50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyRGVzdHJ1Y3RvcihzdGF0ZSwgKCkgPT4gZGVsZWdhdGUuZGVzdHJveU1vZGlmaWVyKGluc3RhbmNlLCBhcmdzKSk7XG5cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBnZXREZWJ1Z05hbWUoeyBkZWJ1Z05hbWUgfTogQ3VzdG9tTW9kaWZpZXJTdGF0ZTxNb2RpZmllckluc3RhbmNlPikge1xuICAgIHJldHVybiBkZWJ1Z05hbWUhO1xuICB9XG5cbiAgZ2V0VGFnKHsgdGFnIH06IEN1c3RvbU1vZGlmaWVyU3RhdGU8TW9kaWZpZXJJbnN0YW5jZT4pIHtcbiAgICByZXR1cm4gdGFnO1xuICB9XG5cbiAgaW5zdGFsbCh7IGVsZW1lbnQsIGFyZ3MsIG1vZGlmaWVyLCBkZWxlZ2F0ZSB9OiBDdXN0b21Nb2RpZmllclN0YXRlPE1vZGlmaWVySW5zdGFuY2U+KSB7XG4gICAgbGV0IHsgY2FwYWJpbGl0aWVzIH0gPSBkZWxlZ2F0ZTtcblxuICAgIGlmIChjYXBhYmlsaXRpZXMuZGlzYWJsZUF1dG9UcmFja2luZyA9PT0gdHJ1ZSkge1xuICAgICAgdW50cmFjaygoKSA9PiBkZWxlZ2F0ZS5pbnN0YWxsTW9kaWZpZXIobW9kaWZpZXIsIGNhc3RUb0Jyb3dzZXIoZWxlbWVudCwgJ0VMRU1FTlQnKSwgYXJncykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxlZ2F0ZS5pbnN0YWxsTW9kaWZpZXIobW9kaWZpZXIsIGNhc3RUb0Jyb3dzZXIoZWxlbWVudCwgJ0VMRU1FTlQnKSwgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKHsgYXJncywgbW9kaWZpZXIsIGRlbGVnYXRlIH06IEN1c3RvbU1vZGlmaWVyU3RhdGU8TW9kaWZpZXJJbnN0YW5jZT4pIHtcbiAgICBsZXQgeyBjYXBhYmlsaXRpZXMgfSA9IGRlbGVnYXRlO1xuXG4gICAgaWYgKGNhcGFiaWxpdGllcy5kaXNhYmxlQXV0b1RyYWNraW5nID09PSB0cnVlKSB7XG4gICAgICB1bnRyYWNrKCgpID0+IGRlbGVnYXRlLnVwZGF0ZU1vZGlmaWVyKG1vZGlmaWVyLCBhcmdzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGVnYXRlLnVwZGF0ZU1vZGlmaWVyKG1vZGlmaWVyLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICBnZXREZXN0cm95YWJsZShzdGF0ZTogQ3VzdG9tTW9kaWZpZXJTdGF0ZTxNb2RpZmllckluc3RhbmNlPikge1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVpZnlBcmdzKHtcbiAgbmFtZWQsXG4gIHBvc2l0aW9uYWwsXG59OiBDYXB0dXJlZEFyZ3VtZW50cyk6IHsgbmFtZWQ6IFJlY29yZDxzdHJpbmcsIHVua25vd24+OyBwb3NpdGlvbmFsOiB1bmtub3duW10gfSB7XG4gIGxldCByZWlmaWVkTmFtZWQgPSBkaWN0KCk7XG5cbiAgZm9yIChsZXQga2V5IGluIG5hbWVkKSB7XG4gICAgcmVpZmllZE5hbWVkW2tleV0gPSB2YWx1ZUZvclJlZihuYW1lZFtrZXldKTtcbiAgfVxuXG4gIGxldCByZWlmaWVkUG9zaXRpb25hbCA9IHBvc2l0aW9uYWwubWFwKHZhbHVlRm9yUmVmKTtcblxuICByZXR1cm4ge1xuICAgIG5hbWVkOiByZWlmaWVkTmFtZWQsXG4gICAgcG9zaXRpb25hbDogcmVpZmllZFBvc2l0aW9uYWwsXG4gIH07XG59XG4iXSwic291cmNlUm9vdCI6IiJ9