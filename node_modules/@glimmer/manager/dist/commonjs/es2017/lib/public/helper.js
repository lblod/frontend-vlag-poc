"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.helperCapabilities = helperCapabilities;
exports.hasValue = hasValue;
exports.hasDestroyable = hasDestroyable;
exports.CustomHelperManager = void 0;

var _destroyable = require("@glimmer/destroyable");

var _env = require("@glimmer/env");

var _reference = require("@glimmer/reference");

var _capabilities = require("../util/capabilities");

var _argsProxy = require("../util/args-proxy");

function helperCapabilities(managerAPI, options = {}) {
  if (_env.DEBUG && managerAPI !== '3.23') {
    throw new Error('Invalid helper manager compatibility specified');
  }

  if (_env.DEBUG && (!(options.hasValue || options.hasScheduledEffect) || options.hasValue && options.hasScheduledEffect)) {
    throw new Error('You must pass either the `hasValue` OR the `hasScheduledEffect` capability when defining a helper manager. Passing neither, or both, is not permitted.');
  }

  if (_env.DEBUG && options.hasScheduledEffect) {
    throw new Error('The `hasScheduledEffect` capability has not yet been implemented for helper managers. Please pass `hasValue` instead');
  }

  return (0, _capabilities.buildCapabilities)({
    hasValue: Boolean(options.hasValue),
    hasDestroyable: Boolean(options.hasDestroyable),
    hasScheduledEffect: Boolean(options.hasScheduledEffect)
  });
} ////////////


function hasValue(manager) {
  return manager.capabilities.hasValue;
}

function hasDestroyable(manager) {
  return manager.capabilities.hasDestroyable;
} ////////////


class CustomHelperManager {
  constructor(factory) {
    this.factory = factory;
    this.helperManagerDelegates = new WeakMap();
    this.undefinedDelegate = null;
  }

  getDelegateForOwner(owner) {
    let delegate = this.helperManagerDelegates.get(owner);

    if (delegate === undefined) {
      let {
        factory
      } = this;
      delegate = factory(owner);

      if (_env.DEBUG && !_capabilities.FROM_CAPABILITIES.has(delegate.capabilities)) {
        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200
        throw new Error(`Custom helper managers must have a \`capabilities\` property that is the result of calling the \`capabilities('3.23')\` (imported via \`import { capabilities } from '@ember/helper';\`). Received: \`${JSON.stringify(delegate.capabilities)}\` for: \`${delegate}\``);
      }

      this.helperManagerDelegates.set(owner, delegate);
    }

    return delegate;
  }

  getDelegateFor(owner) {
    if (owner === undefined) {
      let {
        undefinedDelegate
      } = this;

      if (undefinedDelegate === null) {
        let {
          factory
        } = this;
        this.undefinedDelegate = undefinedDelegate = factory(undefined);
      }

      return undefinedDelegate;
    } else {
      return this.getDelegateForOwner(owner);
    }
  }

  getHelper(definition) {
    return (capturedArgs, owner) => {
      var _a, _b;

      let manager = this.getDelegateFor(owner);
      const args = (0, _argsProxy.argsProxyFor)(capturedArgs, 'helper');
      const bucket = manager.createHelper(definition, args);

      if (hasValue(manager)) {
        let cache = (0, _reference.createComputeRef)(() => manager.getValue(bucket), null, _env.DEBUG && manager.getDebugName && manager.getDebugName(definition));

        if (hasDestroyable(manager)) {
          (0, _destroyable.associateDestroyableChild)(cache, manager.getDestroyable(bucket));
        }

        return cache;
      } else if (hasDestroyable(manager)) {
        let ref = (0, _reference.createConstRef)(undefined, _env.DEBUG && ((_b = (_a = manager.getDebugName) === null || _a === void 0 ? void 0 : _a.call(manager, definition)) !== null && _b !== void 0 ? _b : 'unknown helper'));
        (0, _destroyable.associateDestroyableChild)(ref, manager.getDestroyable(bucket));
        return ref;
      } else {
        return _reference.UNDEFINED_REFERENCE;
      }
    };
  }

}

exports.CustomHelperManager = CustomHelperManager;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL3B1YmxpYy9oZWxwZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQVlBOztBQUVBOztBQUNBOztBQUdNLFNBQUEsa0JBQUEsQ0FBQSxVQUFBLEVBRUosT0FBQSxHQUZJLEVBQUEsRUFFcUM7QUFFekMsTUFBSSxjQUFTLFVBQVUsS0FBdkIsTUFBQSxFQUFvQztBQUNsQyxVQUFNLElBQUEsS0FBQSxDQUFOLGdEQUFNLENBQU47QUFDRDs7QUFFRCxNQUNFLGVBQ0MsRUFBRSxPQUFPLENBQVAsUUFBQSxJQUFvQixPQUFPLENBQTdCLGtCQUFBLEtBQ0UsT0FBTyxDQUFQLFFBQUEsSUFBb0IsT0FBTyxDQUhoQyxrQkFDRSxDQURGLEVBSUU7QUFDQSxVQUFNLElBQUEsS0FBQSxDQUFOLHdKQUFNLENBQU47QUFHRDs7QUFFRCxNQUFJLGNBQVMsT0FBTyxDQUFwQixrQkFBQSxFQUF5QztBQUN2QyxVQUFNLElBQUEsS0FBQSxDQUFOLHNIQUFNLENBQU47QUFHRDs7QUFFRCxTQUFPLHFDQUFrQjtBQUN2QixJQUFBLFFBQVEsRUFBRSxPQUFPLENBQUMsT0FBTyxDQURGLFFBQ04sQ0FETTtBQUV2QixJQUFBLGNBQWMsRUFBRSxPQUFPLENBQUMsT0FBTyxDQUZSLGNBRUEsQ0FGQTtBQUd2QixJQUFBLGtCQUFrQixFQUFFLE9BQU8sQ0FBQyxPQUFPLENBQVIsa0JBQUE7QUFISixHQUFsQixDQUFQO0VBT0Y7OztBQUVNLFNBQUEsUUFBQSxDQUFBLE9BQUEsRUFDMkI7QUFFL0IsU0FBTyxPQUFPLENBQVAsWUFBQSxDQUFQLFFBQUE7QUFDRDs7QUFFSyxTQUFBLGNBQUEsQ0FBQSxPQUFBLEVBQzJCO0FBRS9CLFNBQU8sT0FBTyxDQUFQLFlBQUEsQ0FBUCxjQUFBO0VBR0Y7OztBQUVNLE1BQUEsbUJBQUEsQ0FBMEI7QUFDOUIsRUFBQSxXQUFBLENBQUEsT0FBQSxFQUFrRjtBQUE5RCxTQUFBLE9BQUEsR0FBQSxPQUFBO0FBRVosU0FBQSxzQkFBQSxHQUF5QixJQUF6QixPQUF5QixFQUF6QjtBQUNBLFNBQUEsaUJBQUEsR0FBQSxJQUFBO0FBSDhFOztBQUs5RSxFQUFBLG1CQUFtQixDQUFBLEtBQUEsRUFBUztBQUNsQyxRQUFJLFFBQVEsR0FBRyxLQUFBLHNCQUFBLENBQUEsR0FBQSxDQUFmLEtBQWUsQ0FBZjs7QUFFQSxRQUFJLFFBQVEsS0FBWixTQUFBLEVBQTRCO0FBQzFCLFVBQUk7QUFBRSxRQUFBO0FBQUYsVUFBSixJQUFBO0FBQ0EsTUFBQSxRQUFRLEdBQUcsT0FBTyxDQUFsQixLQUFrQixDQUFsQjs7QUFFQSxVQUFJLGNBQVMsQ0FBQyxnQ0FBQSxHQUFBLENBQXVCLFFBQVEsQ0FBN0MsWUFBYyxDQUFkLEVBQTZEO0FBQzNEO0FBQ0EsY0FBTSxJQUFBLEtBQUEsQ0FDSix5TUFBeU0sSUFBSSxDQUFKLFNBQUEsQ0FDdk0sUUFBUSxDQUQrTCxZQUFBLENBRXhNLGFBQWEsUUFIaEIsSUFBTSxDQUFOO0FBS0Q7O0FBRUQsV0FBQSxzQkFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLEVBQUEsUUFBQTtBQUNEOztBQUVELFdBQUEsUUFBQTtBQUNEOztBQUVELEVBQUEsY0FBYyxDQUFBLEtBQUEsRUFBcUI7QUFDakMsUUFBSSxLQUFLLEtBQVQsU0FBQSxFQUF5QjtBQUN2QixVQUFJO0FBQUUsUUFBQTtBQUFGLFVBQUosSUFBQTs7QUFFQSxVQUFJLGlCQUFpQixLQUFyQixJQUFBLEVBQWdDO0FBQzlCLFlBQUk7QUFBRSxVQUFBO0FBQUYsWUFBSixJQUFBO0FBQ0EsYUFBQSxpQkFBQSxHQUF5QixpQkFBaUIsR0FBRyxPQUFPLENBQXBELFNBQW9ELENBQXBEO0FBQ0Q7O0FBRUQsYUFBQSxpQkFBQTtBQVJGLEtBQUEsTUFTTztBQUNMLGFBQU8sS0FBQSxtQkFBQSxDQUFQLEtBQU8sQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsRUFBQSxTQUFTLENBQUEsVUFBQSxFQUFrQztBQUN6QyxXQUFPLENBQUEsWUFBQSxFQUFBLEtBQUEsS0FBd0I7OztBQUM3QixVQUFJLE9BQU8sR0FBRyxLQUFBLGNBQUEsQ0FBZCxLQUFjLENBQWQ7QUFFQSxZQUFNLElBQUksR0FBRyw2QkFBWSxZQUFaLEVBQWIsUUFBYSxDQUFiO0FBQ0EsWUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFQLFlBQUEsQ0FBQSxVQUFBLEVBQWYsSUFBZSxDQUFmOztBQUVBLFVBQUksUUFBUSxDQUFaLE9BQVksQ0FBWixFQUF1QjtBQUNyQixZQUFJLEtBQUssR0FBRyxpQ0FDVixNQUFPLE9BQTJDLENBQTNDLFFBQUEsQ0FEbUIsTUFDbkIsQ0FERyxFQUFnQixJQUFoQixFQUdWLGNBQVMsT0FBTyxDQUFoQixZQUFBLElBQWlDLE9BQU8sQ0FBUCxZQUFBLENBSG5DLFVBR21DLENBSHZCLENBQVo7O0FBTUEsWUFBSSxjQUFjLENBQWxCLE9BQWtCLENBQWxCLEVBQTZCO0FBQzNCLHNEQUF5QixLQUF6QixFQUFpQyxPQUFPLENBQVAsY0FBQSxDQUFqQyxNQUFpQyxDQUFqQztBQUNEOztBQUVELGVBQUEsS0FBQTtBQVhGLE9BQUEsTUFZTyxJQUFJLGNBQWMsQ0FBbEIsT0FBa0IsQ0FBbEIsRUFBNkI7QUFDbEMsWUFBSSxHQUFHLEdBQUcsK0JBQWMsU0FBZCxFQUVSLGVBQVMsQ0FBQSxFQUFBLEdBQUEsQ0FBQSxFQUFBLEdBQUMsT0FBTyxDQUFSLFlBQUEsTUFBQSxJQUFBLElBQXFCLEVBQUEsS0FBQSxLQUFyQixDQUFBLEdBQXFCLEtBQXJCLENBQUEsR0FBcUIsRUFBQSxDQUFBLElBQUEsQ0FBcEIsT0FBb0IsRUFBckIsVUFBcUIsQ0FBckIsTUFBQSxJQUFBLElBQWtDLEVBQUEsS0FBQSxLQUFsQyxDQUFBLEdBQUEsRUFBQSxHQUZYLGdCQUVFLENBRlEsQ0FBVjtBQUtBLG9EQUF5QixHQUF6QixFQUErQixPQUFPLENBQVAsY0FBQSxDQUEvQixNQUErQixDQUEvQjtBQUVBLGVBQUEsR0FBQTtBQVJLLE9BQUEsTUFTQTtBQUNMLGVBQUEsOEJBQUE7QUFDRDtBQTdCSCxLQUFBO0FBK0JEOztBQTNFNkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkIH0gZnJvbSAnQGdsaW1tZXIvZGVzdHJveWFibGUnO1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHtcbiAgSGVscGVyLFxuICBIZWxwZXJDYXBhYmlsaXRpZXMsXG4gIEhlbHBlckNhcGFiaWxpdGllc1ZlcnNpb25zLFxuICBIZWxwZXJEZWZpbml0aW9uU3RhdGUsXG4gIEhlbHBlck1hbmFnZXIsXG4gIEhlbHBlck1hbmFnZXJXaXRoRGVzdHJveWFibGUsXG4gIEhlbHBlck1hbmFnZXJXaXRoVmFsdWUsXG4gIEludGVybmFsSGVscGVyTWFuYWdlcixcbiAgT3duZXIsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgY3JlYXRlQ29tcHV0ZVJlZiwgY3JlYXRlQ29uc3RSZWYsIFVOREVGSU5FRF9SRUZFUkVOQ0UgfSBmcm9tICdAZ2xpbW1lci9yZWZlcmVuY2UnO1xuXG5pbXBvcnQgeyBidWlsZENhcGFiaWxpdGllcywgRlJPTV9DQVBBQklMSVRJRVMgfSBmcm9tICcuLi91dGlsL2NhcGFiaWxpdGllcyc7XG5pbXBvcnQgeyBhcmdzUHJveHlGb3IgfSBmcm9tICcuLi91dGlsL2FyZ3MtcHJveHknO1xuaW1wb3J0IHsgTWFuYWdlckZhY3RvcnkgfSBmcm9tICcuL2luZGV4JztcblxuZXhwb3J0IGZ1bmN0aW9uIGhlbHBlckNhcGFiaWxpdGllczxWZXJzaW9uIGV4dGVuZHMga2V5b2YgSGVscGVyQ2FwYWJpbGl0aWVzVmVyc2lvbnM+KFxuICBtYW5hZ2VyQVBJOiBWZXJzaW9uLFxuICBvcHRpb25zOiBQYXJ0aWFsPEhlbHBlckNhcGFiaWxpdGllcz4gPSB7fVxuKTogSGVscGVyQ2FwYWJpbGl0aWVzIHtcbiAgaWYgKERFQlVHICYmIG1hbmFnZXJBUEkgIT09ICczLjIzJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZWxwZXIgbWFuYWdlciBjb21wYXRpYmlsaXR5IHNwZWNpZmllZCcpO1xuICB9XG5cbiAgaWYgKFxuICAgIERFQlVHICYmXG4gICAgKCEob3B0aW9ucy5oYXNWYWx1ZSB8fCBvcHRpb25zLmhhc1NjaGVkdWxlZEVmZmVjdCkgfHxcbiAgICAgIChvcHRpb25zLmhhc1ZhbHVlICYmIG9wdGlvbnMuaGFzU2NoZWR1bGVkRWZmZWN0KSlcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1lvdSBtdXN0IHBhc3MgZWl0aGVyIHRoZSBgaGFzVmFsdWVgIE9SIHRoZSBgaGFzU2NoZWR1bGVkRWZmZWN0YCBjYXBhYmlsaXR5IHdoZW4gZGVmaW5pbmcgYSBoZWxwZXIgbWFuYWdlci4gUGFzc2luZyBuZWl0aGVyLCBvciBib3RoLCBpcyBub3QgcGVybWl0dGVkLidcbiAgICApO1xuICB9XG5cbiAgaWYgKERFQlVHICYmIG9wdGlvbnMuaGFzU2NoZWR1bGVkRWZmZWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1RoZSBgaGFzU2NoZWR1bGVkRWZmZWN0YCBjYXBhYmlsaXR5IGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQgZm9yIGhlbHBlciBtYW5hZ2Vycy4gUGxlYXNlIHBhc3MgYGhhc1ZhbHVlYCBpbnN0ZWFkJ1xuICAgICk7XG4gIH1cblxuICByZXR1cm4gYnVpbGRDYXBhYmlsaXRpZXMoe1xuICAgIGhhc1ZhbHVlOiBCb29sZWFuKG9wdGlvbnMuaGFzVmFsdWUpLFxuICAgIGhhc0Rlc3Ryb3lhYmxlOiBCb29sZWFuKG9wdGlvbnMuaGFzRGVzdHJveWFibGUpLFxuICAgIGhhc1NjaGVkdWxlZEVmZmVjdDogQm9vbGVhbihvcHRpb25zLmhhc1NjaGVkdWxlZEVmZmVjdCksXG4gIH0pO1xufVxuXG4vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1ZhbHVlKFxuICBtYW5hZ2VyOiBIZWxwZXJNYW5hZ2VyPHVua25vd24+XG4pOiBtYW5hZ2VyIGlzIEhlbHBlck1hbmFnZXJXaXRoVmFsdWU8dW5rbm93bj4ge1xuICByZXR1cm4gbWFuYWdlci5jYXBhYmlsaXRpZXMuaGFzVmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNEZXN0cm95YWJsZShcbiAgbWFuYWdlcjogSGVscGVyTWFuYWdlcjx1bmtub3duPlxuKTogbWFuYWdlciBpcyBIZWxwZXJNYW5hZ2VyV2l0aERlc3Ryb3lhYmxlPHVua25vd24+IHtcbiAgcmV0dXJuIG1hbmFnZXIuY2FwYWJpbGl0aWVzLmhhc0Rlc3Ryb3lhYmxlO1xufVxuXG4vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGNsYXNzIEN1c3RvbUhlbHBlck1hbmFnZXI8TyBleHRlbmRzIE93bmVyID0gT3duZXI+IGltcGxlbWVudHMgSW50ZXJuYWxIZWxwZXJNYW5hZ2VyPE8+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBmYWN0b3J5OiBNYW5hZ2VyRmFjdG9yeTxPIHwgdW5kZWZpbmVkLCBIZWxwZXJNYW5hZ2VyPHVua25vd24+Pikge31cblxuICBwcml2YXRlIGhlbHBlck1hbmFnZXJEZWxlZ2F0ZXMgPSBuZXcgV2Vha01hcDxPLCBIZWxwZXJNYW5hZ2VyPHVua25vd24+PigpO1xuICBwcml2YXRlIHVuZGVmaW5lZERlbGVnYXRlOiBIZWxwZXJNYW5hZ2VyPHVua25vd24+IHwgbnVsbCA9IG51bGw7XG5cbiAgcHJpdmF0ZSBnZXREZWxlZ2F0ZUZvck93bmVyKG93bmVyOiBPKSB7XG4gICAgbGV0IGRlbGVnYXRlID0gdGhpcy5oZWxwZXJNYW5hZ2VyRGVsZWdhdGVzLmdldChvd25lcik7XG5cbiAgICBpZiAoZGVsZWdhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHsgZmFjdG9yeSB9ID0gdGhpcztcbiAgICAgIGRlbGVnYXRlID0gZmFjdG9yeShvd25lcik7XG5cbiAgICAgIGlmIChERUJVRyAmJiAhRlJPTV9DQVBBQklMSVRJRVMhLmhhcyhkZWxlZ2F0ZS5jYXBhYmlsaXRpZXMpKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgbWVzc2FnZSBzaG91bGQgbWFrZSBzZW5zZSBpbiBib3RoIEVtYmVyIGFuZCBHbGltbWVyIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGltbWVyanMvZ2xpbW1lci12bS9pc3N1ZXMvMTIwMFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEN1c3RvbSBoZWxwZXIgbWFuYWdlcnMgbXVzdCBoYXZlIGEgXFxgY2FwYWJpbGl0aWVzXFxgIHByb3BlcnR5IHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBcXGBjYXBhYmlsaXRpZXMoJzMuMjMnKVxcYCAoaW1wb3J0ZWQgdmlhIFxcYGltcG9ydCB7IGNhcGFiaWxpdGllcyB9IGZyb20gJ0BlbWJlci9oZWxwZXInO1xcYCkuIFJlY2VpdmVkOiBcXGAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgZGVsZWdhdGUuY2FwYWJpbGl0aWVzXG4gICAgICAgICAgKX1cXGAgZm9yOiBcXGAke2RlbGVnYXRlfVxcYGBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5oZWxwZXJNYW5hZ2VyRGVsZWdhdGVzLnNldChvd25lciwgZGVsZWdhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWxlZ2F0ZTtcbiAgfVxuXG4gIGdldERlbGVnYXRlRm9yKG93bmVyOiBPIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKG93bmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCB7IHVuZGVmaW5lZERlbGVnYXRlIH0gPSB0aGlzO1xuXG4gICAgICBpZiAodW5kZWZpbmVkRGVsZWdhdGUgPT09IG51bGwpIHtcbiAgICAgICAgbGV0IHsgZmFjdG9yeSB9ID0gdGhpcztcbiAgICAgICAgdGhpcy51bmRlZmluZWREZWxlZ2F0ZSA9IHVuZGVmaW5lZERlbGVnYXRlID0gZmFjdG9yeSh1bmRlZmluZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkRGVsZWdhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmdldERlbGVnYXRlRm9yT3duZXIob3duZXIpO1xuICAgIH1cbiAgfVxuXG4gIGdldEhlbHBlcihkZWZpbml0aW9uOiBIZWxwZXJEZWZpbml0aW9uU3RhdGUpOiBIZWxwZXIge1xuICAgIHJldHVybiAoY2FwdHVyZWRBcmdzLCBvd25lcikgPT4ge1xuICAgICAgbGV0IG1hbmFnZXIgPSB0aGlzLmdldERlbGVnYXRlRm9yKG93bmVyIGFzIE8gfCB1bmRlZmluZWQpO1xuXG4gICAgICBjb25zdCBhcmdzID0gYXJnc1Byb3h5Rm9yKGNhcHR1cmVkQXJncywgJ2hlbHBlcicpO1xuICAgICAgY29uc3QgYnVja2V0ID0gbWFuYWdlci5jcmVhdGVIZWxwZXIoZGVmaW5pdGlvbiwgYXJncyk7XG5cbiAgICAgIGlmIChoYXNWYWx1ZShtYW5hZ2VyKSkge1xuICAgICAgICBsZXQgY2FjaGUgPSBjcmVhdGVDb21wdXRlUmVmKFxuICAgICAgICAgICgpID0+IChtYW5hZ2VyIGFzIEhlbHBlck1hbmFnZXJXaXRoVmFsdWU8dW5rbm93bj4pLmdldFZhbHVlKGJ1Y2tldCksXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBERUJVRyAmJiBtYW5hZ2VyLmdldERlYnVnTmFtZSAmJiBtYW5hZ2VyLmdldERlYnVnTmFtZShkZWZpbml0aW9uKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChoYXNEZXN0cm95YWJsZShtYW5hZ2VyKSkge1xuICAgICAgICAgIGFzc29jaWF0ZURlc3Ryb3lhYmxlQ2hpbGQoY2FjaGUsIG1hbmFnZXIuZ2V0RGVzdHJveWFibGUoYnVja2V0KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICB9IGVsc2UgaWYgKGhhc0Rlc3Ryb3lhYmxlKG1hbmFnZXIpKSB7XG4gICAgICAgIGxldCByZWYgPSBjcmVhdGVDb25zdFJlZihcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgREVCVUcgJiYgKG1hbmFnZXIuZ2V0RGVidWdOYW1lPy4oZGVmaW5pdGlvbikgPz8gJ3Vua25vd24gaGVscGVyJylcbiAgICAgICAgKTtcblxuICAgICAgICBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkKHJlZiwgbWFuYWdlci5nZXREZXN0cm95YWJsZShidWNrZXQpKTtcblxuICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVOREVGSU5FRF9SRUZFUkVOQ0U7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==