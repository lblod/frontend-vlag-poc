define('@glimmer/manager', ['exports', '@glimmer/env', '@glimmer/util', '@glimmer/global-context', '@glimmer/destroyable', '@glimmer/reference', '@glimmer/validator'], function (exports, env, util, globalContext, destroyable, reference, validator) { 'use strict';

  var FROM_CAPABILITIES = env.DEBUG ? new util._WeakSet() : undefined;
  function buildCapabilities(capabilities) {
    if (env.DEBUG) {
      FROM_CAPABILITIES.add(capabilities);
      Object.freeze(capabilities);
    }

    return capabilities;
  }
  /**
   * Converts a ComponentCapabilities object into a 32-bit integer representation.
   */

  function capabilityFlagsFrom(capabilities) {
    return 0 | (capabilities.dynamicLayout ? 1
    /* DynamicLayout */
    : 0) | (capabilities.dynamicTag ? 2
    /* DynamicTag */
    : 0) | (capabilities.prepareArgs ? 4
    /* PrepareArgs */
    : 0) | (capabilities.createArgs ? 8
    /* CreateArgs */
    : 0) | (capabilities.attributeHook ? 16
    /* AttributeHook */
    : 0) | (capabilities.elementHook ? 32
    /* ElementHook */
    : 0) | (capabilities.dynamicScope ? 64
    /* DynamicScope */
    : 0) | (capabilities.createCaller ? 128
    /* CreateCaller */
    : 0) | (capabilities.updateHook ? 256
    /* UpdateHook */
    : 0) | (capabilities.createInstance ? 512
    /* CreateInstance */
    : 0) | (capabilities.wrapped ? 1024
    /* Wrapped */
    : 0) | (capabilities.willDestroy ? 2048
    /* WillDestroy */
    : 0) | (capabilities.hasSubOwner ? 4096
    /* HasSubOwner */
    : 0);
  }
  function managerHasCapability(_manager, capabilities, capability) {
    return !!(capabilities & capability);
  }
  function hasCapability(capabilities, capability) {
    return !!(capabilities & capability);
  }

  var CUSTOM_TAG_FOR = new WeakMap();
  function getCustomTagFor(obj) {
    return CUSTOM_TAG_FOR.get(obj);
  }
  function setCustomTagFor(obj, customTagFn) {
    CUSTOM_TAG_FOR.set(obj, customTagFn);
  }

  function convertToInt(prop) {
    if (typeof prop === 'symbol') return null;
    var num = Number(prop);
    if (isNaN(num)) return null;
    return num % 1 === 0 ? num : null;
  }

  function tagForNamedArg(namedArgs, key) {
    return validator.track(function () {
      if (key in namedArgs) {
        reference.valueForRef(namedArgs[key]);
      }
    });
  }

  function tagForPositionalArg(positionalArgs, key) {
    return validator.track(function () {
      if (key === '[]') {
        // consume all of the tags in the positional array
        positionalArgs.forEach(reference.valueForRef);
      }

      var parsed = convertToInt(key);

      if (parsed !== null && parsed < positionalArgs.length) {
        // consume the tag of the referenced index
        reference.valueForRef(positionalArgs[parsed]);
      }
    });
  }

  var argsProxyFor;

  var NamedArgsProxy = /*#__PURE__*/function () {
    function NamedArgsProxy(named) {
      this.named = named;
    }

    var _proto = NamedArgsProxy.prototype;

    _proto.get = function get(_target, prop) {
      var ref = this.named[prop];

      if (ref !== undefined) {
        return reference.valueForRef(ref);
      }
    };

    _proto.has = function has(_target, prop) {
      return prop in this.named;
    };

    _proto.ownKeys = function ownKeys() {
      return Object.keys(this.named);
    };

    _proto.isExtensible = function isExtensible() {
      return false;
    };

    _proto.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(_target, prop) {
      if (env.DEBUG && !(prop in this.named)) {
        throw new Error("args proxies do not have real property descriptors, so you should never need to call getOwnPropertyDescriptor yourself. This code exists for enumerability, such as in for-in loops and Object.keys(). Attempted to get the descriptor for `" + String(prop) + "`");
      }

      return {
        enumerable: true,
        configurable: true
      };
    };

    return NamedArgsProxy;
  }();

  var PositionalArgsProxy = /*#__PURE__*/function () {
    function PositionalArgsProxy(positional) {
      this.positional = positional;
    }

    var _proto2 = PositionalArgsProxy.prototype;

    _proto2.get = function get(target, prop) {
      var positional = this.positional;

      if (prop === 'length') {
        return positional.length;
      }

      var parsed = convertToInt(prop);

      if (parsed !== null && parsed < positional.length) {
        return reference.valueForRef(positional[parsed]);
      }

      return target[prop];
    };

    _proto2.isExtensible = function isExtensible() {
      return false;
    };

    _proto2.has = function has(_target, prop) {
      var parsed = convertToInt(prop);
      return parsed !== null && parsed < this.positional.length;
    };

    return PositionalArgsProxy;
  }();

  if (util.HAS_NATIVE_PROXY) {
    argsProxyFor = function argsProxyFor(capturedArgs, type) {
      var named = capturedArgs.named,
          positional = capturedArgs.positional;

      var getNamedTag = function getNamedTag(_obj, key) {
        return tagForNamedArg(named, key);
      };

      var getPositionalTag = function getPositionalTag(_obj, key) {
        return tagForPositionalArg(positional, key);
      };

      var namedHandler = new NamedArgsProxy(named);
      var positionalHandler = new PositionalArgsProxy(positional);
      var namedTarget = Object.create(null);
      var positionalTarget = [];

      if (env.DEBUG) {
        var setHandler = function setHandler(_target, prop) {
          throw new Error("You attempted to set " + String(prop) + " on the arguments of a component, helper, or modifier. Arguments are immutable and cannot be updated directly; they always represent the values that are passed down. If you want to set default values, you should use a getter and local tracked state instead.");
        };

        var forInDebugHandler = function forInDebugHandler() {
          throw new Error("Object.keys() was called on the positional arguments array for a " + type + ", which is not supported. This function is a low-level function that should not need to be called for positional argument arrays. You may be attempting to iterate over the array using for...in instead of for...of.");
        };

        namedHandler.set = setHandler;
        positionalHandler.set = setHandler;
        positionalHandler.ownKeys = forInDebugHandler;
      }

      var namedProxy = new Proxy(namedTarget, namedHandler);
      var positionalProxy = new Proxy(positionalTarget, positionalHandler);
      setCustomTagFor(namedProxy, getNamedTag);
      setCustomTagFor(positionalProxy, getPositionalTag);
      return {
        named: namedProxy,
        positional: positionalProxy
      };
    };
  } else {
    argsProxyFor = function argsProxyFor(capturedArgs, _type) {
      var named = capturedArgs.named,
          positional = capturedArgs.positional;

      var getNamedTag = function getNamedTag(_obj, key) {
        return tagForNamedArg(named, key);
      };

      var getPositionalTag = function getPositionalTag(_obj, key) {
        return tagForPositionalArg(positional, key);
      };

      var namedProxy = {};
      var positionalProxy = [];
      setCustomTagFor(namedProxy, getNamedTag);
      setCustomTagFor(positionalProxy, getPositionalTag);
      Object.keys(named).forEach(function (name) {
        Object.defineProperty(namedProxy, name, {
          enumerable: true,
          configurable: true,
          get: function get() {
            return reference.valueForRef(named[name]);
          }
        });
      });
      positional.forEach(function (ref, index) {
        Object.defineProperty(positionalProxy, index, {
          enumerable: true,
          configurable: true,
          get: function get() {
            return reference.valueForRef(ref);
          }
        });
      });

      if (env.DEBUG) {
        // Prevent mutations in development mode. This will not prevent the
        // proxy from updating, but will prevent assigning new values or pushing
        // for instance.
        Object.freeze(namedProxy);
        Object.freeze(positionalProxy);
      }

      return {
        named: namedProxy,
        positional: positionalProxy
      };
    };
  }

  function helperCapabilities(managerAPI, options) {
    if (options === void 0) {
      options = {};
    }

    if (env.DEBUG && managerAPI !== '3.23') {
      throw new Error('Invalid helper manager compatibility specified');
    }

    if (env.DEBUG && (!(options.hasValue || options.hasScheduledEffect) || options.hasValue && options.hasScheduledEffect)) {
      throw new Error('You must pass either the `hasValue` OR the `hasScheduledEffect` capability when defining a helper manager. Passing neither, or both, is not permitted.');
    }

    if (env.DEBUG && options.hasScheduledEffect) {
      throw new Error('The `hasScheduledEffect` capability has not yet been implemented for helper managers. Please pass `hasValue` instead');
    }

    return buildCapabilities({
      hasValue: Boolean(options.hasValue),
      hasDestroyable: Boolean(options.hasDestroyable),
      hasScheduledEffect: Boolean(options.hasScheduledEffect)
    });
  } ////////////

  function hasValue(manager) {
    return manager.capabilities.hasValue;
  }
  function hasDestroyable(manager) {
    return manager.capabilities.hasDestroyable;
  } ////////////

  var CustomHelperManager = /*#__PURE__*/function () {
    function CustomHelperManager(factory) {
      this.factory = factory;
      this.helperManagerDelegates = new WeakMap();
      this.undefinedDelegate = null;
    }

    var _proto = CustomHelperManager.prototype;

    _proto.getDelegateForOwner = function getDelegateForOwner(owner) {
      var delegate = this.helperManagerDelegates.get(owner);

      if (delegate === undefined) {
        var factory = this.factory;
        delegate = factory(owner);

        if (env.DEBUG && !FROM_CAPABILITIES.has(delegate.capabilities)) {
          // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200
          throw new Error("Custom helper managers must have a `capabilities` property that is the result of calling the `capabilities('3.23')` (imported via `import { capabilities } from '@ember/helper';`). Received: `" + JSON.stringify(delegate.capabilities) + "` for: `" + delegate + "`");
        }

        this.helperManagerDelegates.set(owner, delegate);
      }

      return delegate;
    };

    _proto.getDelegateFor = function getDelegateFor(owner) {
      if (owner === undefined) {
        var undefinedDelegate = this.undefinedDelegate;

        if (undefinedDelegate === null) {
          var factory = this.factory;
          this.undefinedDelegate = undefinedDelegate = factory(undefined);
        }

        return undefinedDelegate;
      } else {
        return this.getDelegateForOwner(owner);
      }
    };

    _proto.getHelper = function getHelper(definition) {
      var _this = this;

      return function (capturedArgs, owner) {
        var _a, _b;

        var manager = _this.getDelegateFor(owner);

        var args = argsProxyFor(capturedArgs, 'helper');
        var bucket = manager.createHelper(definition, args);

        if (hasValue(manager)) {
          var cache = reference.createComputeRef(function () {
            return manager.getValue(bucket);
          }, null, env.DEBUG && manager.getDebugName && manager.getDebugName(definition));

          if (hasDestroyable(manager)) {
            destroyable.associateDestroyableChild(cache, manager.getDestroyable(bucket));
          }

          return cache;
        } else if (hasDestroyable(manager)) {
          var ref = reference.createConstRef(undefined, env.DEBUG && ((_b = (_a = manager.getDebugName) === null || _a === void 0 ? void 0 : _a.call(manager, definition)) !== null && _b !== void 0 ? _b : 'unknown helper'));
          destroyable.associateDestroyableChild(ref, manager.getDestroyable(bucket));
          return ref;
        } else {
          return reference.UNDEFINED_REFERENCE;
        }
      };
    };

    return CustomHelperManager;
  }();

  var FunctionHelperManager = /*#__PURE__*/function () {
    function FunctionHelperManager() {
      this.capabilities = buildCapabilities({
        hasValue: true,
        hasDestroyable: false,
        hasScheduledEffect: false
      });
    }

    var _proto = FunctionHelperManager.prototype;

    _proto.createHelper = function createHelper(fn, args) {
      return {
        fn: fn,
        args: args
      };
    };

    _proto.getValue = function getValue(_ref) {
      var fn = _ref.fn,
          args = _ref.args;

      if (Object.keys(args.named).length > 0) {
        var argsForFn = [].concat(args.positional, [args.named]);
        return fn.apply(void 0, argsForFn);
      }

      return fn.apply(void 0, args.positional);
    };

    _proto.getDebugName = function getDebugName(fn) {
      if (fn.name) {
        return "(helper function " + fn.name + ")";
      }

      return '(anonymous helper function)';
    };

    return FunctionHelperManager;
  }();

  var COMPONENT_MANAGERS = new WeakMap();
  var MODIFIER_MANAGERS = new WeakMap();
  var HELPER_MANAGERS = new WeakMap(); ///////////

  var getPrototypeOf = Object.getPrototypeOf;

  function setManager(map, manager, obj) {
    if (env.DEBUG && (typeof obj !== 'object' || obj === null) && typeof obj !== 'function') {
      throw new Error("Attempted to set a manager on a non-object value. Managers can only be associated with objects or functions. Value was " + util.debugToString(obj));
    }

    if (env.DEBUG && map.has(obj)) {
      throw new Error("Attempted to set the same type of manager multiple times on a value. You can only associate one manager of each type with a given value. Value was " + util.debugToString(obj));
    }

    map.set(obj, manager);
    return obj;
  }

  function getManager(map, obj) {
    var pointer = obj;

    while (pointer !== undefined && pointer !== null) {
      var manager = map.get(pointer);

      if (manager !== undefined) {
        return manager;
      }

      pointer = getPrototypeOf(pointer);
    }

    return undefined;
  } ///////////


  function setInternalModifierManager(manager, definition) {
    return setManager(MODIFIER_MANAGERS, manager, definition);
  }
  function getInternalModifierManager(definition, isOptional) {
    if (env.DEBUG && typeof definition !== 'function' && (typeof definition !== 'object' || definition === null)) {
      throw new Error("Attempted to use a value as a modifier, but it was not an object or function. Modifier definitions must be objects or functions with an associated modifier manager. The value was: " + definition);
    }

    var manager = getManager(MODIFIER_MANAGERS, definition);

    if (manager === undefined) {
      if (isOptional === true) {
        return null;
      } else if (env.DEBUG) {
        throw new Error("Attempted to load a modifier, but there wasn't a modifier manager associated with the definition. The definition was: " + util.debugToString(definition));
      }
    }

    return manager;
  }
  function setInternalHelperManager(manager, definition) {
    return setManager(HELPER_MANAGERS, manager, definition);
  }
  var DEFAULT_MANAGER = new CustomHelperManager(function () {
    return new FunctionHelperManager();
  });
  function getInternalHelperManager(definition, isOptional) {
    if (env.DEBUG && typeof definition !== 'function' && (typeof definition !== 'object' || definition === null)) {
      throw new Error("Attempted to use a value as a helper, but it was not an object or function. Helper definitions must be objects or functions with an associated helper manager. The value was: " + definition);
    }

    var manager = getManager(HELPER_MANAGERS, definition);

    if (globalContext.FEATURE_DEFAULT_HELPER_MANAGER) {
      // Functions are special-cased because functions are defined
      // as the "default" helper, per: https://github.com/emberjs/rfcs/pull/756
      if (manager === undefined && typeof definition === 'function') {
        manager = DEFAULT_MANAGER;
      }
    }

    if (manager) {
      return manager;
    } else if (isOptional === true) {
      return null;
    } else if (env.DEBUG) {
      throw new Error("Attempted to load a helper, but there wasn't a helper manager associated with the definition. The definition was: " + util.debugToString(definition));
    }

    return null;
  }
  function setInternalComponentManager(factory, obj) {
    return setManager(COMPONENT_MANAGERS, factory, obj);
  }
  function getInternalComponentManager(definition, isOptional) {
    if (env.DEBUG && typeof definition !== 'function' && (typeof definition !== 'object' || definition === null)) {
      throw new Error("Attempted to use a value as a component, but it was not an object or function. Component definitions must be objects or functions with an associated component manager. The value was: " + definition);
    }

    var manager = getManager(COMPONENT_MANAGERS, definition);

    if (manager === undefined) {
      if (isOptional === true) {
        return null;
      } else if (env.DEBUG) {
        throw new Error("Attempted to load a component, but there wasn't a component manager associated with the definition. The definition was: " + util.debugToString(definition));
      }
    }

    return manager;
  } ///////////

  function hasInternalComponentManager(definition) {
    return  getManager(COMPONENT_MANAGERS, definition) !== undefined;
  }
  function hasInternalHelperManager(definition) {
    return hasDefaultHelperManager(definition) || getManager(HELPER_MANAGERS, definition) !== undefined;
  }
  function hasInternalModifierManager(definition) {
    return  getManager(MODIFIER_MANAGERS, definition) !== undefined;
  }

  function hasDefaultHelperManager(definition) {
    if (globalContext.FEATURE_DEFAULT_HELPER_MANAGER) {
      return typeof definition === 'function';
    }

    return false;
  }

  var CAPABILITIES = {
    dynamicLayout: false,
    dynamicTag: false,
    prepareArgs: false,
    createArgs: true,
    attributeHook: false,
    elementHook: false,
    createCaller: false,
    dynamicScope: true,
    updateHook: true,
    createInstance: true,
    wrapped: false,
    willDestroy: false,
    hasSubOwner: false
  };
  function componentCapabilities(managerAPI, options) {
    if (options === void 0) {
      options = {};
    }

    if (env.DEBUG && managerAPI !== '3.13') {
      throw new Error('Invalid component manager compatibility specified');
    }

    var updateHook = Boolean(options.updateHook);
    return buildCapabilities({
      asyncLifeCycleCallbacks: Boolean(options.asyncLifecycleCallbacks),
      destructor: Boolean(options.destructor),
      updateHook: updateHook
    });
  }
  function hasAsyncLifeCycleCallbacks(delegate) {
    return delegate.capabilities.asyncLifeCycleCallbacks;
  }
  function hasUpdateHook(delegate) {
    return delegate.capabilities.updateHook;
  }
  function hasAsyncUpdateHook(delegate) {
    return hasAsyncLifeCycleCallbacks(delegate) && hasUpdateHook(delegate);
  }
  function hasDestructors(delegate) {
    return delegate.capabilities.destructor;
  }
  /**
    The CustomComponentManager allows addons to provide custom component
    implementations that integrate seamlessly into Ember. This is accomplished
    through a delegate, registered with the custom component manager, which
    implements a set of hooks that determine component behavior.

    To create a custom component manager, instantiate a new CustomComponentManager
    class and pass the delegate as the first argument:

    ```js
    let manager = new CustomComponentManager({
      // ...delegate implementation...
    });
    ```

    ## Delegate Hooks

    Throughout the lifecycle of a component, the component manager will invoke
    delegate hooks that are responsible for surfacing those lifecycle changes to
    the end developer.

    * `create()` - invoked when a new instance of a component should be created
    * `update()` - invoked when the arguments passed to a component change
    * `getContext()` - returns the object that should be
  */

  var CustomComponentManager = /*#__PURE__*/function () {
    function CustomComponentManager(factory) {
      this.factory = factory;
      this.componentManagerDelegates = new WeakMap();
    }

    var _proto = CustomComponentManager.prototype;

    _proto.getDelegateFor = function getDelegateFor(owner) {
      var componentManagerDelegates = this.componentManagerDelegates;
      var delegate = componentManagerDelegates.get(owner);

      if (delegate === undefined) {
        var factory = this.factory;
        delegate = factory(owner);

        if (env.DEBUG && !FROM_CAPABILITIES.has(delegate.capabilities)) {
          // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200
          throw new Error("Custom component managers must have a `capabilities` property that is the result of calling the `capabilities('3.13')` (imported via `import { capabilities } from '@ember/component';`). Received: `" + JSON.stringify(delegate.capabilities) + "` for: `" + delegate + "`");
        }

        componentManagerDelegates.set(owner, delegate);
      }

      return delegate;
    };

    _proto.create = function create(owner, definition, vmArgs) {
      var delegate = this.getDelegateFor(owner);
      var args = argsProxyFor(vmArgs.capture(), 'component');
      var component = delegate.createComponent(definition, args);
      return new CustomComponentState(component, delegate, args);
    };

    _proto.getDebugName = function getDebugName(definition) {
      return typeof definition === 'function' ? definition.name : definition.toString();
    };

    _proto.update = function update(bucket) {
      var delegate = bucket.delegate;

      if (hasUpdateHook(delegate)) {
        var component = bucket.component,
            args = bucket.args;
        delegate.updateComponent(component, args);
      }
    };

    _proto.didCreate = function didCreate(_ref) {
      var component = _ref.component,
          delegate = _ref.delegate;

      if (hasAsyncLifeCycleCallbacks(delegate)) {
        delegate.didCreateComponent(component);
      }
    };

    _proto.didUpdate = function didUpdate(_ref2) {
      var component = _ref2.component,
          delegate = _ref2.delegate;

      if (hasAsyncUpdateHook(delegate)) {
        delegate.didUpdateComponent(component);
      }
    };

    _proto.didRenderLayout = function didRenderLayout() {};

    _proto.didUpdateLayout = function didUpdateLayout() {};

    _proto.getSelf = function getSelf(_ref3) {
      var component = _ref3.component,
          delegate = _ref3.delegate;
      return reference.createConstRef(delegate.getContext(component), 'this');
    };

    _proto.getDestroyable = function getDestroyable(bucket) {
      var delegate = bucket.delegate;

      if (hasDestructors(delegate)) {
        var component = bucket.component;
        destroyable.registerDestructor(bucket, function () {
          return delegate.destroyComponent(component);
        });
        return bucket;
      }

      return null;
    };

    _proto.getCapabilities = function getCapabilities() {
      return CAPABILITIES;
    };

    return CustomComponentManager;
  }();
  /**
   * Stores internal state about a component instance after it's been created.
   */

  var CustomComponentState = function CustomComponentState(component, delegate, args) {
    this.component = component;
    this.delegate = delegate;
    this.args = args;
  };

  function modifierCapabilities(managerAPI, optionalFeatures) {
    if (optionalFeatures === void 0) {
      optionalFeatures = {};
    }

    if (env.DEBUG && managerAPI !== '3.22') {
      throw new Error('Invalid modifier manager compatibility specified');
    }

    return buildCapabilities({
      disableAutoTracking: Boolean(optionalFeatures.disableAutoTracking)
    });
  }
  /**
    The CustomModifierManager allows addons to provide custom modifier
    implementations that integrate seamlessly into Ember. This is accomplished
    through a delegate, registered with the custom modifier manager, which
    implements a set of hooks that determine modifier behavior.
    To create a custom modifier manager, instantiate a new CustomModifierManager
    class and pass the delegate as the first argument:

    ```js
    let manager = new CustomModifierManager({
      // ...delegate implementation...
    });
    ```

    ## Delegate Hooks

    Throughout the lifecycle of a modifier, the modifier manager will invoke
    delegate hooks that are responsible for surfacing those lifecycle changes to
    the end developer.
    * `createModifier()` - invoked when a new instance of a modifier should be created
    * `installModifier()` - invoked when the modifier is installed on the element
    * `updateModifier()` - invoked when the arguments passed to a modifier change
    * `destroyModifier()` - invoked when the modifier is about to be destroyed
  */

  var CustomModifierManager = /*#__PURE__*/function () {
    function CustomModifierManager(factory) {
      this.factory = factory;
      this.componentManagerDelegates = new WeakMap();
    }

    var _proto = CustomModifierManager.prototype;

    _proto.getDelegateFor = function getDelegateFor(owner) {
      var componentManagerDelegates = this.componentManagerDelegates;
      var delegate = componentManagerDelegates.get(owner);

      if (delegate === undefined) {
        var factory = this.factory;
        delegate = factory(owner);

        if (env.DEBUG && !FROM_CAPABILITIES.has(delegate.capabilities)) {
          // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200
          throw new Error("Custom modifier managers must have a `capabilities` property that is the result of calling the `capabilities('3.22')` (imported via `import { capabilities } from '@ember/modifier';`). Received: `" + JSON.stringify(delegate.capabilities) + "` for: `" + delegate + "`");
        }

        componentManagerDelegates.set(owner, delegate);
      }

      return delegate;
    };

    _proto.create = function create(owner, element, definition, capturedArgs) {
      var delegate = this.getDelegateFor(owner);
      var args = argsProxyFor(capturedArgs, 'modifier');
      var instance = delegate.createModifier(definition, args);
      var tag = validator.createUpdatableTag();
      var state;
      state = {
        tag: tag,
        element: element,
        delegate: delegate,
        args: args,
        modifier: instance
      };

      if (env.DEBUG) {
        state.debugName = typeof definition === 'function' ? definition.name : definition.toString();
      }

      destroyable.registerDestructor(state, function () {
        return delegate.destroyModifier(instance, args);
      });
      return state;
    };

    _proto.getDebugName = function getDebugName(_ref) {
      var debugName = _ref.debugName;
      return debugName;
    };

    _proto.getTag = function getTag(_ref2) {
      var tag = _ref2.tag;
      return tag;
    };

    _proto.install = function install(_ref3) {
      var element = _ref3.element,
          args = _ref3.args,
          modifier = _ref3.modifier,
          delegate = _ref3.delegate;
      var capabilities = delegate.capabilities;

      if (capabilities.disableAutoTracking === true) {
        validator.untrack(function () {
          return delegate.installModifier(modifier, element, args);
        });
      } else {
        delegate.installModifier(modifier, element, args);
      }
    };

    _proto.update = function update(_ref4) {
      var args = _ref4.args,
          modifier = _ref4.modifier,
          delegate = _ref4.delegate;
      var capabilities = delegate.capabilities;

      if (capabilities.disableAutoTracking === true) {
        validator.untrack(function () {
          return delegate.updateModifier(modifier, args);
        });
      } else {
        delegate.updateModifier(modifier, args);
      }
    };

    _proto.getDestroyable = function getDestroyable(state) {
      return state;
    };

    return CustomModifierManager;
  }();

  function setComponentManager(factory, obj) {
    return setInternalComponentManager(new CustomComponentManager(factory), obj);
  }
  function setModifierManager(factory, obj) {
    return setInternalModifierManager(new CustomModifierManager(factory), obj);
  }
  function setHelperManager(factory, obj) {
    return setInternalHelperManager(new CustomHelperManager(factory), obj);
  }

  var TEMPLATES = new WeakMap();
  var getPrototypeOf$1 = Object.getPrototypeOf;
  function setComponentTemplate(factory, obj) {
    if (env.DEBUG && !(obj !== null && (typeof obj === 'object' || typeof obj === 'function'))) {
      throw new Error("Cannot call `setComponentTemplate` on `" + util.debugToString(obj) + "`");
    }

    if (env.DEBUG && TEMPLATES.has(obj)) {
      throw new Error("Cannot call `setComponentTemplate` multiple times on the same class (`" + util.debugToString(obj) + "`)");
    }

    TEMPLATES.set(obj, factory);
    return obj;
  }
  function getComponentTemplate(obj) {
    var pointer = obj;

    while (pointer !== null) {
      var template = TEMPLATES.get(pointer);

      if (template !== undefined) {
        return template;
      }

      pointer = getPrototypeOf$1(pointer);
    }

    return undefined;
  }

  exports.CustomComponentManager = CustomComponentManager;
  exports.CustomHelperManager = CustomHelperManager;
  exports.CustomModifierManager = CustomModifierManager;
  exports.capabilityFlagsFrom = capabilityFlagsFrom;
  exports.componentCapabilities = componentCapabilities;
  exports.getComponentTemplate = getComponentTemplate;
  exports.getCustomTagFor = getCustomTagFor;
  exports.getInternalComponentManager = getInternalComponentManager;
  exports.getInternalHelperManager = getInternalHelperManager;
  exports.getInternalModifierManager = getInternalModifierManager;
  exports.hasCapability = hasCapability;
  exports.hasDestroyable = hasDestroyable;
  exports.hasInternalComponentManager = hasInternalComponentManager;
  exports.hasInternalHelperManager = hasInternalHelperManager;
  exports.hasInternalModifierManager = hasInternalModifierManager;
  exports.hasValue = hasValue;
  exports.helperCapabilities = helperCapabilities;
  exports.managerHasCapability = managerHasCapability;
  exports.modifierCapabilities = modifierCapabilities;
  exports.setComponentManager = setComponentManager;
  exports.setComponentTemplate = setComponentTemplate;
  exports.setCustomTagFor = setCustomTagFor;
  exports.setHelperManager = setHelperManager;
  exports.setInternalComponentManager = setInternalComponentManager;
  exports.setInternalHelperManager = setInternalHelperManager;
  exports.setInternalModifierManager = setInternalModifierManager;
  exports.setModifierManager = setModifierManager;

  Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci1tYW5hZ2VyLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9tYW5hZ2VyL2xpYi91dGlsL2NhcGFiaWxpdGllcy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL3V0aWwvYXJncy1wcm94eS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL3B1YmxpYy9oZWxwZXIudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci9tYW5hZ2VyL2xpYi9pbnRlcm5hbC9kZWZhdWx0cy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL2ludGVybmFsL2luZGV4LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvbWFuYWdlci9saWIvcHVibGljL2NvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL3B1YmxpYy9tb2RpZmllci50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL3B1YmxpYy9pbmRleC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL21hbmFnZXIvbGliL3B1YmxpYy90ZW1wbGF0ZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQgeyBfV2Vha1NldCB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHtcbiAgQ2FwYWJpbGl0aWVzLFxuICBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdGllcyxcbiAgSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyLFxuICBXaXRoVXBkYXRlSG9vayxcbiAgV2l0aFByZXBhcmVBcmdzLFxuICBXaXRoQ3JlYXRlSW5zdGFuY2UsXG4gIFdpdGhEeW5hbWljTGF5b3V0LFxuICBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHksXG4gIFdpdGhTdWJPd25lcixcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBjaGVjaywgQ2hlY2tOdW1iZXIgfSBmcm9tICdAZ2xpbW1lci9kZWJ1Zyc7XG5cbmV4cG9ydCBjb25zdCBGUk9NX0NBUEFCSUxJVElFUyA9IERFQlVHID8gbmV3IF9XZWFrU2V0KCkgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZENhcGFiaWxpdGllczxUIGV4dGVuZHMgb2JqZWN0PihjYXBhYmlsaXRpZXM6IFQpOiBUICYgQ2FwYWJpbGl0aWVzIHtcbiAgaWYgKERFQlVHKSB7XG4gICAgRlJPTV9DQVBBQklMSVRJRVMhLmFkZChjYXBhYmlsaXRpZXMpO1xuICAgIE9iamVjdC5mcmVlemUoY2FwYWJpbGl0aWVzKTtcbiAgfVxuXG4gIHJldHVybiBjYXBhYmlsaXRpZXMgYXMgVCAmIENhcGFiaWxpdGllcztcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIENvbXBvbmVudENhcGFiaWxpdGllcyBvYmplY3QgaW50byBhIDMyLWJpdCBpbnRlZ2VyIHJlcHJlc2VudGF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FwYWJpbGl0eUZsYWdzRnJvbShcbiAgY2FwYWJpbGl0aWVzOiBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdGllc1xuKTogSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5IHtcbiAgcmV0dXJuIChcbiAgICAwIHxcbiAgICAoY2FwYWJpbGl0aWVzLmR5bmFtaWNMYXlvdXQgPyBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuRHluYW1pY0xheW91dCA6IDApIHxcbiAgICAoY2FwYWJpbGl0aWVzLmR5bmFtaWNUYWcgPyBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuRHluYW1pY1RhZyA6IDApIHxcbiAgICAoY2FwYWJpbGl0aWVzLnByZXBhcmVBcmdzID8gSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LlByZXBhcmVBcmdzIDogMCkgfFxuICAgIChjYXBhYmlsaXRpZXMuY3JlYXRlQXJncyA/IEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5DcmVhdGVBcmdzIDogMCkgfFxuICAgIChjYXBhYmlsaXRpZXMuYXR0cmlidXRlSG9vayA/IEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5BdHRyaWJ1dGVIb29rIDogMCkgfFxuICAgIChjYXBhYmlsaXRpZXMuZWxlbWVudEhvb2sgPyBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuRWxlbWVudEhvb2sgOiAwKSB8XG4gICAgKGNhcGFiaWxpdGllcy5keW5hbWljU2NvcGUgPyBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuRHluYW1pY1Njb3BlIDogMCkgfFxuICAgIChjYXBhYmlsaXRpZXMuY3JlYXRlQ2FsbGVyID8gSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LkNyZWF0ZUNhbGxlciA6IDApIHxcbiAgICAoY2FwYWJpbGl0aWVzLnVwZGF0ZUhvb2sgPyBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuVXBkYXRlSG9vayA6IDApIHxcbiAgICAoY2FwYWJpbGl0aWVzLmNyZWF0ZUluc3RhbmNlID8gSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LkNyZWF0ZUluc3RhbmNlIDogMCkgfFxuICAgIChjYXBhYmlsaXRpZXMud3JhcHBlZCA/IEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5XcmFwcGVkIDogMCkgfFxuICAgIChjYXBhYmlsaXRpZXMud2lsbERlc3Ryb3kgPyBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuV2lsbERlc3Ryb3kgOiAwKSB8XG4gICAgKGNhcGFiaWxpdGllcy5oYXNTdWJPd25lciA/IEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5IYXNTdWJPd25lciA6IDApXG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5TWFwIHtcbiAgW0ludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5EeW5hbWljTGF5b3V0XTogV2l0aER5bmFtaWNMYXlvdXQ7XG4gIFtJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuRHluYW1pY1RhZ106IEludGVybmFsQ29tcG9uZW50TWFuYWdlcjtcbiAgW0ludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5QcmVwYXJlQXJnc106IFdpdGhQcmVwYXJlQXJncztcbiAgW0ludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5DcmVhdGVBcmdzXTogSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyO1xuICBbSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LkF0dHJpYnV0ZUhvb2tdOiBJbnRlcm5hbENvbXBvbmVudE1hbmFnZXI7XG4gIFtJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuRWxlbWVudEhvb2tdOiBJbnRlcm5hbENvbXBvbmVudE1hbmFnZXI7XG4gIFtJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuRHluYW1pY1Njb3BlXTogSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyO1xuICBbSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LkNyZWF0ZUNhbGxlcl06IEludGVybmFsQ29tcG9uZW50TWFuYWdlcjtcbiAgW0ludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5VcGRhdGVIb29rXTogV2l0aFVwZGF0ZUhvb2s7XG4gIFtJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuQ3JlYXRlSW5zdGFuY2VdOiBXaXRoQ3JlYXRlSW5zdGFuY2U7XG4gIFtJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHkuV3JhcHBlZF06IEludGVybmFsQ29tcG9uZW50TWFuYWdlcjtcbiAgW0ludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5XaWxsRGVzdHJveV06IEludGVybmFsQ29tcG9uZW50TWFuYWdlcjtcbiAgW0ludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eS5IYXNTdWJPd25lcl06IFdpdGhTdWJPd25lcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hbmFnZXJIYXNDYXBhYmlsaXR5PEYgZXh0ZW5kcyBrZXlvZiBJbnRlcm5hbENvbXBvbmVudENhcGFiaWxpdHlNYXA+KFxuICBfbWFuYWdlcjogSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyLFxuICBjYXBhYmlsaXRpZXM6IEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eSxcbiAgY2FwYWJpbGl0eTogRlxuKTogX21hbmFnZXIgaXMgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5TWFwW0ZdIHtcbiAgY2hlY2soY2FwYWJpbGl0aWVzLCBDaGVja051bWJlcik7XG4gIHJldHVybiAhIShjYXBhYmlsaXRpZXMgJiBjYXBhYmlsaXR5KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NhcGFiaWxpdHk8RiBleHRlbmRzIGtleW9mIEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0eU1hcD4oXG4gIGNhcGFiaWxpdGllczogSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXR5LFxuICBjYXBhYmlsaXR5OiBGXG4pOiBib29sZWFuIHtcbiAgY2hlY2soY2FwYWJpbGl0aWVzLCBDaGVja051bWJlcik7XG4gIHJldHVybiAhIShjYXBhYmlsaXRpZXMgJiBjYXBhYmlsaXR5KTtcbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7XG4gIEFyZ3VtZW50cyxcbiAgQ2FwdHVyZWRBcmd1bWVudHMsXG4gIENhcHR1cmVkTmFtZWRBcmd1bWVudHMsXG4gIENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cyxcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBSZWZlcmVuY2UsIHZhbHVlRm9yUmVmIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcbmltcG9ydCB7IEhBU19OQVRJVkVfUFJPWFkgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IFRhZywgdHJhY2sgfSBmcm9tICdAZ2xpbW1lci92YWxpZGF0b3InO1xuXG5jb25zdCBDVVNUT01fVEFHX0ZPUiA9IG5ldyBXZWFrTWFwPG9iamVjdCwgKG9iajogb2JqZWN0LCBrZXk6IHN0cmluZykgPT4gVGFnPigpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VzdG9tVGFnRm9yKG9iajogb2JqZWN0KTogKChvYmo6IG9iamVjdCwga2V5OiBzdHJpbmcpID0+IFRhZykgfCB1bmRlZmluZWQge1xuICByZXR1cm4gQ1VTVE9NX1RBR19GT1IuZ2V0KG9iaik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDdXN0b21UYWdGb3Iob2JqOiBvYmplY3QsIGN1c3RvbVRhZ0ZuOiAob2JqOiBvYmplY3QsIGtleTogc3RyaW5nKSA9PiBUYWcpIHtcbiAgQ1VTVE9NX1RBR19GT1Iuc2V0KG9iaiwgY3VzdG9tVGFnRm4pO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9JbnQocHJvcDogbnVtYmVyIHwgc3RyaW5nIHwgc3ltYm9sKTogbnVtYmVyIHwgbnVsbCB7XG4gIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N5bWJvbCcpIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IG51bSA9IE51bWJlcihwcm9wKTtcblxuICBpZiAoaXNOYU4obnVtKSkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIG51bSAlIDEgPT09IDAgPyBudW0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiB0YWdGb3JOYW1lZEFyZyhuYW1lZEFyZ3M6IENhcHR1cmVkTmFtZWRBcmd1bWVudHMsIGtleTogc3RyaW5nKTogVGFnIHtcbiAgcmV0dXJuIHRyYWNrKCgpID0+IHtcbiAgICBpZiAoa2V5IGluIG5hbWVkQXJncykge1xuICAgICAgdmFsdWVGb3JSZWYobmFtZWRBcmdzW2tleV0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRhZ0ZvclBvc2l0aW9uYWxBcmcocG9zaXRpb25hbEFyZ3M6IENhcHR1cmVkUG9zaXRpb25hbEFyZ3VtZW50cywga2V5OiBzdHJpbmcpOiBUYWcge1xuICByZXR1cm4gdHJhY2soKCkgPT4ge1xuICAgIGlmIChrZXkgPT09ICdbXScpIHtcbiAgICAgIC8vIGNvbnN1bWUgYWxsIG9mIHRoZSB0YWdzIGluIHRoZSBwb3NpdGlvbmFsIGFycmF5XG4gICAgICBwb3NpdGlvbmFsQXJncy5mb3JFYWNoKHZhbHVlRm9yUmVmKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWQgPSBjb252ZXJ0VG9JbnQoa2V5KTtcblxuICAgIGlmIChwYXJzZWQgIT09IG51bGwgJiYgcGFyc2VkIDwgcG9zaXRpb25hbEFyZ3MubGVuZ3RoKSB7XG4gICAgICAvLyBjb25zdW1lIHRoZSB0YWcgb2YgdGhlIHJlZmVyZW5jZWQgaW5kZXhcbiAgICAgIHZhbHVlRm9yUmVmKHBvc2l0aW9uYWxBcmdzW3BhcnNlZF0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBsZXQgYXJnc1Byb3h5Rm9yOiAoXG4gIGNhcHR1cmVkQXJnczogQ2FwdHVyZWRBcmd1bWVudHMsXG4gIHR5cGU6ICdjb21wb25lbnQnIHwgJ2hlbHBlcicgfCAnbW9kaWZpZXInXG4pID0+IEFyZ3VtZW50cztcblxuY2xhc3MgTmFtZWRBcmdzUHJveHkgaW1wbGVtZW50cyBQcm94eUhhbmRsZXI8e30+IHtcbiAgZGVjbGFyZSBzZXQ/OiAodGFyZ2V0OiB7fSwgcHJvcDogc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sKSA9PiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbmFtZWQ6IENhcHR1cmVkTmFtZWRBcmd1bWVudHMpIHt9XG5cbiAgZ2V0KF90YXJnZXQ6IHt9LCBwcm9wOiBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpIHtcbiAgICBjb25zdCByZWYgPSB0aGlzLm5hbWVkW3Byb3AgYXMgc3RyaW5nXTtcblxuICAgIGlmIChyZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHZhbHVlRm9yUmVmKHJlZik7XG4gICAgfVxuICB9XG5cbiAgaGFzKF90YXJnZXQ6IHt9LCBwcm9wOiBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcCBpbiB0aGlzLm5hbWVkO1xuICB9XG5cbiAgb3duS2V5cygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5uYW1lZCk7XG4gIH1cblxuICBpc0V4dGVuc2libGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF90YXJnZXQ6IHt9LCBwcm9wOiBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpIHtcbiAgICBpZiAoREVCVUcgJiYgIShwcm9wIGluIHRoaXMubmFtZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBhcmdzIHByb3hpZXMgZG8gbm90IGhhdmUgcmVhbCBwcm9wZXJ0eSBkZXNjcmlwdG9ycywgc28geW91IHNob3VsZCBuZXZlciBuZWVkIHRvIGNhbGwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIHlvdXJzZWxmLiBUaGlzIGNvZGUgZXhpc3RzIGZvciBlbnVtZXJhYmlsaXR5LCBzdWNoIGFzIGluIGZvci1pbiBsb29wcyBhbmQgT2JqZWN0LmtleXMoKS4gQXR0ZW1wdGVkIHRvIGdldCB0aGUgZGVzY3JpcHRvciBmb3IgXFxgJHtTdHJpbmcoXG4gICAgICAgICAgcHJvcFxuICAgICAgICApfVxcYGBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfTtcbiAgfVxufVxuXG5jbGFzcyBQb3NpdGlvbmFsQXJnc1Byb3h5IGltcGxlbWVudHMgUHJveHlIYW5kbGVyPFtdPiB7XG4gIGRlY2xhcmUgc2V0PzogKHRhcmdldDogW10sIHByb3A6IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCkgPT4gYm9vbGVhbjtcbiAgZGVjbGFyZSBvd25LZXlzPzogKHRhcmdldDogW10pID0+IHN0cmluZ1tdO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcG9zaXRpb25hbDogQ2FwdHVyZWRQb3NpdGlvbmFsQXJndW1lbnRzKSB7fVxuXG4gIGdldCh0YXJnZXQ6IFtdLCBwcm9wOiBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wpIHtcbiAgICBsZXQgeyBwb3NpdGlvbmFsIH0gPSB0aGlzO1xuXG4gICAgaWYgKHByb3AgPT09ICdsZW5ndGgnKSB7XG4gICAgICByZXR1cm4gcG9zaXRpb25hbC5sZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkID0gY29udmVydFRvSW50KHByb3ApO1xuXG4gICAgaWYgKHBhcnNlZCAhPT0gbnVsbCAmJiBwYXJzZWQgPCBwb3NpdGlvbmFsLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHZhbHVlRm9yUmVmKHBvc2l0aW9uYWxbcGFyc2VkXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0YXJnZXQgYXMgYW55KVtwcm9wXTtcbiAgfVxuXG4gIGlzRXh0ZW5zaWJsZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYXMoX3RhcmdldDogW10sIHByb3A6IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IGNvbnZlcnRUb0ludChwcm9wKTtcblxuICAgIHJldHVybiBwYXJzZWQgIT09IG51bGwgJiYgcGFyc2VkIDwgdGhpcy5wb3NpdGlvbmFsLmxlbmd0aDtcbiAgfVxufVxuXG5pZiAoSEFTX05BVElWRV9QUk9YWSkge1xuICBhcmdzUHJveHlGb3IgPSAoY2FwdHVyZWRBcmdzLCB0eXBlKSA9PiB7XG4gICAgY29uc3QgeyBuYW1lZCwgcG9zaXRpb25hbCB9ID0gY2FwdHVyZWRBcmdzO1xuXG4gICAgbGV0IGdldE5hbWVkVGFnID0gKF9vYmo6IG9iamVjdCwga2V5OiBzdHJpbmcpID0+IHRhZ0Zvck5hbWVkQXJnKG5hbWVkLCBrZXkpO1xuICAgIGxldCBnZXRQb3NpdGlvbmFsVGFnID0gKF9vYmo6IG9iamVjdCwga2V5OiBzdHJpbmcpID0+IHRhZ0ZvclBvc2l0aW9uYWxBcmcocG9zaXRpb25hbCwga2V5KTtcblxuICAgIGNvbnN0IG5hbWVkSGFuZGxlciA9IG5ldyBOYW1lZEFyZ3NQcm94eShuYW1lZCk7XG4gICAgY29uc3QgcG9zaXRpb25hbEhhbmRsZXIgPSBuZXcgUG9zaXRpb25hbEFyZ3NQcm94eShwb3NpdGlvbmFsKTtcblxuICAgIGNvbnN0IG5hbWVkVGFyZ2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBwb3NpdGlvbmFsVGFyZ2V0OiB1bmtub3duW10gPSBbXTtcblxuICAgIGlmIChERUJVRykge1xuICAgICAgY29uc3Qgc2V0SGFuZGxlciA9IGZ1bmN0aW9uIChfdGFyZ2V0OiB1bmtub3duLCBwcm9wOiBzeW1ib2wgfCBzdHJpbmcgfCBudW1iZXIpOiBuZXZlciB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IGF0dGVtcHRlZCB0byBzZXQgJHtTdHJpbmcoXG4gICAgICAgICAgICBwcm9wXG4gICAgICAgICAgKX0gb24gdGhlIGFyZ3VtZW50cyBvZiBhIGNvbXBvbmVudCwgaGVscGVyLCBvciBtb2RpZmllci4gQXJndW1lbnRzIGFyZSBpbW11dGFibGUgYW5kIGNhbm5vdCBiZSB1cGRhdGVkIGRpcmVjdGx5OyB0aGV5IGFsd2F5cyByZXByZXNlbnQgdGhlIHZhbHVlcyB0aGF0IGFyZSBwYXNzZWQgZG93bi4gSWYgeW91IHdhbnQgdG8gc2V0IGRlZmF1bHQgdmFsdWVzLCB5b3Ugc2hvdWxkIHVzZSBhIGdldHRlciBhbmQgbG9jYWwgdHJhY2tlZCBzdGF0ZSBpbnN0ZWFkLmBcbiAgICAgICAgKTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGZvckluRGVidWdIYW5kbGVyID0gKCk6IG5ldmVyID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBPYmplY3Qua2V5cygpIHdhcyBjYWxsZWQgb24gdGhlIHBvc2l0aW9uYWwgYXJndW1lbnRzIGFycmF5IGZvciBhICR7dHlwZX0sIHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWQuIFRoaXMgZnVuY3Rpb24gaXMgYSBsb3ctbGV2ZWwgZnVuY3Rpb24gdGhhdCBzaG91bGQgbm90IG5lZWQgdG8gYmUgY2FsbGVkIGZvciBwb3NpdGlvbmFsIGFyZ3VtZW50IGFycmF5cy4gWW91IG1heSBiZSBhdHRlbXB0aW5nIHRvIGl0ZXJhdGUgb3ZlciB0aGUgYXJyYXkgdXNpbmcgZm9yLi4uaW4gaW5zdGVhZCBvZiBmb3IuLi5vZi5gXG4gICAgICAgICk7XG4gICAgICB9O1xuXG4gICAgICBuYW1lZEhhbmRsZXIuc2V0ID0gc2V0SGFuZGxlcjtcbiAgICAgIHBvc2l0aW9uYWxIYW5kbGVyLnNldCA9IHNldEhhbmRsZXI7XG4gICAgICBwb3NpdGlvbmFsSGFuZGxlci5vd25LZXlzID0gZm9ySW5EZWJ1Z0hhbmRsZXI7XG4gICAgfVxuXG4gICAgY29uc3QgbmFtZWRQcm94eSA9IG5ldyBQcm94eShuYW1lZFRhcmdldCwgbmFtZWRIYW5kbGVyKTtcbiAgICBjb25zdCBwb3NpdGlvbmFsUHJveHkgPSBuZXcgUHJveHkocG9zaXRpb25hbFRhcmdldCwgcG9zaXRpb25hbEhhbmRsZXIpO1xuXG4gICAgc2V0Q3VzdG9tVGFnRm9yKG5hbWVkUHJveHksIGdldE5hbWVkVGFnKTtcbiAgICBzZXRDdXN0b21UYWdGb3IocG9zaXRpb25hbFByb3h5LCBnZXRQb3NpdGlvbmFsVGFnKTtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lZDogbmFtZWRQcm94eSxcbiAgICAgIHBvc2l0aW9uYWw6IHBvc2l0aW9uYWxQcm94eSxcbiAgICB9O1xuICB9O1xufSBlbHNlIHtcbiAgYXJnc1Byb3h5Rm9yID0gKGNhcHR1cmVkQXJncywgX3R5cGUpID0+IHtcbiAgICBjb25zdCB7IG5hbWVkLCBwb3NpdGlvbmFsIH0gPSBjYXB0dXJlZEFyZ3M7XG5cbiAgICBsZXQgZ2V0TmFtZWRUYWcgPSAoX29iajogb2JqZWN0LCBrZXk6IHN0cmluZykgPT4gdGFnRm9yTmFtZWRBcmcobmFtZWQsIGtleSk7XG4gICAgbGV0IGdldFBvc2l0aW9uYWxUYWcgPSAoX29iajogb2JqZWN0LCBrZXk6IHN0cmluZykgPT4gdGFnRm9yUG9zaXRpb25hbEFyZyhwb3NpdGlvbmFsLCBrZXkpO1xuXG4gICAgbGV0IG5hbWVkUHJveHkgPSB7fTtcbiAgICBsZXQgcG9zaXRpb25hbFByb3h5OiB1bmtub3duW10gPSBbXTtcblxuICAgIHNldEN1c3RvbVRhZ0ZvcihuYW1lZFByb3h5LCBnZXROYW1lZFRhZyk7XG4gICAgc2V0Q3VzdG9tVGFnRm9yKHBvc2l0aW9uYWxQcm94eSwgZ2V0UG9zaXRpb25hbFRhZyk7XG5cbiAgICBPYmplY3Qua2V5cyhuYW1lZCkuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hbWVkUHJveHksIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlRm9yUmVmKG5hbWVkW25hbWVdKTtcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcG9zaXRpb25hbC5mb3JFYWNoKChyZWY6IFJlZmVyZW5jZSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBvc2l0aW9uYWxQcm94eSwgaW5kZXgsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlRm9yUmVmKHJlZik7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGlmIChERUJVRykge1xuICAgICAgLy8gUHJldmVudCBtdXRhdGlvbnMgaW4gZGV2ZWxvcG1lbnQgbW9kZS4gVGhpcyB3aWxsIG5vdCBwcmV2ZW50IHRoZVxuICAgICAgLy8gcHJveHkgZnJvbSB1cGRhdGluZywgYnV0IHdpbGwgcHJldmVudCBhc3NpZ25pbmcgbmV3IHZhbHVlcyBvciBwdXNoaW5nXG4gICAgICAvLyBmb3IgaW5zdGFuY2UuXG4gICAgICBPYmplY3QuZnJlZXplKG5hbWVkUHJveHkpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShwb3NpdGlvbmFsUHJveHkpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lZDogbmFtZWRQcm94eSxcbiAgICAgIHBvc2l0aW9uYWw6IHBvc2l0aW9uYWxQcm94eSxcbiAgICB9O1xuICB9O1xufVxuIiwiaW1wb3J0IHsgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZCB9IGZyb20gJ0BnbGltbWVyL2Rlc3Ryb3lhYmxlJztcbmltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7XG4gIEhlbHBlcixcbiAgSGVscGVyQ2FwYWJpbGl0aWVzLFxuICBIZWxwZXJDYXBhYmlsaXRpZXNWZXJzaW9ucyxcbiAgSGVscGVyRGVmaW5pdGlvblN0YXRlLFxuICBIZWxwZXJNYW5hZ2VyLFxuICBIZWxwZXJNYW5hZ2VyV2l0aERlc3Ryb3lhYmxlLFxuICBIZWxwZXJNYW5hZ2VyV2l0aFZhbHVlLFxuICBJbnRlcm5hbEhlbHBlck1hbmFnZXIsXG4gIE93bmVyLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGNyZWF0ZUNvbXB1dGVSZWYsIGNyZWF0ZUNvbnN0UmVmLCBVTkRFRklORURfUkVGRVJFTkNFIH0gZnJvbSAnQGdsaW1tZXIvcmVmZXJlbmNlJztcblxuaW1wb3J0IHsgYnVpbGRDYXBhYmlsaXRpZXMsIEZST01fQ0FQQUJJTElUSUVTIH0gZnJvbSAnLi4vdXRpbC9jYXBhYmlsaXRpZXMnO1xuaW1wb3J0IHsgYXJnc1Byb3h5Rm9yIH0gZnJvbSAnLi4vdXRpbC9hcmdzLXByb3h5JztcbmltcG9ydCB7IE1hbmFnZXJGYWN0b3J5IH0gZnJvbSAnLi9pbmRleCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBoZWxwZXJDYXBhYmlsaXRpZXM8VmVyc2lvbiBleHRlbmRzIGtleW9mIEhlbHBlckNhcGFiaWxpdGllc1ZlcnNpb25zPihcbiAgbWFuYWdlckFQSTogVmVyc2lvbixcbiAgb3B0aW9uczogUGFydGlhbDxIZWxwZXJDYXBhYmlsaXRpZXM+ID0ge31cbik6IEhlbHBlckNhcGFiaWxpdGllcyB7XG4gIGlmIChERUJVRyAmJiBtYW5hZ2VyQVBJICE9PSAnMy4yMycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGVscGVyIG1hbmFnZXIgY29tcGF0aWJpbGl0eSBzcGVjaWZpZWQnKTtcbiAgfVxuXG4gIGlmIChcbiAgICBERUJVRyAmJlxuICAgICghKG9wdGlvbnMuaGFzVmFsdWUgfHwgb3B0aW9ucy5oYXNTY2hlZHVsZWRFZmZlY3QpIHx8XG4gICAgICAob3B0aW9ucy5oYXNWYWx1ZSAmJiBvcHRpb25zLmhhc1NjaGVkdWxlZEVmZmVjdCkpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdZb3UgbXVzdCBwYXNzIGVpdGhlciB0aGUgYGhhc1ZhbHVlYCBPUiB0aGUgYGhhc1NjaGVkdWxlZEVmZmVjdGAgY2FwYWJpbGl0eSB3aGVuIGRlZmluaW5nIGEgaGVscGVyIG1hbmFnZXIuIFBhc3NpbmcgbmVpdGhlciwgb3IgYm90aCwgaXMgbm90IHBlcm1pdHRlZC4nXG4gICAgKTtcbiAgfVxuXG4gIGlmIChERUJVRyAmJiBvcHRpb25zLmhhc1NjaGVkdWxlZEVmZmVjdCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdUaGUgYGhhc1NjaGVkdWxlZEVmZmVjdGAgY2FwYWJpbGl0eSBoYXMgbm90IHlldCBiZWVuIGltcGxlbWVudGVkIGZvciBoZWxwZXIgbWFuYWdlcnMuIFBsZWFzZSBwYXNzIGBoYXNWYWx1ZWAgaW5zdGVhZCdcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGJ1aWxkQ2FwYWJpbGl0aWVzKHtcbiAgICBoYXNWYWx1ZTogQm9vbGVhbihvcHRpb25zLmhhc1ZhbHVlKSxcbiAgICBoYXNEZXN0cm95YWJsZTogQm9vbGVhbihvcHRpb25zLmhhc0Rlc3Ryb3lhYmxlKSxcbiAgICBoYXNTY2hlZHVsZWRFZmZlY3Q6IEJvb2xlYW4ob3B0aW9ucy5oYXNTY2hlZHVsZWRFZmZlY3QpLFxuICB9KTtcbn1cblxuLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNWYWx1ZShcbiAgbWFuYWdlcjogSGVscGVyTWFuYWdlcjx1bmtub3duPlxuKTogbWFuYWdlciBpcyBIZWxwZXJNYW5hZ2VyV2l0aFZhbHVlPHVua25vd24+IHtcbiAgcmV0dXJuIG1hbmFnZXIuY2FwYWJpbGl0aWVzLmhhc1ZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzRGVzdHJveWFibGUoXG4gIG1hbmFnZXI6IEhlbHBlck1hbmFnZXI8dW5rbm93bj5cbik6IG1hbmFnZXIgaXMgSGVscGVyTWFuYWdlcldpdGhEZXN0cm95YWJsZTx1bmtub3duPiB7XG4gIHJldHVybiBtYW5hZ2VyLmNhcGFiaWxpdGllcy5oYXNEZXN0cm95YWJsZTtcbn1cblxuLy8vLy8vLy8vLy8vXG5cbmV4cG9ydCBjbGFzcyBDdXN0b21IZWxwZXJNYW5hZ2VyPE8gZXh0ZW5kcyBPd25lciA9IE93bmVyPiBpbXBsZW1lbnRzIEludGVybmFsSGVscGVyTWFuYWdlcjxPPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZmFjdG9yeTogTWFuYWdlckZhY3Rvcnk8TyB8IHVuZGVmaW5lZCwgSGVscGVyTWFuYWdlcjx1bmtub3duPj4pIHt9XG5cbiAgcHJpdmF0ZSBoZWxwZXJNYW5hZ2VyRGVsZWdhdGVzID0gbmV3IFdlYWtNYXA8TywgSGVscGVyTWFuYWdlcjx1bmtub3duPj4oKTtcbiAgcHJpdmF0ZSB1bmRlZmluZWREZWxlZ2F0ZTogSGVscGVyTWFuYWdlcjx1bmtub3duPiB8IG51bGwgPSBudWxsO1xuXG4gIHByaXZhdGUgZ2V0RGVsZWdhdGVGb3JPd25lcihvd25lcjogTykge1xuICAgIGxldCBkZWxlZ2F0ZSA9IHRoaXMuaGVscGVyTWFuYWdlckRlbGVnYXRlcy5nZXQob3duZXIpO1xuXG4gICAgaWYgKGRlbGVnYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCB7IGZhY3RvcnkgfSA9IHRoaXM7XG4gICAgICBkZWxlZ2F0ZSA9IGZhY3Rvcnkob3duZXIpO1xuXG4gICAgICBpZiAoREVCVUcgJiYgIUZST01fQ0FQQUJJTElUSUVTIS5oYXMoZGVsZWdhdGUuY2FwYWJpbGl0aWVzKSkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGVycm9yIG1lc3NhZ2Ugc2hvdWxkIG1ha2Ugc2Vuc2UgaW4gYm90aCBFbWJlciBhbmQgR2xpbW1lciBodHRwczovL2dpdGh1Yi5jb20vZ2xpbW1lcmpzL2dsaW1tZXItdm0vaXNzdWVzLzEyMDBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDdXN0b20gaGVscGVyIG1hbmFnZXJzIG11c3QgaGF2ZSBhIFxcYGNhcGFiaWxpdGllc1xcYCBwcm9wZXJ0eSB0aGF0IGlzIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgXFxgY2FwYWJpbGl0aWVzKCczLjIzJylcXGAgKGltcG9ydGVkIHZpYSBcXGBpbXBvcnQgeyBjYXBhYmlsaXRpZXMgfSBmcm9tICdAZW1iZXIvaGVscGVyJztcXGApLiBSZWNlaXZlZDogXFxgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGRlbGVnYXRlLmNhcGFiaWxpdGllc1xuICAgICAgICAgICl9XFxgIGZvcjogXFxgJHtkZWxlZ2F0ZX1cXGBgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGVscGVyTWFuYWdlckRlbGVnYXRlcy5zZXQob3duZXIsIGRlbGVnYXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZWdhdGU7XG4gIH1cblxuICBnZXREZWxlZ2F0ZUZvcihvd25lcjogTyB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChvd25lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgeyB1bmRlZmluZWREZWxlZ2F0ZSB9ID0gdGhpcztcblxuICAgICAgaWYgKHVuZGVmaW5lZERlbGVnYXRlID09PSBudWxsKSB7XG4gICAgICAgIGxldCB7IGZhY3RvcnkgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMudW5kZWZpbmVkRGVsZWdhdGUgPSB1bmRlZmluZWREZWxlZ2F0ZSA9IGZhY3RvcnkodW5kZWZpbmVkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZERlbGVnYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXREZWxlZ2F0ZUZvck93bmVyKG93bmVyKTtcbiAgICB9XG4gIH1cblxuICBnZXRIZWxwZXIoZGVmaW5pdGlvbjogSGVscGVyRGVmaW5pdGlvblN0YXRlKTogSGVscGVyIHtcbiAgICByZXR1cm4gKGNhcHR1cmVkQXJncywgb3duZXIpID0+IHtcbiAgICAgIGxldCBtYW5hZ2VyID0gdGhpcy5nZXREZWxlZ2F0ZUZvcihvd25lciBhcyBPIHwgdW5kZWZpbmVkKTtcblxuICAgICAgY29uc3QgYXJncyA9IGFyZ3NQcm94eUZvcihjYXB0dXJlZEFyZ3MsICdoZWxwZXInKTtcbiAgICAgIGNvbnN0IGJ1Y2tldCA9IG1hbmFnZXIuY3JlYXRlSGVscGVyKGRlZmluaXRpb24sIGFyZ3MpO1xuXG4gICAgICBpZiAoaGFzVmFsdWUobWFuYWdlcikpIHtcbiAgICAgICAgbGV0IGNhY2hlID0gY3JlYXRlQ29tcHV0ZVJlZihcbiAgICAgICAgICAoKSA9PiAobWFuYWdlciBhcyBIZWxwZXJNYW5hZ2VyV2l0aFZhbHVlPHVua25vd24+KS5nZXRWYWx1ZShidWNrZXQpLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgREVCVUcgJiYgbWFuYWdlci5nZXREZWJ1Z05hbWUgJiYgbWFuYWdlci5nZXREZWJ1Z05hbWUoZGVmaW5pdGlvbilcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoaGFzRGVzdHJveWFibGUobWFuYWdlcikpIHtcbiAgICAgICAgICBhc3NvY2lhdGVEZXN0cm95YWJsZUNoaWxkKGNhY2hlLCBtYW5hZ2VyLmdldERlc3Ryb3lhYmxlKGJ1Y2tldCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgfSBlbHNlIGlmIChoYXNEZXN0cm95YWJsZShtYW5hZ2VyKSkge1xuICAgICAgICBsZXQgcmVmID0gY3JlYXRlQ29uc3RSZWYoXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIERFQlVHICYmIChtYW5hZ2VyLmdldERlYnVnTmFtZT8uKGRlZmluaXRpb24pID8/ICd1bmtub3duIGhlbHBlcicpXG4gICAgICAgICk7XG5cbiAgICAgICAgYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZChyZWYsIG1hbmFnZXIuZ2V0RGVzdHJveWFibGUoYnVja2V0KSk7XG5cbiAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVTkRFRklORURfUkVGRVJFTkNFO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7IGJ1aWxkQ2FwYWJpbGl0aWVzIH0gZnJvbSAnLi4vdXRpbC9jYXBhYmlsaXRpZXMnO1xuXG5pbXBvcnQgdHlwZSB7XG4gIENhcHR1cmVkQXJndW1lbnRzIGFzIEFyZ3VtZW50cyxcbiAgSGVscGVyQ2FwYWJpbGl0aWVzLFxuICBIZWxwZXJNYW5hZ2VyV2l0aFZhbHVlLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcblxudHlwZSBGbkFyZ3M8QXJncyBleHRlbmRzIEFyZ3VtZW50cyA9IEFyZ3VtZW50cz4gPVxuICB8IFsuLi5BcmdzWydwb3NpdGlvbmFsJ10sIEFyZ3NbJ25hbWVkJ11dXG4gIHwgWy4uLkFyZ3NbJ3Bvc2l0aW9uYWwnXV07XG5cbnR5cGUgQW55RnVuY3Rpb24gPSAoLi4uYXJnczogYW55W10pID0+IHVua25vd247XG5cbmludGVyZmFjZSBTdGF0ZSB7XG4gIGZuOiBBbnlGdW5jdGlvbjtcbiAgYXJnczogQXJndW1lbnRzO1xufVxuXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25IZWxwZXJNYW5hZ2VyIGltcGxlbWVudHMgSGVscGVyTWFuYWdlcldpdGhWYWx1ZTxTdGF0ZT4ge1xuICBjYXBhYmlsaXRpZXMgPSBidWlsZENhcGFiaWxpdGllcyh7XG4gICAgaGFzVmFsdWU6IHRydWUsXG4gICAgaGFzRGVzdHJveWFibGU6IGZhbHNlLFxuICAgIGhhc1NjaGVkdWxlZEVmZmVjdDogZmFsc2UsXG4gIH0pIGFzIEhlbHBlckNhcGFiaWxpdGllcztcblxuICBjcmVhdGVIZWxwZXIoZm46IEFueUZ1bmN0aW9uLCBhcmdzOiBBcmd1bWVudHMpOiBTdGF0ZSB7XG4gICAgcmV0dXJuIHsgZm4sIGFyZ3MgfTtcbiAgfVxuXG4gIGdldFZhbHVlKHsgZm4sIGFyZ3MgfTogU3RhdGUpOiB1bmtub3duIHtcbiAgICBpZiAoT2JqZWN0LmtleXMoYXJncy5uYW1lZCkubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IGFyZ3NGb3JGbjogRm5BcmdzPEFyZ3VtZW50cz4gPSBbLi4uYXJncy5wb3NpdGlvbmFsLCBhcmdzLm5hbWVkXTtcblxuICAgICAgcmV0dXJuIGZuKC4uLmFyZ3NGb3JGbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZuKC4uLmFyZ3MucG9zaXRpb25hbCk7XG4gIH1cblxuICBnZXREZWJ1Z05hbWUoZm46IEFueUZ1bmN0aW9uKTogc3RyaW5nIHtcbiAgICBpZiAoZm4ubmFtZSkge1xuICAgICAgcmV0dXJuIGAoaGVscGVyIGZ1bmN0aW9uICR7Zm4ubmFtZX0pYDtcbiAgICB9XG5cbiAgICByZXR1cm4gJyhhbm9ueW1vdXMgaGVscGVyIGZ1bmN0aW9uKSc7XG4gIH1cbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IGRlYnVnVG9TdHJpbmcsIF9XZWFrU2V0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBGRUFUVVJFX0RFRkFVTFRfSEVMUEVSX01BTkFHRVIgfSBmcm9tICdAZ2xpbW1lci9nbG9iYWwtY29udGV4dCc7XG5pbXBvcnQge1xuICBJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIsXG4gIEludGVybmFsTW9kaWZpZXJNYW5hZ2VyLFxuICBIZWxwZXIsXG4gIE93bmVyLFxufSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IEN1c3RvbUhlbHBlck1hbmFnZXIgfSBmcm9tICcuLi9wdWJsaWMvaGVscGVyJztcbmltcG9ydCB7IEZ1bmN0aW9uSGVscGVyTWFuYWdlciB9IGZyb20gJy4vZGVmYXVsdHMnO1xuXG50eXBlIEludGVybmFsTWFuYWdlciA9XG4gIHwgSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyXG4gIHwgSW50ZXJuYWxNb2RpZmllck1hbmFnZXJcbiAgfCBDdXN0b21IZWxwZXJNYW5hZ2VyXG4gIHwgSGVscGVyO1xuXG5jb25zdCBDT01QT05FTlRfTUFOQUdFUlMgPSBuZXcgV2Vha01hcDxvYmplY3QsIEludGVybmFsQ29tcG9uZW50TWFuYWdlcj4oKTtcblxuY29uc3QgTU9ESUZJRVJfTUFOQUdFUlMgPSBuZXcgV2Vha01hcDxvYmplY3QsIEludGVybmFsTW9kaWZpZXJNYW5hZ2VyPigpO1xuXG5jb25zdCBIRUxQRVJfTUFOQUdFUlMgPSBuZXcgV2Vha01hcDxvYmplY3QsIEN1c3RvbUhlbHBlck1hbmFnZXIgfCBIZWxwZXI+KCk7XG5cbi8vLy8vLy8vLy8vXG5cbmNvbnN0IGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuXG5mdW5jdGlvbiBzZXRNYW5hZ2VyPERlZiBleHRlbmRzIG9iamVjdD4oXG4gIG1hcDogV2Vha01hcDxvYmplY3QsIG9iamVjdD4sXG4gIG1hbmFnZXI6IG9iamVjdCxcbiAgb2JqOiBEZWZcbik6IERlZiB7XG4gIGlmIChERUJVRyAmJiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRlZCB0byBzZXQgYSBtYW5hZ2VyIG9uIGEgbm9uLW9iamVjdCB2YWx1ZS4gTWFuYWdlcnMgY2FuIG9ubHkgYmUgYXNzb2NpYXRlZCB3aXRoIG9iamVjdHMgb3IgZnVuY3Rpb25zLiBWYWx1ZSB3YXMgJHtkZWJ1Z1RvU3RyaW5nIShcbiAgICAgICAgb2JqXG4gICAgICApfWBcbiAgICApO1xuICB9XG5cbiAgaWYgKERFQlVHICYmIG1hcC5oYXMob2JqKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBBdHRlbXB0ZWQgdG8gc2V0IHRoZSBzYW1lIHR5cGUgb2YgbWFuYWdlciBtdWx0aXBsZSB0aW1lcyBvbiBhIHZhbHVlLiBZb3UgY2FuIG9ubHkgYXNzb2NpYXRlIG9uZSBtYW5hZ2VyIG9mIGVhY2ggdHlwZSB3aXRoIGEgZ2l2ZW4gdmFsdWUuIFZhbHVlIHdhcyAke2RlYnVnVG9TdHJpbmchKFxuICAgICAgICBvYmpcbiAgICAgICl9YFxuICAgICk7XG4gIH1cblxuICBtYXAuc2V0KG9iaiwgbWFuYWdlcik7XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGdldE1hbmFnZXI8TSBleHRlbmRzIEludGVybmFsTWFuYWdlcj4oXG4gIG1hcDogV2Vha01hcDxvYmplY3QsIE0+LFxuICBvYmo6IG9iamVjdFxuKTogTSB8IHVuZGVmaW5lZCB7XG4gIGxldCBwb2ludGVyID0gb2JqO1xuICB3aGlsZSAocG9pbnRlciAhPT0gdW5kZWZpbmVkICYmIHBvaW50ZXIgIT09IG51bGwpIHtcbiAgICBjb25zdCBtYW5hZ2VyID0gbWFwLmdldChwb2ludGVyKTtcblxuICAgIGlmIChtYW5hZ2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBtYW5hZ2VyO1xuICAgIH1cblxuICAgIHBvaW50ZXIgPSBnZXRQcm90b3R5cGVPZihwb2ludGVyKTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8vLy8vLy8vLy8vXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcjxUIGV4dGVuZHMgb2JqZWN0PihcbiAgbWFuYWdlcjogSW50ZXJuYWxNb2RpZmllck1hbmFnZXIsXG4gIGRlZmluaXRpb246IFRcbik6IFQge1xuICByZXR1cm4gc2V0TWFuYWdlcihNT0RJRklFUl9NQU5BR0VSUywgbWFuYWdlciwgZGVmaW5pdGlvbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcihkZWZpbml0aW9uOiBvYmplY3QpOiBJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcihcbiAgZGVmaW5pdGlvbjogb2JqZWN0LFxuICBpc09wdGlvbmFsOiB0cnVlIHwgdW5kZWZpbmVkXG4pOiBJbnRlcm5hbE1vZGlmaWVyTWFuYWdlciB8IG51bGw7XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJuYWxNb2RpZmllck1hbmFnZXIoXG4gIGRlZmluaXRpb246IG9iamVjdCxcbiAgaXNPcHRpb25hbD86IHRydWUgfCB1bmRlZmluZWRcbik6IEludGVybmFsTW9kaWZpZXJNYW5hZ2VyIHwgbnVsbCB7XG4gIGlmIChcbiAgICBERUJVRyAmJlxuICAgIHR5cGVvZiBkZWZpbml0aW9uICE9PSAnZnVuY3Rpb24nICYmXG4gICAgKHR5cGVvZiBkZWZpbml0aW9uICE9PSAnb2JqZWN0JyB8fCBkZWZpbml0aW9uID09PSBudWxsKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQXR0ZW1wdGVkIHRvIHVzZSBhIHZhbHVlIGFzIGEgbW9kaWZpZXIsIGJ1dCBpdCB3YXMgbm90IGFuIG9iamVjdCBvciBmdW5jdGlvbi4gTW9kaWZpZXIgZGVmaW5pdGlvbnMgbXVzdCBiZSBvYmplY3RzIG9yIGZ1bmN0aW9ucyB3aXRoIGFuIGFzc29jaWF0ZWQgbW9kaWZpZXIgbWFuYWdlci4gVGhlIHZhbHVlIHdhczogJHtkZWZpbml0aW9ufWBcbiAgICApO1xuICB9XG5cbiAgY29uc3QgbWFuYWdlciA9IGdldE1hbmFnZXIoTU9ESUZJRVJfTUFOQUdFUlMsIGRlZmluaXRpb24pITtcblxuICBpZiAobWFuYWdlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlzT3B0aW9uYWwgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoREVCVUcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEF0dGVtcHRlZCB0byBsb2FkIGEgbW9kaWZpZXIsIGJ1dCB0aGVyZSB3YXNuJ3QgYSBtb2RpZmllciBtYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgZGVmaW5pdGlvbi4gVGhlIGRlZmluaXRpb24gd2FzOiAke2RlYnVnVG9TdHJpbmchKFxuICAgICAgICAgIGRlZmluaXRpb25cbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYW5hZ2VyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0SW50ZXJuYWxIZWxwZXJNYW5hZ2VyPFQgZXh0ZW5kcyBvYmplY3QsIE8gZXh0ZW5kcyBPd25lcj4oXG4gIG1hbmFnZXI6IEN1c3RvbUhlbHBlck1hbmFnZXI8Tz4gfCBIZWxwZXI8Tz4sXG4gIGRlZmluaXRpb246IFRcbik6IFQge1xuICByZXR1cm4gc2V0TWFuYWdlcihIRUxQRVJfTUFOQUdFUlMsIG1hbmFnZXIsIGRlZmluaXRpb24pO1xufVxuXG5jb25zdCBERUZBVUxUX01BTkFHRVIgPSBuZXcgQ3VzdG9tSGVscGVyTWFuYWdlcigoKSA9PiBuZXcgRnVuY3Rpb25IZWxwZXJNYW5hZ2VyKCkpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJuYWxIZWxwZXJNYW5hZ2VyKGRlZmluaXRpb246IG9iamVjdCk6IEN1c3RvbUhlbHBlck1hbmFnZXIgfCBIZWxwZXI7XG5leHBvcnQgZnVuY3Rpb24gZ2V0SW50ZXJuYWxIZWxwZXJNYW5hZ2VyKFxuICBkZWZpbml0aW9uOiBvYmplY3QsXG4gIGlzT3B0aW9uYWw6IHRydWUgfCB1bmRlZmluZWRcbik6IEN1c3RvbUhlbHBlck1hbmFnZXIgfCBIZWxwZXIgfCBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVybmFsSGVscGVyTWFuYWdlcihcbiAgZGVmaW5pdGlvbjogb2JqZWN0LFxuICBpc09wdGlvbmFsPzogdHJ1ZSB8IHVuZGVmaW5lZFxuKTogQ3VzdG9tSGVscGVyTWFuYWdlciB8IEhlbHBlciB8IG51bGwge1xuICBpZiAoXG4gICAgREVCVUcgJiZcbiAgICB0eXBlb2YgZGVmaW5pdGlvbiAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICh0eXBlb2YgZGVmaW5pdGlvbiAhPT0gJ29iamVjdCcgfHwgZGVmaW5pdGlvbiA9PT0gbnVsbClcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRlZCB0byB1c2UgYSB2YWx1ZSBhcyBhIGhlbHBlciwgYnV0IGl0IHdhcyBub3QgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uLiBIZWxwZXIgZGVmaW5pdGlvbnMgbXVzdCBiZSBvYmplY3RzIG9yIGZ1bmN0aW9ucyB3aXRoIGFuIGFzc29jaWF0ZWQgaGVscGVyIG1hbmFnZXIuIFRoZSB2YWx1ZSB3YXM6ICR7ZGVmaW5pdGlvbn1gXG4gICAgKTtcbiAgfVxuXG4gIGxldCBtYW5hZ2VyID0gZ2V0TWFuYWdlcihIRUxQRVJfTUFOQUdFUlMsIGRlZmluaXRpb24pO1xuXG4gIGlmIChGRUFUVVJFX0RFRkFVTFRfSEVMUEVSX01BTkFHRVIpIHtcbiAgICAvLyBGdW5jdGlvbnMgYXJlIHNwZWNpYWwtY2FzZWQgYmVjYXVzZSBmdW5jdGlvbnMgYXJlIGRlZmluZWRcbiAgICAvLyBhcyB0aGUgXCJkZWZhdWx0XCIgaGVscGVyLCBwZXI6IGh0dHBzOi8vZ2l0aHViLmNvbS9lbWJlcmpzL3JmY3MvcHVsbC83NTZcbiAgICBpZiAobWFuYWdlciA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBtYW5hZ2VyID0gREVGQVVMVF9NQU5BR0VSO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIG1hbmFnZXI7XG4gIH0gZWxzZSBpZiAoaXNPcHRpb25hbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKERFQlVHKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEF0dGVtcHRlZCB0byBsb2FkIGEgaGVscGVyLCBidXQgdGhlcmUgd2Fzbid0IGEgaGVscGVyIG1hbmFnZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBkZWZpbml0aW9uLiBUaGUgZGVmaW5pdGlvbiB3YXM6ICR7ZGVidWdUb1N0cmluZyEoXG4gICAgICAgIGRlZmluaXRpb25cbiAgICAgICl9YFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEludGVybmFsQ29tcG9uZW50TWFuYWdlcjxUIGV4dGVuZHMgb2JqZWN0PihcbiAgZmFjdG9yeTogSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyLFxuICBvYmo6IFRcbik6IFQge1xuICByZXR1cm4gc2V0TWFuYWdlcihDT01QT05FTlRfTUFOQUdFUlMsIGZhY3RvcnksIG9iaik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIoZGVmaW5pdGlvbjogb2JqZWN0KTogSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVybmFsQ29tcG9uZW50TWFuYWdlcihcbiAgZGVmaW5pdGlvbjogb2JqZWN0LFxuICBpc09wdGlvbmFsOiB0cnVlIHwgdW5kZWZpbmVkXG4pOiBJbnRlcm5hbENvbXBvbmVudE1hbmFnZXIgfCBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVybmFsQ29tcG9uZW50TWFuYWdlcihcbiAgZGVmaW5pdGlvbjogb2JqZWN0LFxuICBpc09wdGlvbmFsPzogdHJ1ZSB8IHVuZGVmaW5lZFxuKTogSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyIHwgbnVsbCB7XG4gIGlmIChcbiAgICBERUJVRyAmJlxuICAgIHR5cGVvZiBkZWZpbml0aW9uICE9PSAnZnVuY3Rpb24nICYmXG4gICAgKHR5cGVvZiBkZWZpbml0aW9uICE9PSAnb2JqZWN0JyB8fCBkZWZpbml0aW9uID09PSBudWxsKVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQXR0ZW1wdGVkIHRvIHVzZSBhIHZhbHVlIGFzIGEgY29tcG9uZW50LCBidXQgaXQgd2FzIG5vdCBhbiBvYmplY3Qgb3IgZnVuY3Rpb24uIENvbXBvbmVudCBkZWZpbml0aW9ucyBtdXN0IGJlIG9iamVjdHMgb3IgZnVuY3Rpb25zIHdpdGggYW4gYXNzb2NpYXRlZCBjb21wb25lbnQgbWFuYWdlci4gVGhlIHZhbHVlIHdhczogJHtkZWZpbml0aW9ufWBcbiAgICApO1xuICB9XG5cbiAgY29uc3QgbWFuYWdlciA9IGdldE1hbmFnZXIoQ09NUE9ORU5UX01BTkFHRVJTLCBkZWZpbml0aW9uKSE7XG5cbiAgaWYgKG1hbmFnZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChpc09wdGlvbmFsID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKERFQlVHKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBdHRlbXB0ZWQgdG8gbG9hZCBhIGNvbXBvbmVudCwgYnV0IHRoZXJlIHdhc24ndCBhIGNvbXBvbmVudCBtYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgZGVmaW5pdGlvbi4gVGhlIGRlZmluaXRpb24gd2FzOiAke2RlYnVnVG9TdHJpbmchKFxuICAgICAgICAgIGRlZmluaXRpb25cbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYW5hZ2VyO1xufVxuXG4vLy8vLy8vLy8vL1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyKGRlZmluaXRpb246IG9iamVjdCk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGhhc0RlZmF1bHRDb21wb25lbnRNYW5hZ2VyKGRlZmluaXRpb24pIHx8XG4gICAgZ2V0TWFuYWdlcihDT01QT05FTlRfTUFOQUdFUlMsIGRlZmluaXRpb24pICE9PSB1bmRlZmluZWRcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludGVybmFsSGVscGVyTWFuYWdlcihkZWZpbml0aW9uOiBvYmplY3QpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICBoYXNEZWZhdWx0SGVscGVyTWFuYWdlcihkZWZpbml0aW9uKSB8fCBnZXRNYW5hZ2VyKEhFTFBFUl9NQU5BR0VSUywgZGVmaW5pdGlvbikgIT09IHVuZGVmaW5lZFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW50ZXJuYWxNb2RpZmllck1hbmFnZXIoZGVmaW5pdGlvbjogb2JqZWN0KTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgaGFzRGVmYXVsdE1vZGlmaWVyTWFuYWdlcihkZWZpbml0aW9uKSB8fCBnZXRNYW5hZ2VyKE1PRElGSUVSX01BTkFHRVJTLCBkZWZpbml0aW9uKSAhPT0gdW5kZWZpbmVkXG4gICk7XG59XG5cbmZ1bmN0aW9uIGhhc0RlZmF1bHRDb21wb25lbnRNYW5hZ2VyKF9kZWZpbml0aW9uOiBvYmplY3QpOiBib29sZWFuIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBoYXNEZWZhdWx0SGVscGVyTWFuYWdlcihkZWZpbml0aW9uOiBvYmplY3QpOiBib29sZWFuIHtcbiAgaWYgKEZFQVRVUkVfREVGQVVMVF9IRUxQRVJfTUFOQUdFUikge1xuICAgIHJldHVybiB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaGFzRGVmYXVsdE1vZGlmaWVyTWFuYWdlcihfZGVmaW5pdGlvbjogb2JqZWN0KTogYm9vbGVhbiB7XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7XG4gIEFyZ3VtZW50cyxcbiAgQ29tcG9uZW50Q2FwYWJpbGl0aWVzLFxuICBDb21wb25lbnRDYXBhYmlsaXRpZXNWZXJzaW9ucyxcbiAgQ29tcG9uZW50RGVmaW5pdGlvblN0YXRlLFxuICBDb21wb25lbnRNYW5hZ2VyLFxuICBDb21wb25lbnRNYW5hZ2VyV2l0aEFzeW5jTGlmZUN5Y2xlQ2FsbGJhY2tzLFxuICBDb21wb25lbnRNYW5hZ2VyV2l0aEFzeW5jVXBkYXRlSG9vayxcbiAgQ29tcG9uZW50TWFuYWdlcldpdGhEZXN0cnVjdG9ycyxcbiAgQ29tcG9uZW50TWFuYWdlcldpdGhVcGRhdGVIb29rLFxuICBEZXN0cm95YWJsZSxcbiAgSW50ZXJuYWxDb21wb25lbnRDYXBhYmlsaXRpZXMsXG4gIEludGVybmFsQ29tcG9uZW50TWFuYWdlcixcbiAgT3B0aW9uLFxuICBPd25lcixcbiAgVk1Bcmd1bWVudHMsXG59IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgY3JlYXRlQ29uc3RSZWYsIFJlZmVyZW5jZSB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyByZWdpc3RlckRlc3RydWN0b3IgfSBmcm9tICdAZ2xpbW1lci9kZXN0cm95YWJsZSc7XG5pbXBvcnQgeyBidWlsZENhcGFiaWxpdGllcywgRlJPTV9DQVBBQklMSVRJRVMgfSBmcm9tICcuLi91dGlsL2NhcGFiaWxpdGllcyc7XG5pbXBvcnQgeyBhcmdzUHJveHlGb3IgfSBmcm9tICcuLi91dGlsL2FyZ3MtcHJveHknO1xuaW1wb3J0IHsgTWFuYWdlckZhY3RvcnkgfSBmcm9tICcuL2luZGV4JztcblxuY29uc3QgQ0FQQUJJTElUSUVTID0ge1xuICBkeW5hbWljTGF5b3V0OiBmYWxzZSxcbiAgZHluYW1pY1RhZzogZmFsc2UsXG4gIHByZXBhcmVBcmdzOiBmYWxzZSxcbiAgY3JlYXRlQXJnczogdHJ1ZSxcbiAgYXR0cmlidXRlSG9vazogZmFsc2UsXG4gIGVsZW1lbnRIb29rOiBmYWxzZSxcbiAgY3JlYXRlQ2FsbGVyOiBmYWxzZSxcbiAgZHluYW1pY1Njb3BlOiB0cnVlLFxuICB1cGRhdGVIb29rOiB0cnVlLFxuICBjcmVhdGVJbnN0YW5jZTogdHJ1ZSxcbiAgd3JhcHBlZDogZmFsc2UsXG4gIHdpbGxEZXN0cm95OiBmYWxzZSxcbiAgaGFzU3ViT3duZXI6IGZhbHNlLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudENhcGFiaWxpdGllczxWZXJzaW9uIGV4dGVuZHMga2V5b2YgQ29tcG9uZW50Q2FwYWJpbGl0aWVzVmVyc2lvbnM+KFxuICBtYW5hZ2VyQVBJOiBWZXJzaW9uLFxuICBvcHRpb25zOiBDb21wb25lbnRDYXBhYmlsaXRpZXNWZXJzaW9uc1tWZXJzaW9uXSA9IHt9XG4pOiBDb21wb25lbnRDYXBhYmlsaXRpZXMge1xuICBpZiAoREVCVUcgJiYgbWFuYWdlckFQSSAhPT0gJzMuMTMnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvbXBvbmVudCBtYW5hZ2VyIGNvbXBhdGliaWxpdHkgc3BlY2lmaWVkJyk7XG4gIH1cblxuICBsZXQgdXBkYXRlSG9vayA9IEJvb2xlYW4oKG9wdGlvbnMgYXMgQ29tcG9uZW50Q2FwYWJpbGl0aWVzVmVyc2lvbnNbJzMuMTMnXSkudXBkYXRlSG9vayk7XG5cbiAgcmV0dXJuIGJ1aWxkQ2FwYWJpbGl0aWVzKHtcbiAgICBhc3luY0xpZmVDeWNsZUNhbGxiYWNrczogQm9vbGVhbihvcHRpb25zLmFzeW5jTGlmZWN5Y2xlQ2FsbGJhY2tzKSxcbiAgICBkZXN0cnVjdG9yOiBCb29sZWFuKG9wdGlvbnMuZGVzdHJ1Y3RvciksXG4gICAgdXBkYXRlSG9vayxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNBc3luY0xpZmVDeWNsZUNhbGxiYWNrczxDb21wb25lbnRJbnN0YW5jZT4oXG4gIGRlbGVnYXRlOiBDb21wb25lbnRNYW5hZ2VyPENvbXBvbmVudEluc3RhbmNlPlxuKTogZGVsZWdhdGUgaXMgQ29tcG9uZW50TWFuYWdlcldpdGhBc3luY0xpZmVDeWNsZUNhbGxiYWNrczxDb21wb25lbnRJbnN0YW5jZT4ge1xuICByZXR1cm4gZGVsZWdhdGUuY2FwYWJpbGl0aWVzLmFzeW5jTGlmZUN5Y2xlQ2FsbGJhY2tzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzVXBkYXRlSG9vazxDb21wb25lbnRJbnN0YW5jZT4oXG4gIGRlbGVnYXRlOiBDb21wb25lbnRNYW5hZ2VyPENvbXBvbmVudEluc3RhbmNlPlxuKTogZGVsZWdhdGUgaXMgQ29tcG9uZW50TWFuYWdlcldpdGhVcGRhdGVIb29rPENvbXBvbmVudEluc3RhbmNlPiB7XG4gIHJldHVybiBkZWxlZ2F0ZS5jYXBhYmlsaXRpZXMudXBkYXRlSG9vaztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0FzeW5jVXBkYXRlSG9vazxDb21wb25lbnRJbnN0YW5jZT4oXG4gIGRlbGVnYXRlOiBDb21wb25lbnRNYW5hZ2VyPENvbXBvbmVudEluc3RhbmNlPlxuKTogZGVsZWdhdGUgaXMgQ29tcG9uZW50TWFuYWdlcldpdGhBc3luY1VwZGF0ZUhvb2s8Q29tcG9uZW50SW5zdGFuY2U+IHtcbiAgcmV0dXJuIGhhc0FzeW5jTGlmZUN5Y2xlQ2FsbGJhY2tzKGRlbGVnYXRlKSAmJiBoYXNVcGRhdGVIb29rKGRlbGVnYXRlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0Rlc3RydWN0b3JzPENvbXBvbmVudEluc3RhbmNlPihcbiAgZGVsZWdhdGU6IENvbXBvbmVudE1hbmFnZXI8Q29tcG9uZW50SW5zdGFuY2U+XG4pOiBkZWxlZ2F0ZSBpcyBDb21wb25lbnRNYW5hZ2VyV2l0aERlc3RydWN0b3JzPENvbXBvbmVudEluc3RhbmNlPiB7XG4gIHJldHVybiBkZWxlZ2F0ZS5jYXBhYmlsaXRpZXMuZGVzdHJ1Y3Rvcjtcbn1cblxuLyoqXG4gIFRoZSBDdXN0b21Db21wb25lbnRNYW5hZ2VyIGFsbG93cyBhZGRvbnMgdG8gcHJvdmlkZSBjdXN0b20gY29tcG9uZW50XG4gIGltcGxlbWVudGF0aW9ucyB0aGF0IGludGVncmF0ZSBzZWFtbGVzc2x5IGludG8gRW1iZXIuIFRoaXMgaXMgYWNjb21wbGlzaGVkXG4gIHRocm91Z2ggYSBkZWxlZ2F0ZSwgcmVnaXN0ZXJlZCB3aXRoIHRoZSBjdXN0b20gY29tcG9uZW50IG1hbmFnZXIsIHdoaWNoXG4gIGltcGxlbWVudHMgYSBzZXQgb2YgaG9va3MgdGhhdCBkZXRlcm1pbmUgY29tcG9uZW50IGJlaGF2aW9yLlxuXG4gIFRvIGNyZWF0ZSBhIGN1c3RvbSBjb21wb25lbnQgbWFuYWdlciwgaW5zdGFudGlhdGUgYSBuZXcgQ3VzdG9tQ29tcG9uZW50TWFuYWdlclxuICBjbGFzcyBhbmQgcGFzcyB0aGUgZGVsZWdhdGUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50OlxuXG4gIGBgYGpzXG4gIGxldCBtYW5hZ2VyID0gbmV3IEN1c3RvbUNvbXBvbmVudE1hbmFnZXIoe1xuICAgIC8vIC4uLmRlbGVnYXRlIGltcGxlbWVudGF0aW9uLi4uXG4gIH0pO1xuICBgYGBcblxuICAjIyBEZWxlZ2F0ZSBIb29rc1xuXG4gIFRocm91Z2hvdXQgdGhlIGxpZmVjeWNsZSBvZiBhIGNvbXBvbmVudCwgdGhlIGNvbXBvbmVudCBtYW5hZ2VyIHdpbGwgaW52b2tlXG4gIGRlbGVnYXRlIGhvb2tzIHRoYXQgYXJlIHJlc3BvbnNpYmxlIGZvciBzdXJmYWNpbmcgdGhvc2UgbGlmZWN5Y2xlIGNoYW5nZXMgdG9cbiAgdGhlIGVuZCBkZXZlbG9wZXIuXG5cbiAgKiBgY3JlYXRlKClgIC0gaW52b2tlZCB3aGVuIGEgbmV3IGluc3RhbmNlIG9mIGEgY29tcG9uZW50IHNob3VsZCBiZSBjcmVhdGVkXG4gICogYHVwZGF0ZSgpYCAtIGludm9rZWQgd2hlbiB0aGUgYXJndW1lbnRzIHBhc3NlZCB0byBhIGNvbXBvbmVudCBjaGFuZ2VcbiAgKiBgZ2V0Q29udGV4dCgpYCAtIHJldHVybnMgdGhlIG9iamVjdCB0aGF0IHNob3VsZCBiZVxuKi9cbmV4cG9ydCBjbGFzcyBDdXN0b21Db21wb25lbnRNYW5hZ2VyPE8gZXh0ZW5kcyBPd25lciwgQ29tcG9uZW50SW5zdGFuY2U+XG4gIGltcGxlbWVudHMgSW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyPEN1c3RvbUNvbXBvbmVudFN0YXRlPENvbXBvbmVudEluc3RhbmNlPj4ge1xuICBwcml2YXRlIGNvbXBvbmVudE1hbmFnZXJEZWxlZ2F0ZXMgPSBuZXcgV2Vha01hcDxPLCBDb21wb25lbnRNYW5hZ2VyPENvbXBvbmVudEluc3RhbmNlPj4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGZhY3Rvcnk6IE1hbmFnZXJGYWN0b3J5PE8sIENvbXBvbmVudE1hbmFnZXI8Q29tcG9uZW50SW5zdGFuY2U+Pikge31cblxuICBwcml2YXRlIGdldERlbGVnYXRlRm9yKG93bmVyOiBPKSB7XG4gICAgbGV0IHsgY29tcG9uZW50TWFuYWdlckRlbGVnYXRlcyB9ID0gdGhpcztcbiAgICBsZXQgZGVsZWdhdGUgPSBjb21wb25lbnRNYW5hZ2VyRGVsZWdhdGVzLmdldChvd25lcik7XG5cbiAgICBpZiAoZGVsZWdhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHsgZmFjdG9yeSB9ID0gdGhpcztcbiAgICAgIGRlbGVnYXRlID0gZmFjdG9yeShvd25lcik7XG5cbiAgICAgIGlmIChERUJVRyAmJiAhRlJPTV9DQVBBQklMSVRJRVMhLmhhcyhkZWxlZ2F0ZS5jYXBhYmlsaXRpZXMpKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgbWVzc2FnZSBzaG91bGQgbWFrZSBzZW5zZSBpbiBib3RoIEVtYmVyIGFuZCBHbGltbWVyIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGltbWVyanMvZ2xpbW1lci12bS9pc3N1ZXMvMTIwMFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEN1c3RvbSBjb21wb25lbnQgbWFuYWdlcnMgbXVzdCBoYXZlIGEgXFxgY2FwYWJpbGl0aWVzXFxgIHByb3BlcnR5IHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBcXGBjYXBhYmlsaXRpZXMoJzMuMTMnKVxcYCAoaW1wb3J0ZWQgdmlhIFxcYGltcG9ydCB7IGNhcGFiaWxpdGllcyB9IGZyb20gJ0BlbWJlci9jb21wb25lbnQnO1xcYCkuIFJlY2VpdmVkOiBcXGAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgZGVsZWdhdGUuY2FwYWJpbGl0aWVzXG4gICAgICAgICAgKX1cXGAgZm9yOiBcXGAke2RlbGVnYXRlfVxcYGBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50TWFuYWdlckRlbGVnYXRlcy5zZXQob3duZXIsIGRlbGVnYXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVsZWdhdGU7XG4gIH1cblxuICBjcmVhdGUoXG4gICAgb3duZXI6IE8sXG4gICAgZGVmaW5pdGlvbjogQ29tcG9uZW50RGVmaW5pdGlvblN0YXRlLFxuICAgIHZtQXJnczogVk1Bcmd1bWVudHNcbiAgKTogQ3VzdG9tQ29tcG9uZW50U3RhdGU8Q29tcG9uZW50SW5zdGFuY2U+IHtcbiAgICBsZXQgZGVsZWdhdGUgPSB0aGlzLmdldERlbGVnYXRlRm9yKG93bmVyKTtcbiAgICBsZXQgYXJncyA9IGFyZ3NQcm94eUZvcih2bUFyZ3MuY2FwdHVyZSgpLCAnY29tcG9uZW50Jyk7XG5cbiAgICBsZXQgY29tcG9uZW50OiBDb21wb25lbnRJbnN0YW5jZSA9IGRlbGVnYXRlLmNyZWF0ZUNvbXBvbmVudChkZWZpbml0aW9uLCBhcmdzKTtcblxuICAgIHJldHVybiBuZXcgQ3VzdG9tQ29tcG9uZW50U3RhdGUoY29tcG9uZW50ISwgZGVsZWdhdGUsIGFyZ3MpO1xuICB9XG5cbiAgZ2V0RGVidWdOYW1lKGRlZmluaXRpb246IENvbXBvbmVudERlZmluaXRpb25TdGF0ZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nID8gZGVmaW5pdGlvbi5uYW1lIDogZGVmaW5pdGlvbi50b1N0cmluZygpO1xuICB9XG5cbiAgdXBkYXRlKGJ1Y2tldDogQ3VzdG9tQ29tcG9uZW50U3RhdGU8Q29tcG9uZW50SW5zdGFuY2U+KTogdm9pZCB7XG4gICAgbGV0IHsgZGVsZWdhdGUgfSA9IGJ1Y2tldDtcbiAgICBpZiAoaGFzVXBkYXRlSG9vayhkZWxlZ2F0ZSkpIHtcbiAgICAgIGxldCB7IGNvbXBvbmVudCwgYXJncyB9ID0gYnVja2V0O1xuXG4gICAgICBkZWxlZ2F0ZS51cGRhdGVDb21wb25lbnQoY29tcG9uZW50LCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICBkaWRDcmVhdGUoeyBjb21wb25lbnQsIGRlbGVnYXRlIH06IEN1c3RvbUNvbXBvbmVudFN0YXRlPENvbXBvbmVudEluc3RhbmNlPik6IHZvaWQge1xuICAgIGlmIChoYXNBc3luY0xpZmVDeWNsZUNhbGxiYWNrcyhkZWxlZ2F0ZSkpIHtcbiAgICAgIGRlbGVnYXRlLmRpZENyZWF0ZUNvbXBvbmVudChjb21wb25lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGRpZFVwZGF0ZSh7IGNvbXBvbmVudCwgZGVsZWdhdGUgfTogQ3VzdG9tQ29tcG9uZW50U3RhdGU8Q29tcG9uZW50SW5zdGFuY2U+KTogdm9pZCB7XG4gICAgaWYgKGhhc0FzeW5jVXBkYXRlSG9vayhkZWxlZ2F0ZSkpIHtcbiAgICAgIGRlbGVnYXRlLmRpZFVwZGF0ZUNvbXBvbmVudChjb21wb25lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGRpZFJlbmRlckxheW91dCgpOiB2b2lkIHt9XG5cbiAgZGlkVXBkYXRlTGF5b3V0KCk6IHZvaWQge31cblxuICBnZXRTZWxmKHsgY29tcG9uZW50LCBkZWxlZ2F0ZSB9OiBDdXN0b21Db21wb25lbnRTdGF0ZTxDb21wb25lbnRJbnN0YW5jZT4pOiBSZWZlcmVuY2Uge1xuICAgIHJldHVybiBjcmVhdGVDb25zdFJlZihkZWxlZ2F0ZS5nZXRDb250ZXh0KGNvbXBvbmVudCksICd0aGlzJyk7XG4gIH1cblxuICBnZXREZXN0cm95YWJsZShidWNrZXQ6IEN1c3RvbUNvbXBvbmVudFN0YXRlPENvbXBvbmVudEluc3RhbmNlPik6IE9wdGlvbjxEZXN0cm95YWJsZT4ge1xuICAgIGNvbnN0IHsgZGVsZWdhdGUgfSA9IGJ1Y2tldDtcblxuICAgIGlmIChoYXNEZXN0cnVjdG9ycyhkZWxlZ2F0ZSkpIHtcbiAgICAgIGNvbnN0IHsgY29tcG9uZW50IH0gPSBidWNrZXQ7XG5cbiAgICAgIHJlZ2lzdGVyRGVzdHJ1Y3RvcihidWNrZXQsICgpID0+IGRlbGVnYXRlLmRlc3Ryb3lDb21wb25lbnQoY29tcG9uZW50KSk7XG4gICAgICByZXR1cm4gYnVja2V0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZ2V0Q2FwYWJpbGl0aWVzKCk6IEludGVybmFsQ29tcG9uZW50Q2FwYWJpbGl0aWVzIHtcbiAgICByZXR1cm4gQ0FQQUJJTElUSUVTO1xuICB9XG59XG5cbi8qKlxuICogU3RvcmVzIGludGVybmFsIHN0YXRlIGFib3V0IGEgY29tcG9uZW50IGluc3RhbmNlIGFmdGVyIGl0J3MgYmVlbiBjcmVhdGVkLlxuICovXG5leHBvcnQgY2xhc3MgQ3VzdG9tQ29tcG9uZW50U3RhdGU8Q29tcG9uZW50SW5zdGFuY2U+IHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGNvbXBvbmVudDogQ29tcG9uZW50SW5zdGFuY2UsXG4gICAgcHVibGljIGRlbGVnYXRlOiBDb21wb25lbnRNYW5hZ2VyPENvbXBvbmVudEluc3RhbmNlPixcbiAgICBwdWJsaWMgYXJnczogQXJndW1lbnRzXG4gICkge31cbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7XG4gIEFyZ3VtZW50cyxcbiAgQ2FwdHVyZWRBcmd1bWVudHMsXG4gIEludGVybmFsTW9kaWZpZXJNYW5hZ2VyLFxuICBNb2RpZmllckNhcGFiaWxpdGllcyxcbiAgTW9kaWZpZXJDYXBhYmlsaXRpZXNWZXJzaW9ucyxcbiAgTW9kaWZpZXJNYW5hZ2VyLFxuICBPd25lcixcbn0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyByZWdpc3RlckRlc3RydWN0b3IgfSBmcm9tICdAZ2xpbW1lci9kZXN0cm95YWJsZSc7XG5pbXBvcnQgeyB2YWx1ZUZvclJlZiB9IGZyb20gJ0BnbGltbWVyL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBjYXN0VG9Ccm93c2VyLCBkaWN0IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBjcmVhdGVVcGRhdGFibGVUYWcsIHVudHJhY2ssIFVwZGF0YWJsZVRhZyB9IGZyb20gJ0BnbGltbWVyL3ZhbGlkYXRvcic7XG5pbXBvcnQgeyBTaW1wbGVFbGVtZW50IH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcbmltcG9ydCB7IGJ1aWxkQ2FwYWJpbGl0aWVzLCBGUk9NX0NBUEFCSUxJVElFUyB9IGZyb20gJy4uL3V0aWwvY2FwYWJpbGl0aWVzJztcbmltcG9ydCB7IGFyZ3NQcm94eUZvciB9IGZyb20gJy4uL3V0aWwvYXJncy1wcm94eSc7XG5pbXBvcnQgeyBNYW5hZ2VyRmFjdG9yeSB9IGZyb20gJy4nO1xuXG5leHBvcnQgZnVuY3Rpb24gbW9kaWZpZXJDYXBhYmlsaXRpZXM8VmVyc2lvbiBleHRlbmRzIGtleW9mIE1vZGlmaWVyQ2FwYWJpbGl0aWVzVmVyc2lvbnM+KFxuICBtYW5hZ2VyQVBJOiBWZXJzaW9uLFxuICBvcHRpb25hbEZlYXR1cmVzOiBNb2RpZmllckNhcGFiaWxpdGllc1ZlcnNpb25zW1ZlcnNpb25dID0ge31cbik6IE1vZGlmaWVyQ2FwYWJpbGl0aWVzIHtcbiAgaWYgKERFQlVHICYmIG1hbmFnZXJBUEkgIT09ICczLjIyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtb2RpZmllciBtYW5hZ2VyIGNvbXBhdGliaWxpdHkgc3BlY2lmaWVkJyk7XG4gIH1cblxuICByZXR1cm4gYnVpbGRDYXBhYmlsaXRpZXMoe1xuICAgIGRpc2FibGVBdXRvVHJhY2tpbmc6IEJvb2xlYW4ob3B0aW9uYWxGZWF0dXJlcy5kaXNhYmxlQXV0b1RyYWNraW5nKSxcbiAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3VzdG9tTW9kaWZpZXJTdGF0ZTxNb2RpZmllckluc3RhbmNlPiB7XG4gIHRhZzogVXBkYXRhYmxlVGFnO1xuICBlbGVtZW50OiBTaW1wbGVFbGVtZW50O1xuICBtb2RpZmllcjogTW9kaWZpZXJJbnN0YW5jZTtcbiAgZGVsZWdhdGU6IE1vZGlmaWVyTWFuYWdlcjxNb2RpZmllckluc3RhbmNlPjtcbiAgYXJnczogQXJndW1lbnRzO1xuICBkZWJ1Z05hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICBUaGUgQ3VzdG9tTW9kaWZpZXJNYW5hZ2VyIGFsbG93cyBhZGRvbnMgdG8gcHJvdmlkZSBjdXN0b20gbW9kaWZpZXJcbiAgaW1wbGVtZW50YXRpb25zIHRoYXQgaW50ZWdyYXRlIHNlYW1sZXNzbHkgaW50byBFbWJlci4gVGhpcyBpcyBhY2NvbXBsaXNoZWRcbiAgdGhyb3VnaCBhIGRlbGVnYXRlLCByZWdpc3RlcmVkIHdpdGggdGhlIGN1c3RvbSBtb2RpZmllciBtYW5hZ2VyLCB3aGljaFxuICBpbXBsZW1lbnRzIGEgc2V0IG9mIGhvb2tzIHRoYXQgZGV0ZXJtaW5lIG1vZGlmaWVyIGJlaGF2aW9yLlxuICBUbyBjcmVhdGUgYSBjdXN0b20gbW9kaWZpZXIgbWFuYWdlciwgaW5zdGFudGlhdGUgYSBuZXcgQ3VzdG9tTW9kaWZpZXJNYW5hZ2VyXG4gIGNsYXNzIGFuZCBwYXNzIHRoZSBkZWxlZ2F0ZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQ6XG5cbiAgYGBganNcbiAgbGV0IG1hbmFnZXIgPSBuZXcgQ3VzdG9tTW9kaWZpZXJNYW5hZ2VyKHtcbiAgICAvLyAuLi5kZWxlZ2F0ZSBpbXBsZW1lbnRhdGlvbi4uLlxuICB9KTtcbiAgYGBgXG5cbiAgIyMgRGVsZWdhdGUgSG9va3NcblxuICBUaHJvdWdob3V0IHRoZSBsaWZlY3ljbGUgb2YgYSBtb2RpZmllciwgdGhlIG1vZGlmaWVyIG1hbmFnZXIgd2lsbCBpbnZva2VcbiAgZGVsZWdhdGUgaG9va3MgdGhhdCBhcmUgcmVzcG9uc2libGUgZm9yIHN1cmZhY2luZyB0aG9zZSBsaWZlY3ljbGUgY2hhbmdlcyB0b1xuICB0aGUgZW5kIGRldmVsb3Blci5cbiAgKiBgY3JlYXRlTW9kaWZpZXIoKWAgLSBpbnZva2VkIHdoZW4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBtb2RpZmllciBzaG91bGQgYmUgY3JlYXRlZFxuICAqIGBpbnN0YWxsTW9kaWZpZXIoKWAgLSBpbnZva2VkIHdoZW4gdGhlIG1vZGlmaWVyIGlzIGluc3RhbGxlZCBvbiB0aGUgZWxlbWVudFxuICAqIGB1cGRhdGVNb2RpZmllcigpYCAtIGludm9rZWQgd2hlbiB0aGUgYXJndW1lbnRzIHBhc3NlZCB0byBhIG1vZGlmaWVyIGNoYW5nZVxuICAqIGBkZXN0cm95TW9kaWZpZXIoKWAgLSBpbnZva2VkIHdoZW4gdGhlIG1vZGlmaWVyIGlzIGFib3V0IHRvIGJlIGRlc3Ryb3llZFxuKi9cbmV4cG9ydCBjbGFzcyBDdXN0b21Nb2RpZmllck1hbmFnZXI8TyBleHRlbmRzIE93bmVyLCBNb2RpZmllckluc3RhbmNlPlxuICBpbXBsZW1lbnRzIEludGVybmFsTW9kaWZpZXJNYW5hZ2VyPEN1c3RvbU1vZGlmaWVyU3RhdGU8TW9kaWZpZXJJbnN0YW5jZT4+IHtcbiAgcHJpdmF0ZSBjb21wb25lbnRNYW5hZ2VyRGVsZWdhdGVzID0gbmV3IFdlYWtNYXA8TywgTW9kaWZpZXJNYW5hZ2VyPE1vZGlmaWVySW5zdGFuY2U+PigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZmFjdG9yeTogTWFuYWdlckZhY3Rvcnk8TywgTW9kaWZpZXJNYW5hZ2VyPE1vZGlmaWVySW5zdGFuY2U+Pikge31cblxuICBwcml2YXRlIGdldERlbGVnYXRlRm9yKG93bmVyOiBPKSB7XG4gICAgbGV0IHsgY29tcG9uZW50TWFuYWdlckRlbGVnYXRlcyB9ID0gdGhpcztcbiAgICBsZXQgZGVsZWdhdGUgPSBjb21wb25lbnRNYW5hZ2VyRGVsZWdhdGVzLmdldChvd25lcik7XG5cbiAgICBpZiAoZGVsZWdhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHsgZmFjdG9yeSB9ID0gdGhpcztcbiAgICAgIGRlbGVnYXRlID0gZmFjdG9yeShvd25lcik7XG5cbiAgICAgIGlmIChERUJVRyAmJiAhRlJPTV9DQVBBQklMSVRJRVMhLmhhcyhkZWxlZ2F0ZS5jYXBhYmlsaXRpZXMpKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgbWVzc2FnZSBzaG91bGQgbWFrZSBzZW5zZSBpbiBib3RoIEVtYmVyIGFuZCBHbGltbWVyIGh0dHBzOi8vZ2l0aHViLmNvbS9nbGltbWVyanMvZ2xpbW1lci12bS9pc3N1ZXMvMTIwMFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEN1c3RvbSBtb2RpZmllciBtYW5hZ2VycyBtdXN0IGhhdmUgYSBcXGBjYXBhYmlsaXRpZXNcXGAgcHJvcGVydHkgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFxcYGNhcGFiaWxpdGllcygnMy4yMicpXFxgIChpbXBvcnRlZCB2aWEgXFxgaW1wb3J0IHsgY2FwYWJpbGl0aWVzIH0gZnJvbSAnQGVtYmVyL21vZGlmaWVyJztcXGApLiBSZWNlaXZlZDogXFxgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGRlbGVnYXRlLmNhcGFiaWxpdGllc1xuICAgICAgICAgICl9XFxgIGZvcjogXFxgJHtkZWxlZ2F0ZX1cXGBgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbXBvbmVudE1hbmFnZXJEZWxlZ2F0ZXMuc2V0KG93bmVyLCBkZWxlZ2F0ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlbGVnYXRlO1xuICB9XG5cbiAgY3JlYXRlKG93bmVyOiBPLCBlbGVtZW50OiBTaW1wbGVFbGVtZW50LCBkZWZpbml0aW9uOiBvYmplY3QsIGNhcHR1cmVkQXJnczogQ2FwdHVyZWRBcmd1bWVudHMpIHtcbiAgICBsZXQgZGVsZWdhdGUgPSB0aGlzLmdldERlbGVnYXRlRm9yKG93bmVyKTtcblxuICAgIGxldCBhcmdzID0gYXJnc1Byb3h5Rm9yKGNhcHR1cmVkQXJncywgJ21vZGlmaWVyJyk7XG4gICAgbGV0IGluc3RhbmNlOiBNb2RpZmllckluc3RhbmNlID0gZGVsZWdhdGUuY3JlYXRlTW9kaWZpZXIoZGVmaW5pdGlvbiwgYXJncyk7XG5cbiAgICBsZXQgdGFnID0gY3JlYXRlVXBkYXRhYmxlVGFnKCk7XG4gICAgbGV0IHN0YXRlOiBDdXN0b21Nb2RpZmllclN0YXRlPE1vZGlmaWVySW5zdGFuY2U+O1xuXG4gICAgc3RhdGUgPSB7XG4gICAgICB0YWcsXG4gICAgICBlbGVtZW50LFxuICAgICAgZGVsZWdhdGUsXG4gICAgICBhcmdzLFxuICAgICAgbW9kaWZpZXI6IGluc3RhbmNlISxcbiAgICB9O1xuXG4gICAgaWYgKERFQlVHKSB7XG4gICAgICBzdGF0ZS5kZWJ1Z05hbWUgPSB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IGRlZmluaXRpb24ubmFtZSA6IGRlZmluaXRpb24udG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICByZWdpc3RlckRlc3RydWN0b3Ioc3RhdGUsICgpID0+IGRlbGVnYXRlLmRlc3Ryb3lNb2RpZmllcihpbnN0YW5jZSwgYXJncykpO1xuXG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgZ2V0RGVidWdOYW1lKHsgZGVidWdOYW1lIH06IEN1c3RvbU1vZGlmaWVyU3RhdGU8TW9kaWZpZXJJbnN0YW5jZT4pIHtcbiAgICByZXR1cm4gZGVidWdOYW1lITtcbiAgfVxuXG4gIGdldFRhZyh7IHRhZyB9OiBDdXN0b21Nb2RpZmllclN0YXRlPE1vZGlmaWVySW5zdGFuY2U+KSB7XG4gICAgcmV0dXJuIHRhZztcbiAgfVxuXG4gIGluc3RhbGwoeyBlbGVtZW50LCBhcmdzLCBtb2RpZmllciwgZGVsZWdhdGUgfTogQ3VzdG9tTW9kaWZpZXJTdGF0ZTxNb2RpZmllckluc3RhbmNlPikge1xuICAgIGxldCB7IGNhcGFiaWxpdGllcyB9ID0gZGVsZWdhdGU7XG5cbiAgICBpZiAoY2FwYWJpbGl0aWVzLmRpc2FibGVBdXRvVHJhY2tpbmcgPT09IHRydWUpIHtcbiAgICAgIHVudHJhY2soKCkgPT4gZGVsZWdhdGUuaW5zdGFsbE1vZGlmaWVyKG1vZGlmaWVyLCBjYXN0VG9Ccm93c2VyKGVsZW1lbnQsICdFTEVNRU5UJyksIGFyZ3MpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZWdhdGUuaW5zdGFsbE1vZGlmaWVyKG1vZGlmaWVyLCBjYXN0VG9Ccm93c2VyKGVsZW1lbnQsICdFTEVNRU5UJyksIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZSh7IGFyZ3MsIG1vZGlmaWVyLCBkZWxlZ2F0ZSB9OiBDdXN0b21Nb2RpZmllclN0YXRlPE1vZGlmaWVySW5zdGFuY2U+KSB7XG4gICAgbGV0IHsgY2FwYWJpbGl0aWVzIH0gPSBkZWxlZ2F0ZTtcblxuICAgIGlmIChjYXBhYmlsaXRpZXMuZGlzYWJsZUF1dG9UcmFja2luZyA9PT0gdHJ1ZSkge1xuICAgICAgdW50cmFjaygoKSA9PiBkZWxlZ2F0ZS51cGRhdGVNb2RpZmllcihtb2RpZmllciwgYXJncykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxlZ2F0ZS51cGRhdGVNb2RpZmllcihtb2RpZmllciwgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0RGVzdHJveWFibGUoc3RhdGU6IEN1c3RvbU1vZGlmaWVyU3RhdGU8TW9kaWZpZXJJbnN0YW5jZT4pIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlaWZ5QXJncyh7XG4gIG5hbWVkLFxuICBwb3NpdGlvbmFsLFxufTogQ2FwdHVyZWRBcmd1bWVudHMpOiB7IG5hbWVkOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjsgcG9zaXRpb25hbDogdW5rbm93bltdIH0ge1xuICBsZXQgcmVpZmllZE5hbWVkID0gZGljdCgpO1xuXG4gIGZvciAobGV0IGtleSBpbiBuYW1lZCkge1xuICAgIHJlaWZpZWROYW1lZFtrZXldID0gdmFsdWVGb3JSZWYobmFtZWRba2V5XSk7XG4gIH1cblxuICBsZXQgcmVpZmllZFBvc2l0aW9uYWwgPSBwb3NpdGlvbmFsLm1hcCh2YWx1ZUZvclJlZik7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lZDogcmVpZmllZE5hbWVkLFxuICAgIHBvc2l0aW9uYWw6IHJlaWZpZWRQb3NpdGlvbmFsLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgX1dlYWtTZXQgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IENvbXBvbmVudE1hbmFnZXIsIEhlbHBlck1hbmFnZXIsIE1vZGlmaWVyTWFuYWdlciwgT3duZXIgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7XG4gIHNldEludGVybmFsQ29tcG9uZW50TWFuYWdlcixcbiAgc2V0SW50ZXJuYWxIZWxwZXJNYW5hZ2VyLFxuICBzZXRJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcixcbn0gZnJvbSAnLi4vaW50ZXJuYWwvaW5kZXgnO1xuaW1wb3J0IHsgQ3VzdG9tQ29tcG9uZW50TWFuYWdlciB9IGZyb20gJy4vY29tcG9uZW50JztcbmltcG9ydCB7IEN1c3RvbU1vZGlmaWVyTWFuYWdlciB9IGZyb20gJy4vbW9kaWZpZXInO1xuaW1wb3J0IHsgQ3VzdG9tSGVscGVyTWFuYWdlciB9IGZyb20gJy4vaGVscGVyJztcblxudHlwZSBNYW5hZ2VyID0gQ29tcG9uZW50TWFuYWdlcjx1bmtub3duPiB8IE1vZGlmaWVyTWFuYWdlcjx1bmtub3duPiB8IEhlbHBlck1hbmFnZXI8dW5rbm93bj47XG5cbmV4cG9ydCB0eXBlIE1hbmFnZXJGYWN0b3J5PE8sIEQgZXh0ZW5kcyBNYW5hZ2VyID0gTWFuYWdlcj4gPSAob3duZXI6IE8pID0+IEQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb21wb25lbnRNYW5hZ2VyPE8gZXh0ZW5kcyBPd25lciwgVCBleHRlbmRzIG9iamVjdD4oXG4gIGZhY3Rvcnk6IE1hbmFnZXJGYWN0b3J5PE8sIENvbXBvbmVudE1hbmFnZXI8dW5rbm93bj4+LFxuICBvYmo6IFRcbik6IFQge1xuICByZXR1cm4gc2V0SW50ZXJuYWxDb21wb25lbnRNYW5hZ2VyKG5ldyBDdXN0b21Db21wb25lbnRNYW5hZ2VyKGZhY3RvcnkpLCBvYmopO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0TW9kaWZpZXJNYW5hZ2VyPE8gZXh0ZW5kcyBPd25lciwgVCBleHRlbmRzIG9iamVjdD4oXG4gIGZhY3Rvcnk6IE1hbmFnZXJGYWN0b3J5PE8sIE1vZGlmaWVyTWFuYWdlcjx1bmtub3duPj4sXG4gIG9iajogVFxuKTogVCB7XG4gIHJldHVybiBzZXRJbnRlcm5hbE1vZGlmaWVyTWFuYWdlcihuZXcgQ3VzdG9tTW9kaWZpZXJNYW5hZ2VyKGZhY3RvcnkpLCBvYmopO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0SGVscGVyTWFuYWdlcjxPIGV4dGVuZHMgT3duZXIsIFQgZXh0ZW5kcyBvYmplY3Q+KFxuICBmYWN0b3J5OiBNYW5hZ2VyRmFjdG9yeTxPIHwgdW5kZWZpbmVkLCBIZWxwZXJNYW5hZ2VyPHVua25vd24+PixcbiAgb2JqOiBUXG4pOiBUIHtcbiAgcmV0dXJuIHNldEludGVybmFsSGVscGVyTWFuYWdlcihuZXcgQ3VzdG9tSGVscGVyTWFuYWdlcihmYWN0b3J5KSwgb2JqKTtcbn1cbiIsImltcG9ydCB7IERFQlVHIH0gZnJvbSAnQGdsaW1tZXIvZW52JztcbmltcG9ydCB7IGRlYnVnVG9TdHJpbmcgfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IFRlbXBsYXRlRmFjdG9yeSB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuXG5jb25zdCBURU1QTEFURVM6IFdlYWtNYXA8b2JqZWN0LCBUZW1wbGF0ZUZhY3Rvcnk+ID0gbmV3IFdlYWtNYXAoKTtcblxuY29uc3QgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDb21wb25lbnRUZW1wbGF0ZShmYWN0b3J5OiBUZW1wbGF0ZUZhY3RvcnksIG9iajogb2JqZWN0KSB7XG4gIGlmIChERUJVRyAmJiAhKG9iaiAhPT0gbnVsbCAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgY2FsbCBcXGBzZXRDb21wb25lbnRUZW1wbGF0ZVxcYCBvbiBcXGAke2RlYnVnVG9TdHJpbmchKG9iail9XFxgYCk7XG4gIH1cblxuICBpZiAoREVCVUcgJiYgVEVNUExBVEVTLmhhcyhvYmopKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbm5vdCBjYWxsIFxcYHNldENvbXBvbmVudFRlbXBsYXRlXFxgIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lIGNsYXNzIChcXGAke2RlYnVnVG9TdHJpbmchKFxuICAgICAgICBvYmpcbiAgICAgICl9XFxgKWBcbiAgICApO1xuICB9XG5cbiAgVEVNUExBVEVTLnNldChvYmosIGZhY3RvcnkpO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wb25lbnRUZW1wbGF0ZShvYmo6IG9iamVjdCk6IFRlbXBsYXRlRmFjdG9yeSB8IHVuZGVmaW5lZCB7XG4gIGxldCBwb2ludGVyID0gb2JqO1xuXG4gIHdoaWxlIChwb2ludGVyICE9PSBudWxsKSB7XG4gICAgbGV0IHRlbXBsYXRlID0gVEVNUExBVEVTLmdldChwb2ludGVyKTtcblxuICAgIGlmICh0ZW1wbGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgcG9pbnRlciA9IGdldFByb3RvdHlwZU9mKHBvaW50ZXIpO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbiJdLCJuYW1lcyI6WyJERUJVRyIsIl9XZWFrU2V0IiwidHJhY2siLCJ2YWx1ZUZvclJlZiIsIkhBU19OQVRJVkVfUFJPWFkiLCJjcmVhdGVDb21wdXRlUmVmIiwiYXNzb2NpYXRlRGVzdHJveWFibGVDaGlsZCIsImNyZWF0ZUNvbnN0UmVmIiwiVU5ERUZJTkVEX1JFRkVSRU5DRSIsImRlYnVnVG9TdHJpbmciLCJGRUFUVVJFX0RFRkFVTFRfSEVMUEVSX01BTkFHRVIiLCJyZWdpc3RlckRlc3RydWN0b3IiLCJjcmVhdGVVcGRhdGFibGVUYWciLCJ1bnRyYWNrIiwiZ2V0UHJvdG90eXBlT2YiXSwibWFwcGluZ3MiOiI7O0VBZU8sSUFBTSxpQkFBaUIsR0FBR0EsU0FBSyxHQUFHLElBQUhDLGFBQUcsRUFBSCxHQUEvQixTQUFBO0VBRUQsU0FBQSxpQkFBQSxDQUFBLFlBQUEsRUFBNkQ7RUFDakUsTUFBQUQsU0FBQSxFQUFXO0VBQ1QsSUFBQSxpQkFBa0IsQ0FBbEIsR0FBQSxDQUFBLFlBQUE7RUFDQSxJQUFBLE1BQU0sQ0FBTixNQUFBLENBQUEsWUFBQTtFQUNEOztFQUVELFNBQUEsWUFBQTtFQUNEO0VBRUQ7Ozs7RUFHTSxTQUFBLG1CQUFBLENBQUEsWUFBQSxFQUN1QztFQUUzQyxTQUNFLEtBQ0MsWUFBWSxDQUFaLGFBQUEsR0FBNEI7RUFBQTtFQUE1QixJQURELENBQUEsS0FFQyxZQUFZLENBQVosVUFBQSxHQUF5QjtFQUFBO0VBQXpCLElBRkQsQ0FBQSxLQUdDLFlBQVksQ0FBWixXQUFBLEdBQTBCO0VBQUE7RUFBMUIsSUFIRCxDQUFBLEtBSUMsWUFBWSxDQUFaLFVBQUEsR0FBeUI7RUFBQTtFQUF6QixJQUpELENBQUEsS0FLQyxZQUFZLENBQVosYUFBQSxHQUE0QjtFQUFBO0VBQTVCLElBTEQsQ0FBQSxLQU1DLFlBQVksQ0FBWixXQUFBLEdBQTBCO0VBQUE7RUFBMUIsSUFORCxDQUFBLEtBT0MsWUFBWSxDQUFaLFlBQUEsR0FBMkI7RUFBQTtFQUEzQixJQVBELENBQUEsS0FRQyxZQUFZLENBQVosWUFBQSxHQUEyQjtFQUFBO0VBQTNCLElBUkQs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
